{
  "contract_name": "astroport-emissions-controller",
  "contract_version": "1.0.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "description": "This structure describes the basic settings for creating a contract.",
    "type": "object",
    "required": [
      "assembly",
      "astro_denom",
      "collected_astro",
      "ema",
      "emissions_multiple",
      "factory",
      "fee_receiver",
      "max_astro",
      "owner",
      "pools_per_outpost",
      "vxastro_code_id",
      "vxastro_marketing_info",
      "whitelist_threshold",
      "whitelisting_fee",
      "xastro_denom"
    ],
    "properties": {
      "assembly": {
        "description": "Astroport Assembly contract address",
        "type": "string"
      },
      "astro_denom": {
        "description": "ASTRO denom on the Hub",
        "type": "string"
      },
      "collected_astro": {
        "description": "Defines the number of ASTRO collected to staking contract from 2-weeks period preceding the current epoch.",
        "allOf": [
          {
            "$ref": "#/definitions/Uint128"
          }
        ]
      },
      "ema": {
        "description": "EMA of the collected ASTRO from the previous epoch",
        "allOf": [
          {
            "$ref": "#/definitions/Uint128"
          }
        ]
      },
      "emissions_multiple": {
        "description": "Controls ASTRO emissions for the next epoch. If multiple < 1 then protocol emits less ASTRO than it buys back, otherwise protocol is inflating ASTRO supply.",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      },
      "factory": {
        "description": "Astroport Factory contract",
        "type": "string"
      },
      "fee_receiver": {
        "description": "Address that receives the whitelisting fee",
        "type": "string"
      },
      "max_astro": {
        "description": "Max ASTRO allowed per epoch. Parameter of the dynamic emissions curve.",
        "allOf": [
          {
            "$ref": "#/definitions/Uint128"
          }
        ]
      },
      "owner": {
        "description": "Contract owner",
        "type": "string"
      },
      "pools_per_outpost": {
        "description": "Max number of pools that can receive ASTRO emissions per outpost added. For example, if there are 3 outposts, and the pools_limit is 10, then 30 pools can receive ASTRO emissions. This limit doesn't enforce the exact number of pools per outpost, but adds flexibility to the contract to automatically adjust the max number of pools based on the number of outposts.",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      },
      "vxastro_code_id": {
        "description": "vxASTRO contract code id",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      },
      "vxastro_marketing_info": {
        "description": "vxASTRO token marketing info",
        "allOf": [
          {
            "$ref": "#/definitions/UpdateMarketingInfo"
          }
        ]
      },
      "whitelist_threshold": {
        "description": "Minimal percentage of total voting power required to keep a pool in the whitelist",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      },
      "whitelisting_fee": {
        "description": "Fee required to whitelist a pool",
        "allOf": [
          {
            "$ref": "#/definitions/Coin"
          }
        ]
      },
      "xastro_denom": {
        "description": "xASTRO denom",
        "type": "string"
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "EmbeddedLogo": {
        "description": "This is used to store the logo on the blockchain in an accepted format. Enforce maximum size of 5KB on all variants.",
        "oneOf": [
          {
            "description": "Store the Logo as an SVG file. The content must conform to the spec at https://en.wikipedia.org/wiki/Scalable_Vector_Graphics (The contract should do some light-weight sanity-check validation)",
            "type": "object",
            "required": [
              "svg"
            ],
            "properties": {
              "svg": {
                "$ref": "#/definitions/Binary"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Store the Logo as a PNG file. This will likely only support up to 64x64 or so within the 5KB limit.",
            "type": "object",
            "required": [
              "png"
            ],
            "properties": {
              "png": {
                "$ref": "#/definitions/Binary"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Logo": {
        "description": "This is used for uploading logo data, or setting it in InstantiateData",
        "oneOf": [
          {
            "description": "A reference to an externally hosted logo. Must be a valid HTTP or HTTPS URL.",
            "type": "object",
            "required": [
              "url"
            ],
            "properties": {
              "url": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Logo content stored on the blockchain. Enforce maximum size of 5KB on all variants",
            "type": "object",
            "required": [
              "embedded"
            ],
            "properties": {
              "embedded": {
                "$ref": "#/definitions/EmbeddedLogo"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "UpdateMarketingInfo": {
        "description": "This structure stores marketing information for vxASTRO.",
        "type": "object",
        "properties": {
          "description": {
            "description": "Token description",
            "type": [
              "string",
              "null"
            ]
          },
          "logo": {
            "description": "Token logo",
            "anyOf": [
              {
                "$ref": "#/definitions/Logo"
              },
              {
                "type": "null"
              }
            ]
          },
          "marketing": {
            "description": "Token marketing information",
            "type": [
              "string",
              "null"
            ]
          },
          "project": {
            "description": "Project URL",
            "type": [
              "string",
              "null"
            ]
          }
        },
        "additionalProperties": false
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Vote allows a vxASTRO holders to cast votes on which pools should get ASTRO emissions in the next epoch",
        "type": "object",
        "required": [
          "vote"
        ],
        "properties": {
          "vote": {
            "type": "object",
            "required": [
              "votes"
            ],
            "properties": {
              "votes": {
                "type": "array",
                "items": {
                  "type": "array",
                  "items": [
                    {
                      "type": "string"
                    },
                    {
                      "$ref": "#/definitions/Decimal"
                    }
                  ],
                  "maxItems": 2,
                  "minItems": 2
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only vxASTRO contract can call this endpoint. Updates user votes according to the current voting power.",
        "type": "object",
        "required": [
          "update_user_votes"
        ],
        "properties": {
          "update_user_votes": {
            "type": "object",
            "required": [
              "is_unlock",
              "user"
            ],
            "properties": {
              "is_unlock": {
                "type": "boolean"
              },
              "user": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Permissionless endpoint which allows user to update their voting power contribution in case of IBC failures or pool has been re-added to whitelist.",
        "type": "object",
        "required": [
          "refresh_user_votes"
        ],
        "properties": {
          "refresh_user_votes": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "ProposeNewOwner proposes a new owner for the contract",
        "type": "object",
        "required": [
          "propose_new_owner"
        ],
        "properties": {
          "propose_new_owner": {
            "type": "object",
            "required": [
              "expires_in",
              "new_owner"
            ],
            "properties": {
              "expires_in": {
                "description": "The timestamp when the contract ownership change expires",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "new_owner": {
                "description": "Newly proposed contract owner",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "DropOwnershipProposal removes the latest contract ownership transfer proposal",
        "type": "object",
        "required": [
          "drop_ownership_proposal"
        ],
        "properties": {
          "drop_ownership_proposal": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "ClaimOwnership allows the newly proposed owner to claim contract ownership",
        "type": "object",
        "required": [
          "claim_ownership"
        ],
        "properties": {
          "claim_ownership": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Set of endpoints specific for Hub/Outpost",
        "type": "object",
        "required": [
          "custom"
        ],
        "properties": {
          "custom": {
            "$ref": "#/definitions/HubMsg"
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "AstroPoolConfig": {
        "type": "object",
        "required": [
          "astro_pool",
          "constant_emissions"
        ],
        "properties": {
          "astro_pool": {
            "description": "The most liquid ASTRO pool on this outpost",
            "type": "string"
          },
          "constant_emissions": {
            "description": "The constant ASTRO pool emissions. Can be set to 0 if emissions are not needed.",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "HubMsg": {
        "oneOf": [
          {
            "description": "TunePools transforms the latest vote distribution into alloc_points which turn into ASTRO emissions",
            "type": "object",
            "required": [
              "tune_pools"
            ],
            "properties": {
              "tune_pools": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Repeats IBC transfer messages with IBC hook for all outposts in Failed state.",
            "type": "object",
            "required": [
              "retry_failed_outposts"
            ],
            "properties": {
              "retry_failed_outposts": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Update the contract configuration",
            "type": "object",
            "required": [
              "update_config"
            ],
            "properties": {
              "update_config": {
                "type": "object",
                "properties": {
                  "emissions_multiple": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Decimal"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "fee_receiver": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "max_astro": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Uint128"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "pools_per_outpost": {
                    "type": [
                      "integer",
                      "null"
                    ],
                    "format": "uint64",
                    "minimum": 0.0
                  },
                  "whitelisting_fee": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Coin"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Whitelists a pool to receive ASTRO emissions. Requires fee payment",
            "type": "object",
            "required": [
              "whitelist_pool"
            ],
            "properties": {
              "whitelist_pool": {
                "type": "object",
                "required": [
                  "lp_token"
                ],
                "properties": {
                  "lp_token": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Register or update an outpost",
            "type": "object",
            "required": [
              "update_outpost"
            ],
            "properties": {
              "update_outpost": {
                "type": "object",
                "required": [
                  "astro_denom",
                  "prefix"
                ],
                "properties": {
                  "astro_denom": {
                    "description": "Astro denom on this outpost",
                    "type": "string"
                  },
                  "astro_pool_config": {
                    "description": "A pool that must receive flat ASTRO emissions. Optional.",
                    "anyOf": [
                      {
                        "$ref": "#/definitions/AstroPoolConfig"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "outpost_params": {
                    "description": "Outpost params contain all necessary information to interact with the remote outpost. This field also serves as marker whether it is The hub (params: None) or remote outpost (Some(params))",
                    "anyOf": [
                      {
                        "$ref": "#/definitions/OutpostParams"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "prefix": {
                    "description": "Bech32 prefix",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Remove an outpost",
            "type": "object",
            "required": [
              "remove_outpost"
            ],
            "properties": {
              "remove_outpost": {
                "type": "object",
                "required": [
                  "prefix"
                ],
                "properties": {
                  "prefix": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Permissionless endpoint to stream proposal info from the Hub to all outposts",
            "type": "object",
            "required": [
              "register_proposal"
            ],
            "properties": {
              "register_proposal": {
                "type": "object",
                "required": [
                  "proposal_id"
                ],
                "properties": {
                  "proposal_id": {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "OutpostParams": {
        "type": "object",
        "required": [
          "emissions_controller",
          "ics20_channel",
          "voting_channel"
        ],
        "properties": {
          "emissions_controller": {
            "description": "Emissions controller on a given outpost",
            "type": "string"
          },
          "ics20_channel": {
            "description": "General IBC channel for fungible token transfers",
            "type": "string"
          },
          "voting_channel": {
            "description": "wasm<>wasm IBC channel for voting",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "description": "This structure describes the query messages available in the contract.",
    "oneOf": [
      {
        "description": "UserInfo returns information about a voter and the pools they voted for. If timestamp is not provided, the current block time is used.",
        "type": "object",
        "required": [
          "user_info"
        ],
        "properties": {
          "user_info": {
            "type": "object",
            "required": [
              "user"
            ],
            "properties": {
              "timestamp": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "user": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "TuneInfo returns emissions voting outcome at a certain timestamp. If timestamp is not provided, return the latest tune info.",
        "type": "object",
        "required": [
          "tune_info"
        ],
        "properties": {
          "tune_info": {
            "type": "object",
            "properties": {
              "timestamp": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Config returns the contract configuration",
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "VotedPools returns how much voting power a pool received at a certain timestamp.",
        "type": "object",
        "required": [
          "voted_pool"
        ],
        "properties": {
          "voted_pool": {
            "type": "object",
            "required": [
              "pool"
            ],
            "properties": {
              "pool": {
                "type": "string"
              },
              "timestamp": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns paginated list of all pools that received votes at the current epoch",
        "type": "object",
        "required": [
          "voted_pools"
        ],
        "properties": {
          "voted_pools": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint8",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "ListOutposts returns all outposts registered in the contract",
        "type": "object",
        "required": [
          "list_outposts"
        ],
        "properties": {
          "list_outposts": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "QueryWhitelist returns the list of pools that are allowed to be voted for",
        "type": "object",
        "required": [
          "query_whitelist"
        ],
        "properties": {
          "query_whitelist": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "SimulateTune simulates the ASTRO amount that will be emitted in the next epoch per pool considering if the next epoch starts right now. This query is useful for the UI to show the expected ASTRO emissions as well as might be useful for integrator estimations. It filters out pools which don't belong to any of outposts and invalid Hub-based LP tokens. Returns TuneResultResponse object which contains emissions state and next pools grouped by outpost prefix.",
        "type": "object",
        "required": [
          "simulate_tune"
        ],
        "properties": {
          "simulate_tune": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Config",
      "description": "General contract configuration",
      "type": "object",
      "required": [
        "assembly",
        "astro_denom",
        "emissions_multiple",
        "factory",
        "fee_receiver",
        "incentives_addr",
        "max_astro",
        "owner",
        "pools_per_outpost",
        "staking",
        "vxastro",
        "whitelist_threshold",
        "whitelisting_fee",
        "xastro_denom"
      ],
      "properties": {
        "assembly": {
          "description": "Astroport Assembly contract address",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "astro_denom": {
          "description": "ASTRO denom on the Hub",
          "type": "string"
        },
        "emissions_multiple": {
          "description": "Controls the number of ASTRO emissions for the next epoch where next amount = two epoch EMA * emissions_multiple. If multiple < 1 then protocol emits less ASTRO than it buys back, otherwise protocol is inflating ASTRO supply.",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "factory": {
          "description": "Astroport Factory contract",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "fee_receiver": {
          "description": "Address that receives the whitelisting fee",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "incentives_addr": {
          "description": "The Astroport Incentives contract",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "max_astro": {
          "description": "Max ASTRO allowed per epoch. Parameter of the dynamic emissions curve.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "owner": {
          "description": "Address that's allowed to change contract parameters",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "pools_per_outpost": {
          "description": "Max number of pools that can receive ASTRO emissions per outpost added. For example, if there are 3 outposts, and the pools_limit is 10, then 30 pools can receive ASTRO emissions. This limit doesn't enforce the exact number of pools per outpost, but adds flexibility to the contract to automatically adjust the max number of pools based on the number of outposts.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "staking": {
          "description": "Staking contract",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "vxastro": {
          "description": "vxASTRO contract address",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "whitelist_threshold": {
          "description": "Minimal percentage of total voting power required to keep a pool in the whitelist",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "whitelisting_fee": {
          "description": "Fee required to whitelist a pool",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        },
        "xastro_denom": {
          "description": "xASTRO denom",
          "type": "string"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "list_outposts": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Tuple_of_String_and_OutpostInfo",
      "type": "array",
      "items": {
        "type": "array",
        "items": [
          {
            "type": "string"
          },
          {
            "$ref": "#/definitions/OutpostInfo"
          }
        ],
        "maxItems": 2,
        "minItems": 2
      },
      "definitions": {
        "AstroPoolConfig": {
          "type": "object",
          "required": [
            "astro_pool",
            "constant_emissions"
          ],
          "properties": {
            "astro_pool": {
              "description": "The most liquid ASTRO pool on this outpost",
              "type": "string"
            },
            "constant_emissions": {
              "description": "The constant ASTRO pool emissions. Can be set to 0 if emissions are not needed.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "OutpostInfo": {
          "type": "object",
          "required": [
            "astro_denom"
          ],
          "properties": {
            "astro_denom": {
              "description": "ASTRO token denom",
              "type": "string"
            },
            "astro_pool_config": {
              "description": "A pool that must receive flat ASTRO emissions. Optional.",
              "anyOf": [
                {
                  "$ref": "#/definitions/AstroPoolConfig"
                },
                {
                  "type": "null"
                }
              ]
            },
            "params": {
              "description": "Outpost params contain all necessary information to interact with the remote outpost. This field also serves as marker whether it is The hub (params: None) or remote outpost (Some(params))",
              "anyOf": [
                {
                  "$ref": "#/definitions/OutpostParams"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "OutpostParams": {
          "type": "object",
          "required": [
            "emissions_controller",
            "ics20_channel",
            "voting_channel"
          ],
          "properties": {
            "emissions_controller": {
              "description": "Emissions controller on a given outpost",
              "type": "string"
            },
            "ics20_channel": {
              "description": "General IBC channel for fungible token transfers",
              "type": "string"
            },
            "voting_channel": {
              "description": "wasm<>wasm IBC channel for voting",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "query_whitelist": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_String",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "simulate_tune": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "SimulateTuneResponse",
      "type": "object",
      "required": [
        "new_emissions_state",
        "next_pools_grouped"
      ],
      "properties": {
        "new_emissions_state": {
          "$ref": "#/definitions/EmissionsState"
        },
        "next_pools_grouped": {
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "array",
              "items": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/definitions/Uint128"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            }
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "EmissionsState": {
          "type": "object",
          "required": [
            "collected_astro",
            "ema",
            "emissions_amount",
            "xastro_rate"
          ],
          "properties": {
            "collected_astro": {
              "description": "Collected ASTRO from previous epoch.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "ema": {
              "description": "EMA of the collected ASTRO from the previous epoch",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "emissions_amount": {
              "description": "Amount of ASTRO to be emitted in the current epoch",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "xastro_rate": {
              "description": "xASTRO to ASTRO staking rate from the previous epoch",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "tune_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TuneInfo",
      "type": "object",
      "required": [
        "emissions_state",
        "outpost_emissions_statuses",
        "pools_grouped",
        "tune_ts"
      ],
      "properties": {
        "emissions_state": {
          "description": "State of the dynamic emissions curve",
          "allOf": [
            {
              "$ref": "#/definitions/EmissionsState"
            }
          ]
        },
        "outpost_emissions_statuses": {
          "description": "Map of outpost prefix -> IBC status. Hub should never enter this map.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/OutpostStatus"
          }
        },
        "pools_grouped": {
          "description": "Map of outpost prefix -> array of pools with their emissions",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "array",
              "items": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/definitions/Uint128"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            }
          }
        },
        "tune_ts": {
          "description": "Last time when the tune was executed. Matches epoch start i.e., Monday 00:00 UTC every 2 weeks",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "EmissionsState": {
          "type": "object",
          "required": [
            "collected_astro",
            "ema",
            "emissions_amount",
            "xastro_rate"
          ],
          "properties": {
            "collected_astro": {
              "description": "Collected ASTRO from previous epoch.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "ema": {
              "description": "EMA of the collected ASTRO from the previous epoch",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "emissions_amount": {
              "description": "Amount of ASTRO to be emitted in the current epoch",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "xastro_rate": {
              "description": "xASTRO to ASTRO staking rate from the previous epoch",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "OutpostStatus": {
          "type": "string",
          "enum": [
            "in_progress",
            "failed",
            "done"
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "user_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UserInfoResponse",
      "type": "object",
      "required": [
        "applied_votes",
        "vote_ts",
        "votes",
        "voting_power"
      ],
      "properties": {
        "applied_votes": {
          "description": "Actual applied votes. This list excludes non-whitelisted pools",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Decimal"
          }
        },
        "vote_ts": {
          "description": "Last time when a user voted",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "votes": {
          "description": "Vote distribution for all the pools a user picked",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Decimal"
          }
        },
        "voting_power": {
          "description": "Voting power used for the vote",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "voted_pool": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "VotedPoolInfo",
      "type": "object",
      "required": [
        "init_ts",
        "voting_power"
      ],
      "properties": {
        "init_ts": {
          "description": "Time when the pool was whitelisted",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "voting_power": {
          "description": "Voting power the pool received",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "voted_pools": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Tuple_of_String_and_VotedPoolInfo",
      "type": "array",
      "items": {
        "type": "array",
        "items": [
          {
            "type": "string"
          },
          {
            "$ref": "#/definitions/VotedPoolInfo"
          }
        ],
        "maxItems": 2,
        "minItems": 2
      },
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "VotedPoolInfo": {
          "type": "object",
          "required": [
            "init_ts",
            "voting_power"
          ],
          "properties": {
            "init_ts": {
              "description": "Time when the pool was whitelisted",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "voting_power": {
              "description": "Voting power the pool received",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        }
      }
    }
  }
}
