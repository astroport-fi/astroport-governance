<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","assembly","examples","assembly_schema.rs"],"content":"use astroport_governance::assembly::{ExecuteMsg, InstantiateMsg, QueryMsg};\nuse cosmwasm_schema::write_api;\n\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        query: QueryMsg,\n        execute: ExecuteMsg,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","assembly","src","contract.rs"],"content":"use cosmwasm_std::{\n    attr, entry_point, from_binary, to_binary, wasm_execute, Addr, Binary, CosmosMsg, Decimal,\n    Deps, DepsMut, Env, IbcQuery, ListChannelsResponse, MessageInfo, Order, QuerierWrapper,\n    QueryRequest, Response, StdResult, Uint128, Uint64, WasmMsg,\n};\nuse cw2::{get_contract_version, set_contract_version};\nuse cw20::{BalanceResponse, Cw20ExecuteMsg, Cw20ReceiveMsg};\nuse cw_storage_plus::Bound;\nuse std::str::FromStr;\n\nuse crate::astroport;\nuse astroport_governance::assembly::{\n    helpers::validate_links, Config, Cw20HookMsg, ExecuteMsg, InstantiateMsg, Proposal,\n    ProposalListResponse, ProposalStatus, ProposalVoteOption, ProposalVotesResponse, QueryMsg,\n    UpdateConfig,\n};\n\nuse crate::astroport::asset::addr_opt_validate;\nuse astroport::xastro_token::QueryMsg as XAstroTokenQueryMsg;\nuse astroport_governance::builder_unlock::msg::{\n    AllocationResponse, QueryMsg as BuilderUnlockQueryMsg, StateResponse,\n};\nuse astroport_governance::utils::WEEK;\nuse astroport_governance::voting_escrow::{QueryMsg as VotingEscrowQueryMsg, VotingPowerResponse};\nuse astroport_governance::voting_escrow_delegation::QueryMsg::AdjustedBalance;\n\nuse crate::error::ContractError;\nuse crate::migration::{migrate_config_to_140, migrate_proposals_to_v140, MigrateMsg};\nuse crate::state::{CONFIG, PROPOSALS, PROPOSAL_COUNT};\n\nuse ibc_controller_package::ExecuteMsg as ControllerExecuteMsg;\n\n// Contract name and version used for migration.\nconst CONTRACT_NAME: \u0026str = \"astro-assembly\";\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n// Default pagination constants\nconst DEFAULT_LIMIT: u32 = 10;\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_VOTERS_LIMIT: u32 = 100;\nconst MAX_VOTERS_LIMIT: u32 = 250;\n\n/// Creates a new contract with the specified parameters in the `msg` variable.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    if msg.whitelisted_links.is_empty() {\n        return Err(ContractError::WhitelistEmpty {});\n    }\n\n    validate_links(\u0026msg.whitelisted_links)?;\n\n    let config = Config {\n        xastro_token_addr: deps.api.addr_validate(\u0026msg.xastro_token_addr)?,\n        vxastro_token_addr: addr_opt_validate(deps.api, \u0026msg.vxastro_token_addr)?,\n        voting_escrow_delegator_addr: addr_opt_validate(\n            deps.api,\n            \u0026msg.voting_escrow_delegator_addr,\n        )?,\n        ibc_controller: addr_opt_validate(deps.api, \u0026msg.ibc_controller)?,\n        builder_unlock_addr: deps.api.addr_validate(\u0026msg.builder_unlock_addr)?,\n        proposal_voting_period: msg.proposal_voting_period,\n        proposal_effective_delay: msg.proposal_effective_delay,\n        proposal_expiration_period: msg.proposal_expiration_period,\n        proposal_required_deposit: msg.proposal_required_deposit,\n        proposal_required_quorum: Decimal::from_str(\u0026msg.proposal_required_quorum)?,\n        proposal_required_threshold: Decimal::from_str(\u0026msg.proposal_required_threshold)?,\n        whitelisted_links: msg.whitelisted_links,\n    };\n\n    config.validate()?;\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    PROPOSAL_COUNT.save(deps.storage, \u0026Uint64::zero())?;\n\n    Ok(Response::default())\n}\n\n/// Exposes all the execute functions available in the contract.\n///\n/// ## Execute messages\n/// * **ExecuteMsg::Receive(cw20_msg)** Receives a message of type [`Cw20ReceiveMsg`] and processes\n/// it depending on the received template.\n///\n/// * **ExecuteMsg::CastVote { proposal_id, vote }** Cast a vote on a specific proposal.\n///\n/// * **ExecuteMsg::EndProposal { proposal_id }** Sets the status of an expired/finalized proposal.\n///\n/// * **ExecuteMsg::ExecuteProposal { proposal_id }** Executes a successful proposal.\n///\n/// * **ExecuteMsg::RemoveCompletedProposal { proposal_id }** Removes a finalized proposal from the proposal list.\n///\n/// * **ExecuteMsg::UpdateConfig(config)** Updates the contract configuration.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::Receive(cw20_msg) =\u003e receive_cw20(deps, env, info, cw20_msg),\n        ExecuteMsg::CastVote { proposal_id, vote } =\u003e cast_vote(deps, env, info, proposal_id, vote),\n        ExecuteMsg::EndProposal { proposal_id } =\u003e end_proposal(deps, env, proposal_id),\n        ExecuteMsg::ExecuteProposal { proposal_id } =\u003e execute_proposal(deps, env, proposal_id),\n        ExecuteMsg::CheckMessages { messages } =\u003e check_messages(env, messages),\n        ExecuteMsg::CheckMessagesPassed {} =\u003e Err(ContractError::MessagesCheckPassed {}),\n        ExecuteMsg::RemoveCompletedProposal { proposal_id } =\u003e {\n            remove_completed_proposal(deps, env, proposal_id)\n        }\n        ExecuteMsg::UpdateConfig(config) =\u003e update_config(deps, env, info, config),\n        ExecuteMsg::IBCProposalCompleted {\n            proposal_id,\n            status,\n        } =\u003e update_ibc_proposal_status(deps, info, proposal_id, status),\n    }\n}\n\n/// Receives a message of type [`Cw20ReceiveMsg`] and processes it depending on the received template.\n///\n/// * **cw20_msg** CW20 message to process.\npub fn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match from_binary(\u0026cw20_msg.msg)? {\n        Cw20HookMsg::SubmitProposal {\n            title,\n            description,\n            link,\n            messages,\n            ibc_channel,\n        } =\u003e submit_proposal(\n            deps,\n            env,\n            info,\n            Addr::unchecked(cw20_msg.sender),\n            cw20_msg.amount,\n            title,\n            description,\n            link,\n            messages,\n            ibc_channel,\n        ),\n    }\n}\n\n/// Submit a brand new proposal and locks some xASTRO as an anti-spam mechanism.\n///\n/// * **sender** proposal submitter.\n///\n/// * **deposit_amount**  amount of xASTRO to deposit in order to submit the proposal.\n///\n/// * **title** proposal title.\n///\n/// * **description** proposal description.\n///\n/// * **link** proposal link.\n///\n/// * **messages** executable messages (actions to perform if the proposal passes).\n#[allow(clippy::too_many_arguments)]\npub fn submit_proposal(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    sender: Addr,\n    deposit_amount: Uint128,\n    title: String,\n    description: String,\n    link: Option\u003cString\u003e,\n    messages: Option\u003cVec\u003cCosmosMsg\u003e\u003e,\n    ibc_channel: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    if info.sender != config.xastro_token_addr {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if deposit_amount \u003c config.proposal_required_deposit {\n        return Err(ContractError::InsufficientDeposit {});\n    }\n\n    // Update the proposal count\n    let count = PROPOSAL_COUNT.update(deps.storage, |c| -\u003e StdResult\u003c_\u003e {\n        Ok(c.checked_add(Uint64::new(1))?)\n    })?;\n\n    // Check that controller exists and it supports this channel\n    if let Some(ibc_channel) = \u0026ibc_channel {\n        if let Some(ibc_controller) = \u0026config.ibc_controller {\n            check_controller_supports_channel(deps.querier, ibc_controller, ibc_channel)?;\n        } else {\n            return Err(ContractError::MissingIBCController {});\n        }\n    }\n\n    let proposal = Proposal {\n        proposal_id: count,\n        submitter: sender.clone(),\n        status: ProposalStatus::Active,\n        for_power: Uint128::zero(),\n        against_power: Uint128::zero(),\n        for_voters: Vec::new(),\n        against_voters: Vec::new(),\n        start_block: env.block.height,\n        start_time: env.block.time.seconds(),\n        end_block: env.block.height + config.proposal_voting_period,\n        delayed_end_block: env.block.height\n            + config.proposal_voting_period\n            + config.proposal_effective_delay,\n        expiration_block: env.block.height\n            + config.proposal_voting_period\n            + config.proposal_effective_delay\n            + config.proposal_expiration_period,\n        title,\n        description,\n        link,\n        messages,\n        deposit_amount,\n        ibc_channel,\n    };\n\n    proposal.validate(config.whitelisted_links)?;\n\n    PROPOSALS.save(deps.storage, count.u64(), \u0026proposal)?;\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"submit_proposal\"),\n        attr(\"submitter\", sender),\n        attr(\"proposal_id\", count),\n        attr(\n            \"proposal_end_height\",\n            (env.block.height + config.proposal_voting_period).to_string(),\n        ),\n    ]))\n}\n\n/// Cast a vote on a proposal.\n///\n/// * **proposal_id** is the identifier of the proposal.\n///\n/// * **vote_option** contains the vote option.\npub fn cast_vote(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    proposal_id: u64,\n    vote_option: ProposalVoteOption,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut proposal = PROPOSALS.load(deps.storage, proposal_id)?;\n\n    if proposal.status != ProposalStatus::Active {\n        return Err(ContractError::ProposalNotActive {});\n    }\n\n    if proposal.submitter == info.sender {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if env.block.height \u003e proposal.end_block {\n        return Err(ContractError::VotingPeriodEnded {});\n    }\n\n    if proposal.for_voters.contains(\u0026info.sender) || proposal.against_voters.contains(\u0026info.sender)\n    {\n        return Err(ContractError::UserAlreadyVoted {});\n    }\n\n    let voting_power = calc_voting_power(deps.as_ref(), info.sender.to_string(), \u0026proposal)?;\n\n    if voting_power.is_zero() {\n        return Err(ContractError::NoVotingPower {});\n    }\n\n    match vote_option {\n        ProposalVoteOption::For =\u003e {\n            proposal.for_power = proposal.for_power.checked_add(voting_power)?;\n            proposal.for_voters.push(info.sender.clone());\n        }\n        ProposalVoteOption::Against =\u003e {\n            proposal.against_power = proposal.against_power.checked_add(voting_power)?;\n            proposal.against_voters.push(info.sender.clone());\n        }\n    };\n\n    PROPOSALS.save(deps.storage, proposal_id, \u0026proposal)?;\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"cast_vote\"),\n        attr(\"proposal_id\", proposal_id.to_string()),\n        attr(\"voter\", \u0026info.sender),\n        attr(\"vote\", vote_option.to_string()),\n        attr(\"voting_power\", voting_power),\n    ]))\n}\n\n/// Ends proposal voting period and sets the proposal status by id.\npub fn end_proposal(deps: DepsMut, env: Env, proposal_id: u64) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut proposal = PROPOSALS.load(deps.storage, proposal_id)?;\n\n    if proposal.status != ProposalStatus::Active {\n        return Err(ContractError::ProposalNotActive {});\n    }\n\n    if env.block.height \u003c= proposal.end_block {\n        return Err(ContractError::VotingPeriodNotEnded {});\n    }\n\n    let config = CONFIG.load(deps.storage)?;\n\n    let for_votes = proposal.for_power;\n    let against_votes = proposal.against_power;\n    let total_votes = for_votes + against_votes;\n\n    let total_voting_power = calc_total_voting_power_at(deps.as_ref(), \u0026proposal)?;\n\n    let mut proposal_quorum: Decimal = Decimal::zero();\n    let mut proposal_threshold: Decimal = Decimal::zero();\n\n    if !total_voting_power.is_zero() {\n        proposal_quorum = Decimal::from_ratio(total_votes, total_voting_power);\n    }\n\n    if !total_votes.is_zero() {\n        proposal_threshold = Decimal::from_ratio(for_votes, total_votes);\n    }\n\n    // Determine the proposal result\n    proposal.status = if proposal_quorum \u003e= config.proposal_required_quorum\n        \u0026\u0026 proposal_threshold \u003e config.proposal_required_threshold\n    {\n        ProposalStatus::Passed\n    } else {\n        ProposalStatus::Rejected\n    };\n\n    PROPOSALS.save(deps.storage, proposal_id, \u0026proposal)?;\n\n    let response = Response::new()\n        .add_attributes(vec![\n            attr(\"action\", \"end_proposal\"),\n            attr(\"proposal_id\", proposal_id.to_string()),\n            attr(\"proposal_result\", proposal.status.to_string()),\n        ])\n        .add_message(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: config.xastro_token_addr.to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                recipient: proposal.submitter.to_string(),\n                amount: proposal.deposit_amount,\n            })?,\n            funds: vec![],\n        }));\n\n    Ok(response)\n}\n\n/// Executes a successful proposal by id.\npub fn execute_proposal(\n    deps: DepsMut,\n    env: Env,\n    proposal_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut proposal = PROPOSALS.load(deps.storage, proposal_id)?;\n\n    if proposal.status != ProposalStatus::Passed {\n        return Err(ContractError::ProposalNotPassed {});\n    }\n\n    if env.block.height \u003c proposal.delayed_end_block {\n        return Err(ContractError::ProposalDelayNotEnded {});\n    }\n\n    if env.block.height \u003e proposal.expiration_block {\n        return Err(ContractError::ExecuteProposalExpired {});\n    }\n\n    let messages;\n    if let Some(channel) = \u0026proposal.ibc_channel {\n        let config = CONFIG.load(deps.storage)?;\n\n        messages = match \u0026proposal.messages {\n            Some(messages) =\u003e {\n                if !messages.is_empty() {\n                    proposal.status = ProposalStatus::InProgress;\n                    vec![CosmosMsg::Wasm(wasm_execute(\n                        config\n                            .ibc_controller\n                            .ok_or(ContractError::MissingIBCController {})?,\n                        \u0026ControllerExecuteMsg::IbcExecuteProposal {\n                            channel_id: channel.to_string(),\n                            proposal_id,\n                            messages: messages.to_vec(),\n                        },\n                        vec![],\n                    )?)]\n                } else {\n                    proposal.status = ProposalStatus::Executed;\n                    vec![]\n                }\n            }\n            None =\u003e {\n                proposal.status = ProposalStatus::Executed;\n                vec![]\n            }\n        };\n\n        PROPOSALS.save(deps.storage, proposal_id, \u0026proposal)?;\n    } else {\n        proposal.status = ProposalStatus::Executed;\n        PROPOSALS.save(deps.storage, proposal_id, \u0026proposal)?;\n\n        messages = proposal.messages.unwrap_or_default()\n    }\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"execute_proposal\")\n        .add_attribute(\"proposal_id\", proposal_id.to_string())\n        .add_messages(messages))\n}\n\n/// Checks that proposal messages are correct.\npub fn check_messages(env: Env, mut messages: Vec\u003cCosmosMsg\u003e) -\u003e Result\u003cResponse, ContractError\u003e {\n    messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: env.contract.address.to_string(),\n        msg: to_binary(\u0026ExecuteMsg::CheckMessagesPassed {})?,\n        funds: vec![],\n    }));\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"check_messages\")\n        .add_messages(messages))\n}\n\n/// Removes an expired or rejected proposal from the general proposal list.\npub fn remove_completed_proposal(\n    deps: DepsMut,\n    env: Env,\n    proposal_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    let mut proposal = PROPOSALS.load(deps.storage, proposal_id)?;\n\n    if env.block.height\n        \u003e (proposal.end_block + config.proposal_effective_delay + config.proposal_expiration_period)\n    {\n        proposal.status = ProposalStatus::Expired;\n    }\n\n    if proposal.status != ProposalStatus::Expired \u0026\u0026 proposal.status != ProposalStatus::Rejected {\n        return Err(ContractError::ProposalNotCompleted {});\n    }\n\n    PROPOSALS.remove(deps.storage, proposal_id);\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"remove_completed_proposal\")\n        .add_attribute(\"proposal_id\", proposal_id.to_string()))\n}\n\n/// Updates Assembly contract parameters.\n///\n/// * **updated_config** new contract configuration.\npub fn update_config(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    updated_config: Box\u003cUpdateConfig\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    // Only the Assembly is allowed to update its own parameters (through a successful proposal)\n    if info.sender != env.contract.address {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(xastro_token_addr) = updated_config.xastro_token_addr {\n        config.xastro_token_addr = deps.api.addr_validate(\u0026xastro_token_addr)?;\n    }\n\n    if let Some(vxastro_token_addr) = updated_config.vxastro_token_addr {\n        config.vxastro_token_addr = Some(deps.api.addr_validate(\u0026vxastro_token_addr)?);\n    }\n\n    if let Some(voting_escrow_delegator_addr) = updated_config.voting_escrow_delegator_addr {\n        config.voting_escrow_delegator_addr = Some(\n            deps.api\n                .addr_validate(voting_escrow_delegator_addr.as_str())?,\n        )\n    }\n\n    if let Some(ibc_controller) = updated_config.ibc_controller {\n        config.ibc_controller = Some(deps.api.addr_validate(\u0026ibc_controller)?)\n    }\n\n    if let Some(builder_unlock_addr) = updated_config.builder_unlock_addr {\n        config.builder_unlock_addr = deps.api.addr_validate(\u0026builder_unlock_addr)?;\n    }\n\n    if let Some(proposal_voting_period) = updated_config.proposal_voting_period {\n        config.proposal_voting_period = proposal_voting_period;\n    }\n\n    if let Some(proposal_effective_delay) = updated_config.proposal_effective_delay {\n        config.proposal_effective_delay = proposal_effective_delay;\n    }\n\n    if let Some(proposal_expiration_period) = updated_config.proposal_expiration_period {\n        config.proposal_expiration_period = proposal_expiration_period;\n    }\n\n    if let Some(proposal_required_deposit) = updated_config.proposal_required_deposit {\n        config.proposal_required_deposit = Uint128::from(proposal_required_deposit);\n    }\n\n    if let Some(proposal_required_quorum) = updated_config.proposal_required_quorum {\n        config.proposal_required_quorum = Decimal::from_str(\u0026proposal_required_quorum)?;\n    }\n\n    if let Some(proposal_required_threshold) = updated_config.proposal_required_threshold {\n        config.proposal_required_threshold = Decimal::from_str(\u0026proposal_required_threshold)?;\n    }\n\n    if let Some(whitelist_add) = updated_config.whitelist_add {\n        validate_links(\u0026whitelist_add)?;\n\n        config.whitelisted_links.append(\n            \u0026mut whitelist_add\n                .into_iter()\n                .filter(|link| !config.whitelisted_links.contains(link))\n                .collect(),\n        );\n    }\n\n    if let Some(whitelist_remove) = updated_config.whitelist_remove {\n        config\n            .whitelisted_links\n            .retain(|link| !whitelist_remove.contains(link));\n\n        if config.whitelisted_links.is_empty() {\n            return Err(ContractError::WhitelistEmpty {});\n        }\n    }\n\n    config.validate()?;\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::new().add_attribute(\"action\", \"update_config\"))\n}\n\n/// Updates proposal status InProgress -\u003e Executed or Failed. Intended to be called in the end of\n/// the ibc execution cycle via ibc-controller. Only ibc controller is able to call this function.\n///\n/// * **id** proposal's id,\n///\n/// * **status** a new proposal status reported by ibc controller.\nfn update_ibc_proposal_status(\n    deps: DepsMut,\n    info: MessageInfo,\n    id: u64,\n    new_status: ProposalStatus,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n    if Some(info.sender) == config.ibc_controller {\n        let mut proposal = PROPOSALS.load(deps.storage, id)?;\n\n        if proposal.status != ProposalStatus::InProgress {\n            return Err(ContractError::WrongIbcProposalStatus(\n                proposal.status.to_string(),\n            ));\n        }\n\n        match new_status {\n            ProposalStatus::Executed {} | ProposalStatus::Failed {} =\u003e {\n                proposal.status = new_status;\n                PROPOSALS.save(deps.storage, id, \u0026proposal)?;\n                Ok(Response::new().add_attribute(\"action\", \"ibc_proposal_completed\"))\n            }\n            _ =\u003e Err(ContractError::InvalidRemoteIbcProposalStatus(\n                new_status.to_string(),\n            )),\n        }\n    } else {\n        Err(ContractError::InvalidIBCController {})\n    }\n}\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::Config {}** Returns core contract settings stored in the [`Config`] structure.\n///\n/// * **QueryMsg::Proposals { start, limit }** Returns a [`ProposalListResponse`] according to the specified input parameters.\n///\n/// * **QueryMsg::Proposal { proposal_id }** Returns a [`Proposal`] according to the specified `proposal_id`.\n///\n/// * **QueryMsg::ProposalVotes { proposal_id }** Returns proposal vote counts that are stored in the [`ProposalVotesResponse`] structure.\n///\n/// * **QueryMsg::UserVotingPower { user, proposal_id }** Returns user voting power for a specific proposal.\n///\n/// * **QueryMsg::TotalVotingPower { proposal_id }** Returns total voting power for a specific proposal.\n///\n/// * **QueryMsg::ProposalVoters {\n///             proposal_id,\n///             vote_option,\n///             start,\n///             limit,\n///         }** Returns a vector of proposal voters according to the specified input parameters.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Config {} =\u003e to_binary(\u0026CONFIG.load(deps.storage)?),\n        QueryMsg::Proposals { start, limit } =\u003e to_binary(\u0026query_proposals(deps, start, limit)?),\n        QueryMsg::Proposal { proposal_id } =\u003e {\n            to_binary(\u0026PROPOSALS.load(deps.storage, proposal_id)?)\n        }\n        QueryMsg::ProposalVotes { proposal_id } =\u003e {\n            to_binary(\u0026query_proposal_votes(deps, proposal_id)?)\n        }\n        QueryMsg::UserVotingPower { user, proposal_id } =\u003e {\n            let proposal = PROPOSALS.load(deps.storage, proposal_id)?;\n\n            deps.api.addr_validate(\u0026user)?;\n\n            to_binary(\u0026calc_voting_power(deps, user, \u0026proposal)?)\n        }\n        QueryMsg::TotalVotingPower { proposal_id } =\u003e {\n            let proposal = PROPOSALS.load(deps.storage, proposal_id)?;\n            to_binary(\u0026calc_total_voting_power_at(deps, \u0026proposal)?)\n        }\n        QueryMsg::ProposalVoters {\n            proposal_id,\n            vote_option,\n            start,\n            limit,\n        } =\u003e to_binary(\u0026query_proposal_voters(\n            deps,\n            proposal_id,\n            vote_option,\n            start,\n            limit,\n        )?),\n    }\n}\n\n/// Returns the current proposal list.\npub fn query_proposals(\n    deps: Deps,\n    start: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cProposalListResponse\u003e {\n    let proposal_count = PROPOSAL_COUNT.load(deps.storage)?;\n\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start.map(Bound::inclusive);\n\n    let proposal_list = PROPOSALS\n        .range(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|item| {\n            let (_, v) = item?;\n            Ok(v)\n        })\n        .collect::\u003cStdResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n    Ok(ProposalListResponse {\n        proposal_count,\n        proposal_list,\n    })\n}\n\n/// Returns proposal's voters.\npub fn query_proposal_voters(\n    deps: Deps,\n    proposal_id: u64,\n    vote_option: ProposalVoteOption,\n    start: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cVec\u003cAddr\u003e\u003e {\n    let limit = limit.unwrap_or(DEFAULT_VOTERS_LIMIT).min(MAX_VOTERS_LIMIT);\n    let start = start.unwrap_or_default();\n\n    let proposal = PROPOSALS.load(deps.storage, proposal_id)?;\n\n    let voters = match vote_option {\n        ProposalVoteOption::For =\u003e proposal.for_voters,\n        ProposalVoteOption::Against =\u003e proposal.against_voters,\n    };\n\n    Ok(voters\n        .iter()\n        .skip(start as usize)\n        .take(limit as usize)\n        .cloned()\n        .collect())\n}\n\n/// Returns proposal votes stored in the [`ProposalVotesResponse`] structure.\npub fn query_proposal_votes(deps: Deps, proposal_id: u64) -\u003e StdResult\u003cProposalVotesResponse\u003e {\n    let proposal = PROPOSALS.load(deps.storage, proposal_id)?;\n\n    Ok(ProposalVotesResponse {\n        proposal_id,\n        for_power: proposal.for_power,\n        against_power: proposal.against_power,\n    })\n}\n\n/// Calculates an address' voting power at the specified block.\n///\n/// * **sender** address whose voting power we calculate.\n///\n/// * **proposal** proposal for which we want to compute the `sender` (voter) voting power.\npub fn calc_voting_power(deps: Deps, sender: String, proposal: \u0026Proposal) -\u003e StdResult\u003cUint128\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // This is the address' xASTRO balance at the previous block (proposal.start_block - 1).\n    // We use the previous block because it always has an up-to-date checkpoint.\n    // BalanceAt will always return the balance information in the previous block,\n    // so we don't subtract one block from proposal.start_block.\n    let xastro_amount: BalanceResponse = deps.querier.query_wasm_smart(\n        config.xastro_token_addr,\n        \u0026XAstroTokenQueryMsg::BalanceAt {\n            address: sender.clone(),\n            block: proposal.start_block,\n        },\n    )?;\n\n    let mut total = xastro_amount.balance;\n\n    let locked_amount: AllocationResponse = deps.querier.query_wasm_smart(\n        config.builder_unlock_addr,\n        \u0026BuilderUnlockQueryMsg::Allocation {\n            account: sender.clone(),\n        },\n    )?;\n\n    if !locked_amount.params.amount.is_zero() {\n        total = total\n            .checked_add(locked_amount.params.amount)?\n            .checked_sub(locked_amount.status.astro_withdrawn)?;\n    }\n\n    if let Some(vxastro_token_addr) = config.vxastro_token_addr {\n        let vxastro_amount: Uint128 =\n            if let Some(voting_escrow_delegator_addr) = config.voting_escrow_delegator_addr {\n                deps.querier.query_wasm_smart(\n                    voting_escrow_delegator_addr,\n                    \u0026AdjustedBalance {\n                        account: sender.clone(),\n                        timestamp: Some(proposal.start_time - WEEK),\n                    },\n                )?\n            } else {\n                let res: VotingPowerResponse = deps.querier.query_wasm_smart(\n                    \u0026vxastro_token_addr,\n                    \u0026VotingEscrowQueryMsg::UserVotingPowerAt {\n                        user: sender.clone(),\n                        time: proposal.start_time - WEEK,\n                    },\n                )?;\n\n                res.voting_power\n            };\n\n        if !vxastro_amount.is_zero() {\n            total = total.checked_add(vxastro_amount)?;\n        }\n\n        let locked_xastro: Uint128 = deps.querier.query_wasm_smart(\n            vxastro_token_addr,\n            \u0026VotingEscrowQueryMsg::UserDepositAtHeight {\n                user: sender,\n                height: proposal.start_block,\n            },\n        )?;\n\n        total = total.checked_add(locked_xastro)?;\n    }\n\n    Ok(total)\n}\n\n/// Calculates the total voting power at a specified block (that is relevant for a specific proposal).\n///\n/// * **proposal** proposal for which we calculate the total voting power.\npub fn calc_total_voting_power_at(deps: Deps, proposal: \u0026Proposal) -\u003e StdResult\u003cUint128\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // This is the address' xASTRO balance at the previous block (proposal.start_block - 1).\n    // We use the previous block because it always has an up-to-date checkpoint.\n    let mut total: Uint128 = deps.querier.query_wasm_smart(\n        \u0026config.xastro_token_addr,\n        \u0026XAstroTokenQueryMsg::TotalSupplyAt {\n            block: proposal.start_block - 1,\n        },\n    )?;\n\n    // Total amount of ASTRO locked in the initial builder's unlock schedule\n    let builder_state: StateResponse = deps\n        .querier\n        .query_wasm_smart(config.builder_unlock_addr, \u0026BuilderUnlockQueryMsg::State {})?;\n\n    if !builder_state.remaining_astro_tokens.is_zero() {\n        total = total.checked_add(builder_state.remaining_astro_tokens)?;\n    }\n\n    if let Some(vxastro_token_addr) = config.vxastro_token_addr {\n        // Total vxASTRO voting power\n        let vxastro: VotingPowerResponse = deps.querier.query_wasm_smart(\n            vxastro_token_addr,\n            \u0026VotingEscrowQueryMsg::TotalVotingPowerAt {\n                time: proposal.start_time - WEEK,\n            },\n        )?;\n        if !vxastro.voting_power.is_zero() {\n            total = total.checked_add(vxastro.voting_power)?;\n        }\n    }\n\n    Ok(total)\n}\n\n/// Checks that controller supports given IBC-channel.\n/// ## Params\n/// * **querier** is an object of type [`QuerierWrapper`].\n///\n/// * **ibc_controller** is an ibc controller contract address.\n///\n/// * **given_channel** is an IBC channel id the function needs to check.\npub fn check_controller_supports_channel(\n    querier: QuerierWrapper,\n    ibc_controller: \u0026Addr,\n    given_channel: \u0026String,\n) -\u003e Result\u003c(), ContractError\u003e {\n    let port_id = Some(format!(\"wasm.{ibc_controller}\"));\n    let ListChannelsResponse { channels } =\n        querier.query(\u0026QueryRequest::Ibc(IbcQuery::ListChannels { port_id }))?;\n    channels\n        .iter()\n        .find(|channel| \u0026channel.endpoint.channel_id == given_channel)\n        .map(|_| ())\n        .ok_or_else(|| ContractError::InvalidChannel(given_channel.to_string()))\n}\n\n/// Manages contract migration.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(mut deps: DepsMut, _env: Env, msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    let contract_version = get_contract_version(deps.storage)?;\n\n    match contract_version.contract.as_ref() {\n        \"astro-assembly\" =\u003e match contract_version.version.as_ref() {\n            \"1.3.0\" =\u003e {\n                let cfg = migrate_config_to_140(deps.branch(), msg)?;\n                migrate_proposals_to_v140(deps.branch(), \u0026cfg)?;\n            }\n            _ =\u003e return Err(ContractError::MigrationError {}),\n        },\n        _ =\u003e return Err(ContractError::MigrationError {}),\n    };\n\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    Ok(Response::new()\n        .add_attribute(\"previous_contract_name\", \u0026contract_version.contract)\n        .add_attribute(\"previous_contract_version\", \u0026contract_version.version)\n        .add_attribute(\"new_contract_name\", CONTRACT_NAME)\n        .add_attribute(\"new_contract_version\", CONTRACT_VERSION))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","assembly","src","error.rs"],"content":"use astroport_governance::assembly::ProposalStatus;\nuse cosmwasm_std::{OverflowError, StdError};\nuse thiserror::Error;\n\n/// This enum describes Assembly contract errors\n#[derive(Error, Debug)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Proposal not active!\")]\n    ProposalNotActive {},\n\n    #[error(\"Voting period ended!\")]\n    VotingPeriodEnded {},\n\n    #[error(\"User already voted!\")]\n    UserAlreadyVoted {},\n\n    #[error(\"You don't have any voting power!\")]\n    NoVotingPower {},\n\n    #[error(\"Voting period not ended yet!\")]\n    VotingPeriodNotEnded {},\n\n    #[error(\"Proposal expired!\")]\n    ExecuteProposalExpired {},\n\n    #[error(\"Insufficient token deposit!\")]\n    InsufficientDeposit {},\n\n    #[error(\"Proposal not passed!\")]\n    ProposalNotPassed {},\n\n    #[error(\"Proposal not completed!\")]\n    ProposalNotCompleted {},\n\n    #[error(\"Proposal delay not ended!\")]\n    ProposalDelayNotEnded {},\n\n    #[error(\"Contract can't be migrated!\")]\n    MigrationError {},\n\n    #[error(\"Whitelist cannot be empty!\")]\n    WhitelistEmpty {},\n\n    #[error(\"Messages check passed. Nothing was committed to the blockchain\")]\n    MessagesCheckPassed {},\n\n    #[error(\"IBC controller does not have channel {0}\")]\n    InvalidChannel(String),\n\n    #[error(\"IBC controller is not set\")]\n    MissingIBCController {},\n\n    #[error(\n        \"Failed to process callback from IBC controller as proposal {0} is not in \\\"{}\\\" state\",\n        ProposalStatus::InProgress\n    )]\n    WrongIbcProposalStatus(String),\n\n    #[error(\"The IBC controller reports an invalid proposal status: {0}. Valid statuses: failed or executed \")]\n    InvalidRemoteIbcProposalStatus(String),\n\n    #[error(\"Sender is not an IBC controller installed in the assembly\")]\n    InvalidIBCController {},\n}\n\nimpl From\u003cOverflowError\u003e for ContractError {\n    fn from(o: OverflowError) -\u003e Self {\n        StdError::from(o).into()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","assembly","src","lib.rs"],"content":"pub mod contract;\npub mod error;\npub mod state;\n\nmod migration;\n\n// During development this import could be replaced with another astroport version.\n// However, in production, the astroport version should be the same for all contracts.\npub use astroport_governance::astroport;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","assembly","src","migration.rs"],"content":"use crate::state::{CONFIG, PROPOSALS};\nuse astroport_governance::{\n    assembly::{Config, Proposal, ProposalStatus},\n    astroport::asset::addr_opt_validate,\n};\n\nuse cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, CosmosMsg, Decimal, DepsMut, StdResult, Uint128, Uint64};\nuse cw_storage_plus::{Item, Map};\n\n/// This structure describes a migration message.\n#[cw_serde]\npub struct MigrateMsg {\n    voting_escrow_delegator_addr: Option\u003cString\u003e,\n    vxastro_token_addr: Option\u003cString\u003e,\n    ibc_controller: Option\u003cString\u003e,\n}\n\n#[cw_serde]\npub struct ProposalV130 {\n    /// Unique proposal ID\n    pub proposal_id: Uint64,\n    /// The address of the proposal submitter\n    pub submitter: Addr,\n    /// Status of the proposal\n    pub status: ProposalStatus,\n    /// `For` power of proposal\n    pub for_power: Uint128,\n    /// `Against` power of proposal\n    pub against_power: Uint128,\n    /// `For` votes for the proposal\n    pub for_voters: Vec\u003cAddr\u003e,\n    /// `Against` votes for the proposal\n    pub against_voters: Vec\u003cAddr\u003e,\n    /// Start block of proposal\n    pub start_block: u64,\n    /// Start time of proposal\n    pub start_time: u64,\n    /// End block of proposal\n    pub end_block: u64,\n    /// Delayed end block of proposal\n    pub delayed_end_block: u64,\n    /// Expiration block of proposal\n    pub expiration_block: u64,\n    /// Proposal title\n    pub title: String,\n    /// Proposal description\n    pub description: String,\n    /// Proposal link\n    pub link: Option\u003cString\u003e,\n    /// Proposal messages\n    pub messages: Option\u003cVec\u003cCosmosMsg\u003e\u003e,\n    /// Amount of xASTRO deposited in order to post the proposal\n    pub deposit_amount: Uint128,\n    /// IBC channel\n    pub ibc_channel: Option\u003cString\u003e,\n}\n\n#[cw_serde]\npub struct ConfigV130 {\n    /// xASTRO token address\n    pub xastro_token_addr: Addr,\n    /// vxASTRO token address\n    pub vxastro_token_addr: Option\u003cAddr\u003e,\n    /// Astroport IBC controller contract\n    pub ibc_controller: Option\u003cAddr\u003e,\n    /// Builder unlock contract address\n    pub builder_unlock_addr: Addr,\n    /// Proposal voting period\n    pub proposal_voting_period: u64,\n    /// Proposal effective delay\n    pub proposal_effective_delay: u64,\n    /// Proposal expiration period\n    pub proposal_expiration_period: u64,\n    /// Proposal required deposit\n    pub proposal_required_deposit: Uint128,\n    /// Proposal required quorum\n    pub proposal_required_quorum: Decimal,\n    /// Proposal required threshold\n    pub proposal_required_threshold: Decimal,\n    /// Whitelisted links\n    pub whitelisted_links: Vec\u003cString\u003e,\n}\n\npub const CONFIG_V130: Item\u003cConfigV130\u003e = Item::new(\"config\");\n\n/// Migrate proposals to V1.4.0\npub(crate) fn migrate_proposals_to_v140(deps: DepsMut, cfg: \u0026Config) -\u003e StdResult\u003c()\u003e {\n    let v130_proposals_interface: Map\u003cu64, ProposalV130\u003e = Map::new(\"proposals\");\n    let proposals_v130 = v130_proposals_interface\n        .range(deps.storage, None, None, cosmwasm_std::Order::Ascending {})\n        .collect::\u003cStdResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n    for (key, proposal) in proposals_v130 {\n        PROPOSALS.save(\n            deps.storage,\n            key,\n            \u0026Proposal {\n                proposal_id: proposal.proposal_id,\n                submitter: proposal.submitter,\n                status: proposal.status,\n                for_power: proposal.for_power,\n                against_power: proposal.against_power,\n                for_voters: proposal.for_voters,\n                against_voters: proposal.against_voters,\n                start_block: proposal.start_block,\n                start_time: proposal.start_time,\n                end_block: proposal.end_block,\n                delayed_end_block: proposal.end_block + cfg.proposal_effective_delay,\n                expiration_block: proposal.end_block\n                    + cfg.proposal_effective_delay\n                    + cfg.proposal_expiration_period,\n                title: proposal.title,\n                description: proposal.description,\n                link: proposal.link,\n                messages: proposal.messages,\n                deposit_amount: proposal.deposit_amount,\n                ibc_channel: proposal.ibc_channel,\n            },\n        )?;\n    }\n\n    Ok(())\n}\n\n/// Migrate contract config to V1.4.0\npub(crate) fn migrate_config_to_140(deps: DepsMut, msg: MigrateMsg) -\u003e StdResult\u003cConfig\u003e {\n    let cfg_v130 = CONFIG_V130.load(deps.storage)?;\n\n    let cfg = Config {\n        xastro_token_addr: cfg_v130.xastro_token_addr,\n        vxastro_token_addr: cfg_v130.vxastro_token_addr,\n        voting_escrow_delegator_addr: addr_opt_validate(\n            deps.api,\n            \u0026msg.voting_escrow_delegator_addr,\n        )?,\n        ibc_controller: cfg_v130.ibc_controller,\n        builder_unlock_addr: cfg_v130.builder_unlock_addr,\n        proposal_voting_period: cfg_v130.proposal_voting_period,\n        proposal_effective_delay: cfg_v130.proposal_effective_delay,\n        proposal_expiration_period: cfg_v130.proposal_expiration_period,\n        proposal_required_deposit: cfg_v130.proposal_required_deposit,\n        proposal_required_quorum: cfg_v130.proposal_required_quorum,\n        proposal_required_threshold: cfg_v130.proposal_required_threshold,\n        whitelisted_links: cfg_v130.whitelisted_links,\n    };\n\n    CONFIG.save(deps.storage, \u0026cfg)?;\n\n    Ok(cfg)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","assembly","src","state.rs"],"content":"use astroport_governance::assembly::{Config, Proposal};\nuse cosmwasm_std::Uint64;\nuse cw_storage_plus::{Item, Map};\n\n/// Stores the config for the Assembly contract\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n\n/// Stores the global state for the Assembly contract\npub const PROPOSAL_COUNT: Item\u003cUint64\u003e = Item::new(\"proposal_count\");\n\n/// This is a map that contains information about all proposals\npub const PROPOSALS: Map\u003cu64, Proposal\u003e = Map::new(\"proposals\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","assembly","tests","integration.rs"],"content":"use astro_assembly::astroport;\nuse astroport::{\n    token::InstantiateMsg as TokenInstantiateMsg, xastro_token::QueryMsg as XAstroQueryMsg,\n};\nuse astroport_governance::assembly::{\n    Config, Cw20HookMsg, ExecuteMsg, InstantiateMsg, Proposal, ProposalListResponse,\n    ProposalStatus, ProposalVoteOption, ProposalVotesResponse, QueryMsg, UpdateConfig,\n    DEPOSIT_INTERVAL, VOTING_PERIOD_INTERVAL,\n};\n\nuse std::str::FromStr;\n\nuse astroport_governance::voting_escrow::{\n    Cw20HookMsg as VXAstroCw20HookMsg, InstantiateMsg as VXAstroInstantiateMsg,\n};\n\nuse astroport_governance::builder_unlock::msg::{\n    InstantiateMsg as BuilderUnlockInstantiateMsg, ReceiveMsg as BuilderUnlockReceiveMsg,\n};\nuse astroport_governance::builder_unlock::{AllocationParams, Schedule};\nuse astroport_governance::utils::{EPOCH_START, WEEK};\nuse astroport_governance::voting_escrow_delegation::{\n    ExecuteMsg as DelegatorExecuteMsg, InstantiateMsg as DelegatorInstantiateMsg,\n    QueryMsg as DelegatorQueryMsg,\n};\nuse cosmwasm_std::{\n    testing::{mock_env, MockApi, MockStorage},\n    to_binary, Addr, Binary, CosmosMsg, Decimal, QueryRequest, StdResult, Timestamp, Uint128,\n    Uint64, WasmMsg, WasmQuery,\n};\nuse cw20::{BalanceResponse, Cw20ExecuteMsg, MinterResponse};\nuse cw_multi_test::{\n    next_block, App, AppBuilder, AppResponse, BankKeeper, ContractWrapper, Executor,\n};\n\nconst PROPOSAL_VOTING_PERIOD: u64 = *VOTING_PERIOD_INTERVAL.start();\nconst PROPOSAL_EFFECTIVE_DELAY: u64 = 12_342;\nconst PROPOSAL_EXPIRATION_PERIOD: u64 = 86_399;\nconst PROPOSAL_REQUIRED_DEPOSIT: u128 = *DEPOSIT_INTERVAL.start();\nconst PROPOSAL_REQUIRED_QUORUM: \u0026str = \"0.50\";\nconst PROPOSAL_REQUIRED_THRESHOLD: \u0026str = \"0.60\";\n\n#[cfg(not(feature = \"testnet\"))]\n#[test]\nfn test_contract_instantiation() {\n    let mut app = mock_app();\n\n    let owner = Addr::unchecked(\"owner\");\n\n    // Instantiate needed contracts\n    let token_addr = instantiate_astro_token(\u0026mut app, \u0026owner);\n    let (_, xastro_token_addr) = instantiate_xastro_token(\u0026mut app, \u0026owner, \u0026token_addr);\n    let vxastro_token_addr = instantiate_vxastro_token(\u0026mut app, \u0026owner, \u0026xastro_token_addr);\n    let builder_unlock_addr = instantiate_builder_unlock_contract(\u0026mut app, \u0026owner, \u0026token_addr);\n\n    let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n        astro_assembly::contract::execute,\n        astro_assembly::contract::instantiate,\n        astro_assembly::contract::query,\n    ));\n\n    let assembly_code = app.store_code(assembly_contract);\n\n    let assembly_default_instantiate_msg = InstantiateMsg {\n        xastro_token_addr: xastro_token_addr.to_string(),\n        vxastro_token_addr: Some(vxastro_token_addr.to_string()),\n        voting_escrow_delegator_addr: None,\n        ibc_controller: None,\n        builder_unlock_addr: builder_unlock_addr.to_string(),\n        proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n        proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n        proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n        proposal_required_deposit: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n        proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n        proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n        whitelisted_links: vec![\"https://some.link/\".to_string()],\n    };\n\n    // Try to instantiate assembly with wrong threshold\n    let err = app\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                proposal_required_threshold: \"0.3\".to_string(),\n                ..assembly_default_instantiate_msg.clone()\n            },\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: The required threshold for a proposal cannot be lower than 33% or higher than 100%\"\n    );\n\n    let err = app\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                proposal_required_threshold: \"1.1\".to_string(),\n                ..assembly_default_instantiate_msg.clone()\n            },\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: The required threshold for a proposal cannot be lower than 33% or higher than 100%\"\n    );\n\n    let err = app\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                proposal_required_quorum: \"1.1\".to_string(),\n                ..assembly_default_instantiate_msg.clone()\n            },\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: The required quorum for a proposal cannot be lower than 1% or higher than 100%\"\n    );\n\n    let err = app\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                proposal_expiration_period: 500,\n                ..assembly_default_instantiate_msg.clone()\n            },\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: The expiration period for a proposal cannot be lower than 12342 or higher than 100800\"\n    );\n\n    let err = app\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                proposal_effective_delay: 400,\n                ..assembly_default_instantiate_msg.clone()\n            },\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: The effective delay for a proposal cannot be lower than 6171 or higher than 14400\"\n    );\n\n    let assembly_instance = app\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026assembly_default_instantiate_msg,\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let res: Config = app\n        .wrap()\n        .query_wasm_smart(assembly_instance, \u0026QueryMsg::Config {})\n        .unwrap();\n\n    assert_eq!(res.xastro_token_addr, xastro_token_addr);\n    assert_eq!(res.builder_unlock_addr, builder_unlock_addr);\n    assert_eq!(res.proposal_voting_period, PROPOSAL_VOTING_PERIOD);\n    assert_eq!(res.proposal_effective_delay, PROPOSAL_EFFECTIVE_DELAY);\n    assert_eq!(res.proposal_expiration_period, PROPOSAL_EXPIRATION_PERIOD);\n    assert_eq!(\n        res.proposal_required_deposit,\n        Uint128::from(PROPOSAL_REQUIRED_DEPOSIT)\n    );\n    assert_eq!(\n        res.proposal_required_quorum,\n        Decimal::from_str(PROPOSAL_REQUIRED_QUORUM).unwrap()\n    );\n    assert_eq!(\n        res.proposal_required_threshold,\n        Decimal::from_str(PROPOSAL_REQUIRED_THRESHOLD).unwrap()\n    );\n    assert_eq!(\n        res.whitelisted_links,\n        vec![\"https://some.link/\".to_string(),]\n    );\n}\n\n#[test]\nfn test_proposal_submitting() {\n    let mut app = mock_app();\n\n    let owner = Addr::unchecked(\"owner\");\n    let user = Addr::unchecked(\"user1\");\n\n    let (_, staking_instance, xastro_addr, _, _, assembly_addr, _) =\n        instantiate_contracts(\u0026mut app, owner, false);\n\n    let proposals: ProposalListResponse = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposals {\n                start: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(proposals.proposal_count, Uint64::from(0u32));\n    assert_eq!(proposals.proposal_list, vec![]);\n\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026user,\n        PROPOSAL_REQUIRED_DEPOSIT,\n    );\n\n    check_token_balance(\u0026mut app, \u0026xastro_addr, \u0026user, PROPOSAL_REQUIRED_DEPOSIT);\n\n    // Try to create proposal with insufficient token deposit\n    let submit_proposal_msg = Cw20ExecuteMsg::Send {\n        contract: assembly_addr.to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n            title: String::from(\"Title\"),\n            description: String::from(\"Description\"),\n            link: Some(String::from(\"https://some.link\")),\n            messages: None,\n            ibc_channel: None,\n        })\n        .unwrap(),\n        amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT - 1),\n    };\n\n    let err = app\n        .execute_contract(user.clone(), xastro_addr.clone(), \u0026submit_proposal_msg, \u0026[])\n        .unwrap_err();\n\n    assert_eq!(err.root_cause().to_string(), \"Insufficient token deposit!\");\n\n    // Try to create a proposal with wrong title\n    let err = app\n        .execute_contract(\n            user.clone(),\n            xastro_addr.clone(),\n            \u0026Cw20ExecuteMsg::Send {\n                contract: assembly_addr.to_string(),\n                msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                    title: String::from(\"X\"),\n                    description: String::from(\"Description\"),\n                    link: Some(String::from(\"https://some.link/\")),\n                    messages: None,\n                    ibc_channel: None,\n                })\n                .unwrap(),\n                amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Title too short!\"\n    );\n\n    let err = app\n        .execute_contract(\n            user.clone(),\n            xastro_addr.clone(),\n            \u0026Cw20ExecuteMsg::Send {\n                contract: assembly_addr.to_string(),\n                msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                    title: String::from_utf8(vec![b'X'; 65]).unwrap(),\n                    description: String::from(\"Description\"),\n                    link: Some(String::from(\"https://some.link/\")),\n                    messages: None,\n                    ibc_channel: None,\n                })\n                .unwrap(),\n                amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Title too long!\"\n    );\n\n    // Try to create a proposal with wrong description\n    let err = app\n        .execute_contract(\n            user.clone(),\n            xastro_addr.clone(),\n            \u0026Cw20ExecuteMsg::Send {\n                contract: assembly_addr.to_string(),\n                msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                    title: String::from(\"Title\"),\n                    description: String::from(\"X\"),\n                    link: Some(String::from(\"https://some.link/\")),\n                    messages: None,\n                    ibc_channel: None,\n                })\n                .unwrap(),\n                amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Description too short!\"\n    );\n\n    let err = app\n        .execute_contract(\n            user.clone(),\n            xastro_addr.clone(),\n            \u0026Cw20ExecuteMsg::Send {\n                contract: assembly_addr.to_string(),\n                msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                    title: String::from(\"Title\"),\n                    description: String::from_utf8(vec![b'X'; 1025]).unwrap(),\n                    link: Some(String::from(\"https://some.link/\")),\n                    messages: None,\n                    ibc_channel: None,\n                })\n                .unwrap(),\n                amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Description too long!\"\n    );\n\n    // Try to create a proposal with wrong link\n    let err = app\n        .execute_contract(\n            user.clone(),\n            xastro_addr.clone(),\n            \u0026Cw20ExecuteMsg::Send {\n                contract: assembly_addr.to_string(),\n                msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                    title: String::from(\"Title\"),\n                    description: String::from(\"Description\"),\n                    link: Some(String::from(\"X\")),\n                    messages: None,\n                    ibc_channel: None,\n                })\n                .unwrap(),\n                amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Link too short!\"\n    );\n\n    let err = app\n        .execute_contract(\n            user.clone(),\n            xastro_addr.clone(),\n            \u0026Cw20ExecuteMsg::Send {\n                contract: assembly_addr.to_string(),\n                msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                    title: String::from(\"Title\"),\n                    description: String::from(\"Description\"),\n                    link: Some(String::from_utf8(vec![b'X'; 129]).unwrap()),\n                    messages: None,\n                    ibc_channel: None,\n                })\n                .unwrap(),\n                amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Link too long!\"\n    );\n\n    let err = app\n        .execute_contract(\n            user.clone(),\n            xastro_addr.clone(),\n            \u0026Cw20ExecuteMsg::Send {\n                contract: assembly_addr.to_string(),\n                msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                    title: String::from(\"Title\"),\n                    description: String::from(\"Description\"),\n                    link: Some(String::from(\"https://some1.link\")),\n                    messages: None,\n                    ibc_channel: None,\n                })\n                .unwrap(),\n                amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Link is not whitelisted!\"\n    );\n\n    let err = app\n        .execute_contract(\n            user.clone(),\n            xastro_addr.clone(),\n            \u0026Cw20ExecuteMsg::Send {\n                contract: assembly_addr.to_string(),\n                msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                    title: String::from(\"Title\"),\n                    description: String::from(\"Description\"),\n                    link: Some(String::from(\n                        \"https://some.link/\u003cscript\u003ealert('test');\u003c/script\u003e\",\n                    )),\n                    messages: None,\n                    ibc_channel: None,\n                })\n                .unwrap(),\n                amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Link is not properly formatted or contains unsafe characters!\"\n    );\n\n    // Valid proposal submission\n    app.execute_contract(\n        user.clone(),\n        xastro_addr.clone(),\n        \u0026Cw20ExecuteMsg::Send {\n            contract: assembly_addr.to_string(),\n            msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                title: String::from(\"Title\"),\n                description: String::from(\"Description\"),\n                link: Some(String::from(\"https://some.link/q/\")),\n                messages: Some(vec![CosmosMsg::Wasm(WasmMsg::Execute {\n                    contract_addr: assembly_addr.to_string(),\n                    msg: to_binary(\u0026ExecuteMsg::UpdateConfig(Box::new(UpdateConfig {\n                        xastro_token_addr: None,\n                        vxastro_token_addr: None,\n                        voting_escrow_delegator_addr: None,\n                        ibc_controller: None,\n                        builder_unlock_addr: None,\n                        proposal_voting_period: Some(750),\n                        proposal_effective_delay: None,\n                        proposal_expiration_period: None,\n                        proposal_required_deposit: None,\n                        proposal_required_quorum: None,\n                        proposal_required_threshold: None,\n                        whitelist_add: None,\n                        whitelist_remove: None,\n                    })))\n                    .unwrap(),\n                    funds: vec![],\n                })]),\n                ibc_channel: None,\n            })\n            .unwrap(),\n            amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    assert_eq!(proposal.proposal_id, Uint64::from(1u64));\n    assert_eq!(proposal.submitter, user);\n    assert_eq!(proposal.status, ProposalStatus::Active);\n    assert_eq!(proposal.for_power, Uint128::zero());\n    assert_eq!(proposal.against_power, Uint128::zero());\n    assert_eq!(proposal.start_block, 12_345);\n    assert_eq!(proposal.end_block, 12_345 + PROPOSAL_VOTING_PERIOD);\n    assert_eq!(proposal.title, String::from(\"Title\"));\n    assert_eq!(proposal.description, String::from(\"Description\"));\n    assert_eq!(proposal.link, Some(String::from(\"https://some.link/q/\")));\n    assert_eq!(\n        proposal.messages,\n        Some(vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: assembly_addr.to_string(),\n            msg: to_binary(\u0026ExecuteMsg::UpdateConfig(Box::new(UpdateConfig {\n                xastro_token_addr: None,\n                vxastro_token_addr: None,\n                voting_escrow_delegator_addr: None,\n                ibc_controller: None,\n                builder_unlock_addr: None,\n                proposal_voting_period: Some(750),\n                proposal_effective_delay: None,\n                proposal_expiration_period: None,\n                proposal_required_deposit: None,\n                proposal_required_quorum: None,\n                proposal_required_threshold: None,\n                whitelist_add: None,\n                whitelist_remove: None,\n            })))\n            .unwrap(),\n            funds: vec![],\n        })])\n    );\n    assert_eq!(\n        proposal.deposit_amount,\n        Uint128::from(PROPOSAL_REQUIRED_DEPOSIT)\n    )\n}\n\n#[cfg(not(feature = \"testnet\"))]\n#[test]\nfn test_successful_proposal() {\n    let mut app = mock_app();\n\n    let owner = Addr::unchecked(\"owner\");\n\n    let (\n        token_addr,\n        staking_instance,\n        xastro_addr,\n        vxastro_addr,\n        builder_unlock_addr,\n        assembly_addr,\n        _,\n    ) = instantiate_contracts(\u0026mut app, owner, false);\n\n    // Init voting power for users\n    let balances: Vec\u003c(\u0026str, u128, u128)\u003e = vec![\n        (\"user0\", PROPOSAL_REQUIRED_DEPOSIT, 0), // proposal submitter\n        (\"user1\", 20, 80),\n        (\"user2\", 100, 100),\n        (\"user3\", 300, 100),\n        (\"user4\", 200, 50),\n        (\"user5\", 0, 90),\n        (\"user6\", 100, 200),\n        (\"user7\", 30, 0),\n        (\"user8\", 80, 100),\n        (\"user9\", 50, 0),\n        (\"user10\", 0, 90),\n        (\"user11\", 500, 0),\n        (\"user12\", 10000_000000, 0),\n    ];\n\n    let default_allocation_params = AllocationParams {\n        amount: Uint128::zero(),\n        unlock_schedule: Schedule {\n            start_time: 12_345,\n            cliff: 5,\n            duration: 500,\n        },\n        proposed_receiver: None,\n    };\n\n    let locked_balances = vec![\n        (\n            \"user1\".to_string(),\n            AllocationParams {\n                amount: Uint128::from(80u32),\n                ..default_allocation_params.clone()\n            },\n        ),\n        (\n            \"user4\".to_string(),\n            AllocationParams {\n                amount: Uint128::from(50u32),\n                ..default_allocation_params.clone()\n            },\n        ),\n        (\n            \"user7\".to_string(),\n            AllocationParams {\n                amount: Uint128::from(100u32),\n                ..default_allocation_params.clone()\n            },\n        ),\n        (\n            \"user10\".to_string(),\n            AllocationParams {\n                amount: Uint128::from(30u32),\n                ..default_allocation_params.clone()\n            },\n        ),\n    ];\n\n    for (addr, xastro, vxastro) in balances {\n        if xastro \u003e 0 {\n            mint_tokens(\n                \u0026mut app,\n                \u0026staking_instance,\n                \u0026xastro_addr,\n                \u0026Addr::unchecked(addr),\n                xastro,\n            );\n        }\n\n        if vxastro \u003e 0 {\n            mint_vxastro(\n                \u0026mut app,\n                \u0026staking_instance,\n                xastro_addr.clone(),\n                \u0026vxastro_addr,\n                Addr::unchecked(addr),\n                vxastro,\n            );\n        }\n    }\n\n    create_allocations(\u0026mut app, token_addr, builder_unlock_addr, locked_balances);\n\n    // Skip period\n    app.update_block(|mut block| {\n        block.time = block.time.plus_seconds(WEEK);\n        block.height += WEEK / 5;\n    });\n\n    // Create default proposal\n    create_proposal(\n        \u0026mut app,\n        \u0026xastro_addr,\n        \u0026assembly_addr,\n        Addr::unchecked(\"user0\"),\n        Some(vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: assembly_addr.to_string(),\n            msg: to_binary(\u0026ExecuteMsg::UpdateConfig(Box::new(UpdateConfig {\n                xastro_token_addr: None,\n                vxastro_token_addr: None,\n                voting_escrow_delegator_addr: None,\n                ibc_controller: None,\n                builder_unlock_addr: None,\n                proposal_voting_period: Some(PROPOSAL_VOTING_PERIOD + 1000),\n                proposal_effective_delay: None,\n                proposal_expiration_period: None,\n                proposal_required_deposit: None,\n                proposal_required_quorum: None,\n                proposal_required_threshold: None,\n                whitelist_add: Some(vec![\n                    \"https://some1.link/\".to_string(),\n                    \"https://some2.link/\".to_string(),\n                ]),\n                whitelist_remove: Some(vec![\"https://some.link/\".to_string()]),\n            })))\n            .unwrap(),\n            funds: vec![],\n        })]),\n    );\n\n    let votes: Vec\u003c(\u0026str, ProposalVoteOption, u128)\u003e = vec![\n        (\"user1\", ProposalVoteOption::For, 280u128),\n        (\"user2\", ProposalVoteOption::For, 350u128),\n        (\"user3\", ProposalVoteOption::For, 550u128),\n        (\"user4\", ProposalVoteOption::For, 350u128),\n        (\"user5\", ProposalVoteOption::For, 240u128),\n        (\"user6\", ProposalVoteOption::For, 600u128),\n        (\"user7\", ProposalVoteOption::For, 130u128),\n        (\"user8\", ProposalVoteOption::Against, 330u128),\n        (\"user9\", ProposalVoteOption::Against, 50u128),\n        (\"user10\", ProposalVoteOption::Against, 270u128),\n        (\"user11\", ProposalVoteOption::Against, 500u128),\n        (\"user12\", ProposalVoteOption::For, 10000_000000u128),\n    ];\n\n    check_total_vp(\u0026mut app, \u0026assembly_addr, 1, 20000003650);\n\n    for (addr, option, expected_vp) in votes {\n        let sender = Addr::unchecked(addr);\n\n        check_user_vp(\u0026mut app, \u0026assembly_addr, \u0026sender, 1, expected_vp);\n\n        cast_vote(\u0026mut app, assembly_addr.clone(), 1, sender, option).unwrap();\n    }\n\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    let proposal_votes: ProposalVotesResponse = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::ProposalVotes { proposal_id: 1 },\n        )\n        .unwrap();\n\n    let proposal_for_voters: Vec\u003cAddr\u003e = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::ProposalVoters {\n                proposal_id: 1,\n                vote_option: ProposalVoteOption::For,\n                start: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    let proposal_against_voters: Vec\u003cAddr\u003e = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::ProposalVoters {\n                proposal_id: 1,\n                vote_option: ProposalVoteOption::Against,\n                start: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    // Check proposal votes\n    assert_eq!(proposal.for_power, Uint128::from(10000002500u128));\n    assert_eq!(proposal.against_power, Uint128::from(1150u32));\n\n    assert_eq!(proposal_votes.for_power, Uint128::from(10000002500u128));\n    assert_eq!(proposal_votes.against_power, Uint128::from(1150u32));\n\n    assert_eq!(\n        proposal_for_voters,\n        vec![\n            Addr::unchecked(\"user1\"),\n            Addr::unchecked(\"user2\"),\n            Addr::unchecked(\"user3\"),\n            Addr::unchecked(\"user4\"),\n            Addr::unchecked(\"user5\"),\n            Addr::unchecked(\"user6\"),\n            Addr::unchecked(\"user7\"),\n            Addr::unchecked(\"user12\"),\n        ]\n    );\n    assert_eq!(\n        proposal_against_voters,\n        vec![\n            Addr::unchecked(\"user8\"),\n            Addr::unchecked(\"user9\"),\n            Addr::unchecked(\"user10\"),\n            Addr::unchecked(\"user11\")\n        ]\n    );\n\n    // Skip voting period\n    app.update_block(|bi| {\n        bi.height += PROPOSAL_VOTING_PERIOD + 1;\n        bi.time = bi.time.plus_seconds(5 * (PROPOSAL_VOTING_PERIOD + 1));\n    });\n\n    // Try to vote after voting period\n    let err = cast_vote(\n        \u0026mut app,\n        assembly_addr.clone(),\n        1,\n        Addr::unchecked(\"user11\"),\n        ProposalVoteOption::Against,\n    )\n    .unwrap_err();\n\n    assert_eq!(err.root_cause().to_string(), \"Voting period ended!\");\n\n    // Try to execute the proposal before end_proposal\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"user0\"),\n            assembly_addr.clone(),\n            \u0026ExecuteMsg::ExecuteProposal { proposal_id: 1 },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(err.root_cause().to_string(), \"Proposal not passed!\");\n\n    // Check the successful completion of the proposal\n    check_token_balance(\u0026mut app, \u0026xastro_addr, \u0026Addr::unchecked(\"user0\"), 0);\n\n    app.execute_contract(\n        Addr::unchecked(\"user0\"),\n        assembly_addr.clone(),\n        \u0026ExecuteMsg::EndProposal { proposal_id: 1 },\n        \u0026[],\n    )\n    .unwrap();\n\n    check_token_balance(\n        \u0026mut app,\n        \u0026xastro_addr,\n        \u0026Addr::unchecked(\"user0\"),\n        PROPOSAL_REQUIRED_DEPOSIT,\n    );\n\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    assert_eq!(proposal.status, ProposalStatus::Passed);\n\n    // Try to end proposal again\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"user0\"),\n            assembly_addr.clone(),\n            \u0026ExecuteMsg::EndProposal { proposal_id: 1 },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(err.root_cause().to_string(), \"Proposal not active!\");\n\n    // Try to execute the proposal before the delay\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"user0\"),\n            assembly_addr.clone(),\n            \u0026ExecuteMsg::ExecuteProposal { proposal_id: 1 },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(err.root_cause().to_string(), \"Proposal delay not ended!\");\n\n    // Skip blocks\n    app.update_block(|bi| {\n        bi.height += PROPOSAL_EFFECTIVE_DELAY + 1;\n        bi.time = bi.time.plus_seconds(5 * (PROPOSAL_EFFECTIVE_DELAY + 1));\n    });\n\n    // Try to execute the proposal after the delay\n    app.execute_contract(\n        Addr::unchecked(\"user0\"),\n        assembly_addr.clone(),\n        \u0026ExecuteMsg::ExecuteProposal { proposal_id: 1 },\n        \u0026[],\n    )\n    .unwrap();\n\n    let config: Config = app\n        .wrap()\n        .query_wasm_smart(assembly_addr.to_string(), \u0026QueryMsg::Config {})\n        .unwrap();\n\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.to_string(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    // Check execution result\n    assert_eq!(config.proposal_voting_period, PROPOSAL_VOTING_PERIOD + 1000);\n    assert_eq!(\n        config.whitelisted_links,\n        vec![\n            \"https://some1.link/\".to_string(),\n            \"https://some2.link/\".to_string(),\n        ]\n    );\n    assert_eq!(proposal.status, ProposalStatus::Executed);\n\n    // Try to remove proposal before expiration period\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"user0\"),\n            assembly_addr.clone(),\n            \u0026ExecuteMsg::RemoveCompletedProposal { proposal_id: 1 },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(err.root_cause().to_string(), \"Proposal not completed!\");\n\n    // Remove expired proposal\n    app.update_block(|bi| {\n        bi.height += PROPOSAL_EXPIRATION_PERIOD + 1;\n        bi.time = bi.time.plus_seconds(5 * (PROPOSAL_EXPIRATION_PERIOD + 1));\n    });\n\n    app.execute_contract(\n        Addr::unchecked(\"user0\"),\n        assembly_addr.clone(),\n        \u0026ExecuteMsg::RemoveCompletedProposal { proposal_id: 1 },\n        \u0026[],\n    )\n    .unwrap();\n\n    let res: ProposalListResponse = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.to_string(),\n            \u0026QueryMsg::Proposals {\n                start: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(res.proposal_list, vec![]);\n    // proposal_count should not be changed after removing a proposal\n    assert_eq!(res.proposal_count, Uint64::from(1u32));\n}\n\n#[test]\nfn test_voting_power_changes() {\n    let mut app = mock_app();\n\n    let owner = Addr::unchecked(\"owner\");\n\n    let (_, staking_instance, xastro_addr, _, _, assembly_addr, _) =\n        instantiate_contracts(\u0026mut app, owner, false);\n\n    // Mint tokens for submitting proposal\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026Addr::unchecked(\"user0\"),\n        PROPOSAL_REQUIRED_DEPOSIT,\n    );\n\n    // Mint tokens for casting votes at start block\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026Addr::unchecked(\"user1\"),\n        40000_000000,\n    );\n\n    app.update_block(|mut block| {\n        block.time = block.time.plus_seconds(WEEK);\n        block.height += WEEK / 5;\n    });\n\n    // Create proposal\n    create_proposal(\n        \u0026mut app,\n        \u0026xastro_addr,\n        \u0026assembly_addr,\n        Addr::unchecked(\"user0\"),\n        Some(vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: assembly_addr.to_string(),\n            msg: to_binary(\u0026ExecuteMsg::UpdateConfig(Box::new(UpdateConfig {\n                xastro_token_addr: None,\n                vxastro_token_addr: None,\n                voting_escrow_delegator_addr: None,\n                ibc_controller: None,\n                builder_unlock_addr: None,\n                proposal_voting_period: Some(750),\n                proposal_effective_delay: None,\n                proposal_expiration_period: None,\n                proposal_required_deposit: None,\n                proposal_required_quorum: None,\n                proposal_required_threshold: None,\n                whitelist_add: None,\n                whitelist_remove: None,\n            })))\n            .unwrap(),\n            funds: vec![],\n        })]),\n    );\n    // Mint user2's tokens at the same block to increase total supply and add voting power to try to cast vote.\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026Addr::unchecked(\"user2\"),\n        5000_000000,\n    );\n\n    app.update_block(next_block);\n\n    // user1 can vote as he had voting power before the proposal submitting.\n    cast_vote(\n        \u0026mut app,\n        assembly_addr.clone(),\n        1,\n        Addr::unchecked(\"user1\"),\n        ProposalVoteOption::For,\n    )\n    .unwrap();\n    // Should panic, because user2 doesn't have any voting power.\n    let err = cast_vote(\n        \u0026mut app,\n        assembly_addr.clone(),\n        1,\n        Addr::unchecked(\"user2\"),\n        ProposalVoteOption::Against,\n    )\n    .unwrap_err();\n\n    // user2 doesn't have voting power and doesn't affect on total voting power(total supply at)\n    // total supply = 5000\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"You don't have any voting power!\"\n    );\n\n    app.update_block(next_block);\n\n    // Skip voting period and delay\n    app.update_block(|bi| {\n        bi.height += PROPOSAL_VOTING_PERIOD + PROPOSAL_EFFECTIVE_DELAY + 1;\n        bi.time = bi\n            .time\n            .plus_seconds(5 * (PROPOSAL_VOTING_PERIOD + PROPOSAL_EFFECTIVE_DELAY + 1));\n    });\n\n    // End proposal\n    app.execute_contract(\n        Addr::unchecked(\"user0\"),\n        assembly_addr.clone(),\n        \u0026ExecuteMsg::EndProposal { proposal_id: 1 },\n        \u0026[],\n    )\n    .unwrap();\n\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    // Check proposal votes\n    assert_eq!(proposal.for_power, Uint128::from(40000_000000u128));\n    assert_eq!(proposal.against_power, Uint128::zero());\n    // Should be passed, as total_voting_power=5000, for_votes=40000.\n    // So user2 didn't affect the result. Because he had to have xASTRO before the vote was submitted.\n    assert_eq!(proposal.status, ProposalStatus::Passed);\n}\n\n#[cfg(not(feature = \"testnet\"))]\n#[test]\nfn test_block_height_selection() {\n    // Block height is 12345 after app initialization\n    let mut app = mock_app();\n\n    let owner = Addr::unchecked(\"owner\");\n    let user1 = Addr::unchecked(\"user1\");\n    let user2 = Addr::unchecked(\"user2\");\n    let user3 = Addr::unchecked(\"user3\");\n\n    let (_, staking_instance, xastro_addr, _, _, assembly_addr, _) =\n        instantiate_contracts(\u0026mut app, owner, false);\n\n    // Mint tokens for submitting proposal\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026Addr::unchecked(\"user0\"),\n        PROPOSAL_REQUIRED_DEPOSIT,\n    );\n\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026user1,\n        6000_000001,\n    );\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026user2,\n        4000_000000,\n    );\n\n    // Skip to the next period\n    app.update_block(|mut block| {\n        block.time = block.time.plus_seconds(WEEK);\n        block.height += WEEK / 5;\n    });\n\n    // Create proposal\n    create_proposal(\n        \u0026mut app,\n        \u0026xastro_addr,\n        \u0026assembly_addr,\n        Addr::unchecked(\"user0\"),\n        None,\n    );\n\n    cast_vote(\n        \u0026mut app,\n        assembly_addr.clone(),\n        1,\n        user1,\n        ProposalVoteOption::For,\n    )\n    .unwrap();\n\n    // Mint huge amount of xASTRO. These tokens cannot affect on total supply in proposal 1 because\n    // they were minted after proposal.start_block - 1\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026user3,\n        100000_000000,\n    );\n    // Mint more xASTRO to user2, who will vote against the proposal, what is enough to make proposal unsuccessful.\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026user2,\n        3000_000000,\n    );\n    // Total voting power should be 20k xASTRO (proposal minimum deposit 10k + 4k + 6k users VP)\n    check_total_vp(\u0026mut app, \u0026assembly_addr, 1, 20000_000001);\n\n    cast_vote(\n        \u0026mut app,\n        assembly_addr.clone(),\n        1,\n        user2,\n        ProposalVoteOption::Against,\n    )\n    .unwrap();\n\n    // Skip voting period\n    app.update_block(|bi| {\n        bi.height += PROPOSAL_VOTING_PERIOD + PROPOSAL_EFFECTIVE_DELAY + 1;\n        bi.time = bi\n            .time\n            .plus_seconds(5 * (PROPOSAL_VOTING_PERIOD + PROPOSAL_EFFECTIVE_DELAY + 1));\n    });\n\n    // End proposal\n    app.execute_contract(\n        Addr::unchecked(\"user0\"),\n        assembly_addr.clone(),\n        \u0026ExecuteMsg::EndProposal { proposal_id: 1 },\n        \u0026[],\n    )\n    .unwrap();\n\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    assert_eq!(proposal.for_power, Uint128::new(6000_000001));\n    // Against power is 4000, as user2's balance was increased after proposal.start_block - 1\n    // at which everyone's voting power are considered.\n    assert_eq!(proposal.against_power, Uint128::new(4000_000000));\n    // Proposal is passed, as the total supply was increased after proposal.start_block - 1.\n    assert_eq!(proposal.status, ProposalStatus::Passed);\n}\n\n#[cfg(not(feature = \"testnet\"))]\n#[test]\nfn test_unsuccessful_proposal() {\n    let mut app = mock_app();\n\n    let owner = Addr::unchecked(\"owner\");\n\n    let (_, staking_instance, xastro_addr, _, _, assembly_addr, _) =\n        instantiate_contracts(\u0026mut app, owner, false);\n\n    // Init voting power for users\n    let xastro_balances: Vec\u003c(\u0026str, u128)\u003e = vec![\n        (\"user0\", PROPOSAL_REQUIRED_DEPOSIT), // proposal submitter\n        (\"user1\", 100),\n        (\"user2\", 200),\n        (\"user3\", 400),\n        (\"user4\", 250),\n        (\"user5\", 90),\n        (\"user6\", 300),\n        (\"user7\", 30),\n        (\"user8\", 180),\n        (\"user9\", 50),\n        (\"user10\", 90),\n        (\"user11\", 500),\n    ];\n\n    for (addr, xastro) in xastro_balances {\n        mint_tokens(\n            \u0026mut app,\n            \u0026staking_instance,\n            \u0026xastro_addr,\n            \u0026Addr::unchecked(addr),\n            xastro,\n        );\n    }\n\n    // Skip period\n    app.update_block(|mut block| {\n        block.time = block.time.plus_seconds(WEEK);\n        block.height += WEEK / 5;\n    });\n\n    // Create proposal\n    create_proposal(\n        \u0026mut app,\n        \u0026xastro_addr,\n        \u0026assembly_addr,\n        Addr::unchecked(\"user0\"),\n        None,\n    );\n\n    let expected_voting_power: Vec\u003c(\u0026str, ProposalVoteOption)\u003e = vec![\n        (\"user1\", ProposalVoteOption::For),\n        (\"user2\", ProposalVoteOption::For),\n        (\"user3\", ProposalVoteOption::For),\n        (\"user4\", ProposalVoteOption::Against),\n        (\"user5\", ProposalVoteOption::Against),\n        (\"user6\", ProposalVoteOption::Against),\n        (\"user7\", ProposalVoteOption::Against),\n        (\"user8\", ProposalVoteOption::Against),\n        (\"user9\", ProposalVoteOption::Against),\n        (\"user10\", ProposalVoteOption::Against),\n    ];\n\n    for (addr, option) in expected_voting_power {\n        cast_vote(\n            \u0026mut app,\n            assembly_addr.clone(),\n            1,\n            Addr::unchecked(addr),\n            option,\n        )\n        .unwrap();\n    }\n\n    // Skip voting period\n    app.update_block(|bi| {\n        bi.height += PROPOSAL_VOTING_PERIOD + 1;\n        bi.time = bi.time.plus_seconds(5 * (PROPOSAL_VOTING_PERIOD + 1));\n    });\n\n    // Check balance of submitter before and after proposal completion\n    check_token_balance(\u0026mut app, \u0026xastro_addr, \u0026Addr::unchecked(\"user0\"), 0);\n\n    app.execute_contract(\n        Addr::unchecked(\"user0\"),\n        assembly_addr.clone(),\n        \u0026ExecuteMsg::EndProposal { proposal_id: 1 },\n        \u0026[],\n    )\n    .unwrap();\n\n    check_token_balance(\n        \u0026mut app,\n        \u0026xastro_addr,\n        \u0026Addr::unchecked(\"user0\"),\n        10000_000000,\n    );\n\n    // Check proposal status\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    assert_eq!(proposal.status, ProposalStatus::Rejected);\n\n    // Remove expired proposal\n    app.update_block(|bi| {\n        bi.height += PROPOSAL_EXPIRATION_PERIOD + PROPOSAL_EFFECTIVE_DELAY + 1;\n        bi.time = bi\n            .time\n            .plus_seconds(5 * (PROPOSAL_EXPIRATION_PERIOD + PROPOSAL_EFFECTIVE_DELAY + 1));\n    });\n\n    app.execute_contract(\n        Addr::unchecked(\"user0\"),\n        assembly_addr.clone(),\n        \u0026ExecuteMsg::RemoveCompletedProposal { proposal_id: 1 },\n        \u0026[],\n    )\n    .unwrap();\n\n    let res: ProposalListResponse = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.to_string(),\n            \u0026QueryMsg::Proposals {\n                start: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(res.proposal_list, vec![]);\n    // proposal_count should not be changed after removing\n    assert_eq!(res.proposal_count, Uint64::from(1u32));\n}\n\n#[test]\nfn test_check_messages() {\n    let mut app = mock_app();\n    let owner = Addr::unchecked(\"owner\");\n    let (_, _, _, vxastro_addr, _, assembly_addr, _) =\n        instantiate_contracts(\u0026mut app, owner, false);\n\n    change_owner(\u0026mut app, \u0026vxastro_addr, \u0026assembly_addr);\n    let user = Addr::unchecked(\"user\");\n    let into_check_msg = |msgs: Vec\u003c(String, Binary)\u003e| {\n        let messages = msgs\n            .into_iter()\n            .map(|(contract_addr, msg)| {\n                CosmosMsg::Wasm(WasmMsg::Execute {\n                    contract_addr,\n                    msg,\n                    funds: vec![],\n                })\n            })\n            .collect();\n        ExecuteMsg::CheckMessages { messages }\n    };\n\n    let config_before: astroport_governance::voting_escrow::ConfigResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026vxastro_addr,\n            \u0026astroport_governance::voting_escrow::QueryMsg::Config {},\n        )\n        .unwrap();\n\n    let vxastro_blacklist_msg = vec![(\n        vxastro_addr.to_string(),\n        to_binary(\n            \u0026astroport_governance::voting_escrow::ExecuteMsg::UpdateConfig { new_guardian: None },\n        )\n        .unwrap(),\n    )];\n    let err = app\n        .execute_contract(\n            user.clone(),\n            assembly_addr.clone(),\n            \u0026into_check_msg(vxastro_blacklist_msg),\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"Messages check passed. Nothing was committed to the blockchain\"\n    );\n\n    let config_after: astroport_governance::voting_escrow::ConfigResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026vxastro_addr,\n            \u0026astroport_governance::voting_escrow::QueryMsg::Config {},\n        )\n        .unwrap();\n    assert_eq!(config_before, config_after);\n}\n\n#[test]\nfn test_delegated_vp() {\n    let mut app = mock_app();\n\n    let owner = Addr::unchecked(\"owner\");\n\n    let (_, staking_instance, xastro_addr, vxastro_addr, _, assembly_addr, delegator) =\n        instantiate_contracts(\u0026mut app, owner, true);\n    let delegator = delegator.unwrap();\n\n    let users = vec![\n        (\n            \"user1\",\n            103_000_000_000u128,\n            1000u16,\n            \"user4\",\n            177_278_846_150u128,\n        ),\n        (\n            \"user2\",\n            612_000_000_000u128,\n            2000u16,\n            \"user5\",\n            1_053_346_153_800u128,\n        ),\n        (\n            \"user3\",\n            205_000_000_000u128,\n            3000u16,\n            \"user6\",\n            352_836_538_450u128,\n        ),\n    ];\n\n    // Mint tokens for submitting proposal\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026Addr::unchecked(\"user0\"),\n        PROPOSAL_REQUIRED_DEPOSIT,\n    );\n\n    // Mint vxASTRO and delegate it to the other users\n    for (from, amount, bps, to, exp_vp) in users {\n        mint_vxastro(\n            \u0026mut app,\n            \u0026staking_instance,\n            xastro_addr.clone(),\n            \u0026vxastro_addr,\n            Addr::unchecked(from),\n            amount,\n        );\n        delegate_vxastro(\n            \u0026mut app,\n            delegator.clone(),\n            Addr::unchecked(from),\n            Addr::unchecked(to),\n            bps,\n        );\n\n        let from_amount: Uint128 = app\n            .wrap()\n            .query_wasm_smart(\n                \u0026delegator,\n                \u0026DelegatorQueryMsg::AdjustedBalance {\n                    account: from.to_string(),\n                    timestamp: None,\n                },\n            )\n            .unwrap();\n\n        let to_amount: Uint128 = app\n            .wrap()\n            .query_wasm_smart(\n                \u0026delegator,\n                \u0026DelegatorQueryMsg::AdjustedBalance {\n                    account: to.to_string(),\n                    timestamp: None,\n                },\n            )\n            .unwrap();\n\n        assert_eq!(from_amount + to_amount, Uint128::from(exp_vp));\n    }\n\n    app.update_block(|mut block| {\n        block.time = block.time.plus_seconds(WEEK);\n        block.height += WEEK / 5;\n    });\n\n    // Create proposal\n    create_proposal(\n        \u0026mut app,\n        \u0026xastro_addr,\n        \u0026assembly_addr,\n        Addr::unchecked(\"user0\"),\n        Some(vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: assembly_addr.to_string(),\n            msg: to_binary(\u0026ExecuteMsg::UpdateConfig(Box::new(UpdateConfig {\n                xastro_token_addr: None,\n                vxastro_token_addr: None,\n                voting_escrow_delegator_addr: None,\n                ibc_controller: None,\n                builder_unlock_addr: None,\n                proposal_voting_period: Some(750),\n                proposal_effective_delay: None,\n                proposal_expiration_period: None,\n                proposal_required_deposit: None,\n                proposal_required_quorum: None,\n                proposal_required_threshold: None,\n                whitelist_add: None,\n                whitelist_remove: None,\n            })))\n            .unwrap(),\n            funds: vec![],\n        })]),\n    );\n\n    let votes: Vec\u003c(\u0026str, ProposalVoteOption)\u003e = vec![\n        (\"user1\", ProposalVoteOption::Against),\n        (\"user2\", ProposalVoteOption::For),\n        (\"user3\", ProposalVoteOption::Against),\n        (\"user4\", ProposalVoteOption::For),\n        (\"user5\", ProposalVoteOption::Against),\n        (\"user6\", ProposalVoteOption::For),\n    ];\n\n    for (user, vote) in votes {\n        cast_vote(\n            \u0026mut app,\n            assembly_addr.clone(),\n            1u64,\n            Addr::unchecked(user),\n            vote,\n        )\n        .unwrap();\n    }\n\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    assert_eq!(proposal.for_power, Uint128::from(1_578_255_769_188u128));\n    assert_eq!(proposal.against_power, Uint128::from(925_205_769_212u128));\n\n    // Skip voting period\n    app.update_block(|bi| {\n        bi.height += PROPOSAL_VOTING_PERIOD + 1;\n        bi.time = bi.time.plus_seconds(5 * (PROPOSAL_VOTING_PERIOD + 1));\n    });\n\n    app.execute_contract(\n        Addr::unchecked(\"user0\"),\n        assembly_addr.clone(),\n        \u0026ExecuteMsg::EndProposal { proposal_id: 1 },\n        \u0026[],\n    )\n    .unwrap();\n\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    assert_eq!(proposal.status, ProposalStatus::Passed);\n}\n\nfn mock_app() -\u003e App {\n    let mut env = mock_env();\n    env.block.time = Timestamp::from_seconds(EPOCH_START);\n    let api = MockApi::default();\n    let bank = BankKeeper::new();\n    let storage = MockStorage::new();\n\n    AppBuilder::new()\n        .with_api(api)\n        .with_block(env.block)\n        .with_bank(bank)\n        .with_storage(storage)\n        .build(|_, _, _| {})\n}\n\nfn instantiate_contracts(\n    router: \u0026mut App,\n    owner: Addr,\n    with_delegator: bool,\n) -\u003e (Addr, Addr, Addr, Addr, Addr, Addr, Option\u003cAddr\u003e) {\n    let token_addr = instantiate_astro_token(router, \u0026owner);\n    let (staking_addr, xastro_token_addr) = instantiate_xastro_token(router, \u0026owner, \u0026token_addr);\n    let vxastro_token_addr = instantiate_vxastro_token(router, \u0026owner, \u0026xastro_token_addr);\n    let builder_unlock_addr = instantiate_builder_unlock_contract(router, \u0026owner, \u0026token_addr);\n\n    let mut delegator_addr = None;\n\n    if with_delegator {\n        delegator_addr = Some(instantiate_delegator_contract(\n            router,\n            \u0026owner,\n            \u0026vxastro_token_addr,\n        ));\n    }\n\n    let assembly_addr = instantiate_assembly_contract(\n        router,\n        \u0026owner,\n        \u0026xastro_token_addr,\n        \u0026vxastro_token_addr,\n        \u0026builder_unlock_addr,\n        delegator_addr.clone().map(String::from),\n    );\n\n    (\n        token_addr,\n        staking_addr,\n        xastro_token_addr,\n        vxastro_token_addr,\n        builder_unlock_addr,\n        assembly_addr,\n        delegator_addr,\n    )\n}\n\nfn instantiate_astro_token(router: \u0026mut App, owner: \u0026Addr) -\u003e Addr {\n    let astro_token_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_token::contract::execute,\n        astroport_token::contract::instantiate,\n        astroport_token::contract::query,\n    ));\n\n    let astro_token_code_id = router.store_code(astro_token_contract);\n\n    let msg = TokenInstantiateMsg {\n        name: String::from(\"Astro token\"),\n        symbol: String::from(\"ASTRO\"),\n        decimals: 6,\n        initial_balances: vec![],\n        mint: Some(MinterResponse {\n            minter: owner.to_string(),\n            cap: None,\n        }),\n        marketing: None,\n    };\n\n    router\n        .instantiate_contract(\n            astro_token_code_id,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            String::from(\"ASTRO\"),\n            None,\n        )\n        .unwrap()\n}\n\nfn instantiate_xastro_token(router: \u0026mut App, owner: \u0026Addr, astro_token: \u0026Addr) -\u003e (Addr, Addr) {\n    let xastro_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_xastro_token::contract::execute,\n        astroport_xastro_token::contract::instantiate,\n        astroport_xastro_token::contract::query,\n    ));\n\n    let xastro_code_id = router.store_code(xastro_contract);\n\n    let staking_contract = Box::new(\n        ContractWrapper::new_with_empty(\n            astroport_staking::contract::execute,\n            astroport_staking::contract::instantiate,\n            astroport_staking::contract::query,\n        )\n        .with_reply_empty(astroport_staking::contract::reply),\n    );\n\n    let staking_code_id = router.store_code(staking_contract);\n\n    let msg = astroport::staking::InstantiateMsg {\n        owner: owner.to_string(),\n        token_code_id: xastro_code_id,\n        deposit_token_addr: astro_token.to_string(),\n        marketing: None,\n    };\n    let staking_instance = router\n        .instantiate_contract(\n            staking_code_id,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            String::from(\"xASTRO\"),\n            None,\n        )\n        .unwrap();\n\n    let res = router\n        .wrap()\n        .query::\u003castroport::staking::ConfigResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: staking_instance.to_string(),\n            msg: to_binary(\u0026astroport::staking::QueryMsg::Config {}).unwrap(),\n        }))\n        .unwrap();\n\n    (staking_instance, res.share_token_addr)\n}\n\nfn instantiate_vxastro_token(router: \u0026mut App, owner: \u0026Addr, xastro: \u0026Addr) -\u003e Addr {\n    let vxastro_token_contract = Box::new(ContractWrapper::new_with_empty(\n        voting_escrow::contract::execute,\n        voting_escrow::contract::instantiate,\n        voting_escrow::contract::query,\n    ));\n\n    let vxastro_token_code_id = router.store_code(vxastro_token_contract);\n\n    let msg = VXAstroInstantiateMsg {\n        owner: owner.to_string(),\n        guardian_addr: Some(owner.to_string()),\n        deposit_token_addr: xastro.to_string(),\n        marketing: None,\n        logo_urls_whitelist: vec![],\n    };\n\n    router\n        .instantiate_contract(\n            vxastro_token_code_id,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            String::from(\"vxASTRO\"),\n            None,\n        )\n        .unwrap()\n}\n\nfn instantiate_builder_unlock_contract(router: \u0026mut App, owner: \u0026Addr, astro_token: \u0026Addr) -\u003e Addr {\n    let builder_unlock_contract = Box::new(ContractWrapper::new_with_empty(\n        builder_unlock::contract::execute,\n        builder_unlock::contract::instantiate,\n        builder_unlock::contract::query,\n    ));\n\n    let builder_unlock_code_id = router.store_code(builder_unlock_contract);\n\n    let msg = BuilderUnlockInstantiateMsg {\n        owner: owner.to_string(),\n        astro_token: astro_token.to_string(),\n        max_allocations_amount: Uint128::new(300_000_000_000_000u128),\n    };\n\n    router\n        .instantiate_contract(\n            builder_unlock_code_id,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            \"Builder Unlock contract\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap()\n}\n\nfn instantiate_assembly_contract(\n    router: \u0026mut App,\n    owner: \u0026Addr,\n    xastro: \u0026Addr,\n    vxastro: \u0026Addr,\n    builder: \u0026Addr,\n    delegator: Option\u003cString\u003e,\n) -\u003e Addr {\n    let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n        astro_assembly::contract::execute,\n        astro_assembly::contract::instantiate,\n        astro_assembly::contract::query,\n    ));\n\n    let assembly_code = router.store_code(assembly_contract);\n\n    let msg = InstantiateMsg {\n        xastro_token_addr: xastro.to_string(),\n        vxastro_token_addr: Some(vxastro.to_string()),\n        voting_escrow_delegator_addr: delegator,\n        ibc_controller: None,\n        builder_unlock_addr: builder.to_string(),\n        proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n        proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n        proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n        proposal_required_deposit: Uint128::new(PROPOSAL_REQUIRED_DEPOSIT),\n        proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n        proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n        whitelisted_links: vec![\"https://some.link/\".to_string()],\n    };\n\n    router\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap()\n}\n\nfn instantiate_delegator_contract(router: \u0026mut App, owner: \u0026Addr, vxastro: \u0026Addr) -\u003e Addr {\n    let nft_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_nft::contract::execute,\n        astroport_nft::contract::instantiate,\n        astroport_nft::contract::query,\n    ));\n\n    let nft_code_id = router.store_code(nft_contract);\n\n    let delegator_contract = Box::new(\n        ContractWrapper::new_with_empty(\n            voting_escrow_delegation::contract::execute,\n            voting_escrow_delegation::contract::instantiate,\n            voting_escrow_delegation::contract::query,\n        )\n        .with_reply_empty(voting_escrow_delegation::contract::reply),\n    );\n\n    let delegator_code_id = router.store_code(delegator_contract);\n\n    let msg = DelegatorInstantiateMsg {\n        owner: owner.to_string(),\n        nft_code_id,\n        voting_escrow_addr: vxastro.to_string(),\n    };\n\n    router\n        .instantiate_contract(\n            delegator_code_id,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            \"Voting Escrow Delegator\",\n            Some(owner.to_string()),\n        )\n        .unwrap()\n}\n\nfn mint_tokens(app: \u0026mut App, minter: \u0026Addr, token: \u0026Addr, recipient: \u0026Addr, amount: u128) {\n    let msg = Cw20ExecuteMsg::Mint {\n        recipient: recipient.to_string(),\n        amount: Uint128::from(amount),\n    };\n\n    app.execute_contract(minter.clone(), token.to_owned(), \u0026msg, \u0026[])\n        .unwrap();\n}\n\nfn mint_vxastro(\n    app: \u0026mut App,\n    staking_instance: \u0026Addr,\n    xastro: Addr,\n    vxastro: \u0026Addr,\n    recipient: Addr,\n    amount: u128,\n) {\n    mint_tokens(\n        app,\n        staking_instance,\n        \u0026xastro.clone(),\n        \u0026recipient.clone(),\n        amount,\n    );\n\n    let msg = Cw20ExecuteMsg::Send {\n        contract: vxastro.to_string(),\n        amount: Uint128::from(amount),\n        msg: to_binary(\u0026VXAstroCw20HookMsg::CreateLock { time: WEEK * 50 }).unwrap(),\n    };\n\n    app.execute_contract(recipient, xastro, \u0026msg, \u0026[]).unwrap();\n}\n\nfn delegate_vxastro(app: \u0026mut App, delegator_addr: Addr, from: Addr, to: Addr, bps: u16) {\n    let msg = DelegatorExecuteMsg::CreateDelegation {\n        bps,\n        expire_time: 2 * 7 * 86400,\n        token_id: format!(\"{}-{}-{}\", from, to, bps),\n        recipient: to.to_string(),\n    };\n\n    app.execute_contract(from.clone(), delegator_addr, \u0026msg, \u0026[])\n        .unwrap();\n}\n\nfn create_allocations(\n    app: \u0026mut App,\n    token: Addr,\n    builder_unlock_contract_addr: Addr,\n    allocations: Vec\u003c(String, AllocationParams)\u003e,\n) {\n    let amount = allocations\n        .iter()\n        .map(|params| params.1.amount.u128())\n        .sum();\n\n    mint_tokens(\n        app,\n        \u0026Addr::unchecked(\"owner\"),\n        \u0026token,\n        \u0026Addr::unchecked(\"owner\"),\n        amount,\n    );\n\n    app.execute_contract(\n        Addr::unchecked(\"owner\"),\n        Addr::unchecked(token.to_string()),\n        \u0026Cw20ExecuteMsg::Send {\n            contract: builder_unlock_contract_addr.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026BuilderUnlockReceiveMsg::CreateAllocations { allocations }).unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n}\n\nfn create_proposal(\n    app: \u0026mut App,\n    token: \u0026Addr,\n    assembly: \u0026Addr,\n    submitter: Addr,\n    msgs: Option\u003cVec\u003cCosmosMsg\u003e\u003e,\n) {\n    let submit_proposal_msg = Cw20HookMsg::SubmitProposal {\n        title: \"Test title!\".to_string(),\n        description: \"Test description!\".to_string(),\n        link: None,\n        messages: msgs,\n        ibc_channel: None,\n    };\n\n    app.execute_contract(\n        submitter,\n        token.clone(),\n        \u0026Cw20ExecuteMsg::Send {\n            contract: assembly.to_string(),\n            amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            msg: to_binary(\u0026submit_proposal_msg).unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n}\n\nfn check_token_balance(app: \u0026mut App, token: \u0026Addr, address: \u0026Addr, expected: u128) {\n    let msg = XAstroQueryMsg::Balance {\n        address: address.to_string(),\n    };\n    let res: StdResult\u003cBalanceResponse\u003e = app.wrap().query_wasm_smart(token, \u0026msg);\n    assert_eq!(res.unwrap().balance, Uint128::from(expected));\n}\n\nfn check_user_vp(app: \u0026mut App, assembly: \u0026Addr, address: \u0026Addr, proposal_id: u64, expected: u128) {\n    let res: Uint128 = app\n        .wrap()\n        .query_wasm_smart(\n            assembly.to_string(),\n            \u0026QueryMsg::UserVotingPower {\n                user: address.to_string(),\n                proposal_id,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(res.u128(), expected);\n}\n\nfn check_total_vp(app: \u0026mut App, assembly: \u0026Addr, proposal_id: u64, expected: u128) {\n    let res: Uint128 = app\n        .wrap()\n        .query_wasm_smart(\n            assembly.to_string(),\n            \u0026QueryMsg::TotalVotingPower { proposal_id },\n        )\n        .unwrap();\n\n    assert_eq!(res.u128(), expected);\n}\n\nfn cast_vote(\n    app: \u0026mut App,\n    assembly: Addr,\n    proposal_id: u64,\n    sender: Addr,\n    option: ProposalVoteOption,\n) -\u003e anyhow::Result\u003cAppResponse\u003e {\n    app.execute_contract(\n        sender,\n        assembly,\n        \u0026ExecuteMsg::CastVote {\n            proposal_id,\n            vote: option,\n        },\n        \u0026[],\n    )\n}\n\nfn change_owner(app: \u0026mut App, contract: \u0026Addr, assembly: \u0026Addr) {\n    let msg = astroport_governance::voting_escrow::ExecuteMsg::ProposeNewOwner {\n        new_owner: assembly.to_string(),\n        expires_in: 100,\n    };\n    app.execute_contract(Addr::unchecked(\"owner\"), contract.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    app.execute_contract(\n        assembly.clone(),\n        contract.clone(),\n        \u0026astroport_governance::voting_escrow::ExecuteMsg::ClaimOwnership {},\n        \u0026[],\n    )\n    .unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","builder_unlock","examples","unlock_schema.rs"],"content":"use astroport_governance::builder_unlock::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\nuse cosmwasm_schema::write_api;\n\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        query: QueryMsg,\n        execute: ExecuteMsg\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","builder_unlock","src","contract.rs"],"content":"use crate::astroport::common::{claim_ownership, drop_ownership_proposal, propose_new_owner};\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\n\nuse cosmwasm_std::{\n    attr, from_binary, to_binary, Addr, Binary, Deps, DepsMut, Env, MessageInfo, Order, Response,\n    StdError, StdResult, Uint128, WasmMsg,\n};\nuse cw2::{get_contract_version, set_contract_version};\nuse cw20::{Cw20ExecuteMsg, Cw20ReceiveMsg};\nuse cw_storage_plus::Bound;\n\nuse crate::astroport::asset::addr_opt_validate;\nuse crate::contract::helpers::{compute_unlocked_amount, compute_withdraw_amount};\nuse crate::migration::MigrateMsg;\nuse astroport_governance::builder_unlock::msg::{\n    AllocationResponse, ExecuteMsg, InstantiateMsg, QueryMsg, ReceiveMsg, SimulateWithdrawResponse,\n    StateResponse,\n};\nuse astroport_governance::builder_unlock::{AllocationParams, AllocationStatus, Config, Schedule};\n\nuse astroport_governance::{DEFAULT_LIMIT, MAX_LIMIT};\n\nuse crate::state::{CONFIG, OWNERSHIP_PROPOSAL, PARAMS, STATE, STATUS};\n\n// Version and name used for contract migration.\nconst CONTRACT_NAME: \u0026str = \"builder-unlock\";\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Creates a new contract with the specified parameters in the `msg` variable.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    STATE.save(deps.storage, \u0026Default::default())?;\n\n    CONFIG.save(\n        deps.storage,\n        \u0026Config {\n            owner: deps.api.addr_validate(\u0026msg.owner)?,\n            astro_token: deps.api.addr_validate(\u0026msg.astro_token)?,\n            max_allocations_amount: msg.max_allocations_amount,\n        },\n    )?;\n    Ok(Response::default())\n}\n\n/// Exposes all the execute functions available in the contract.\n///\n/// ## Execute messages\n/// * **ExecuteMsg::Receive(cw20_msg)** Parse incoming messages coming from the ASTRO token contract.\n///\n/// * **ExecuteMsg::Withdraw** Withdraw unlocked ASTRO.\n///\n/// * **ExecuteMsg::TransferOwnership** Transfer contract ownership.\n///\n/// * **ExecuteMsg::ProposeNewReceiver** Propose a new receiver for a specific ASTRO unlock schedule.\n///\n/// * **ExecuteMsg::DropNewReceiver** Drop the proposal to change the receiver for an unlock schedule.\n///\n/// * **ExecuteMsg::ClaimReceiver**  Claim the position as a receiver for a specific unlock schedule.\n///\n/// * **ExecuteMsg::IncreaseAllocation** Increase ASTRO allocation for receiver.\n///\n/// * **ExecuteMsg::DecreaseAllocation** Decrease ASTRO allocation for receiver.\n///\n/// * **ExecuteMsg::TransferUnallocated** Transfer unallocated tokens.\n///\n/// * **ExecuteMsg::ProposeNewOwner** Creates a new request to change contract ownership.\n///\n/// * **ExecuteMsg::DropOwnershipProposal** Removes a request to change contract ownership.\n///\n/// * **ExecuteMsg::ClaimOwnership** Claims contract ownership.\n///\n/// * **ExecuteMsg::UpdateConfig** Update contract configuration.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -\u003e StdResult\u003cResponse\u003e {\n    match msg {\n        ExecuteMsg::Receive(cw20_msg) =\u003e execute_receive_cw20(deps, info, cw20_msg),\n        ExecuteMsg::Withdraw {} =\u003e execute_withdraw(deps, env, info),\n        ExecuteMsg::ProposeNewReceiver { new_receiver } =\u003e {\n            execute_propose_new_receiver(deps, info, new_receiver)\n        }\n        ExecuteMsg::DropNewReceiver {} =\u003e execute_drop_new_receiver(deps, info),\n        ExecuteMsg::ClaimReceiver { prev_receiver } =\u003e {\n            execute_claim_receiver(deps, info, prev_receiver)\n        }\n        ExecuteMsg::IncreaseAllocation { receiver, amount } =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n            if info.sender != config.owner {\n                return Err(StdError::generic_err(\n                    \"Only the contract owner can increase allocations\",\n                ));\n            }\n            execute_increase_allocation(deps, \u0026config, receiver, amount, None)\n        }\n        ExecuteMsg::DecreaseAllocation { receiver, amount } =\u003e {\n            execute_decrease_allocation(deps, env, info, receiver, amount)\n        }\n        ExecuteMsg::TransferUnallocated { amount, recipient } =\u003e {\n            execute_transfer_unallocated(deps, info, amount, recipient)\n        }\n        ExecuteMsg::ProposeNewOwner {\n            new_owner,\n            expires_in,\n        } =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n\n            propose_new_owner(\n                deps,\n                info,\n                env,\n                new_owner,\n                expires_in,\n                config.owner,\n                OWNERSHIP_PROPOSAL,\n            )\n        }\n        ExecuteMsg::DropOwnershipProposal {} =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n\n            drop_ownership_proposal(deps, info, config.owner, OWNERSHIP_PROPOSAL)\n        }\n        ExecuteMsg::ClaimOwnership {} =\u003e {\n            claim_ownership(deps, info, env, OWNERSHIP_PROPOSAL, |deps, new_owner| {\n                CONFIG.update::\u003c_, StdError\u003e(deps.storage, |mut v| {\n                    v.owner = new_owner;\n                    Ok(v)\n                })?;\n\n                Ok(())\n            })\n        }\n        ExecuteMsg::UpdateConfig {\n            new_max_allocations_amount,\n        } =\u003e update_config(deps, info, new_max_allocations_amount),\n        ExecuteMsg::UpdateUnlockSchedules {\n            new_unlock_schedules,\n        } =\u003e update_unlock_schedules(deps, env, info, new_unlock_schedules),\n    }\n}\n\n/// Receives a message of type [`Cw20ReceiveMsg`] and processes it depending on the received template.\n///\n/// * **cw20_msg** CW20 message to process.\nfn execute_receive_cw20(\n    deps: DepsMut,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    match from_binary(\u0026cw20_msg.msg)? {\n        ReceiveMsg::CreateAllocations { allocations } =\u003e execute_create_allocations(\n            deps,\n            cw20_msg.sender,\n            info.sender,\n            cw20_msg.amount,\n            allocations,\n        ),\n        ReceiveMsg::IncreaseAllocation { user, amount } =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n\n            if config.astro_token != info.sender {\n                return Err(StdError::generic_err(\"Only ASTRO can be deposited\"));\n            }\n            if deps.api.addr_validate(\u0026cw20_msg.sender)? != config.owner {\n                return Err(StdError::generic_err(\n                    \"Only the contract owner can increase allocations\",\n                ));\n            }\n\n            execute_increase_allocation(deps, \u0026config, user, amount, Some(cw20_msg.amount))\n        }\n    }\n}\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::Config {}** Return the contract configuration.\n///\n/// * **QueryMsg::State {}** Return the contract state (number of ASTRO that still need to be withdrawn).\n///\n/// * **QueryMsg::Allocation {}** Return the allocation details for a specific account.\n///\n/// * **QueryMsg::UnlockedTokens {}** Return the amount of unlocked ASTRO for a specific account.\n///\n/// * **QueryMsg::SimulateWithdraw {}** Return the result of a withdrawal simulation.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Config {} =\u003e to_binary(\u0026CONFIG.load(deps.storage)?),\n        QueryMsg::State {} =\u003e to_binary(\u0026query_state(deps)?),\n        QueryMsg::Allocation { account } =\u003e to_binary(\u0026query_allocation(deps, account)?),\n        QueryMsg::UnlockedTokens { account } =\u003e {\n            to_binary(\u0026query_tokens_unlocked(deps, env, account)?)\n        }\n        QueryMsg::SimulateWithdraw { account, timestamp } =\u003e {\n            to_binary(\u0026query_simulate_withdraw(deps, env, account, timestamp)?)\n        }\n        QueryMsg::Allocations { start_after, limit } =\u003e {\n            to_binary(\u0026query_allocations(deps, start_after, limit)?)\n        }\n    }\n}\n\n/// Admin function facilitating the creation of new allocations.\n///\n/// * **creator** allocations creator (the contract admin).\n///\n/// * **deposit_token** token being deposited (should be ASTRO).\n///\n/// * **deposit_amount** tokens sent along with the call (should equal the sum of allocation amounts)\n///\n/// * **deposit_amount** new allocations being created.\nfn execute_create_allocations(\n    deps: DepsMut,\n    creator: String,\n    deposit_token: Addr,\n    deposit_amount: Uint128,\n    allocations: Vec\u003c(String, AllocationParams)\u003e,\n) -\u003e StdResult\u003cResponse\u003e {\n    let config = CONFIG.load(deps.storage)?;\n    let mut state = STATE.load(deps.storage)?;\n\n    if deps.api.addr_validate(\u0026creator)? != config.owner {\n        return Err(StdError::generic_err(\n            \"Only the contract owner can create allocations\",\n        ));\n    }\n\n    if deposit_token != config.astro_token {\n        return Err(StdError::generic_err(\"Only ASTRO can be deposited\"));\n    }\n\n    if deposit_amount\n        != allocations\n            .iter()\n            .map(|params| params.1.amount)\n            .sum::\u003cUint128\u003e()\n    {\n        return Err(StdError::generic_err(\"ASTRO deposit amount mismatch\"));\n    }\n\n    state.total_astro_deposited += deposit_amount;\n    state.remaining_astro_tokens += deposit_amount;\n\n    if state.total_astro_deposited \u003e config.max_allocations_amount {\n        return Err(StdError::generic_err(format!(\n            \"The total allocation for all recipients cannot exceed total ASTRO amount allocated to unlock (currently {} ASTRO)\",\n            config.max_allocations_amount,\n        )));\n    }\n\n    for (user_unchecked, params) in allocations {\n        params.validate(\u0026user_unchecked)?;\n        let user = deps.api.addr_validate(\u0026user_unchecked)?;\n\n        if PARAMS.has(deps.storage, \u0026user) {\n            return Err(StdError::generic_err(format!(\n                \"Allocation (params) already exists for {user}\"\n            )));\n        }\n        PARAMS.save(deps.storage, \u0026user, \u0026params)?;\n        STATUS.save(deps.storage, \u0026user, \u0026AllocationStatus::new())?;\n    }\n\n    STATE.save(deps.storage, \u0026state)?;\n    Ok(Response::default())\n}\n\n/// Allow allocation recipients to withdraw unlocked ASTRO.\nfn execute_withdraw(deps: DepsMut, env: Env, info: MessageInfo) -\u003e StdResult\u003cResponse\u003e {\n    let config = CONFIG.load(deps.storage)?;\n    let mut state = STATE.load(deps.storage)?;\n\n    let params = PARAMS.load(deps.storage, \u0026info.sender)?;\n\n    if params.proposed_receiver.is_some() {\n        return Err(StdError::generic_err(\n            \"You may not withdraw once you proposed new receiver!\",\n        ));\n    }\n\n    let mut status = STATUS.load(deps.storage, \u0026info.sender)?;\n\n    let SimulateWithdrawResponse { astro_to_withdraw } =\n        compute_withdraw_amount(env.block.time.seconds(), \u0026params, \u0026status);\n\n    if astro_to_withdraw.is_zero() {\n        return Err(StdError::generic_err(\"No unlocked ASTRO to be withdrawn\"));\n    }\n\n    status.astro_withdrawn += astro_to_withdraw;\n    state.remaining_astro_tokens -= astro_to_withdraw;\n\n    // SAVE :: state \u0026 allocation\n    STATE.save(deps.storage, \u0026state)?;\n\n    // Update status\n    STATUS.save(deps.storage, \u0026info.sender, \u0026status)?;\n\n    Ok(Response::new()\n        .add_message(WasmMsg::Execute {\n            contract_addr: config.astro_token.to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                recipient: info.sender.to_string(),\n                amount: astro_to_withdraw,\n            })?,\n            funds: vec![],\n        })\n        .add_attribute(\"astro_withdrawn\", astro_to_withdraw))\n}\n\n/// Allows the current allocation receiver to propose a new receiver.\n///\n/// * **new_receiver** new proposed receiver for the allocation.\nfn execute_propose_new_receiver(\n    deps: DepsMut,\n    info: MessageInfo,\n    new_receiver: String,\n) -\u003e StdResult\u003cResponse\u003e {\n    let mut alloc_params = PARAMS.load(deps.storage, \u0026info.sender)?;\n    let new_receiver = deps.api.addr_validate(\u0026new_receiver)?;\n\n    match alloc_params.proposed_receiver {\n        Some(proposed_receiver) =\u003e {\n            return Err(StdError::generic_err(format!(\n                \"Proposed receiver already set to {proposed_receiver}\"\n            )));\n        }\n        None =\u003e {\n            if PARAMS.has(deps.storage, \u0026new_receiver) {\n                return Err(StdError::generic_err(\n                    \"Invalid new_receiver. Proposed receiver already has an ASTRO allocation\",\n                ));\n            }\n\n            alloc_params.proposed_receiver = Some(new_receiver.clone());\n            PARAMS.save(deps.storage, \u0026info.sender, \u0026alloc_params)?;\n        }\n    }\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"ProposeNewReceiver\")\n        .add_attribute(\"proposed_receiver\", new_receiver))\n}\n\n/// Drop the new proposed receiver for a specific allocation.\nfn execute_drop_new_receiver(deps: DepsMut, info: MessageInfo) -\u003e StdResult\u003cResponse\u003e {\n    let mut alloc_params = PARAMS.load(deps.storage, \u0026info.sender)?;\n\n    match alloc_params.proposed_receiver {\n        Some(proposed_receiver) =\u003e {\n            alloc_params.proposed_receiver = None;\n            PARAMS.save(deps.storage, \u0026info.sender, \u0026alloc_params)?;\n\n            Ok(Response::new()\n                .add_attribute(\"action\", \"DropNewReceiver\")\n                .add_attribute(\"dropped_proposed_receiver\", proposed_receiver))\n        }\n        None =\u003e Err(StdError::generic_err(\"Proposed receiver not set\")),\n    }\n}\n\n/// Decrease an address' ASTRO allocation.\n///\n/// * **receiver** address that will have its allocation decreased.\n///\n/// * **amount** ASTRO amount to decrease the allocation by.\nfn execute_decrease_allocation(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    receiver: String,\n    amount: Uint128,\n) -\u003e StdResult\u003cResponse\u003e {\n    let config = CONFIG.load(deps.storage)?;\n    if info.sender != config.owner {\n        return Err(StdError::generic_err(\n            \"Only the contract owner can decrease allocations\",\n        ));\n    }\n\n    let receiver = deps.api.addr_validate(\u0026receiver)?;\n\n    let mut state = STATE.load(deps.storage)?;\n    let mut params = PARAMS.load(deps.storage, \u0026receiver)?;\n    let mut status = STATUS.load(deps.storage, \u0026receiver)?;\n\n    let unlocked_amount = compute_unlocked_amount(\n        env.block.time.seconds(),\n        params.amount,\n        \u0026params.unlock_schedule,\n        status.unlocked_amount_checkpoint,\n    );\n    let locked_amount = params.amount - unlocked_amount;\n\n    if locked_amount \u003c amount {\n        return Err(StdError::generic_err(format!(\n            \"Insufficient amount of lock to decrease allocation, user has locked {locked_amount} ASTRO.\"\n        )));\n    }\n\n    params.amount = params.amount.checked_sub(amount)?;\n    status.unlocked_amount_checkpoint = unlocked_amount;\n    state.unallocated_tokens = state.unallocated_tokens.checked_add(amount)?;\n    state.remaining_astro_tokens = state.remaining_astro_tokens.checked_sub(amount)?;\n\n    STATUS.save(deps.storage, \u0026receiver, \u0026status)?;\n    PARAMS.save(deps.storage, \u0026receiver, \u0026params)?;\n    STATE.save(deps.storage, \u0026state)?;\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"execute_decrease_allocation\"),\n        attr(\"receiver\", receiver),\n        attr(\"amount\", amount),\n    ]))\n}\n\n/// Increase an address' ASTRO allocation.\n///\n/// * **receiver** address that will have its allocation incrased.\n///\n/// * **amount** ASTRO amount to increase the allocation by.\n///\n/// * **deposit_amount** is amount of ASTRO to increase the allocation by using CW20 Receive.\nfn execute_increase_allocation(\n    deps: DepsMut,\n    config: \u0026Config,\n    receiver: String,\n    amount: Uint128,\n    deposit_amount: Option\u003cUint128\u003e,\n) -\u003e StdResult\u003cResponse\u003e {\n    let receiver = deps.api.addr_validate(\u0026receiver)?;\n\n    match PARAMS.may_load(deps.storage, \u0026receiver)? {\n        Some(mut params) =\u003e {\n            let mut state = STATE.load(deps.storage)?;\n\n            if let Some(deposit_amount) = deposit_amount {\n                state.total_astro_deposited =\n                    state.total_astro_deposited.checked_add(deposit_amount)?;\n                state.unallocated_tokens = state.unallocated_tokens.checked_add(deposit_amount)?;\n\n                if state.total_astro_deposited \u003e config.max_allocations_amount {\n                    return Err(StdError::generic_err(format!(\n                        \"The total allocation for all recipients cannot exceed total ASTRO amount allocated to unlock (currently {} ASTRO)\",\n                        config.max_allocations_amount,\n                    )));\n                }\n            }\n\n            if state.unallocated_tokens \u003c amount {\n                return Err(StdError::generic_err(format!(\n                    \"Insufficient unallocated ASTRO to increase allocation. Contract has: {} unallocated ASTRO.\",\n                    state.unallocated_tokens\n                )));\n            }\n\n            params.amount = params.amount.checked_add(amount)?;\n            state.unallocated_tokens = state.unallocated_tokens.checked_sub(amount)?;\n            state.remaining_astro_tokens = state.remaining_astro_tokens.checked_add(amount)?;\n\n            PARAMS.save(deps.storage, \u0026receiver, \u0026params)?;\n            STATE.save(deps.storage, \u0026state)?;\n        }\n        None =\u003e {\n            return Err(StdError::generic_err(\"Proposed receiver not set\"));\n        }\n    }\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"execute_increase_allocation\")\n        .add_attribute(\"amount\", amount)\n        .add_attribute(\"receiver\", receiver))\n}\n\n/// Transfer unallocated ASTRO tokens to a recipient.\n///\n/// * **amount** amount ASTRO to transfer.\n///\n/// * **recipient** transfer recipient.\nfn execute_transfer_unallocated(\n    deps: DepsMut,\n    info: MessageInfo,\n    amount: Uint128,\n    recipient: Option\u003cString\u003e,\n) -\u003e StdResult\u003cResponse\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    if config.owner != info.sender {\n        return Err(StdError::generic_err(\n            \"Only contract owner can transfer unallocated ASTRO.\",\n        ));\n    }\n\n    let mut state = STATE.load(deps.storage)?;\n\n    if state.unallocated_tokens \u003c amount {\n        return Err(StdError::generic_err(format!(\n            \"Insufficient unallocated ASTRO to transfer. Contract has: {} unallocated ASTRO.\",\n            state.unallocated_tokens\n        )));\n    }\n\n    state.unallocated_tokens = state.unallocated_tokens.checked_sub(amount)?;\n    state.total_astro_deposited = state.total_astro_deposited.checked_sub(amount)?;\n\n    let recipient = addr_opt_validate(deps.api, \u0026recipient)?.unwrap_or_else(|| info.sender.clone());\n    let msg = WasmMsg::Execute {\n        contract_addr: config.astro_token.to_string(),\n        msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n            recipient: recipient.to_string(),\n            amount,\n        })?,\n        funds: vec![],\n    };\n\n    STATE.save(deps.storage, \u0026state)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"execute_transfer_unallocated\")\n        .add_attribute(\"amount\", amount)\n        .add_message(msg))\n}\n\n/// Allows a newly proposed allocation receiver to claim the ownership of that allocation.\n///\n/// * **prev_receiver** this is the previous receiver for the allocation.\nfn execute_claim_receiver(\n    deps: DepsMut,\n    info: MessageInfo,\n    prev_receiver: String,\n) -\u003e StdResult\u003cResponse\u003e {\n    let prev_receiver_addr = deps.api.addr_validate(\u0026prev_receiver)?;\n    let mut alloc_params = PARAMS.load(deps.storage, \u0026prev_receiver_addr)?;\n\n    match alloc_params.proposed_receiver {\n        Some(proposed_receiver) =\u003e {\n            if proposed_receiver == info.sender {\n                if let Some(sender_params) = PARAMS.may_load(deps.storage, \u0026info.sender)? {\n                    return Err(StdError::generic_err(format!(\n                        \"The proposed receiver already has an ASTRO allocation of {} ASTRO, that ends at {}\",\n                        sender_params.amount,\n                        sender_params.unlock_schedule.start_time + sender_params.unlock_schedule.duration + sender_params.unlock_schedule.cliff,\n                    )));\n                }\n\n                // Transfers allocation parameters\n                // 1. Save the allocation for the new receiver\n                alloc_params.proposed_receiver = None;\n                PARAMS.save(deps.storage, \u0026info.sender, \u0026alloc_params)?;\n                // 2. Remove the allocation info from the previous owner\n                PARAMS.remove(deps.storage, \u0026prev_receiver_addr);\n                // Transfers Allocation Status\n                let status = STATUS.load(deps.storage, \u0026prev_receiver_addr)?;\n\n                STATUS.save(deps.storage, \u0026info.sender, \u0026status)?;\n                STATUS.remove(deps.storage, \u0026prev_receiver_addr)\n            } else {\n                return Err(StdError::generic_err(format!(\n                    \"Proposed receiver mismatch, actual proposed receiver : {proposed_receiver}\"\n                )));\n            }\n        }\n        None =\u003e {\n            return Err(StdError::generic_err(\"Proposed receiver not set\"));\n        }\n    }\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"ClaimReceiver\"),\n        attr(\"prev_receiver\", prev_receiver),\n        attr(\"receiver\", info.sender),\n    ]))\n}\n\n/// Updates builder unlock contract parameters.\nfn update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    new_max_allocations_amount: Uint128,\n) -\u003e StdResult\u003cResponse\u003e {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    if info.sender != config.owner {\n        return Err(StdError::generic_err(\n            \"Only the contract owner can change config\",\n        ));\n    }\n\n    let state = STATE.load(deps.storage)?;\n\n    if new_max_allocations_amount \u003c state.total_astro_deposited {\n        return Err(StdError::generic_err(format!(\n            \"The new max allocations amount {} can not be less than currently deposited {}\",\n            new_max_allocations_amount, state.total_astro_deposited,\n        )));\n    }\n\n    config.max_allocations_amount = new_max_allocations_amount;\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"update_config\")\n        .add_attribute(\"new_max_allocations_amount\", new_max_allocations_amount))\n}\n\n/// Updates builder unlock schedules for specified accounts.\nfn update_unlock_schedules(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    new_unlock_schedules: Vec\u003c(String, Schedule)\u003e,\n) -\u003e StdResult\u003cResponse\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    if info.sender != config.owner {\n        return Err(StdError::generic_err(\n            \"Only the contract owner can change config\",\n        ));\n    }\n\n    for (account, new_schedule) in new_unlock_schedules {\n        let account_addr = deps.api.addr_validate(\u0026account)?;\n        let mut params = PARAMS.load(deps.storage, \u0026account_addr)?;\n\n        let mut status = STATUS.load(deps.storage, \u0026account_addr)?;\n\n        let unlocked_amount_checkpoint = compute_unlocked_amount(\n            env.block.time.seconds(),\n            params.amount,\n            \u0026params.unlock_schedule,\n            status.unlocked_amount_checkpoint,\n        );\n\n        if unlocked_amount_checkpoint \u003e status.unlocked_amount_checkpoint {\n            status.unlocked_amount_checkpoint = unlocked_amount_checkpoint;\n            STATUS.save(deps.storage, \u0026account_addr, \u0026status)?;\n        }\n\n        params.update_schedule(new_schedule, \u0026account)?;\n        PARAMS.save(deps.storage, \u0026account_addr, \u0026params)?;\n    }\n\n    Ok(Response::new().add_attribute(\"action\", \"update_unlock_schedules\"))\n}\n\n/// Return the global distribution state.\npub fn query_state(deps: Deps) -\u003e StdResult\u003cStateResponse\u003e {\n    let state = STATE.load(deps.storage)?;\n    Ok(StateResponse {\n        total_astro_deposited: state.total_astro_deposited,\n        remaining_astro_tokens: state.remaining_astro_tokens,\n        unallocated_astro_tokens: state.unallocated_tokens,\n    })\n}\n\n/// Return information about a specific allocation.\n///\n/// * **account** account whose allocation we query.\nfn query_allocation(deps: Deps, account: String) -\u003e StdResult\u003cAllocationResponse\u003e {\n    let account_checked = deps.api.addr_validate(\u0026account)?;\n\n    Ok(AllocationResponse {\n        params: PARAMS\n            .may_load(deps.storage, \u0026account_checked)?\n            .unwrap_or_default(),\n        status: STATUS\n            .may_load(deps.storage, \u0026account_checked)?\n            .unwrap_or_default(),\n    })\n}\n\n/// Return information about a specific allocation.\n///\n/// * **start_after** account from which to start querying.\n///\n/// * **limit** max amount of entries to return.\nfn query_allocations(\n    deps: Deps,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cVec\u003c(Addr, AllocationParams)\u003e\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let default_start;\n\n    let start = if let Some(start_after) = start_after {\n        default_start = deps.api.addr_validate(\u0026start_after)?;\n        Some(Bound::exclusive(\u0026default_start))\n    } else {\n        None\n    };\n\n    PARAMS\n        .range(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .collect()\n}\n\n/// Return the total amount of unlocked tokens for a specific account.\n///\n/// * **account** account whose unlocked token amount we query.\nfn query_tokens_unlocked(deps: Deps, env: Env, account: String) -\u003e StdResult\u003cUint128\u003e {\n    let account_checked = deps.api.addr_validate(\u0026account)?;\n\n    let params = PARAMS.load(deps.storage, \u0026account_checked)?;\n    let status = STATUS.load(deps.storage, \u0026account_checked)?;\n\n    Ok(compute_unlocked_amount(\n        env.block.time.seconds(),\n        params.amount,\n        \u0026params.unlock_schedule,\n        status.unlocked_amount_checkpoint,\n    ))\n}\n\n/// Simulate a token withdrawal.\n///\n/// * **account** account for which we simulate a withdrawal.\n///\n/// * **timestamp** timestamp where we assume the account would withdraw.\nfn query_simulate_withdraw(\n    deps: Deps,\n    env: Env,\n    account: String,\n    timestamp: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cSimulateWithdrawResponse\u003e {\n    let account_checked = deps.api.addr_validate(\u0026account)?;\n\n    let params = PARAMS.load(deps.storage, \u0026account_checked)?;\n    let status = STATUS.load(deps.storage, \u0026account_checked)?;\n\n    Ok(compute_withdraw_amount(\n        timestamp.unwrap_or_else(|| env.block.time.seconds()),\n        \u0026params,\n        \u0026status,\n    ))\n}\n\n/// Manages contract migration\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e StdResult\u003cResponse\u003e {\n    let contract_version = get_contract_version(deps.storage)?;\n\n    match contract_version.contract.as_ref() {\n        \"builder-unlock\" =\u003e match contract_version.version.as_ref() {\n            \"1.2.0\" =\u003e {}\n            \"1.2.2\" =\u003e {}\n            _ =\u003e return Err(StdError::generic_err(\"Contract can't be migrated!\")),\n        },\n        _ =\u003e return Err(StdError::generic_err(\"Contract can't be migrated!\")),\n    };\n\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    Ok(Response::new()\n        .add_attribute(\"previous_contract_name\", \u0026contract_version.contract)\n        .add_attribute(\"previous_contract_version\", \u0026contract_version.version)\n        .add_attribute(\"new_contract_name\", CONTRACT_NAME)\n        .add_attribute(\"new_contract_version\", CONTRACT_VERSION))\n}\n\n//----------------------------------------------------------------------------------------\n// Helper Functions\n//----------------------------------------------------------------------------------------\n\nmod helpers {\n    use cosmwasm_std::Uint128;\n\n    use astroport_governance::builder_unlock::msg::SimulateWithdrawResponse;\n    use astroport_governance::builder_unlock::{AllocationParams, AllocationStatus, Schedule};\n\n    /// Computes number of tokens that are now unlocked for a given allocation\n    pub fn compute_unlocked_amount(\n        timestamp: u64,\n        amount: Uint128,\n        schedule: \u0026Schedule,\n        unlock_checkpoint: Uint128,\n    ) -\u003e Uint128 {\n        // Tokens haven't begun unlocking\n        if timestamp \u003c schedule.start_time + schedule.cliff {\n            unlock_checkpoint\n        }\n        // Tokens unlock linearly between start time and end time\n        else if (timestamp \u003c schedule.start_time + schedule.duration) \u0026\u0026 schedule.duration != 0 {\n            let unlocked_amount =\n                amount.multiply_ratio(timestamp - schedule.start_time, schedule.duration);\n\n            if unlocked_amount \u003e unlock_checkpoint {\n                unlocked_amount\n            } else {\n                unlock_checkpoint\n            }\n        }\n        // After end time, all tokens are fully unlocked\n        else {\n            amount\n        }\n    }\n\n    /// Computes number of tokens that are withdrawable for a given allocation\n    pub fn compute_withdraw_amount(\n        timestamp: u64,\n        params: \u0026AllocationParams,\n        status: \u0026AllocationStatus,\n    ) -\u003e SimulateWithdrawResponse {\n        // \"Unlocked\" amount\n        let astro_unlocked = compute_unlocked_amount(\n            timestamp,\n            params.amount,\n            \u0026params.unlock_schedule,\n            status.unlocked_amount_checkpoint,\n        );\n\n        // Withdrawal amount is unlocked amount minus the amount already withdrawn\n        let astro_withdrawable = astro_unlocked - status.astro_withdrawn;\n\n        SimulateWithdrawResponse {\n            astro_to_withdraw: astro_withdrawable,\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","builder_unlock","src","lib.rs"],"content":"pub mod contract;\nmod migration;\npub mod state;\n\n// During development this import could be replaced with another astroport version.\n// However, in production, the astroport version should be the same for all contracts.\npub use astroport_governance::astroport;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","builder_unlock","src","migration.rs"],"content":"use cosmwasm_schema::cw_serde;\n\n/// This structure describes a migration message.\n#[cw_serde]\npub struct MigrateMsg {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","builder_unlock","src","state.rs"],"content":"use crate::astroport::common::OwnershipProposal;\nuse cosmwasm_std::Addr;\nuse cw_storage_plus::{Item, Map};\n\nuse astroport_governance::builder_unlock::{AllocationParams, AllocationStatus, Config, State};\n\n/// Stores the contract configuration\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n/// Stores global unlcok state such as the total amount of ASTRO tokens still to be distributed\npub const STATE: Item\u003cState\u003e = Item::new(\"state\");\n/// Allocation parameters for each unlock recipient\npub const PARAMS: Map\u003c\u0026Addr, AllocationParams\u003e = Map::new(\"params\");\n/// The status of each unlock schedule\npub const STATUS: Map\u003c\u0026Addr, AllocationStatus\u003e = Map::new(\"status\");\n/// Contains a proposal to change contract ownership\npub const OWNERSHIP_PROPOSAL: Item\u003cOwnershipProposal\u003e = Item::new(\"ownership_proposal\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","builder_unlock","tests","integration.rs"],"content":"use astroport::token::InstantiateMsg as TokenInstantiateMsg;\nuse astroport_governance::builder_unlock::{AllocationParams, Schedule};\n\nuse astroport_governance::builder_unlock::msg::{\n    AllocationResponse, ConfigResponse, ExecuteMsg, InstantiateMsg, QueryMsg, ReceiveMsg,\n    SimulateWithdrawResponse, StateResponse,\n};\nuse cosmwasm_std::{attr, to_binary, Addr, StdResult, Timestamp, Uint128};\nuse cw20::BalanceResponse;\nuse cw_multi_test::{App, BasicApp, ContractWrapper, Executor};\n\nconst OWNER: \u0026str = \"owner\";\n\nfn mock_app() -\u003e App {\n    BasicApp::default()\n}\n\nfn init_contracts(app: \u0026mut App) -\u003e (Addr, Addr, InstantiateMsg) {\n    // Instantiate ASTRO token contract\n    let astro_token_contract = Box::new(ContractWrapper::new(\n        astroport_token::contract::execute,\n        astroport_token::contract::instantiate,\n        astroport_token::contract::query,\n    ));\n\n    let astro_token_code_id = app.store_code(astro_token_contract);\n\n    let msg = TokenInstantiateMsg {\n        name: String::from(\"Astro token\"),\n        symbol: String::from(\"ASTRO\"),\n        decimals: 6,\n        initial_balances: vec![],\n        mint: Some(cw20::MinterResponse {\n            minter: OWNER.clone().to_string(),\n            cap: None,\n        }),\n        marketing: None,\n    };\n\n    let astro_token_instance = app\n        .instantiate_contract(\n            astro_token_code_id,\n            Addr::unchecked(OWNER.clone().to_string()),\n            \u0026msg,\n            \u0026[],\n            String::from(\"ASTRO\"),\n            None,\n        )\n        .unwrap();\n\n    // Instantiate the contract\n    let unlock_contract = Box::new(ContractWrapper::new(\n        builder_unlock::contract::execute,\n        builder_unlock::contract::instantiate,\n        builder_unlock::contract::query,\n    ));\n\n    let unlock_code_id = app.store_code(unlock_contract);\n\n    let unlock_instantiate_msg = InstantiateMsg {\n        owner: OWNER.clone().to_string(),\n        astro_token: astro_token_instance.to_string(),\n        max_allocations_amount: Uint128::new(300_000_000_000_000u128),\n    };\n\n    // Init contract\n    let unlock_instance = app\n        .instantiate_contract(\n            unlock_code_id,\n            Addr::unchecked(OWNER.clone()),\n            \u0026unlock_instantiate_msg,\n            \u0026[],\n            \"unlock\",\n            None,\n        )\n        .unwrap();\n\n    (\n        unlock_instance,\n        astro_token_instance,\n        unlock_instantiate_msg,\n    )\n}\n\nfn mint_some_astro(\n    app: \u0026mut App,\n    owner: Addr,\n    astro_token_instance: Addr,\n    amount: Uint128,\n    to: String,\n) {\n    let msg = cw20::Cw20ExecuteMsg::Mint {\n        recipient: to.clone(),\n        amount: amount,\n    };\n    let res = app\n        .execute_contract(owner.clone(), astro_token_instance.clone(), \u0026msg, \u0026[])\n        .unwrap();\n    assert_eq!(res.events[1].attributes[1], attr(\"action\", \"mint\"));\n    assert_eq!(res.events[1].attributes[2], attr(\"to\", to));\n    assert_eq!(res.events[1].attributes[3], attr(\"amount\", amount));\n}\n\nfn check_alloc_amount(app: \u0026mut App, contract_addr: \u0026Addr, account: \u0026Addr, amount: Uint128) {\n    let res: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            contract_addr,\n            \u0026QueryMsg::Allocation {\n                account: account.to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(res.params.amount, amount);\n}\n\nfn check_unlock_amount(app: \u0026mut App, contract_addr: \u0026Addr, account: \u0026Addr, amount: Uint128) {\n    let resp: Uint128 = app\n        .wrap()\n        .query_wasm_smart(\n            contract_addr,\n            \u0026QueryMsg::UnlockedTokens {\n                account: account.to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(resp, amount);\n}\n\n#[test]\nfn proper_initialization() {\n    let mut app = mock_app();\n    let (unlock_instance, _astro_instance, init_msg) = init_contracts(\u0026mut app);\n\n    let resp: ConfigResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026unlock_instance, \u0026QueryMsg::Config {})\n        .unwrap();\n\n    // Check config\n    assert_eq!(init_msg.owner, resp.owner);\n    assert_eq!(init_msg.astro_token, resp.astro_token);\n\n    // Check state\n    let resp: StateResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026unlock_instance, \u0026QueryMsg::State {})\n        .unwrap();\n\n    assert_eq!(Uint128::zero(), resp.total_astro_deposited);\n    assert_eq!(Uint128::zero(), resp.remaining_astro_tokens);\n}\n\n#[test]\nfn test_transfer_ownership() {\n    let mut app = mock_app();\n    let (unlock_instance, _, init_msg) = init_contracts(\u0026mut app);\n\n    // ######    ERROR :: Unauthorized     ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"not_owner\".to_string()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::ProposeNewOwner {\n                new_owner: \"new_owner\".to_string(),\n                expires_in: 600,\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Generic error: Unauthorized\");\n\n    app.execute_contract(\n        Addr::unchecked(OWNER.to_string()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::ProposeNewOwner {\n            new_owner: \"new_owner\".to_string(),\n            expires_in: 100,\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    app.execute_contract(\n        Addr::unchecked(\"new_owner\".to_string()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::ClaimOwnership {},\n        \u0026[],\n    )\n    .unwrap();\n\n    let resp: ConfigResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026unlock_instance, \u0026QueryMsg::Config {})\n        .unwrap();\n\n    // Check config\n    assert_eq!(\"new_owner\".to_string(), resp.owner);\n    assert_eq!(init_msg.astro_token, resp.astro_token);\n}\n\n#[test]\nfn test_create_allocations() {\n    let mut app = mock_app();\n    let (unlock_instance, astro_instance, _) = init_contracts(\u0026mut app);\n\n    mint_some_astro(\n        \u0026mut app,\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        Uint128::new(1_000_000_000_000000),\n        OWNER.to_string(),\n    );\n\n    let mut allocations: Vec\u003c(String, AllocationParams)\u003e = vec![];\n    allocations.push((\n        \"investor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 0u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"advisor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"team_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n\n    // ######    ERROR :: Only owner can create allocations     ######\n    mint_some_astro(\n        \u0026mut app,\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        Uint128::new(1_000),\n        \"not_owner\".to_string(),\n    );\n\n    let mut err = app\n        .execute_contract(\n            Addr::unchecked(\"not_owner\".to_string()),\n            astro_instance.clone(),\n            \u0026cw20::Cw20ExecuteMsg::Send {\n                contract: unlock_instance.clone().to_string(),\n                amount: Uint128::from(1_000u64),\n                msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                    allocations: allocations.clone(),\n                })\n                .unwrap(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Only the contract owner can create allocations\"\n    );\n\n    // ######    ERROR :: Only ASTRO can be can be deposited     ######\n    // Instantiate the ASTRO token contract\n    let not_astro_token_contract = Box::new(ContractWrapper::new(\n        astroport_token::contract::execute,\n        astroport_token::contract::instantiate,\n        astroport_token::contract::query,\n    ));\n\n    let not_astro_token_code_id = app.store_code(not_astro_token_contract);\n\n    let msg = TokenInstantiateMsg {\n        name: String::from(\"Astro Token\"),\n        symbol: String::from(\"ASTRO\"),\n        decimals: 6,\n        initial_balances: vec![],\n        mint: Some(cw20::MinterResponse {\n            minter: OWNER.clone().to_string(),\n            cap: None,\n        }),\n        marketing: None,\n    };\n\n    let not_astro_token_instance = app\n        .instantiate_contract(\n            not_astro_token_code_id,\n            Addr::unchecked(OWNER.clone().to_string()),\n            \u0026msg,\n            \u0026[],\n            String::from(\"FAKE_ASTRO\"),\n            None,\n        )\n        .unwrap();\n\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        not_astro_token_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Mint {\n            recipient: OWNER.clone().to_string(),\n            amount: Uint128::from(15_000_000_000000u64),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            not_astro_token_instance.clone(),\n            \u0026cw20::Cw20ExecuteMsg::Send {\n                contract: unlock_instance.clone().to_string(),\n                amount: Uint128::from(15_000_000_000000u64),\n                msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                    allocations: allocations.clone(),\n                })\n                .unwrap(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Only ASTRO can be deposited\"\n    );\n\n    // ######    ERROR :: ASTRO deposit amount mismatch     ######\n    err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            astro_instance.clone(),\n            \u0026cw20::Cw20ExecuteMsg::Send {\n                contract: unlock_instance.clone().to_string(),\n                amount: Uint128::from(15_000_000_000001u64),\n                msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                    allocations: allocations.clone(),\n                })\n                .unwrap(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: ASTRO deposit amount mismatch\"\n    );\n\n    // ######    SUCCESSFULLY CREATES ALLOCATIONS    ######\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Send {\n            contract: unlock_instance.clone().to_string(),\n            amount: Uint128::from(15_000_000_000000u64),\n            msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                allocations: allocations.clone(),\n            })\n            .unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Check state\n    let resp: StateResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026unlock_instance, \u0026QueryMsg::State {})\n        .unwrap();\n    assert_eq!(\n        resp.total_astro_deposited,\n        Uint128::from(15_000_000_000000u64)\n    );\n    assert_eq!(\n        resp.remaining_astro_tokens,\n        Uint128::from(15_000_000_000000u64)\n    );\n\n    // Check allocation #1\n    let resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(resp.params.amount, Uint128::from(5_000_000_000000u64));\n    assert_eq!(resp.status.astro_withdrawn, Uint128::from(0u64));\n    assert_eq!(\n        resp.params.unlock_schedule,\n        Schedule {\n            start_time: 1642402274u64,\n            cliff: 0u64,\n            duration: 31536000u64\n        }\n    );\n\n    // Check allocation #2\n    let resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"advisor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(resp.params.amount, Uint128::from(5_000_000_000000u64));\n    assert_eq!(resp.status.astro_withdrawn, Uint128::from(0u64));\n    assert_eq!(\n        resp.params.unlock_schedule,\n        Schedule {\n            start_time: 1642402274u64,\n            cliff: 7776000u64,\n            duration: 31536000u64\n        }\n    );\n\n    // Check allocation #3\n    let resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"team_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(resp.params.amount, Uint128::from(5_000_000_000000u64));\n    assert_eq!(resp.status.astro_withdrawn, Uint128::from(0u64));\n    assert_eq!(\n        resp.params.unlock_schedule,\n        Schedule {\n            start_time: 1642402274u64,\n            cliff: 7776000u64,\n            duration: 31536000u64\n        }\n    );\n\n    // ######    ERROR :: Allocation already exists for user {}     ######\n    err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            astro_instance.clone(),\n            \u0026cw20::Cw20ExecuteMsg::Send {\n                contract: unlock_instance.clone().to_string(),\n                amount: Uint128::from(5_000_000_000000u64),\n                msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                    allocations: vec![allocations[0].clone()],\n                })\n                .unwrap(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Allocation (params) already exists for investor_1\"\n    );\n}\n\n#[test]\nfn test_withdraw() {\n    let mut app = mock_app();\n    let (unlock_instance, astro_instance, _) = init_contracts(\u0026mut app);\n\n    mint_some_astro(\n        \u0026mut app,\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        Uint128::new(1_000_000_000_000000),\n        OWNER.to_string(),\n    );\n\n    let mut allocations: Vec\u003c(String, AllocationParams)\u003e = vec![];\n    allocations.push((\n        \"investor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 0u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"advisor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"team_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n\n    // SUCCESSFULLY CREATES ALLOCATIONS\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Send {\n            contract: unlock_instance.clone().to_string(),\n            amount: Uint128::from(15_000_000_000000u64),\n            msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                allocations: allocations.clone(),\n            })\n            .unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // ######    ERROR :: Allocation doesn't exist    ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::Withdraw {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"astroport_governance::builder_unlock::AllocationParams not found\"\n    );\n\n    // ######   SUCCESSFULLY WITHDRAWS ASTRO #1   ######\n    app.update_block(|b| {\n        b.height += 17280;\n        b.time = Timestamp::from_seconds(1642402275)\n    });\n\n    let astro_bal_before: BalanceResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026astro_instance,\n            \u0026cw20::Cw20QueryMsg::Balance {\n                address: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n\n    app.execute_contract(\n        Addr::unchecked(\"investor_1\".clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::Withdraw {},\n        \u0026[],\n    )\n    .unwrap();\n\n    // Check state\n    let state_resp: StateResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026unlock_instance, \u0026QueryMsg::State {})\n        .unwrap();\n    assert_eq!(\n        state_resp.total_astro_deposited,\n        Uint128::from(15_000_000_000000u64)\n    );\n    assert_eq!(\n        state_resp.remaining_astro_tokens,\n        Uint128::from(14_999_999_841452u64)\n    );\n\n    // Check allocation #1\n    let alloc_resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(alloc_resp.params.amount, Uint128::from(5_000_000_000000u64));\n    assert_eq!(alloc_resp.status.astro_withdrawn, Uint128::from(158548u64));\n\n    let astro_bal_after: BalanceResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026astro_instance,\n            \u0026cw20::Cw20QueryMsg::Balance {\n                address: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n\n    assert_eq!(\n        astro_bal_after.balance - astro_bal_before.balance,\n        alloc_resp.status.astro_withdrawn\n    );\n\n    // Check the number of unlocked tokens\n    let mut unlock_resp: Uint128 = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::UnlockedTokens {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(unlock_resp, Uint128::from(158548u64));\n\n    // ######    ERROR :: No unlocked ASTRO to be withdrawn   ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"investor_1\".clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::Withdraw {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: No unlocked ASTRO to be withdrawn\"\n    );\n\n    // ######   SUCCESSFULLY WITHDRAWS ASTRO #2   ######\n    app.update_block(|b| {\n        b.height += 17280;\n        b.time = Timestamp::from_seconds(1642402285)\n    });\n\n    // Check the number of unlocked tokens\n    unlock_resp = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::UnlockedTokens {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(unlock_resp, Uint128::from(1744038u64));\n\n    // Check the number of tokens that can be withdrawn from the contract right now\n    let mut sim_withdraw_resp: SimulateWithdrawResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::SimulateWithdraw {\n                account: \"investor_1\".to_string(),\n                timestamp: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(\n        sim_withdraw_resp.astro_to_withdraw,\n        unlock_resp - alloc_resp.status.astro_withdrawn\n    );\n\n    app.execute_contract(\n        Addr::unchecked(\"investor_1\".clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::Withdraw {},\n        \u0026[],\n    )\n    .unwrap();\n\n    let resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(resp.params.amount, Uint128::from(5_000_000_000000u64));\n    assert_eq!(resp.status.astro_withdrawn, unlock_resp);\n\n    // ######    ERROR :: No unlocked ASTRO to be withdrawn   ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"investor_1\".clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::Withdraw {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: No unlocked ASTRO to be withdrawn\"\n    );\n\n    // ######   SUCCESSFULLY WITHDRAWS ASTRO #3   ######\n    // ***** Check that tokens that can be withdrawn before cliff is 0 *****\n    app.update_block(|b| {\n        b.height += 1572480;\n        b.time = Timestamp::from_seconds(1657954273)\n    });\n\n    // Check the number of unlocked tokens\n    unlock_resp = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::UnlockedTokens {\n                account: \"team_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(unlock_resp, Uint128::from(2465753266108u64));\n\n    // Check Number of tokens that can be withdrawn\n    sim_withdraw_resp = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::SimulateWithdraw {\n                account: \"team_1\".to_string(),\n                timestamp: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(\n        sim_withdraw_resp.astro_to_withdraw,\n        Uint128::from(2465753266108u64)\n    );\n\n    app.update_block(|b| {\n        b.height += 17280;\n        b.time = Timestamp::from_seconds(1657954279)\n    });\n\n    // Check the number of unlocked tokens\n    unlock_resp = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::UnlockedTokens {\n                account: \"team_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(unlock_resp, Uint128::from(2465754217402u64));\n\n    // Check Number of tokens that can be withdrawn\n    sim_withdraw_resp = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::SimulateWithdraw {\n                account: \"team_1\".to_string(),\n                timestamp: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(\n        sim_withdraw_resp.astro_to_withdraw,\n        Uint128::from(2465754217402u64)\n    );\n\n    app.execute_contract(\n        Addr::unchecked(\"team_1\".clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::Withdraw {},\n        \u0026[],\n    )\n    .unwrap();\n\n    let resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"team_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        resp.status.astro_withdrawn,\n        sim_withdraw_resp.astro_to_withdraw\n    );\n\n    // Check Number of tokens that can be withdrawn\n    sim_withdraw_resp = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::SimulateWithdraw {\n                account: \"team_1\".to_string(),\n                timestamp: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(sim_withdraw_resp.astro_to_withdraw, Uint128::zero());\n}\n\n#[test]\nfn test_propose_new_receiver() {\n    let mut app = mock_app();\n    let (unlock_instance, astro_instance, _) = init_contracts(\u0026mut app);\n\n    mint_some_astro(\n        \u0026mut app,\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        Uint128::new(1_000_000_000_000000),\n        OWNER.to_string(),\n    );\n\n    let mut allocations: Vec\u003c(String, AllocationParams)\u003e = vec![];\n    allocations.push((\n        \"investor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 0u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"advisor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"team_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n\n    // SUCCESSFULLY CREATES ALLOCATIONS\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Send {\n            contract: unlock_instance.clone().to_string(),\n            amount: Uint128::from(15_000_000_000000u64),\n            msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                allocations: allocations.clone(),\n            })\n            .unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // ######    ERROR :: Allocation doesn't exist    ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::ProposeNewReceiver {\n                new_receiver: \"investor_1_new\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"astroport_governance::builder_unlock::AllocationParams not found\"\n    );\n\n    // ######    ERROR :: Invalid new_receiver    ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"investor_1\".clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::ProposeNewReceiver {\n                new_receiver: \"team_1\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Invalid new_receiver. Proposed receiver already has an ASTRO allocation\"\n    );\n\n    // ######   SUCCESSFULLY PROPOSES NEW RECEIVER   ######\n    app.execute_contract(\n        Addr::unchecked(\"investor_1\".clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::ProposeNewReceiver {\n            new_receiver: \"investor_1_new\".to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    let resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        resp.params.proposed_receiver,\n        Some(Addr::unchecked(\"investor_1_new\".to_string()))\n    );\n\n    // ######    ERROR ::\"Proposed receiver already set\"   ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"investor_1\".clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::ProposeNewReceiver {\n                new_receiver: \"investor_1_new_\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Proposed receiver already set to investor_1_new\"\n    );\n}\n\n#[test]\nfn test_drop_new_receiver() {\n    let mut app = mock_app();\n    let (unlock_instance, astro_instance, _) = init_contracts(\u0026mut app);\n\n    mint_some_astro(\n        \u0026mut app,\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        Uint128::new(1_000_000_000_000000),\n        OWNER.to_string(),\n    );\n\n    let mut allocations: Vec\u003c(String, AllocationParams)\u003e = vec![];\n    allocations.push((\n        \"investor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 0u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"advisor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"team_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n\n    // SUCCESSFULLY CREATES ALLOCATIONS\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Send {\n            contract: unlock_instance.clone().to_string(),\n            amount: Uint128::from(15_000_000_000000u64),\n            msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                allocations: allocations.clone(),\n            })\n            .unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // ######    ERROR :: Allocation doesn't exist    ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::DropNewReceiver {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"astroport_governance::builder_unlock::AllocationParams not found\"\n    );\n\n    // ######    ERROR ::\"Proposed receiver not set\"   ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"investor_1\".clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::DropNewReceiver {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Proposed receiver not set\"\n    );\n\n    // ######   SUCCESSFULLY DROP NEW RECEIVER   ######\n    // SUCCESSFULLY PROPOSES NEW RECEIVER\n    app.execute_contract(\n        Addr::unchecked(\"investor_1\".clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::ProposeNewReceiver {\n            new_receiver: \"investor_1_new\".to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    let mut resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        resp.params.proposed_receiver,\n        Some(Addr::unchecked(\"investor_1_new\".to_string()))\n    );\n\n    app.execute_contract(\n        Addr::unchecked(\"investor_1\".clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::DropNewReceiver {},\n        \u0026[],\n    )\n    .unwrap();\n\n    resp = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(resp.params.proposed_receiver, None);\n}\n\n#[test]\nfn test_claim_receiver() {\n    let mut app = mock_app();\n    let (unlock_instance, astro_instance, _) = init_contracts(\u0026mut app);\n\n    mint_some_astro(\n        \u0026mut app,\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        Uint128::new(1_000_000_000_000000),\n        OWNER.to_string(),\n    );\n\n    let mut allocations: Vec\u003c(String, AllocationParams)\u003e = vec![];\n    allocations.push((\n        \"investor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 0u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"advisor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"team_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n\n    // SUCCESSFULLY CREATES ALLOCATIONS\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Send {\n            contract: unlock_instance.clone().to_string(),\n            amount: Uint128::from(15_000_000_000000u64),\n            msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                allocations: allocations.clone(),\n            })\n            .unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // ######    ERROR :: Allocation doesn't exist    ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::Withdraw {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"astroport_governance::builder_unlock::AllocationParams not found\"\n    );\n\n    // ######    ERROR ::\"Proposed receiver not set\"   ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"investor_1_new\".clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::ClaimReceiver {\n                prev_receiver: \"investor_1\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Proposed receiver not set\"\n    );\n\n    // ######   SUCCESSFULLY CLAIMED BY NEW RECEIVER   ######\n    // SUCCESSFULLY PROPOSES NEW RECEIVER\n    app.execute_contract(\n        Addr::unchecked(\"investor_1\".clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::ProposeNewReceiver {\n            new_receiver: \"investor_1_new\".to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    let alloc_resp_before: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n\n    // Check Number of tokens that can be withdrawn\n    let sim_withdraw_resp_before: SimulateWithdrawResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::SimulateWithdraw {\n                account: \"investor_1\".to_string(),\n                timestamp: None,\n            },\n        )\n        .unwrap();\n\n    // Claimed by new receiver\n    app.execute_contract(\n        Addr::unchecked(\"investor_1_new\".clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::ClaimReceiver {\n            prev_receiver: \"investor_1\".to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Check allocation state of previous beneficiary\n    let alloc_resp_after: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        AllocationParams {\n            amount: Uint128::zero(),\n            unlock_schedule: Schedule {\n                start_time: 0u64,\n                cliff: 0u64,\n                duration: 0u64,\n            },\n            proposed_receiver: None,\n        },\n        alloc_resp_after.params\n    );\n    assert_eq!(alloc_resp_before.status, alloc_resp_after.status);\n\n    // Check allocation state of new beneficiary\n    let alloc_resp_after: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1_new\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        AllocationParams {\n            amount: alloc_resp_before.params.amount,\n            unlock_schedule: Schedule {\n                start_time: alloc_resp_before.params.unlock_schedule.start_time,\n                cliff: alloc_resp_before.params.unlock_schedule.cliff,\n                duration: alloc_resp_before.params.unlock_schedule.duration,\n            },\n            proposed_receiver: None,\n        },\n        alloc_resp_after.params\n    );\n    assert_eq!(alloc_resp_before.status, alloc_resp_after.status);\n\n    // Check Number of tokens that can be withdrawn\n    let sim_withdraw_resp_after_prev_inv: SimulateWithdrawResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::SimulateWithdraw {\n                account: \"investor_1_new\".to_string(),\n                timestamp: None,\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        sim_withdraw_resp_after_prev_inv.astro_to_withdraw,\n        Uint128::zero()\n    );\n\n    // Check Number of tokens that can be withdrawn\n    let sim_withdraw_resp_after_new_inv: SimulateWithdrawResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::SimulateWithdraw {\n                account: \"investor_1_new\".to_string(),\n                timestamp: None,\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        sim_withdraw_resp_after_new_inv.astro_to_withdraw,\n        sim_withdraw_resp_before.astro_to_withdraw,\n    );\n}\n\n#[test]\nfn test_increase_and_decrease_allocation() {\n    let mut app = mock_app();\n    let (unlock_instance, astro_instance, _) = init_contracts(\u0026mut app);\n\n    mint_some_astro(\n        \u0026mut app,\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        Uint128::new(1_000_000_000_000_000),\n        OWNER.to_string(),\n    );\n\n    // Create allocations\n    let allocations: Vec\u003c(String, AllocationParams)\u003e = vec![(\n        \"investor\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1_571_797_419u64,\n                cliff: 300u64,\n                duration: 1_534_700u64,\n            },\n            proposed_receiver: None,\n        },\n    )];\n\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Send {\n            contract: unlock_instance.clone().to_string(),\n            amount: Uint128::from(5_000_000_000000u64),\n            msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                allocations: allocations.clone(),\n            })\n            .unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Check allocations before changes\n    check_alloc_amount(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \u0026Addr::unchecked(\"investor\"),\n        Uint128::new(5_000_000_000_000u128),\n    );\n\n    // Skip blocks\n    app.update_block(|bi| {\n        bi.height += 1000;\n        bi.time = bi.time.plus_seconds(5_000);\n    });\n\n    // Withdraw ASTRO\n    app.execute_contract(\n        Addr::unchecked(\"investor\".to_string()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::Withdraw {},\n        \u0026[],\n    )\n    .unwrap();\n\n    // Skip blocks\n    app.update_block(|bi| {\n        bi.height += 4000;\n        bi.time = bi.time.plus_seconds(20_000);\n    });\n\n    check_unlock_amount(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \u0026Addr::unchecked(\"investor\"),\n        Uint128::new(81_449_143_155u128),\n    );\n\n    // Try to decrease 4918550856846 ASTRO\n    let err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::DecreaseAllocation {\n                receiver: \"investor\".to_string(),\n                amount: Uint128::from(4_918_550_856_846u128),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Insufficient amount of lock to decrease allocation, user has locked 4918550856845 ASTRO.\"\n    );\n\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::DecreaseAllocation {\n            receiver: \"investor\".to_string(),\n            amount: Uint128::from(1_000_000_000_000u128),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Unlock amount didn't change after decreasing\n    check_unlock_amount(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \u0026Addr::unchecked(\"investor\"),\n        Uint128::new(81_449_143_155u128),\n    );\n    let res: StateResponse = app\n        .wrap()\n        .query_wasm_smart(unlock_instance.clone(), \u0026QueryMsg::State {})\n        .unwrap();\n\n    assert_eq!(\n        res,\n        StateResponse {\n            total_astro_deposited: Uint128::new(5_000_000_000_000u128),\n            remaining_astro_tokens: Uint128::new(3_983_710_171_369u128),\n            unallocated_astro_tokens: Uint128::new(1_000_000_000_000u128)\n        }\n    );\n\n    // Try to increase\n    let err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::IncreaseAllocation {\n                receiver: \"investor\".to_string(),\n                amount: Uint128::from(1_000_000_000_001u128),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Insufficient unallocated ASTRO to increase allocation. Contract has: 1000000000000 unallocated ASTRO.\"\n    );\n\n    // Transfer unallocated tokens to owner\n    app.execute_contract(\n        Addr::unchecked(\"owner\".to_string()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::TransferUnallocated {\n            amount: Uint128::from(500_000_000_000u128),\n            recipient: Some(OWNER.to_string()),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    let res: BalanceResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026astro_instance,\n            \u0026cw20::Cw20QueryMsg::Balance {\n                address: OWNER.to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(res.balance, Uint128::from(995_500_000_000_000u128));\n\n    // Increase allocations with sending cw20\n    app.execute_contract(\n        Addr::unchecked(OWNER),\n        astro_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Send {\n            contract: unlock_instance.clone().to_string(),\n            amount: Uint128::from(1_000u64),\n            msg: to_binary(\u0026ReceiveMsg::IncreaseAllocation {\n                amount: Uint128::from(500_000_001_000u128),\n                user: \"investor\".to_string(),\n            })\n            .unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Withdraw ASTRO\n    app.execute_contract(\n        Addr::unchecked(\"investor\".to_string()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::Withdraw {},\n        \u0026[],\n    )\n    .unwrap();\n\n    let res: BalanceResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026astro_instance,\n            \u0026cw20::Cw20QueryMsg::Balance {\n                address: \"investor\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(res.balance, Uint128::from(81_449_143_155u128));\n\n    // Check allocation amount after decreasing and increasing\n    check_alloc_amount(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \u0026Addr::unchecked(\"investor\"),\n        Uint128::new(4_500_000_001_000u128),\n    );\n    // Check astro to withdraw after withdrawal\n    let res: SimulateWithdrawResponse = app\n        .wrap()\n        .query_wasm_smart(\n            unlock_instance.clone(),\n            \u0026QueryMsg::SimulateWithdraw {\n                account: \"investor\".to_string(),\n                timestamp: None,\n            },\n        )\n        .unwrap();\n    assert_eq!(res.astro_to_withdraw, Uint128::zero());\n    // Check state\n    let res: StateResponse = app\n        .wrap()\n        .query_wasm_smart(unlock_instance.clone(), \u0026QueryMsg::State {})\n        .unwrap();\n    assert_eq!(\n        res,\n        StateResponse {\n            total_astro_deposited: Uint128::new(4_500_000_001_000u128),\n            remaining_astro_tokens: Uint128::new(4_418_550_857_845u128),\n            unallocated_astro_tokens: Uint128::zero()\n        }\n    );\n}\n\n#[test]\nfn test_updates_schedules() {\n    let mut app = mock_app();\n    let (unlock_instance, astro_instance, _) = init_contracts(\u0026mut app);\n\n    mint_some_astro(\n        \u0026mut app,\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        Uint128::new(1_000_000_000_000000),\n        OWNER.to_string(),\n    );\n\n    let mut allocations: Vec\u003c(String, AllocationParams)\u003e = vec![];\n    allocations.push((\n        \"investor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 0u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"advisor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"team_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n\n    // ######    SUCCESSFULLY CREATES ALLOCATIONS    ######\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Send {\n            contract: unlock_instance.clone().to_string(),\n            amount: Uint128::from(15_000_000_000000u64),\n            msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                allocations: allocations.clone(),\n            })\n            .unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Check state before update parameters\n    let resp: StateResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026unlock_instance, \u0026QueryMsg::State {})\n        .unwrap();\n    assert_eq!(\n        resp.total_astro_deposited,\n        Uint128::from(15_000_000_000000u64)\n    );\n    assert_eq!(\n        resp.remaining_astro_tokens,\n        Uint128::from(15_000_000_000000u64)\n    );\n\n    // Check allocation #1 before update\n    check_allocation(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \"investor_1\".to_string(),\n        Uint128::from(5_000_000_000000u64),\n        Uint128::from(0u64),\n        Schedule {\n            start_time: 1642402274u64,\n            cliff: 0u64,\n            duration: 31536000u64,\n        },\n    )\n    .unwrap();\n\n    // Check allocation #2 before update\n    check_allocation(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \"advisor_1\".to_string(),\n        Uint128::from(5_000_000_000000u64),\n        Uint128::from(0u64),\n        Schedule {\n            start_time: 1642402274u64,\n            cliff: 7776000u64,\n            duration: 31536000u64,\n        },\n    )\n    .unwrap();\n\n    // Check allocation #3 before update\n    check_allocation(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \"team_1\".to_string(),\n        Uint128::from(5_000_000_000000u64),\n        Uint128::from(0u64),\n        Schedule {\n            start_time: 1642402274u64,\n            cliff: 7776000u64,\n            duration: 31536000u64,\n        },\n    )\n    .unwrap();\n\n    // not owner try to update configs\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"not_owner\".clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::UpdateUnlockSchedules {\n                new_unlock_schedules: vec![(\n                    \"team_1\".to_string(),\n                    Schedule {\n                        start_time: 123u64,\n                        cliff: 123u64,\n                        duration: 123u64,\n                    },\n                )],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"Generic error: Only the contract owner can change config\",\n        err.root_cause().to_string()\n    );\n\n    let err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::UpdateUnlockSchedules {\n                new_unlock_schedules: vec![\n                    (\n                        \"team_1\".to_string(),\n                        Schedule {\n                            start_time: 123u64,\n                            cliff: 123u64,\n                            duration: 123u64,\n                        },\n                    ),\n                    (\n                        \"advisor_1\".to_string(),\n                        Schedule {\n                            start_time: 123u64,\n                            cliff: 123u64,\n                            duration: 123u64,\n                        },\n                    ),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"Generic error: The new cliff value should be greater than or equal to the old one: 123 \u003e= 7776000. Account error: team_1\",\n        err.root_cause().to_string()\n    );\n\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::UpdateUnlockSchedules {\n            new_unlock_schedules: vec![\n                (\n                    \"team_1\".to_string(),\n                    Schedule {\n                        start_time: 1642402284u64,\n                        cliff: 8776000u64,\n                        duration: 31536001u64,\n                    },\n                ),\n                (\n                    \"advisor_1\".to_string(),\n                    Schedule {\n                        start_time: 1642402284u64,\n                        cliff: 8776000u64,\n                        duration: 31536001u64,\n                    },\n                ),\n            ],\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Check allocation #2 before update\n    check_allocation(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \"advisor_1\".to_string(),\n        Uint128::from(5_000_000_000000u64),\n        Uint128::from(0u64),\n        Schedule {\n            start_time: 1642402284u64,\n            cliff: 8776000u64,\n            duration: 31536001u64,\n        },\n    )\n    .unwrap();\n\n    // Check allocation #3 before update\n    check_allocation(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \"team_1\".to_string(),\n        Uint128::from(5_000_000_000000u64),\n        Uint128::from(0u64),\n        Schedule {\n            start_time: 1642402284u64,\n            cliff: 8776000u64,\n            duration: 31536001u64,\n        },\n    )\n    .unwrap();\n\n    // Query allocations\n    let resp: Vec\u003c(Addr, AllocationParams)\u003e = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocations {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    let comparing_values: Vec\u003c(Addr, AllocationParams)\u003e = vec![\n        (\n            Addr::unchecked(\"advisor_1\"),\n            AllocationParams {\n                amount: Uint128::new(5000000000000),\n                unlock_schedule: Schedule {\n                    start_time: 1642402284u64,\n                    cliff: 8776000u64,\n                    duration: 31536001u64,\n                },\n                proposed_receiver: None,\n            },\n        ),\n        (\n            Addr::unchecked(\"investor_1\"),\n            AllocationParams {\n                amount: Uint128::new(5000000000000),\n                unlock_schedule: Schedule {\n                    start_time: 1642402274,\n                    cliff: 0,\n                    duration: 31536000,\n                },\n                proposed_receiver: None,\n            },\n        ),\n        (\n            Addr::unchecked(\"team_1\"),\n            AllocationParams {\n                amount: Uint128::new(5000000000000),\n                unlock_schedule: Schedule {\n                    start_time: 1642402284u64,\n                    cliff: 8776000u64,\n                    duration: 31536001u64,\n                },\n                proposed_receiver: None,\n            },\n        ),\n    ];\n    assert_eq!(comparing_values, resp);\n\n    // Query allocations by specified parameters\n    let resp: Vec\u003c(Addr, AllocationParams)\u003e = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocations {\n                start_after: Some(\"investor_1\".to_string()),\n                limit: None,\n            },\n        )\n        .unwrap();\n    let comparing_values: Vec\u003c(Addr, AllocationParams)\u003e = vec![(\n        Addr::unchecked(\"team_1\"),\n        AllocationParams {\n            amount: Uint128::new(5000000000000),\n            unlock_schedule: Schedule {\n                start_time: 1642402284u64,\n                cliff: 8776000u64,\n                duration: 31536001u64,\n            },\n            proposed_receiver: None,\n        },\n    )];\n    assert_eq!(comparing_values, resp);\n}\n\nfn check_allocation(\n    app: \u0026mut App,\n    unlock_instance: \u0026Addr,\n    account: String,\n    total_amount: Uint128,\n    astro_withdrawn: Uint128,\n    unlock_schedule: Schedule,\n) -\u003e StdResult\u003c()\u003e {\n    let resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(unlock_instance, \u0026QueryMsg::Allocation { account })\n        .unwrap();\n    assert_eq!(resp.params.amount, total_amount);\n    assert_eq!(resp.status.astro_withdrawn, astro_withdrawn);\n    assert_eq!(resp.params.unlock_schedule, unlock_schedule);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","escrow_fee_distributor","examples","escrow_fee_distributor_schema.rs"],"content":"use astroport_governance::escrow_fee_distributor::{\n    ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg,\n};\nuse cosmwasm_schema::write_api;\n\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        query: QueryMsg,\n        execute: ExecuteMsg,\n        migrate: MigrateMsg\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","escrow_fee_distributor","src","contract.rs"],"content":"use astroport::common::{claim_ownership, drop_ownership_proposal, propose_new_owner};\nuse cosmwasm_std::{\n    attr, entry_point, to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Order, Response,\n    StdError, StdResult, Uint128,\n};\nuse cw2::set_contract_version;\nuse cw20::Cw20ReceiveMsg;\nuse cw_storage_plus::Bound;\n\nuse astroport_governance::escrow_fee_distributor::{\n    ConfigResponse, ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg,\n};\nuse astroport_governance::utils::{get_period, CLAIM_LIMIT, MIN_CLAIM_LIMIT};\nuse astroport_governance::voting_escrow::{get_total_voting_power_at, get_voting_power_at};\n\nuse crate::astroport;\nuse crate::astroport::asset::addr_opt_validate;\nuse crate::error::ContractError;\nuse crate::state::{Config, CONFIG, OWNERSHIP_PROPOSAL, REWARDS_PER_WEEK};\nuse crate::utils::{calc_claim_amount, calculate_reward, transfer_token_amount};\n\n/// Contract name that is used for migration.\nconst CONTRACT_NAME: \u0026str = \"astroport-escrow-fee-distributor\";\n/// Contract version that is used for migration.\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Creates a new contract with the specified parameters in the [`InstantiateMsg`].\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    if let Some(claim_many_limit) = msg.claim_many_limit {\n        if claim_many_limit \u003c MIN_CLAIM_LIMIT {\n            return Err(StdError::generic_err(format!(\n                \"Accounts limit for claim operation cannot be less than {MIN_CLAIM_LIMIT} !\"\n            )));\n        }\n    }\n\n    CONFIG.save(\n        deps.storage,\n        \u0026Config {\n            owner: deps.api.addr_validate(\u0026msg.owner)?,\n            astro_token: deps.api.addr_validate(\u0026msg.astro_token)?,\n            voting_escrow_addr: deps.api.addr_validate(\u0026msg.voting_escrow_addr)?,\n            is_claim_disabled: msg.is_claim_disabled.unwrap_or(false),\n            claim_many_limit: msg.claim_many_limit.unwrap_or(CLAIM_LIMIT),\n        },\n    )?;\n\n    Ok(Response::new())\n}\n\n/// Exposes all the execute functions available in the contract.\n///\n/// ## Execute messages\n/// * **ExecuteMsg::ProposeNewOwner { owner, expires_in }** Creates a request to change contract ownership.\n///\n/// * **ExecuteMsg::DropOwnershipProposal {}** Removes a request to change contract ownership.\n///\n/// * **ExecuteMsg::ClaimOwnership {}** Claims contract ownership.\n///\n/// * **ExecuteMsg::Claim { recipient }** Claims ASTRO fees from the distributor and sends them to the recipient.\n///\n/// * **ExecuteMsg::ClaimMany { receivers }** Perform multiple fee claims in a single transaction.\n///\n/// * **ExecuteMsg::Receive(msg)** Parse incoming messages from the ASTRO token.\n///\n/// * **ExecuteMsg::UpdateConfig { claim_many_limit, is_claim_disabled}** Updates general settings.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config: Config = CONFIG.load(deps.storage)?;\n    match msg {\n        ExecuteMsg::ProposeNewOwner { owner, expires_in } =\u003e propose_new_owner(\n            deps,\n            info,\n            env,\n            owner,\n            expires_in,\n            config.owner,\n            OWNERSHIP_PROPOSAL,\n        )\n        .map_err(Into::into),\n        ExecuteMsg::DropOwnershipProposal {} =\u003e {\n            drop_ownership_proposal(deps, info, config.owner, OWNERSHIP_PROPOSAL)\n                .map_err(Into::into)\n        }\n        ExecuteMsg::ClaimOwnership {} =\u003e {\n            claim_ownership(deps, info, env, OWNERSHIP_PROPOSAL, |deps, new_owner| {\n                CONFIG\n                    .update::\u003c_, StdError\u003e(deps.storage, |mut v| {\n                        v.owner = new_owner;\n                        Ok(v)\n                    })\n                    .map(|_| ())\n            })\n            .map_err(Into::into)\n        }\n        ExecuteMsg::Claim {\n            recipient,\n            max_periods,\n        } =\u003e claim(deps, env, info, recipient, max_periods),\n        ExecuteMsg::ClaimMany { receivers } =\u003e claim_many(deps, env, receivers),\n        ExecuteMsg::UpdateConfig {\n            claim_many_limit,\n            is_claim_disabled,\n        } =\u003e update_config(deps, info, claim_many_limit, is_claim_disabled),\n        ExecuteMsg::Receive(msg) =\u003e receive_cw20(deps, env, info, msg),\n    }\n}\n\n/// Receives a message of type [`Cw20ReceiveMsg`] and processes it depending on the received template.\n///\n/// * **cw20_msg** CW20 message to process.\nfn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config: Config = CONFIG.load(deps.storage)?;\n    if info.sender != config.astro_token {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let curr_period = get_period(env.block.time.seconds())?;\n\n    REWARDS_PER_WEEK.update(deps.storage, curr_period, |period| -\u003e StdResult\u003c_\u003e {\n        if let Some(tokens_amount) = period {\n            Ok(tokens_amount.checked_add(cw20_msg.amount)?)\n        } else {\n            Ok(cw20_msg.amount)\n        }\n    })?;\n\n    Ok(Response::new())\n}\n\n/// Claims ASTRO staking rewards from this contract and sends them to the `recipient`.\n///\n/// * **recipient** address that will receive the ASTRO staking rewards.\npub fn claim(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    recipient: Option\u003cString\u003e,\n    max_periods: Option\u003cu64\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    if config.is_claim_disabled {\n        return Err(ContractError::ClaimDisabled {});\n    }\n\n    let recipient_addr =\n        addr_opt_validate(deps.api, \u0026recipient)?.unwrap_or_else(|| info.sender.clone());\n    let current_period = get_period(env.block.time.seconds())?;\n\n    let claim_amount = calc_claim_amount(\n        deps,\n        current_period,\n        \u0026info.sender,\n        \u0026config.voting_escrow_addr,\n        max_periods,\n    )?;\n\n    let transfer_msg = transfer_token_amount(\u0026config.astro_token, \u0026recipient_addr, claim_amount)?;\n\n    let response = Response::new()\n        .add_attributes(vec![\n            attr(\"action\", \"claim\"),\n            attr(\"address\", recipient_addr.to_string()),\n            attr(\"amount\", claim_amount.to_string()),\n        ])\n        .add_messages(transfer_msg);\n\n    Ok(response)\n}\n\n/// Make multiple ASTRO fee claims in a single call.\n///\n/// * **receivers** list of addresses that will receive the claimed ASTRO.\nfn claim_many(\n    mut deps: DepsMut,\n    env: Env,\n    receivers: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    if config.is_claim_disabled {\n        return Err(ContractError::ClaimDisabled {});\n    }\n\n    if receivers.len() \u003e config.claim_many_limit as usize {\n        return Err(ContractError::ClaimLimitExceeded {});\n    }\n\n    let mut claim_total_amount = Uint128::zero();\n    let mut transfer_msg = vec![];\n    let current_period = get_period(env.block.time.seconds())?;\n\n    for receiver in receivers {\n        let receiver_addr = deps.api.addr_validate(\u0026receiver)?;\n        let claim_amount = calc_claim_amount(\n            deps.branch(),\n            current_period,\n            \u0026receiver_addr,\n            \u0026config.voting_escrow_addr,\n            None,\n        )?;\n\n        if !claim_amount.is_zero() {\n            transfer_msg.extend(transfer_token_amount(\n                \u0026config.astro_token,\n                \u0026receiver_addr,\n                claim_amount,\n            )?);\n            claim_total_amount = claim_total_amount.checked_add(claim_amount)?;\n        };\n    }\n\n    let response = Response::new()\n        .add_attributes(vec![\n            attr(\"action\", \"claim_many\"),\n            attr(\"amount\", claim_total_amount.to_string()),\n        ])\n        .add_messages(transfer_msg);\n\n    Ok(response)\n}\n\n/// Updates general contract settings.\n///\n/// * **claim_many_limit** max amount of rewards slots to claim in one transaction.\n///\n/// * **is_claim_disabled** whether reward claims are disabled or not.\nfn update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    claim_many_limit: Option\u003cu64\u003e,\n    is_claim_disabled: Option\u003cbool\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let mut attributes = vec![attr(\"action\", \"update_config\")];\n\n    if let Some(is_claim_disabled) = is_claim_disabled {\n        if config.is_claim_disabled == is_claim_disabled {\n            return Err(ContractError::Std(StdError::generic_err(format!(\n                \"Parameter is_claim_disabled is already {}!\",\n                config.is_claim_disabled\n            ))));\n        }\n        config.is_claim_disabled = is_claim_disabled;\n        attributes.push(attr(\"is_claim_disabled\", is_claim_disabled.to_string()));\n    };\n\n    if let Some(claim_many_limit) = claim_many_limit {\n        if claim_many_limit \u003c MIN_CLAIM_LIMIT {\n            return Err(StdError::generic_err(format!(\n                \"Accounts limit for claim operation cannot be less than {MIN_CLAIM_LIMIT} !\"\n            ))\n            .into());\n        }\n\n        config.claim_many_limit = claim_many_limit;\n        attributes.push(attr(\"claim_many_limit\", claim_many_limit.to_string()));\n    };\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::new().add_attributes(attributes))\n}\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::UserReward { user, timestamp }** Returns the amount of ASTRO rewards a user can claim at a specific timestamp.\n///\n/// * **QueryMsg::Config {}** Returns the contract configuration.\n///\n/// * **QueryMsg::AvailableRewardPerWeek { start_after, limit }** Returns a vector with total amounts\n/// of ASTRO distributed as rewards every week to stakers.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::UserReward { user, timestamp } =\u003e {\n            to_binary(\u0026query_user_reward(deps, user, timestamp)?)\n        }\n        QueryMsg::Config {} =\u003e to_binary(\u0026query_config(deps)?),\n        QueryMsg::AvailableRewardPerWeek { start_after, limit } =\u003e {\n            to_binary(\u0026query_available_reward_per_week(deps, start_after, limit)?)\n        }\n    }\n}\n\n/// Pagination settings\n/// The maximum limit for reading pairs from [`PAIRS`].\nconst MAX_LIMIT: u64 = 30;\n\n/// The default limit for reading pairs from [`PAIRS`].\nconst DEFAULT_LIMIT: u64 = 10;\n\n/// Returns a vector of weekly rewards for current vxASTRO stakers.\n///\n/// * **start_after** timestamp from which to start querying.\n///\n/// * **limit** max amount of entries to return.\nfn query_available_reward_per_week(\n    deps: Deps,\n    start_after: Option\u003cu64\u003e,\n    limit: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cVec\u003cUint128\u003e\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = if let Some(timestamp) = start_after {\n        Some(Bound::exclusive(get_period(timestamp)?))\n    } else {\n        None\n    };\n\n    REWARDS_PER_WEEK\n        .range(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|week| Ok(week?.1))\n        .collect()\n}\n\n/// Returns the amount of rewards a user accrued at a specific timestamp.\n///\n/// * **user** user for which we return the amount of rewards.\n///\n/// * **timestamp** timestamp at which we fetch the user's reward amount.\nfn query_user_reward(deps: Deps, user: String, timestamp: u64) -\u003e StdResult\u003cUint128\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    let user_voting_power =\n        get_voting_power_at(\u0026deps.querier, \u0026config.voting_escrow_addr, user, timestamp)?;\n    let total_voting_power =\n        get_total_voting_power_at(\u0026deps.querier, \u0026config.voting_escrow_addr, timestamp)?;\n\n    if !total_voting_power.is_zero() {\n        let current_period = get_period(timestamp)?;\n        calculate_reward(\n            deps.storage,\n            current_period,\n            user_voting_power,\n            total_voting_power,\n        )\n    } else {\n        Ok(Uint128::zero())\n    }\n}\n\n/// Returns the contract configuration.\npub fn query_config(deps: Deps) -\u003e StdResult\u003cConfigResponse\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    let resp = ConfigResponse {\n        owner: config.owner,\n        astro_token: config.astro_token,\n        voting_escrow_addr: config.voting_escrow_addr,\n        is_claim_disabled: config.is_claim_disabled,\n        claim_many_limit: config.claim_many_limit,\n    };\n\n    Ok(resp)\n}\n\n/// Manages contract migration.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    Err(ContractError::MigrationError {})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","escrow_fee_distributor","src","error.rs"],"content":"use cosmwasm_std::{OverflowError, StdError};\nuse thiserror::Error;\n\n/// ## Description\n/// This enum describes fee distributor contract errors!\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Exceeded account limit for the claim operation!\")]\n    ClaimLimitExceeded {},\n\n    #[error(\"Claiming is disabled!\")]\n    ClaimDisabled {},\n\n    #[error(\"Contract can't be migrated!\")]\n    MigrationError {},\n}\n\nimpl From\u003cOverflowError\u003e for ContractError {\n    fn from(o: OverflowError) -\u003e Self {\n        StdError::from(o).into()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","escrow_fee_distributor","src","lib.rs"],"content":"pub mod contract;\nmod error;\npub mod state;\nmod utils;\n\n// During development this import could be replaced with another astroport version.\n// However, in production, the astroport version should be the same for all contracts.\nuse astroport_governance::astroport;\n\n#[cfg(test)]\nmod testing;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","escrow_fee_distributor","src","state.rs"],"content":"use cosmwasm_schema::cw_serde;\n\nuse crate::astroport::common::OwnershipProposal;\n\nuse cosmwasm_std::{Addr, Uint128};\nuse cw_storage_plus::{Item, Map};\n\n/// This structure stores the main parameters for the distributor contract.\n#[cw_serde]\npub struct Config {\n    /// Address that's allowed to change contract parameters\n    pub owner: Addr,\n    /// ASTRO token address\n    pub astro_token: Addr,\n    /// vxASTRO contract address\n    pub voting_escrow_addr: Addr,\n    /// Max limit of addresses that can claim rewards in a single call\n    pub claim_many_limit: u64,\n    /// Whether reward claiming is disabled\n    pub is_claim_disabled: bool,\n}\n\n/// Stores the contract config at the given key.\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n/// Contains information about weekly distributed rewards.\npub const REWARDS_PER_WEEK: Map\u003cu64, Uint128\u003e = Map::new(\"rewards_per_week\");\n/// Contains information about the last week of reward issuance.\npub const LAST_CLAIM_PERIOD: Map\u003c\u0026Addr, u64\u003e = Map::new(\"last_claim_period\");\n/// Contains the proposal to change contract ownership.\npub const OWNERSHIP_PROPOSAL: Item\u003cOwnershipProposal\u003e = Item::new(\"ownership_proposal\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","escrow_fee_distributor","src","testing.rs"],"content":"use crate::contract::{instantiate, query};\nuse astroport_governance::escrow_fee_distributor::{ConfigResponse, InstantiateMsg, QueryMsg};\n\nuse cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};\nuse cosmwasm_std::{from_binary, Addr};\n\n#[test]\nfn proper_initialization() {\n    let mut deps = mock_dependencies();\n\n    let msg = InstantiateMsg {\n        owner: \"owner\".to_string(),\n        astro_token: \"token\".to_string(),\n        voting_escrow_addr: \"voting_escrow\".to_string(),\n        claim_many_limit: None,\n        is_claim_disabled: None,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026vec![]);\n    let _res = instantiate(deps.as_mut(), env.clone(), info, msg).unwrap();\n\n    assert_eq!(\n        from_binary::\u003cConfigResponse\u003e(\u0026query(deps.as_ref(), env, QueryMsg::Config {}).unwrap())\n            .unwrap(),\n        ConfigResponse {\n            owner: Addr::unchecked(\"owner\"),\n            astro_token: Addr::unchecked(\"token\"),\n            voting_escrow_addr: Addr::unchecked(\"voting_escrow\"),\n            claim_many_limit: 10,\n            is_claim_disabled: false\n        }\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","escrow_fee_distributor","src","utils.rs"],"content":"use std::cmp::min;\n\nuse cosmwasm_std::{\n    to_binary, Addr, CosmosMsg, DepsMut, StdError, StdResult, Storage, Uint128, WasmMsg,\n};\nuse cw20::Cw20ExecuteMsg;\n\nuse astroport_governance::voting_escrow::{\n    get_lock_info, QueryMsg as VotingQueryMsg, VotingPowerResponse, DEFAULT_PERIODS_LIMIT,\n};\n\nuse crate::error::ContractError;\nuse crate::state::{LAST_CLAIM_PERIOD, REWARDS_PER_WEEK};\n\n/// Transfer tokens to another address.\n///\n/// * **contract_addr** address of the token contract.\n///\n/// * **recipient** address of the token recipient.\n///\n/// * **amount** token amount to transfer.\npub(crate) fn transfer_token_amount(\n    contract_addr: \u0026Addr,\n    recipient: \u0026Addr,\n    amount: Uint128,\n) -\u003e Result\u003cVec\u003cCosmosMsg\u003e, ContractError\u003e {\n    let messages = if !amount.is_zero() {\n        vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: contract_addr.to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                recipient: recipient.to_string(),\n                amount,\n            })?,\n            funds: vec![],\n        })]\n    } else {\n        vec![]\n    };\n\n    Ok(messages)\n}\n\n/// Returns the amount of rewards distributed to a user for a specific period.\n///\n/// * **period** period for which we calculate the user's reward.\n///\n/// * **user_vp** user's voting power for the specified period.\n///\n/// * **total_vp** total voting power for the specified period.\npub(crate) fn calculate_reward(\n    storage: \u0026dyn Storage,\n    period: u64,\n    user_vp: Uint128,\n    total_vp: Uint128,\n) -\u003e StdResult\u003cUint128\u003e {\n    let rewards_per_week = REWARDS_PER_WEEK\n        .may_load(storage, period)?\n        .unwrap_or_default();\n\n    user_vp\n        .checked_multiply_ratio(rewards_per_week, total_vp)\n        .map_err(|e| StdError::generic_err(format!(\"{e:?}\")))\n}\n\n/// Calculates the amount of ASTRO available to claim by a specific address.\n///\n/// * **current_period** current epoch number.\n///\n/// * **account** account for which we calculate the amount of ASTRO rewards available to claim.\n///\n/// * **voting_escrow_addr** vxASTRO contract address.\n///\n/// * **max_periods** maximum number of periods to claim.\npub(crate) fn calc_claim_amount(\n    deps: DepsMut,\n    current_period: u64,\n    account: \u0026Addr,\n    voting_escrow_addr: \u0026Addr,\n    max_periods: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let user_lock_info = get_lock_info(\u0026deps.querier, voting_escrow_addr, account)?;\n\n    let mut claim_period = LAST_CLAIM_PERIOD\n        .may_load(deps.storage, account)?\n        .unwrap_or(user_lock_info.start);\n\n    let lock_end_period = user_lock_info.end;\n    let mut claim_amount: Uint128 = Default::default();\n    let max_period = min(\n        max_periods.unwrap_or(DEFAULT_PERIODS_LIMIT) + claim_period,\n        current_period,\n    );\n\n    loop {\n        // User cannot claim for the current period/\n        if claim_period \u003e= max_period {\n            break;\n        }\n\n        // User cannot claim after their max lock period\n        if claim_period \u003e lock_end_period {\n            break;\n        }\n\n        let user_voting_power: VotingPowerResponse = deps.querier.query_wasm_smart(\n            voting_escrow_addr,\n            \u0026VotingQueryMsg::UserVotingPowerAtPeriod {\n                user: account.to_string(),\n                period: claim_period,\n            },\n        )?;\n\n        let total_voting_power: VotingPowerResponse = deps.querier.query_wasm_smart(\n            voting_escrow_addr,\n            \u0026VotingQueryMsg::TotalVotingPowerAtPeriod {\n                period: claim_period,\n            },\n        )?;\n\n        if !user_voting_power.voting_power.is_zero() \u0026\u0026 !total_voting_power.voting_power.is_zero() {\n            claim_amount = claim_amount.checked_add(calculate_reward(\n                deps.storage,\n                claim_period,\n                user_voting_power.voting_power,\n                total_voting_power.voting_power,\n            )?)?;\n        }\n\n        claim_period += 1;\n    }\n\n    LAST_CLAIM_PERIOD.save(deps.storage, account, \u0026claim_period)?;\n\n    Ok(claim_amount)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","escrow_fee_distributor","tests","integration.rs"],"content":"use cosmwasm_std::testing::{mock_env, MockApi, MockStorage};\nuse cosmwasm_std::{attr, to_binary, Addr, StdResult, Timestamp, Uint128};\n\nuse astroport_governance::utils::{get_period, EPOCH_START, WEEK};\n\nuse astroport_governance::escrow_fee_distributor::{\n    ConfigResponse, Cw20HookMsg, ExecuteMsg, QueryMsg,\n};\nuse astroport_governance::voting_escrow::{\n    LockInfoResponse, QueryMsg as VotingEscrowQueryMsg, VotingPowerResponse,\n};\n\nuse astroport_tests::base::{\n    check_balance, mint, BaseAstroportTestInitMessage, BaseAstroportTestPackage, MULTIPLIER,\n};\nuse cw20::Cw20ExecuteMsg;\nuse cw_multi_test::{next_block, App, AppBuilder, BankKeeper, Executor};\n\nconst OWNER: \u0026str = \"owner\";\nconst USER1: \u0026str = \"user1\";\nconst USER2: \u0026str = \"user2\";\nconst USER3: \u0026str = \"user3\";\nconst USER4: \u0026str = \"user4\";\nconst USER5: \u0026str = \"user5\";\nconst MAKER: \u0026str = \"maker\";\n\nfn mock_app() -\u003e App {\n    let mut env = mock_env();\n    env.block.time = Timestamp::from_seconds(EPOCH_START);\n    let api = MockApi::default();\n    let bank = BankKeeper::new();\n    let storage = MockStorage::new();\n\n    AppBuilder::new()\n        .with_api(api)\n        .with_block(env.block)\n        .with_bank(bank)\n        .with_storage(storage)\n        .build(|_, _, _| {})\n}\n\nfn init_astroport_test_package(router: \u0026mut App) -\u003e StdResult\u003cBaseAstroportTestPackage\u003e {\n    let base_msg = BaseAstroportTestInitMessage {\n        owner: Addr::unchecked(OWNER),\n    };\n\n    Ok(BaseAstroportTestPackage::init_all(router, base_msg))\n}\n\n#[test]\nfn instantiation() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(OWNER);\n\n    let base_pack = init_astroport_test_package(router_ref).unwrap();\n\n    let resp: ConfigResponse = router\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026QueryMsg::Config {},\n        )\n        .unwrap();\n\n    assert_eq!(owner, resp.owner);\n    assert_eq!(base_pack.astro_token.unwrap().address, resp.astro_token);\n    assert_eq!(\n        base_pack.voting_escrow.unwrap().address,\n        resp.voting_escrow_addr\n    );\n    assert_eq!(false, resp.is_claim_disabled);\n    assert_eq!(10u64, resp.claim_many_limit);\n}\n\n#[test]\nfn test_receive_tokens() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(OWNER.clone());\n    let maker = Addr::unchecked(MAKER.clone());\n\n    let base_pack = init_astroport_test_package(router_ref).unwrap();\n\n    // Mint 1000_000_000 ASTRO for the Maker\n    mint(\n        router_ref,\n        owner.clone(),\n        base_pack.astro_token.clone().unwrap().address,\n        \u0026maker,\n        1000,\n    );\n\n    // Check if Maker's ASTRO balance is 1000_000_000\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026maker,\n        1000 * MULTIPLIER as u128,\n    );\n\n    // Check if escrow_fee_distributor ASTRO balance is 0\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        0u128,\n    );\n\n    // Try to send 100_000_000 ASTRO from Maker to distributor\n    let msg = Cw20ExecuteMsg::Send {\n        contract: base_pack\n            .escrow_fee_distributor\n            .clone()\n            .unwrap()\n            .address\n            .to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::ReceiveTokens {}).unwrap(),\n        amount: Uint128::from(100 * MULTIPLIER as u128),\n    };\n\n    router_ref\n        .execute_contract(\n            maker.clone(),\n            base_pack.astro_token.clone().unwrap().address,\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Sends 100_000_000 ASTRO from Maker to distributor for the next 5 weeks\n    for _i in 0..5 {\n        router_ref\n            .execute_contract(\n                maker.clone(),\n                base_pack.astro_token.clone().unwrap().address,\n                \u0026msg,\n                \u0026[],\n            )\n            .unwrap();\n\n        // Going to the next week\n        router_ref.update_block(next_block);\n        router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n    }\n\n    // Check if escrow_fee_distributor's ASTRO balance is equal to 600_000_000\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        600 * MULTIPLIER as u128,\n    );\n\n    // Check if Maker's ASTRO balance is equal to 400_000_000\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026maker.clone(),\n        400 * MULTIPLIER as u128,\n    );\n\n    // Checks rewards per week\n    let resp: Vec\u003cUint128\u003e = router_ref\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026QueryMsg::AvailableRewardPerWeek {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        vec![\n            Uint128::new(200_000_000),\n            Uint128::new(100_000_000),\n            Uint128::new(100_000_000),\n            Uint128::new(100_000_000),\n            Uint128::new(100_000_000),\n        ],\n        resp\n    );\n}\n\n#[test]\nfn update_config() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(OWNER.clone());\n    let user1 = Addr::unchecked(USER1.clone());\n\n    let base_pack = init_astroport_test_package(router_ref).unwrap();\n    let escrow_fee_distributor = base_pack.escrow_fee_distributor.unwrap().address;\n\n    let resp: ConfigResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\u0026escrow_fee_distributor.clone(), \u0026QueryMsg::Config {})\n        .unwrap();\n\n    assert_eq!(10u64, resp.claim_many_limit);\n    assert_eq!(false, resp.is_claim_disabled);\n\n    // Check if a random address can update the config\n    let err = router_ref\n        .execute_contract(\n            user1.clone(),\n            escrow_fee_distributor.clone(),\n            \u0026ExecuteMsg::UpdateConfig {\n                claim_many_limit: Some(20u64),\n                is_claim_disabled: Some(true),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\"Unauthorized\", err.root_cause().to_string());\n\n    // Check that the owner can update the config\n    let resp = router_ref\n        .execute_contract(\n            owner.clone(),\n            escrow_fee_distributor.clone(),\n            \u0026ExecuteMsg::UpdateConfig {\n                claim_many_limit: Some(20u64),\n                is_claim_disabled: Some(true),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    let resp_config: ConfigResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\u0026escrow_fee_distributor.clone(), \u0026QueryMsg::Config {})\n        .unwrap();\n\n    assert_eq!(20u64, resp_config.claim_many_limit);\n    assert_eq!(true, resp_config.is_claim_disabled);\n\n    assert_eq!(\n        vec![\n            attr(\"action\", \"update_config\"),\n            attr(\"is_claim_disabled\", \"true\"),\n            attr(\"claim_many_limit\", \"20\"),\n        ],\n        vec![\n            resp.events[1].attributes[1].clone(),\n            resp.events[1].attributes[2].clone(),\n            resp.events[1].attributes[3].clone(),\n        ]\n    );\n}\n\n#[test]\nfn check_if_user_exists_after_withdraw() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let user1 = Addr::unchecked(USER1.clone());\n\n    let base_pack = init_astroport_test_package(router_ref).unwrap();\n    let xastro_token = base_pack.get_staking_xastro(router_ref);\n\n    // Send 200_000_000 xASTRO tokens to user1\n    mint(\n        router_ref,\n        base_pack.staking.clone().unwrap().address,\n        xastro_token.clone(),\n        \u0026user1,\n        200,\n    );\n\n    // Create lock for user1 for WEEK\n    base_pack\n        .create_lock(router_ref, user1.clone(), WEEK, 200)\n        .unwrap();\n\n    // Going to the last week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n\n    let resp: LockInfoResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.voting_escrow.clone().unwrap().address,\n            \u0026VotingEscrowQueryMsg::LockInfo {\n                user: user1.to_string(),\n            },\n        )\n        .unwrap();\n\n    assert_eq!(Uint128::new(200_000_000), resp.amount);\n    assert_eq!(\n        get_period(router_ref.block_info().time.seconds() - WEEK).unwrap(),\n        resp.start\n    );\n    assert_eq!(\n        get_period(router_ref.block_info().time.seconds()).unwrap(),\n        resp.end\n    );\n\n    base_pack.withdraw(router_ref, user1.as_str()).unwrap();\n\n    let resp: LockInfoResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.voting_escrow.clone().unwrap().address,\n            \u0026VotingEscrowQueryMsg::LockInfo {\n                user: user1.to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(resp.amount, Uint128::zero());\n    assert_eq!(\n        resp.start,\n        get_period(router_ref.block_info().time.minus_seconds(WEEK).seconds()).unwrap()\n    );\n    assert_eq!(\n        resp.end,\n        get_period(router_ref.block_info().time.seconds()).unwrap()\n    );\n}\n\n#[test]\nfn claim_without_fee_on_distributor() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let user1 = Addr::unchecked(USER1.clone());\n    let user2 = Addr::unchecked(USER2.clone());\n\n    let base_pack = init_astroport_test_package(router_ref).unwrap();\n\n    let xastro_token = base_pack.get_staking_xastro(router_ref);\n\n    // Sets 200_000_000 xASTRO tokens to user1\n    mint(\n        router_ref,\n        base_pack.staking.clone().unwrap().address,\n        xastro_token.clone(),\n        \u0026user1,\n        200,\n    );\n\n    // Send 200_000_000 xASTRO tokens to user2\n    mint(\n        router_ref,\n        base_pack.staking.clone().unwrap().address,\n        xastro_token.clone(),\n        \u0026user2,\n        200,\n    );\n\n    // Create lock for user1 for WEEK * 104\n    base_pack\n        .create_lock(router_ref, user1.clone(), WEEK * 104, 200)\n        .unwrap();\n\n    // Create lock for user2 for WEEK * 104\n    base_pack\n        .create_lock(router_ref, user2.clone(), WEEK * 104, 200)\n        .unwrap();\n\n    // Going to the last week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK * 103));\n\n    // Try to claim fees for user1\n    router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::Claim {\n                recipient: None,\n                max_periods: None,\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Try to claim fees for user2\n    router_ref\n        .execute_contract(\n            user2.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::Claim {\n                recipient: None,\n                max_periods: None,\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Check if user1's ASTRO balance is equal to 0\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026user1,\n        0,\n    );\n\n    // Check if user2's ASTRO balance is equal to 0\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026user2,\n        0,\n    );\n}\n\n#[test]\nfn claim_max_period() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(OWNER.clone());\n    let maker = Addr::unchecked(MAKER.clone());\n    let user1 = Addr::unchecked(USER1.clone());\n    let user2 = Addr::unchecked(USER2.clone());\n\n    let base_pack = init_astroport_test_package(router_ref).unwrap();\n\n    let xastro_token = base_pack.get_staking_xastro(router_ref);\n\n    // Send 200_000_000 xASTRO tokens to user1\n    mint(\n        router_ref,\n        base_pack.staking.clone().unwrap().address,\n        xastro_token.clone(),\n        \u0026user1,\n        200,\n    );\n\n    // Send 200_000_000 xASTRO tokens to user2\n    mint(\n        router_ref,\n        base_pack.staking.clone().unwrap().address,\n        xastro_token.clone(),\n        \u0026user2,\n        200,\n    );\n\n    // Create lock for user1 for WEEK * 104\n    base_pack\n        .create_lock(router_ref, user1.clone(), WEEK * 104, 200)\n        .unwrap();\n\n    // Create lock for user2 for WEEK * 104\n    base_pack\n        .create_lock(router_ref, user2.clone(), WEEK * 104, 200)\n        .unwrap();\n\n    // Mint 100_000_000 ASTRO for the Maker\n    mint(\n        router_ref,\n        owner.clone(),\n        base_pack.astro_token.clone().unwrap().address,\n        \u0026maker,\n        100,\n    );\n\n    // Try to send 100_000_000 ASTRO from Maker to distributor for the first period\n    let msg = Cw20ExecuteMsg::Send {\n        contract: base_pack\n            .escrow_fee_distributor\n            .clone()\n            .unwrap()\n            .address\n            .to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::ReceiveTokens {}).unwrap(),\n        amount: Uint128::from(100 * MULTIPLIER as u128),\n    };\n\n    router_ref\n        .execute_contract(\n            maker.clone(),\n            base_pack.astro_token.clone().unwrap().address,\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Going to the next week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n\n    // Mint 100_000_000 ASTRO for the Maker\n    mint(\n        router_ref,\n        owner.clone(),\n        base_pack.astro_token.clone().unwrap().address,\n        \u0026maker,\n        100,\n    );\n\n    // Try to send 100_000_000 ASTRO from Maker to distributor for the second period\n    let msg = Cw20ExecuteMsg::Send {\n        contract: base_pack\n            .escrow_fee_distributor\n            .clone()\n            .unwrap()\n            .address\n            .to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::ReceiveTokens {}).unwrap(),\n        amount: Uint128::from(100 * MULTIPLIER as u128),\n    };\n\n    router_ref\n        .execute_contract(\n            maker.clone(),\n            base_pack.astro_token.clone().unwrap().address,\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Warping to the week after user's lock period ends\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK * 105));\n\n    // Check if rewards for the first and the second weeks equal 100_000_000 ASTRO\n    let resp: Vec\u003cUint128\u003e = router_ref\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026QueryMsg::AvailableRewardPerWeek {\n                start_after: None,\n                limit: Some(2),\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        vec![Uint128::new(100_000_000), Uint128::new(100_000_000)],\n        resp\n    );\n\n    // Claim fees for max period for user1(firstly 1 period)\n    router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::Claim {\n                recipient: None,\n                max_periods: Some(1),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026user1,\n        50_000_000,\n    );\n\n    router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::Claim {\n                recipient: None,\n                max_periods: None,\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Claim fees for max period for user2\n    router_ref\n        .execute_contract(\n            user2.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::Claim {\n                recipient: None,\n                max_periods: None,\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Check if user1's ASTRO balance is equal to 100_000_000 ASTRO\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026user1,\n        100_000_000,\n    );\n\n    // Check if user2's ASTRO balance equal to 100_000_000 ASTRO\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026user2,\n        100_000_000,\n    );\n\n    // Check if distributor's ASTRO balance equal to 0\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        0,\n    );\n}\n\n#[test]\nfn claim_multiple_users() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(OWNER.clone());\n    let maker = Addr::unchecked(MAKER.clone());\n    let user1 = Addr::unchecked(USER1.clone());\n    let user2 = Addr::unchecked(USER2.clone());\n    let user3 = Addr::unchecked(USER3.clone());\n    let user4 = Addr::unchecked(USER4.clone());\n    let user5 = Addr::unchecked(USER5.clone());\n\n    let base_pack = init_astroport_test_package(router_ref).unwrap();\n\n    let xastro_token = base_pack.get_staking_xastro(router_ref);\n\n    for user in [user1.clone(), user2.clone(), user3.clone(), user4.clone()] {\n        // Sends 200_000_000 xASTRO tokens to users\n        mint(\n            router_ref,\n            base_pack.staking.clone().unwrap().address,\n            xastro_token.clone(),\n            \u0026user,\n            200,\n        );\n\n        // Checks if user's xASTRO balance is equal to 200 * 1000_000 ASTRO\n        check_balance(\n            router_ref,\n            \u0026xastro_token.clone(),\n            \u0026user,\n            200 * MULTIPLIER as u128,\n        );\n\n        // Create lock for user for WEEK * 2\n        base_pack\n            .create_lock(router_ref, user.clone(), WEEK * 2, 100)\n            .unwrap();\n    }\n\n    mint(\n        router_ref,\n        owner.clone(),\n        base_pack.astro_token.clone().unwrap().address,\n        \u0026maker,\n        1000,\n    );\n\n    // Sends 100_000_000 ASTRO from Maker to distributor for the first period\n    let msg = Cw20ExecuteMsg::Send {\n        contract: base_pack\n            .escrow_fee_distributor\n            .clone()\n            .unwrap()\n            .address\n            .to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::ReceiveTokens {}).unwrap(),\n        amount: Uint128::from(100 * MULTIPLIER as u128),\n    };\n\n    router_ref\n        .execute_contract(\n            maker.clone(),\n            base_pack.astro_token.clone().unwrap().address,\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Checks if distributor's ASTRO balance is equal to 100_000_000 ASTRO\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        100 * MULTIPLIER as u128,\n    );\n\n    // Check if rewards per week are set to 100_000_000 ASTRO\n    let resp: Vec\u003cUint128\u003e = router_ref\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026QueryMsg::AvailableRewardPerWeek {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n    assert_eq!(vec![Uint128::new(100_000_000)], resp);\n\n    // Check if weekly voting supply can be queried\n    let resp: VotingPowerResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.voting_escrow.clone().unwrap().address,\n            \u0026VotingEscrowQueryMsg::TotalVotingPowerAt {\n                time: router_ref.block_info().time.seconds(),\n            },\n        )\n        .unwrap();\n    assert_eq!(Uint128::new(411_538_456), resp.voting_power);\n\n    // Go to the next week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n\n    // Perform an operation for an unlimited number of users\n    let err = router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::ClaimMany {\n                receivers: vec![\n                    user1.to_string(),\n                    user2.to_string(),\n                    user3.to_string(),\n                    user4.to_string(),\n                    Addr::unchecked(\"user5\").to_string(),\n                    Addr::unchecked(\"user6\").to_string(),\n                    Addr::unchecked(\"user7\").to_string(),\n                    Addr::unchecked(\"user8\").to_string(),\n                    Addr::unchecked(\"user9\").to_string(),\n                    Addr::unchecked(\"user10\").to_string(),\n                    Addr::unchecked(\"user11\").to_string(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        \"Exceeded account limit for the claim operation!\",\n        err.root_cause().to_string()\n    );\n\n    mint(\n        router_ref,\n        base_pack.staking.clone().unwrap().address,\n        xastro_token.clone(),\n        \u0026user5,\n        200,\n    );\n\n    // Check if user5's xASTRO balance is equal to 200 * 1000_000\n    check_balance(\n        router_ref,\n        \u0026xastro_token.clone(),\n        \u0026user5,\n        200 * MULTIPLIER as u128,\n    );\n\n    // Create lock for user5 for WEEK * 2\n    base_pack\n        .create_lock(router_ref, user5.clone(), WEEK * 2, 100)\n        .unwrap();\n\n    // Claim for all users\n    router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::ClaimMany {\n                receivers: vec![\n                    user1.to_string(),\n                    user2.to_string(),\n                    user3.to_string(),\n                    user4.to_string(),\n                    user5.to_string(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Checks if user's ASTRO balance is equal to 100 / 4 = 25 * 1_000_000\n    for user in [user1.clone(), user2.clone(), user3.clone(), user4.clone()] {\n        check_balance(\n            router_ref,\n            \u0026base_pack.astro_token.clone().unwrap().address,\n            \u0026user,\n            25 * MULTIPLIER as u128,\n        );\n    }\n\n    // Checks if user5's ASTRO balance is equal to 0. Cannot claim for the current period\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026user5,\n        0,\n    );\n\n    // Check if distributor's ASTRO balance equal to 0\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        0,\n    );\n\n    // Going to next week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n\n    // Sends 900_000_000 ASTRO from the Maker to the distributor for the third period\n    let msg = Cw20ExecuteMsg::Send {\n        contract: base_pack\n            .escrow_fee_distributor\n            .clone()\n            .unwrap()\n            .address\n            .to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::ReceiveTokens {}).unwrap(),\n        amount: Uint128::from(900 * MULTIPLIER as u128),\n    };\n\n    router_ref\n        .execute_contract(\n            maker.clone(),\n            base_pack.astro_token.clone().unwrap().address,\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Check if rewards per week are set to 900_000_000 ASTRO\n    let resp: Vec\u003cUint128\u003e = router_ref\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026QueryMsg::AvailableRewardPerWeek {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        vec![Uint128::new(100_000_000), Uint128::new(900_000_000),],\n        resp\n    );\n\n    // Try to claim for all users for the current period\n    router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::ClaimMany {\n                receivers: vec![\n                    user1.to_string(),\n                    user2.to_string(),\n                    user3.to_string(),\n                    user4.to_string(),\n                    user5.to_string(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Checks if the user's ASTRO token balance is still equal to 100 / 4 = 25 * 1_000_000\n    for user in [user1.clone(), user2.clone(), user3.clone(), user4.clone()] {\n        check_balance(\n            router_ref,\n            \u0026base_pack.astro_token.clone().unwrap().address,\n            \u0026user,\n            25 * MULTIPLIER as u128,\n        );\n    }\n\n    // Check if user5's ASTRO balance is 0 for the first lock week\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026user5,\n        0,\n    );\n\n    // Check if the distributor's ASTRO balance is still equal to 900_000_000\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        900_000_000,\n    );\n\n    // Going to next week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n\n    // Try to claim for all users\n    router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::ClaimMany {\n                receivers: vec![\n                    user1.to_string(),\n                    user2.to_string(),\n                    user3.to_string(),\n                    user4.to_string(),\n                    user5.to_string(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Checks if the user's ASTRO balance is still equal to 25 * 100_000_000.\n    for user in [user1.clone(), user2.clone(), user3.clone(), user4.clone()] {\n        check_balance(\n            router_ref,\n            \u0026base_pack.astro_token.clone().unwrap().address,\n            \u0026user,\n            25 * MULTIPLIER as u128,\n        );\n    }\n\n    // Checks if user5's ASTRO balance equal to 900_000_000 for the second week of lock\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026user5,\n        900_000_000,\n    );\n\n    // Check if distributor's ASTRO balance still equal to 0\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        0,\n    );\n}\n\n#[test]\nfn is_claim_enabled() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(OWNER.clone());\n    let maker = Addr::unchecked(MAKER.clone());\n    let user1 = Addr::unchecked(USER1.clone());\n    let user2 = Addr::unchecked(USER2.clone());\n\n    let base_pack = init_astroport_test_package(router_ref).unwrap();\n\n    let xastro_token = base_pack.get_staking_xastro(router_ref);\n\n    // Sends 200_000_000 xASTRO tokens to users\n    for user in [user1.clone(), user2.clone()] {\n        mint(\n            router_ref,\n            base_pack.staking.clone().unwrap().address,\n            xastro_token.clone(),\n            \u0026user,\n            200,\n        );\n\n        // Checks if user's xASTRO token balance is equal to 200 * 1000_000\n        check_balance(\n            router_ref,\n            \u0026xastro_token.clone(),\n            \u0026user,\n            200 * MULTIPLIER as u128,\n        );\n\n        // Create a lock for user for WEEK * 3\n        base_pack\n            .create_lock(router_ref, user.clone(), WEEK * 3, 100)\n            .unwrap();\n    }\n\n    // Send 1000_000_000 ASTRO tokens to the Maker\n    mint(\n        router_ref,\n        owner.clone(),\n        base_pack.astro_token.clone().unwrap().address,\n        \u0026maker,\n        1000,\n    );\n\n    // Send 100_000_000 ASTRO from the Maker to the distributor for the first period\n    let msg = Cw20ExecuteMsg::Send {\n        contract: base_pack\n            .escrow_fee_distributor\n            .clone()\n            .unwrap()\n            .address\n            .to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::ReceiveTokens {}).unwrap(),\n        amount: Uint128::from(100 * MULTIPLIER as u128),\n    };\n\n    router_ref\n        .execute_contract(\n            maker.clone(),\n            base_pack.astro_token.clone().unwrap().address,\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Check if distributor's ASTRO balance is equal to 100_000_000 ASTRO\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        100 * MULTIPLIER as u128,\n    );\n\n    // Checl if rewards are set to 100_000_000 ASTRO\n    let resp: Vec\u003cUint128\u003e = router_ref\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026QueryMsg::AvailableRewardPerWeek {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n    assert_eq!(vec![Uint128::new(100_000_000)], resp);\n\n    // Going to the next week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n\n    // Disable claiming\n    router_ref\n        .execute_contract(\n            owner.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::UpdateConfig {\n                claim_many_limit: None,\n                is_claim_disabled: Some(true),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Try to claim fees for all users for the first week\n    let err = router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::ClaimMany {\n                receivers: vec![user1.to_string(), user2.to_string()],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\"Claiming is disabled!\", err.root_cause().to_string());\n\n    // Send 100_000_000 ASTRO from the Maker to the distributor for the first period\n    let msg = Cw20ExecuteMsg::Send {\n        contract: base_pack\n            .escrow_fee_distributor\n            .clone()\n            .unwrap()\n            .address\n            .to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::ReceiveTokens {}).unwrap(),\n        amount: Uint128::from(100 * MULTIPLIER as u128),\n    };\n\n    router_ref\n        .execute_contract(\n            maker.clone(),\n            base_pack.astro_token.clone().unwrap().address,\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Going to the next week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n\n    // Try to claim fees for all users\n    let err = router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::ClaimMany {\n                receivers: vec![user1.to_string(), user2.to_string()],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\"Claiming is disabled!\", err.root_cause().to_string());\n\n    // Going to the next week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n\n    // Enable claiming\n    router_ref\n        .execute_contract(\n            owner.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::UpdateConfig {\n                claim_many_limit: None,\n                is_claim_disabled: Some(false),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Try to claim fees for all users\n    router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::ClaimMany {\n                receivers: vec![user1.to_string(), user2.to_string()],\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Check if the user's ASTRO token balance is equal to 25 * 1_000_000\n    for user in [user1.clone(), user2.clone()] {\n        check_balance(\n            router_ref,\n            \u0026base_pack.astro_token.clone().unwrap().address,\n            \u0026user,\n            100 * MULTIPLIER as u128,\n        );\n    }\n\n    // Check if the distributor's ASTRO balance is 0\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        0,\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","generator_controller","src","bps.rs"],"content":"use crate::error::ContractError;\nuse cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Decimal, Fraction, StdError, Uint128};\nuse std::convert::{TryFrom, TryInto};\nuse std::ops::Mul;\n\n/// BasicPoints struct implementation. BasicPoints value is within [0, 10000] interval.\n/// Technically BasicPoints is wrapper over [`u16`] with additional limit checks and\n/// several implementations of math functions so BasicPoints object\n/// can be used in formulas along with [`Uint128`] and [`Decimal`].\n#[cw_serde]\n#[derive(Default, Copy)]\npub struct BasicPoints(u16);\n\nimpl BasicPoints {\n    pub const MAX: u16 = 10000;\n\n    pub fn checked_add(self, rhs: Self) -\u003e Result\u003cSelf, ContractError\u003e {\n        let next_value = self.0 + rhs.0;\n        if next_value \u003e Self::MAX {\n            Err(ContractError::BPSLimitError {})\n        } else {\n            Ok(Self(next_value))\n        }\n    }\n\n    pub fn from_ratio(numerator: Uint128, denominator: Uint128) -\u003e Result\u003cSelf, ContractError\u003e {\n        numerator\n            .checked_multiply_ratio(Self::MAX, denominator)\n            .map_err(|_| StdError::generic_err(\"Checked multiply ratio error!\"))?\n            .u128()\n            .try_into()\n    }\n}\n\nimpl TryFrom\u003cu16\u003e for BasicPoints {\n    type Error = ContractError;\n\n    fn try_from(value: u16) -\u003e Result\u003cSelf, Self::Error\u003e {\n        if value \u003c= Self::MAX {\n            Ok(Self(value))\n        } else {\n            Err(ContractError::BPSConverstionError(value as u128))\n        }\n    }\n}\n\nimpl TryFrom\u003cu128\u003e for BasicPoints {\n    type Error = ContractError;\n\n    fn try_from(value: u128) -\u003e Result\u003cSelf, Self::Error\u003e {\n        if value \u003c= Self::MAX as u128 {\n            Ok(Self(value as u16))\n        } else {\n            Err(ContractError::BPSConverstionError(value))\n        }\n    }\n}\n\nimpl From\u003cBasicPoints\u003e for u16 {\n    fn from(value: BasicPoints) -\u003e Self {\n        value.0\n    }\n}\n\nimpl From\u003cBasicPoints\u003e for Uint128 {\n    fn from(value: BasicPoints) -\u003e Self {\n        Uint128::from(u16::from(value))\n    }\n}\n\nimpl Mul\u003cUint128\u003e for BasicPoints {\n    type Output = Uint128;\n\n    fn mul(self, rhs: Uint128) -\u003e Self::Output {\n        rhs.multiply_ratio(self.0, Self::MAX)\n    }\n}\n\nimpl Mul\u003cDecimal\u003e for BasicPoints {\n    type Output = Decimal;\n\n    fn mul(self, rhs: Decimal) -\u003e Self::Output {\n        Decimal::from_ratio(\n            rhs.numerator() * Uint128::from(self.0),\n            rhs.denominator() * Uint128::from(Self::MAX),\n        )\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","generator_controller","src","contract.rs"],"content":"use std::collections::HashSet;\nuse std::convert::TryInto;\n\nuse crate::astroport;\nuse astroport::common::{claim_ownership, drop_ownership_proposal, propose_new_owner};\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    to_binary, Addr, Binary, CosmosMsg, Decimal, Deps, DepsMut, Env, Fraction, MessageInfo, Order,\n    Response, StdError, StdResult, Uint128, WasmMsg,\n};\nuse cw2::set_contract_version;\nuse itertools::Itertools;\n\nuse astroport_governance::generator_controller::{\n    ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg, UserInfoResponse, VOTERS_MAX_LIMIT,\n};\nuse astroport_governance::utils::{calc_voting_power, get_period, WEEK};\nuse astroport_governance::voting_escrow::QueryMsg::CheckVotersAreBlacklisted;\nuse astroport_governance::voting_escrow::{\n    get_lock_info, get_voting_power, BlacklistedVotersResponse,\n};\n\nuse crate::bps::BasicPoints;\nuse crate::error::ContractError;\nuse crate::state::{\n    Config, TuneInfo, UserInfo, VotedPoolInfo, CONFIG, OWNERSHIP_PROPOSAL, POOLS, TUNE_INFO,\n    USER_INFO,\n};\n\nuse crate::utils::{\n    cancel_user_changes, check_duplicated, filter_pools, get_pool_info, update_pool_info,\n    validate_pool, validate_pools_limit, vote_for_pool,\n};\n\n/// Contract name that is used for migration.\nconst CONTRACT_NAME: \u0026str = \"generator-controller\";\n/// Contract version that is used for migration.\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\nconst DAY: u64 = 86400;\n/// The user can only vote once every 10 days\nconst VOTE_COOLDOWN: u64 = DAY * 10;\n/// It is possible to tune pools once every 14 days\nconst TUNE_COOLDOWN: u64 = WEEK * 2;\n\ntype ExecuteResult = Result\u003cResponse, ContractError\u003e;\n\n/// Creates a new contract with the specified parameters in the [`InstantiateMsg`].\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e ExecuteResult {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    CONFIG.save(\n        deps.storage,\n        \u0026Config {\n            owner: deps.api.addr_validate(\u0026msg.owner)?,\n            escrow_addr: deps.api.addr_validate(\u0026msg.escrow_addr)?,\n            generator_addr: deps.api.addr_validate(\u0026msg.generator_addr)?,\n            factory_addr: deps.api.addr_validate(\u0026msg.factory_addr)?,\n            pools_limit: validate_pools_limit(msg.pools_limit)?,\n            blacklisted_voters_limit: None,\n            main_pool: None,\n            main_pool_min_alloc: Decimal::zero(),\n            whitelisted_pools: vec![],\n        },\n    )?;\n\n    // Set tune_ts just for safety so the first tuning could happen in 2 weeks\n    TUNE_INFO.save(\n        deps.storage,\n        \u0026TuneInfo {\n            tune_ts: env.block.time.seconds(),\n            pool_alloc_points: vec![],\n        },\n    )?;\n\n    Ok(Response::default())\n}\n\n/// Exposes all the execute functions available in the contract.\n///\n/// ## Execute messages\n/// * **ExecuteMsg::KickBlacklistedVoters { blacklisted_voters }** Removes all votes applied by\n/// blacklisted voters\n///\n/// * **ExecuteMsg::Vote { votes }** Casts votes for pools\n///\n/// * **ExecuteMsg::TunePools** Launches pool tuning\n///\n/// * **ExecuteMsg::ChangePoolsLimit { limit }** Changes the number of pools which are eligible\n/// to receive allocation points\n///\n/// * **ExecuteMsg::UpdateConfig { blacklisted_voters_limit }** Changes the number of blacklisted\n/// voters that can be kicked at once\n///\n/// * **ExecuteMsg::UpdateWhitelist { add, remove }** Adds or removes lp tokens which are eligible\n/// to receive votes.\n///\n/// * **ExecuteMsg::ProposeNewOwner { owner, expires_in }** Creates a new request to change\n/// contract ownership.\n///\n/// * **ExecuteMsg::DropOwnershipProposal {}** Removes a request to change contract ownership.\n///\n/// * **ExecuteMsg::ClaimOwnership {}** Claims contract ownership.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -\u003e ExecuteResult {\n    match msg {\n        ExecuteMsg::KickBlacklistedVoters { blacklisted_voters } =\u003e {\n            kick_blacklisted_voters(deps, env, blacklisted_voters)\n        }\n        ExecuteMsg::Vote { votes } =\u003e handle_vote(deps, env, info, votes),\n        ExecuteMsg::TunePools {} =\u003e tune_pools(deps, env),\n        ExecuteMsg::ChangePoolsLimit { limit } =\u003e change_pools_limit(deps, info, limit),\n        ExecuteMsg::UpdateConfig {\n            blacklisted_voters_limit,\n            main_pool,\n            main_pool_min_alloc,\n            remove_main_pool,\n        } =\u003e update_config(\n            deps,\n            info,\n            blacklisted_voters_limit,\n            main_pool,\n            main_pool_min_alloc,\n            remove_main_pool,\n        ),\n        ExecuteMsg::UpdateWhitelist { add, remove } =\u003e update_whitelist(deps, info, add, remove),\n        ExecuteMsg::ProposeNewOwner {\n            new_owner,\n            expires_in,\n        } =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n\n            propose_new_owner(\n                deps,\n                info,\n                env,\n                new_owner,\n                expires_in,\n                config.owner,\n                OWNERSHIP_PROPOSAL,\n            )\n            .map_err(Into::into)\n        }\n        ExecuteMsg::DropOwnershipProposal {} =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n\n            drop_ownership_proposal(deps, info, config.owner, OWNERSHIP_PROPOSAL)\n                .map_err(Into::into)\n        }\n        ExecuteMsg::ClaimOwnership {} =\u003e {\n            claim_ownership(deps, info, env, OWNERSHIP_PROPOSAL, |deps, new_owner| {\n                CONFIG\n                    .update::\u003c_, StdError\u003e(deps.storage, |mut v| {\n                        v.owner = new_owner;\n                        Ok(v)\n                    })\n                    .map(|_| ())\n            })\n            .map_err(Into::into)\n        }\n    }\n}\n\n/// Adds or removes lp tokens which are eligible to receive votes.\n/// Returns a [`ContractError`] on failure.\nfn update_whitelist(\n    deps: DepsMut,\n    info: MessageInfo,\n    add: Option\u003cVec\u003cString\u003e\u003e,\n    remove: Option\u003cVec\u003cString\u003e\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut cfg = CONFIG.load(deps.storage)?;\n\n    // Permission check\n    if info.sender != cfg.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    // Remove old LP tokens\n    if let Some(remove_lp_tokens) = remove {\n        cfg.whitelisted_pools\n            .retain(|pool| !remove_lp_tokens.contains(\u0026pool.to_string()));\n    }\n\n    // Add new lp tokens\n    if let Some(add_lp_tokens) = add {\n        cfg.whitelisted_pools.append(\n            \u0026mut add_lp_tokens\n                .into_iter()\n                .map(|lp_token| {\n                    let lp_token_addr = deps.api.addr_validate(lp_token.as_str())?;\n                    validate_pool(deps.as_ref(), \u0026cfg, \u0026lp_token_addr)?;\n                    Ok(lp_token_addr)\n                })\n                .collect::\u003cResult\u003cVec\u003c_\u003e, ContractError\u003e\u003e()?,\n        );\n        check_duplicated(\u0026cfg.whitelisted_pools).map_err(|_|\n            ContractError::Std(StdError::generic_err(\"The resulting whitelist contains duplicated pools. It's either provided 'add' list contains duplicated pools or some of the added pools are already whitelisted.\")))?;\n    }\n\n    CONFIG.save(deps.storage, \u0026cfg)?;\n    Ok(Response::default().add_attribute(\"action\", \"update_whitelist\"))\n}\n\n/// This function removes all votes applied by blacklisted voters.\n///\n/// * **holders** list with blacklisted holders whose votes will be removed.\nfn kick_blacklisted_voters(deps: DepsMut, env: Env, voters: Vec\u003cString\u003e) -\u003e ExecuteResult {\n    let block_period = get_period(env.block.time.seconds())?;\n    let config = CONFIG.load(deps.storage)?;\n\n    if voters.len() \u003e config.blacklisted_voters_limit.unwrap_or(VOTERS_MAX_LIMIT) as usize {\n        return Err(ContractError::KickVotersLimitExceeded {});\n    }\n\n    // Check duplicated voters\n    let addrs_set = voters.iter().collect::\u003cHashSet\u003c_\u003e\u003e();\n    if voters.len() != addrs_set.len() {\n        return Err(ContractError::DuplicatedVoters {});\n    }\n\n    // Check if voters are blacklisted\n    let res: BlacklistedVotersResponse = deps.querier.query_wasm_smart(\n        config.escrow_addr,\n        \u0026CheckVotersAreBlacklisted {\n            voters: voters.clone(),\n        },\n    )?;\n\n    if !res.eq(\u0026BlacklistedVotersResponse::VotersBlacklisted {}) {\n        return Err(ContractError::Std(StdError::generic_err(res.to_string())));\n    }\n\n    for voter in voters {\n        let voter_addr = deps.api.addr_validate(\u0026voter)?;\n        if let Some(user_info) = USER_INFO.may_load(deps.storage, \u0026voter_addr)? {\n            if user_info.lock_end \u003e block_period {\n                let user_last_vote_period = get_period(user_info.vote_ts)?;\n                // Calculate voting power before changes\n                let old_vp_at_period = calc_voting_power(\n                    user_info.slope,\n                    user_info.voting_power,\n                    user_last_vote_period,\n                    block_period,\n                );\n\n                // Cancel changes applied by previous votes\n                user_info.votes.iter().try_for_each(|(pool_addr, bps)| {\n                    cancel_user_changes(\n                        deps.storage,\n                        block_period + 1,\n                        pool_addr,\n                        *bps,\n                        old_vp_at_period,\n                        user_info.slope,\n                        user_info.lock_end,\n                    )\n                })?;\n\n                let user_info = UserInfo {\n                    vote_ts: env.block.time.seconds(),\n                    lock_end: block_period,\n                    ..Default::default()\n                };\n\n                USER_INFO.save(deps.storage, \u0026voter_addr, \u0026user_info)?;\n            }\n        }\n    }\n\n    Ok(Response::new().add_attribute(\"action\", \"kick_holders\"))\n}\n\n/// The function checks that:\n/// * the user voting power is \u003e 0,\n/// * user didn't vote for last 10 days,\n/// * all pool addresses are valid LP token addresses,\n/// * 'votes' vector doesn't contain duplicated pool addresses,\n/// * sum of all BPS values \u003c= 10000.\n///\n/// The function cancels changes applied by previous votes and apply new votes for the next period.\n/// New vote parameters are saved in [`USER_INFO`].\n///\n/// The function returns [`Response`] in case of success or [`ContractError`] in case of errors.\n///\n/// * **votes** is a vector of pairs ([`String`], [`u16`]).\n/// Tuple consists of pool address and percentage of user's voting power for a given pool.\n/// Percentage should be in BPS form.\nfn handle_vote(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    votes: Vec\u003c(String, u16)\u003e,\n) -\u003e ExecuteResult {\n    let user = info.sender;\n    let block_period = get_period(env.block.time.seconds())?;\n    let config = CONFIG.load(deps.storage)?;\n    let user_vp = get_voting_power(\u0026deps.querier, \u0026config.escrow_addr, \u0026user)?;\n\n    if user_vp.is_zero() {\n        return Err(ContractError::ZeroVotingPower {});\n    }\n\n    if config.whitelisted_pools.is_empty() {\n        return Err(ContractError::WhitelistEmpty {});\n    }\n\n    let user_info = USER_INFO.may_load(deps.storage, \u0026user)?.unwrap_or_default();\n    // Does the user eligible to vote again?\n    if env.block.time.seconds() - user_info.vote_ts \u003c VOTE_COOLDOWN {\n        return Err(ContractError::CooldownError(VOTE_COOLDOWN / DAY));\n    }\n\n    check_duplicated(\n        \u0026votes\n            .iter()\n            .map(|vote| {\n                let (lp_token, _) = vote;\n                Addr::unchecked(lp_token)\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e(),\n    )?;\n\n    // Validating addrs and bps\n    let votes = votes\n        .into_iter()\n        .map(|(addr, bps)| {\n            let pool = deps.api.addr_validate(\u0026addr)?;\n\n            // Voting for the main pool is prohibited\n            if let Some(main_pool) = \u0026config.main_pool {\n                if pool == main_pool {\n                    return Err(ContractError::MainPoolVoteOrWhitelistingProhibited(\n                        main_pool.to_string(),\n                    ));\n                }\n            }\n            if !config.whitelisted_pools.contains(\u0026pool) {\n                return Err(ContractError::PoolIsNotWhitelisted(pool.to_string()));\n            }\n\n            validate_pool(deps.as_ref(), \u0026config, \u0026pool)?;\n\n            let bps: BasicPoints = bps.try_into()?;\n            Ok((pool, bps))\n        })\n        .collect::\u003cResult\u003cVec\u003c_\u003e, ContractError\u003e\u003e()?;\n\n    // Check the bps sum is within the limit\n    votes\n        .iter()\n        .try_fold(BasicPoints::default(), |acc, (_, bps)| {\n            acc.checked_add(*bps)\n        })?;\n\n    if user_info.lock_end \u003e block_period {\n        let user_last_vote_period = get_period(user_info.vote_ts).unwrap_or(block_period);\n        // Calculate voting power before changes\n        let old_vp_at_period = calc_voting_power(\n            user_info.slope,\n            user_info.voting_power,\n            user_last_vote_period,\n            block_period,\n        );\n\n        // Cancel changes applied by previous votes\n        user_info.votes.iter().try_for_each(|(pool_addr, bps)| {\n            cancel_user_changes(\n                deps.storage,\n                block_period + 1,\n                pool_addr,\n                *bps,\n                old_vp_at_period,\n                user_info.slope,\n                user_info.lock_end,\n            )\n        })?;\n    }\n\n    let ve_lock_info = get_lock_info(\u0026deps.querier, \u0026config.escrow_addr, \u0026user)?;\n\n    // Votes are applied to the next period\n    votes.iter().try_for_each(|(pool_addr, bps)| {\n        vote_for_pool(\n            deps.storage,\n            block_period + 1,\n            pool_addr,\n            *bps,\n            user_vp,\n            ve_lock_info.slope,\n            ve_lock_info.end,\n        )\n    })?;\n\n    let user_info = UserInfo {\n        vote_ts: env.block.time.seconds(),\n        voting_power: user_vp,\n        slope: ve_lock_info.slope,\n        lock_end: ve_lock_info.end,\n        votes,\n    };\n\n    USER_INFO.save(deps.storage, \u0026user, \u0026user_info)?;\n\n    Ok(Response::new().add_attribute(\"action\", \"vote\"))\n}\n\n/// The function checks that the last pools tuning happened \u003e= 14 days ago.\n/// Then it calculates voting power for each pool at the current period, filters all pools which\n/// are not eligible to receive allocation points,\n/// takes top X pools by voting power, where X is 'config.pools_limit', calculates allocation points\n/// for these pools and applies allocation points in generator contract.\nfn tune_pools(deps: DepsMut, env: Env) -\u003e ExecuteResult {\n    let mut tune_info = TUNE_INFO.load(deps.storage)?;\n    let config = CONFIG.load(deps.storage)?;\n    let block_period = get_period(env.block.time.seconds())?;\n\n    if env.block.time.seconds() - tune_info.tune_ts \u003c TUNE_COOLDOWN {\n        return Err(ContractError::CooldownError(TUNE_COOLDOWN / DAY));\n    }\n\n    let pool_votes: Vec\u003c_\u003e = POOLS\n        .keys(deps.as_ref().storage, None, None, Order::Ascending)\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .into_iter()\n        .map(|pool_addr| {\n            let pool_addr = pool_addr?;\n\n            let pool_info = update_pool_info(deps.storage, block_period, \u0026pool_addr, None)?;\n            // Remove pools with zero voting power so we won't iterate over them in future\n            if pool_info.vxastro_amount.is_zero() {\n                POOLS.remove(deps.storage, \u0026pool_addr)\n            }\n            Ok((pool_addr, pool_info.vxastro_amount))\n        })\n        .collect::\u003cStdResult\u003cVec\u003c_\u003e\u003e\u003e()?\n        .into_iter()\n        .filter(|(_, vxastro_amount)| !vxastro_amount.is_zero())\n        .sorted_by(|(_, a), (_, b)| b.cmp(a)) // Sort in descending order\n        .collect();\n\n    tune_info.pool_alloc_points = filter_pools(\n        \u0026deps.querier,\n        \u0026config.generator_addr,\n        \u0026config.factory_addr,\n        pool_votes,\n        config.pools_limit + 1, // +1 additional pool if we will need to remove the main pool\n    )?;\n\n    // Set allocation points for the main pool\n    match config.main_pool {\n        Some(main_pool) if !config.main_pool_min_alloc.is_zero() =\u003e {\n            // Main pool may appear in the pool list thus we need to eliminate its contribution in the total VP.\n            tune_info\n                .pool_alloc_points\n                .retain(|(pool, _)| pool != \u0026main_pool.to_string());\n            // If there is no main pool in the filtered list then we need to remove additional pool\n            tune_info.pool_alloc_points = tune_info\n                .pool_alloc_points\n                .iter()\n                .take(config.pools_limit as usize)\n                .cloned()\n                .collect();\n\n            let total_vp: Uint128 = tune_info\n                .pool_alloc_points\n                .iter()\n                .fold(Uint128::zero(), |acc, (_, vp)| acc + vp);\n            // Calculate main pool contribution.\n            // Example (30% for the main pool): VP + x = y, x = 0.3y =\u003e y = VP/0.7  =\u003e x = 0.3 * VP / 0.7,\n            // where VP - total VP, x - main pool's contribution, y - new total VP.\n            // x = 0.3 * VP * (1-0.3)^(-1)\n            let main_pool_contribution = config.main_pool_min_alloc\n                * total_vp\n                * (Decimal::one() - config.main_pool_min_alloc).inv().unwrap();\n            tune_info\n                .pool_alloc_points\n                .push((main_pool.to_string(), main_pool_contribution))\n        }\n        _ =\u003e {\n            // there is no main pool or min alloc is 0%\n            tune_info.pool_alloc_points = tune_info\n                .pool_alloc_points\n                .iter()\n                .take(config.pools_limit as usize)\n                .cloned()\n                .collect();\n        }\n    }\n\n    if tune_info.pool_alloc_points.is_empty() {\n        return Err(ContractError::TuneNoPools {});\n    }\n\n    tune_info.tune_ts = env.block.time.seconds();\n    TUNE_INFO.save(deps.storage, \u0026tune_info)?;\n\n    // Set new alloc points\n    let setup_pools_msg = CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: config.generator_addr.to_string(),\n        msg: to_binary(\u0026astroport::generator::ExecuteMsg::SetupPools {\n            pools: tune_info.pool_alloc_points,\n        })?,\n        funds: vec![],\n    });\n\n    Ok(Response::new()\n        .add_message(setup_pools_msg)\n        .add_attribute(\"action\", \"tune_pools\"))\n}\n\n/// Only contract owner can call this function.  \n/// The function sets a new limit of blacklisted voters that can be kicked at once.\n///\n/// * **blacklisted_voters_limit** is a new limit of blacklisted voters which can be kicked at once\n///\n/// * **main_pool** is a main pool address\n///\n/// * **main_pool_min_alloc** is a minimum percentage of ASTRO emissions that this pool should get every block\n///\n/// * **remove_main_pool** should the main pool be removed or not\nfn update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    blacklisted_voters_limit: Option\u003cu32\u003e,\n    main_pool: Option\u003cString\u003e,\n    main_pool_min_alloc: Option\u003cDecimal\u003e,\n    remove_main_pool: Option\u003cbool\u003e,\n) -\u003e ExecuteResult {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(blacklisted_voters_limit) = blacklisted_voters_limit {\n        config.blacklisted_voters_limit = Some(blacklisted_voters_limit);\n    }\n\n    if let Some(main_pool_min_alloc) = main_pool_min_alloc {\n        if main_pool_min_alloc == Decimal::zero() || main_pool_min_alloc \u003e= Decimal::one() {\n            return Err(ContractError::MainPoolMinAllocFailed {});\n        }\n        config.main_pool_min_alloc = main_pool_min_alloc;\n    }\n\n    if let Some(main_pool) = main_pool {\n        if config.main_pool_min_alloc.is_zero() {\n            return Err(StdError::generic_err(\"Main pool min alloc can not be zero\").into());\n        }\n        config.main_pool = Some(deps.api.addr_validate(\u0026main_pool)?);\n    }\n\n    if let Some(remove_main_pool) = remove_main_pool {\n        if remove_main_pool {\n            config.main_pool = None;\n        }\n    }\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::default().add_attribute(\"action\", \"update_config\"))\n}\n\n/// Only contract owner can call this function.\n/// The function sets new limit of pools which are eligible to receive allocation points.\n///\n/// * **limit** is a new limit of pools which are eligible to receive allocation points.\nfn change_pools_limit(deps: DepsMut, info: MessageInfo, limit: u64) -\u003e ExecuteResult {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    config.pools_limit = validate_pools_limit(limit)?;\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::default().add_attribute(\"action\", \"change_pools_limit\"))\n}\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::UserInfo { user }** Fetch user information\n///\n/// * **QueryMsg::TuneInfo** Fetch last tuning information\n///\n/// * **QueryMsg::Config** Fetch contract config\n///\n/// * **QueryMsg::PoolInfo { pool_addr }** Fetch pool's voting information at the current period.\n///\n/// * **QueryMsg::PoolInfoAtPeriod { pool_addr, period }** Fetch pool's voting information at a specified period.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::UserInfo { user } =\u003e to_binary(\u0026user_info(deps, user)?),\n        QueryMsg::TuneInfo {} =\u003e to_binary(\u0026TUNE_INFO.load(deps.storage)?),\n        QueryMsg::Config {} =\u003e to_binary(\u0026CONFIG.load(deps.storage)?),\n        QueryMsg::PoolInfo { pool_addr } =\u003e to_binary(\u0026pool_info(deps, env, pool_addr, None)?),\n        QueryMsg::PoolInfoAtPeriod { pool_addr, period } =\u003e {\n            to_binary(\u0026pool_info(deps, env, pool_addr, Some(period))?)\n        }\n    }\n}\n\n/// Returns user information.\nfn user_info(deps: Deps, user: String) -\u003e StdResult\u003cUserInfoResponse\u003e {\n    let user_addr = deps.api.addr_validate(\u0026user)?;\n    USER_INFO\n        .may_load(deps.storage, \u0026user_addr)?\n        .map(UserInfo::into_response)\n        .ok_or_else(|| StdError::generic_err(\"User not found\"))\n}\n\n/// Returns pool's voting information at a specified period.\nfn pool_info(\n    deps: Deps,\n    env: Env,\n    pool_addr: String,\n    period: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cVotedPoolInfo\u003e {\n    let pool_addr = deps.api.addr_validate(\u0026pool_addr)?;\n    let block_period = get_period(env.block.time.seconds())?;\n    let period = period.unwrap_or(block_period);\n    get_pool_info(deps.storage, period, \u0026pool_addr)\n}\n\n/// Manages contract migration\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    Err(ContractError::MigrationError {})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","generator_controller","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse thiserror::Error;\n\n/// This enum describes contract errors\n#[derive(Error, Debug)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Basic points conversion error. {0} \u003e 10000\")]\n    BPSConverstionError(u128),\n\n    #[error(\"Basic points sum exceeds limit\")]\n    BPSLimitError {},\n\n    #[error(\"You can't vote with zero voting power\")]\n    ZeroVotingPower {},\n\n    #[error(\"{0} is the main pool. Voting or whitelisting the main pool is prohibited.\")]\n    MainPoolVoteOrWhitelistingProhibited(String),\n\n    #[error(\"main_pool_min_alloc should be more than 0 and less than 1\")]\n    MainPoolMinAllocFailed {},\n\n    #[error(\"You can only run this action every {0} days\")]\n    CooldownError(u64),\n\n    #[error(\"Invalid lp token address: {0}\")]\n    InvalidLPTokenAddress(String),\n\n    #[error(\"Votes contain duplicated pool addresses\")]\n    DuplicatedPools {},\n\n    #[error(\"There are no pools to tune\")]\n    TuneNoPools {},\n\n    #[error(\"Invalid pool number: {0}. Must be within [2, 100] range\")]\n    InvalidPoolNumber(u64),\n\n    #[error(\"The vector contains duplicated addresses\")]\n    DuplicatedVoters {},\n\n    #[error(\"Exceeded voters limit for kick blacklisted voters operation!\")]\n    KickVotersLimitExceeded {},\n\n    #[error(\"Contract can't be migrated!\")]\n    MigrationError {},\n\n    #[error(\"Whitelist cannot be empty!\")]\n    WhitelistEmpty {},\n\n    #[error(\"The pair aren't registered: {0}-{1}\")]\n    PairNotRegistered(String, String),\n\n    #[error(\"Pool is already whitelisted: {0}\")]\n    PoolIsWhitelisted(String),\n\n    #[error(\"Pool is not whitelisted: {0}\")]\n    PoolIsNotWhitelisted(String),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","generator_controller","src","lib.rs"],"content":"pub mod bps;\npub mod contract;\npub mod state;\n\n// During development this import could be replaced with another astroport version.\n// However, in production, the astroport version should be the same for all contracts.\npub use astroport_governance::astroport;\n\nmod error;\nmod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","generator_controller","src","state.rs"],"content":"use crate::astroport::common::OwnershipProposal;\nuse crate::bps::BasicPoints;\n\nuse astroport_governance::generator_controller::{\n    ConfigResponse, GaugeInfoResponse, UserInfoResponse, VotedPoolInfoResponse,\n};\nuse cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Uint128};\nuse cw_storage_plus::{Item, Map};\n\n/// This structure describes the main control config of generator controller contract.\npub type Config = ConfigResponse;\n/// This structure describes voting parameters for a specific pool.\npub type VotedPoolInfo = VotedPoolInfoResponse;\n/// This structure describes last tuning parameters.\npub type TuneInfo = GaugeInfoResponse;\n\n/// The struct describes last user's votes parameters.\n#[cw_serde]\n#[derive(Default)]\npub struct UserInfo {\n    pub vote_ts: u64,\n    pub voting_power: Uint128,\n    pub slope: Uint128,\n    pub lock_end: u64,\n    pub votes: Vec\u003c(Addr, BasicPoints)\u003e,\n}\n\nimpl UserInfo {\n    /// The function converts [`UserInfo`] object into [`UserInfoResponse`].\n    pub(crate) fn into_response(self) -\u003e UserInfoResponse {\n        let votes = self\n            .votes\n            .iter()\n            .map(|(pool_addr, bps)| (pool_addr.clone(), u16::from(*bps)))\n            .collect();\n\n        UserInfoResponse {\n            vote_ts: self.vote_ts,\n            voting_power: self.voting_power,\n            slope: self.slope,\n            lock_end: self.lock_end,\n            votes,\n        }\n    }\n}\n\n/// Stores config at the given key.\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n\n/// Stores voting parameters per pool at a specific period by key ( period -\u003e pool_addr ).\npub const POOL_VOTES: Map\u003c(u64, \u0026Addr), VotedPoolInfo\u003e = Map::new(\"pool_votes\");\n\n/// HashSet based on [`Map`]. It contains all pool addresses whose voting power \u003e 0.\npub const POOLS: Map\u003c\u0026Addr, ()\u003e = Map::new(\"pools\");\n\n/// Hashset based on [`Map`]. It stores null object by key ( pool_addr -\u003e period ).\n/// This hashset contains all periods which have saved result in [`POOL_VOTES`] for a specific pool address.\npub const POOL_PERIODS: Map\u003c(\u0026Addr, u64), ()\u003e = Map::new(\"pool_periods\");\n\n/// Slope changes for a specific pool address by key ( pool_addr -\u003e period ).\npub const POOL_SLOPE_CHANGES: Map\u003c(\u0026Addr, u64), Uint128\u003e = Map::new(\"pool_slope_changes\");\n\n/// User's voting information.\npub const USER_INFO: Map\u003c\u0026Addr, UserInfo\u003e = Map::new(\"user_info\");\n\n/// Last tuning information.\npub const TUNE_INFO: Item\u003cTuneInfo\u003e = Item::new(\"tune_info\");\n\n/// Contains a proposal to change contract ownership\npub const OWNERSHIP_PROPOSAL: Item\u003cOwnershipProposal\u003e = Item::new(\"ownership_proposal\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","generator_controller","src","utils.rs"],"content":"use std::collections::HashSet;\nuse std::ops::RangeInclusive;\n\nuse crate::astroport;\nuse astroport::asset::{pair_info_by_pool, AssetInfo};\nuse astroport::factory::PairType;\nuse astroport_governance::generator_controller::ConfigResponse;\nuse cosmwasm_std::{Addr, Deps, Order, QuerierWrapper, StdError, StdResult, Storage, Uint128};\nuse cw_storage_plus::Bound;\n\nuse crate::astroport::querier::query_pair_info;\nuse astroport_governance::utils::calc_voting_power;\n\nuse crate::bps::BasicPoints;\nuse crate::error::ContractError;\nuse crate::state::{VotedPoolInfo, POOLS, POOL_PERIODS, POOL_SLOPE_CHANGES, POOL_VOTES};\n\n/// Pools limit should be within the range `[2, 100]`\nconst POOL_NUMBER_LIMIT: RangeInclusive\u003cu64\u003e = 2..=100;\n\n/// The enum defines math operations with voting power and slope.\n#[derive(Debug)]\npub(crate) enum Operation {\n    Add,\n    Sub,\n}\n\nimpl Operation {\n    pub fn calc_slope(\u0026self, cur_slope: Uint128, slope: Uint128, bps: BasicPoints) -\u003e Uint128 {\n        match self {\n            Operation::Add =\u003e cur_slope + bps * slope,\n            Operation::Sub =\u003e cur_slope - bps * slope,\n        }\n    }\n\n    pub fn calc_voting_power(\u0026self, cur_vp: Uint128, vp: Uint128, bps: BasicPoints) -\u003e Uint128 {\n        match self {\n            Operation::Add =\u003e cur_vp + bps * vp,\n            Operation::Sub =\u003e cur_vp.saturating_sub(bps * vp),\n        }\n    }\n}\n\n/// Enum wraps [`VotedPoolInfo`] so the contract can leverage storage operations efficiently.\n#[derive(Debug)]\npub(crate) enum VotedPoolInfoResult {\n    Unchanged(VotedPoolInfo),\n    New(VotedPoolInfo),\n}\n\n/// Filters pairs (LP token address, voting parameters) by criteria:\n/// * pool's pair is registered in Factory,\n/// * pool's pair type is not in blocked list,\n/// * any of pair's token is not listed in blocked tokens list.\npub(crate) fn filter_pools(\n    querier: \u0026QuerierWrapper,\n    generator_addr: \u0026Addr,\n    factory_addr: \u0026Addr,\n    pools: Vec\u003c(Addr, Uint128)\u003e,\n    pools_limit: u64,\n) -\u003e StdResult\u003cVec\u003c(String, Uint128)\u003e\u003e {\n    let blocked_tokens: Vec\u003cAssetInfo\u003e = querier.query_wasm_smart(\n        generator_addr.clone(),\n        \u0026astroport::generator::QueryMsg::BlockedTokensList {},\n    )?;\n    let blocklisted_pair_types: Vec\u003cPairType\u003e = querier.query_wasm_smart(\n        factory_addr.clone(),\n        \u0026astroport::factory::QueryMsg::BlacklistedPairTypes {},\n    )?;\n\n    let pools = pools\n        .into_iter()\n        .filter_map(|(pool_addr, vxastro_amount)| {\n            // Check the address is a LP token and retrieve a pair info\n            let pair_info = pair_info_by_pool(querier, pool_addr).ok()?;\n            // Check a pair is registered in factory\n            query_pair_info(querier, factory_addr.clone(), \u0026pair_info.asset_infos).ok()?;\n            let condition = !blocklisted_pair_types.contains(\u0026pair_info.pair_type)\n                \u0026\u0026 !blocked_tokens.contains(\u0026pair_info.asset_infos[0])\n                \u0026\u0026 !blocked_tokens.contains(\u0026pair_info.asset_infos[1]);\n            if condition {\n                Some((pair_info.liquidity_token.to_string(), vxastro_amount))\n            } else {\n                None\n            }\n        })\n        .take(pools_limit as usize)\n        .collect();\n\n    Ok(pools)\n}\n\n/// Cancels user changes using old voting parameters for a given pool.  \n/// Firstly, it removes slope change scheduled for previous lockup end period.  \n/// Secondly, it updates voting parameters for the given period, but without user's vote.\npub(crate) fn cancel_user_changes(\n    storage: \u0026mut dyn Storage,\n    period: u64,\n    pool_addr: \u0026Addr,\n    old_bps: BasicPoints,\n    old_vp: Uint128,\n    old_slope: Uint128,\n    old_lock_end: u64,\n) -\u003e StdResult\u003c()\u003e {\n    // Cancel scheduled slope changes\n    let last_pool_period = fetch_last_pool_period(storage, period, pool_addr)?.unwrap_or(period);\n    if last_pool_period \u003c old_lock_end + 1 {\n        let end_period_key = old_lock_end + 1;\n        let old_scheduled_change = POOL_SLOPE_CHANGES.load(storage, (pool_addr, end_period_key))?;\n        let new_slope = old_scheduled_change - old_bps * old_slope;\n        if !new_slope.is_zero() {\n            POOL_SLOPE_CHANGES.save(storage, (pool_addr, end_period_key), \u0026new_slope)?\n        } else {\n            POOL_SLOPE_CHANGES.remove(storage, (pool_addr, end_period_key))\n        }\n    }\n\n    update_pool_info(\n        storage,\n        period,\n        pool_addr,\n        Some((old_bps, old_vp, old_slope, Operation::Sub)),\n    )\n    .map(|_| ())\n}\n\n/// Applies user's vote for a given pool.   \n/// Firstly, it schedules slope change for lockup end period.  \n/// Secondly, it updates voting parameters with applied user's vote.\npub(crate) fn vote_for_pool(\n    storage: \u0026mut dyn Storage,\n    period: u64,\n    pool_addr: \u0026Addr,\n    bps: BasicPoints,\n    vp: Uint128,\n    slope: Uint128,\n    lock_end: u64,\n) -\u003e StdResult\u003c()\u003e {\n    // Schedule slope changes\n    POOL_SLOPE_CHANGES.update::\u003c_, StdError\u003e(storage, (pool_addr, lock_end + 1), |slope_opt| {\n        if let Some(saved_slope) = slope_opt {\n            Ok(saved_slope + bps * slope)\n        } else {\n            Ok(bps * slope)\n        }\n    })?;\n    update_pool_info(\n        storage,\n        period,\n        pool_addr,\n        Some((bps, vp, slope, Operation::Add)),\n    )\n    .map(|_| ())\n}\n\n/// Fetches voting parameters for a given pool at specific period, applies new changes, saves it in storage\n/// and returns new voting parameters in [`VotedPoolInfo`] object.\n/// If there are no changes in 'changes' parameter\n/// and voting parameters were already calculated before the function just returns [`VotedPoolInfo`].\npub(crate) fn update_pool_info(\n    storage: \u0026mut dyn Storage,\n    period: u64,\n    pool_addr: \u0026Addr,\n    changes: Option\u003c(BasicPoints, Uint128, Uint128, Operation)\u003e,\n) -\u003e StdResult\u003cVotedPoolInfo\u003e {\n    if POOLS.may_load(storage, pool_addr)?.is_none() {\n        POOLS.save(storage, pool_addr, \u0026())?\n    }\n    let period_key = period;\n    let pool_info = match get_pool_info_mut(storage, period, pool_addr)? {\n        VotedPoolInfoResult::Unchanged(mut pool_info) | VotedPoolInfoResult::New(mut pool_info)\n            if changes.is_some() =\u003e\n        {\n            if let Some((bps, vp, slope, op)) = changes {\n                pool_info.slope = op.calc_slope(pool_info.slope, slope, bps);\n                pool_info.vxastro_amount = op.calc_voting_power(pool_info.vxastro_amount, vp, bps);\n            }\n            POOL_PERIODS.save(storage, (pool_addr, period_key), \u0026())?;\n            POOL_VOTES.save(storage, (period_key, pool_addr), \u0026pool_info)?;\n            pool_info\n        }\n        VotedPoolInfoResult::New(pool_info) =\u003e {\n            POOL_PERIODS.save(storage, (pool_addr, period_key), \u0026())?;\n            POOL_VOTES.save(storage, (period_key, pool_addr), \u0026pool_info)?;\n            pool_info\n        }\n        VotedPoolInfoResult::Unchanged(pool_info) =\u003e pool_info,\n    };\n\n    Ok(pool_info)\n}\n\n/// Returns pool info at specified period or calculates it. Saves intermediate results in storage.\npub(crate) fn get_pool_info_mut(\n    storage: \u0026mut dyn Storage,\n    period: u64,\n    pool_addr: \u0026Addr,\n) -\u003e StdResult\u003cVotedPoolInfoResult\u003e {\n    let pool_info_result = if let Some(pool_info) =\n        POOL_VOTES.may_load(storage, (period, pool_addr))?\n    {\n        VotedPoolInfoResult::Unchanged(pool_info)\n    } else {\n        let pool_info_result =\n            if let Some(mut prev_period) = fetch_last_pool_period(storage, period, pool_addr)? {\n                let mut pool_info = POOL_VOTES.load(storage, (prev_period, pool_addr))?;\n                // Recalculating passed periods\n                let scheduled_slope_changes =\n                    fetch_slope_changes(storage, pool_addr, prev_period, period)?;\n                for (recalc_period, scheduled_change) in scheduled_slope_changes {\n                    pool_info = VotedPoolInfo {\n                        vxastro_amount: calc_voting_power(\n                            pool_info.slope,\n                            pool_info.vxastro_amount,\n                            prev_period,\n                            recalc_period,\n                        ),\n                        slope: pool_info.slope - scheduled_change,\n                    };\n                    // Save intermediate result\n                    let recalc_period_key = recalc_period;\n                    POOL_PERIODS.save(storage, (pool_addr, recalc_period_key), \u0026())?;\n                    POOL_VOTES.save(storage, (recalc_period_key, pool_addr), \u0026pool_info)?;\n                    prev_period = recalc_period\n                }\n\n                VotedPoolInfo {\n                    vxastro_amount: calc_voting_power(\n                        pool_info.slope,\n                        pool_info.vxastro_amount,\n                        prev_period,\n                        period,\n                    ),\n                    ..pool_info\n                }\n            } else {\n                VotedPoolInfo::default()\n            };\n\n        VotedPoolInfoResult::New(pool_info_result)\n    };\n\n    Ok(pool_info_result)\n}\n\n/// Returns pool info at specified period or calculates it.\npub(crate) fn get_pool_info(\n    storage: \u0026dyn Storage,\n    period: u64,\n    pool_addr: \u0026Addr,\n) -\u003e StdResult\u003cVotedPoolInfo\u003e {\n    let pool_info = if let Some(pool_info) = POOL_VOTES.may_load(storage, (period, pool_addr))? {\n        pool_info\n    } else if let Some(mut prev_period) = fetch_last_pool_period(storage, period, pool_addr)? {\n        let mut pool_info = POOL_VOTES.load(storage, (prev_period, pool_addr))?;\n        // Recalculating passed periods\n        let scheduled_slope_changes = fetch_slope_changes(storage, pool_addr, prev_period, period)?;\n        for (recalc_period, scheduled_change) in scheduled_slope_changes {\n            pool_info = VotedPoolInfo {\n                vxastro_amount: calc_voting_power(\n                    pool_info.slope,\n                    pool_info.vxastro_amount,\n                    prev_period,\n                    recalc_period,\n                ),\n                slope: pool_info.slope - scheduled_change,\n            };\n            prev_period = recalc_period\n        }\n\n        VotedPoolInfo {\n            vxastro_amount: calc_voting_power(\n                pool_info.slope,\n                pool_info.vxastro_amount,\n                prev_period,\n                period,\n            ),\n            ..pool_info\n        }\n    } else {\n        VotedPoolInfo::default()\n    };\n\n    Ok(pool_info)\n}\n\n/// Fetches last period for specified pool which has saved result in [`POOL_PERIODS`].\npub(crate) fn fetch_last_pool_period(\n    storage: \u0026dyn Storage,\n    period: u64,\n    pool_addr: \u0026Addr,\n) -\u003e StdResult\u003cOption\u003cu64\u003e\u003e {\n    let period_opt = POOL_PERIODS\n        .prefix(pool_addr)\n        .range(\n            storage,\n            None,\n            Some(Bound::exclusive(period)),\n            Order::Descending,\n        )\n        .next()\n        .transpose()?\n        .map(|(period, _)| period);\n    Ok(period_opt)\n}\n\n/// Fetches all slope changes between `last_period` and `period` for specific pool.\npub(crate) fn fetch_slope_changes(\n    storage: \u0026dyn Storage,\n    pool_addr: \u0026Addr,\n    last_period: u64,\n    period: u64,\n) -\u003e StdResult\u003cVec\u003c(u64, Uint128)\u003e\u003e {\n    POOL_SLOPE_CHANGES\n        .prefix(pool_addr)\n        .range(\n            storage,\n            Some(Bound::exclusive(last_period)),\n            Some(Bound::inclusive(period)),\n            Order::Ascending,\n        )\n        .collect()\n}\n\n/// Input validation for pools limit.\npub(crate) fn validate_pools_limit(number: u64) -\u003e Result\u003cu64, ContractError\u003e {\n    if !POOL_NUMBER_LIMIT.contains(\u0026number) {\n        Err(ContractError::InvalidPoolNumber(number))\n    } else {\n        Ok(number)\n    }\n}\n\n/// Check if a pool isn't the main pool. Check if a pool is an LP token.\n/// Check if a pool is registered in the factory contract.\npub fn validate_pool(\n    deps: Deps,\n    config: \u0026ConfigResponse,\n    pool: \u0026Addr,\n) -\u003e Result\u003c(), ContractError\u003e {\n    // Voting for the main pool or updating it is prohibited\n    if let Some(main_pool) = \u0026config.main_pool {\n        if pool == main_pool {\n            return Err(ContractError::MainPoolVoteOrWhitelistingProhibited(\n                main_pool.to_string(),\n            ));\n        }\n    }\n\n    // Checks if a pool is an LP token\n    let pair_info = pair_info_by_pool(\u0026deps.querier, pool.clone())\n        .map_err(|_| ContractError::InvalidLPTokenAddress(pool.to_string()))?;\n\n    // Check if a pair is registered in the factory\n    query_pair_info(\n        \u0026deps.querier,\n        config.factory_addr.clone(),\n        \u0026pair_info.asset_infos,\n    )\n    .map_err(|_| {\n        ContractError::PairNotRegistered(\n            pair_info.asset_infos[0].to_string(),\n            pair_info.asset_infos[1].to_string(),\n        )\n    })?;\n\n    Ok(())\n}\n\n/// Checks for duplicate pools\npub fn check_duplicated(votes: \u0026[Addr]) -\u003e Result\u003c(), ContractError\u003e {\n    let mut uniq = HashSet::new();\n    if !votes.iter().all(|lp_token| uniq.insert(lp_token)) {\n        return Err(ContractError::DuplicatedPools {});\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","generator_controller","tests","integration.rs"],"content":"use astroport::asset::AssetInfo;\nuse astroport::generator::PoolInfoResponse;\nuse cosmwasm_std::{attr, Addr, Decimal, StdResult, Uint128};\nuse cw_multi_test::{App, ContractWrapper, Executor};\nuse generator_controller::astroport;\nuse std::str::FromStr;\n\nuse crate::astroport::asset::PairInfo;\nuse astroport_governance::generator_controller::{\n    ConfigResponse, ExecuteMsg, QueryMsg, VOTERS_MAX_LIMIT,\n};\nuse astroport_governance::utils::{get_period, MAX_LOCK_TIME, WEEK};\nuse astroport_tests::{\n    controller_helper::ControllerHelper, escrow_helper::MULTIPLIER, mock_app, TerraAppExtension,\n};\nuse generator_controller::state::TuneInfo;\n\n#[test]\nfn update_configs() {\n    let mut router = mock_app();\n    let owner = Addr::unchecked(\"owner\");\n    let helper = ControllerHelper::init(\u0026mut router, \u0026owner);\n\n    let config = helper.query_config(\u0026mut router).unwrap();\n    assert_eq!(config.blacklisted_voters_limit, None);\n\n    // check if user2 cannot update config\n    let err = helper\n        .update_blacklisted_limit(\u0026mut router, \"user2\", Some(4u32))\n        .unwrap_err();\n    assert_eq!(\"Unauthorized\", err.root_cause().to_string());\n\n    // successful update config by owner\n    helper\n        .update_blacklisted_limit(\u0026mut router, \"owner\", Some(4u32))\n        .unwrap();\n\n    let config = helper.query_config(\u0026mut router).unwrap();\n    assert_eq!(config.blacklisted_voters_limit, Some(4u32));\n}\n\n#[test]\nfn check_kick_holders_works() {\n    let mut router = mock_app();\n    let owner = Addr::unchecked(\"owner\");\n    let helper = ControllerHelper::init(\u0026mut router, \u0026owner);\n    let pools = vec![\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"FOO\", \"BAR\")\n            .unwrap(),\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"BAR\", \"ADN\")\n            .unwrap(),\n    ];\n\n    let err = helper\n        .vote(\u0026mut router, \"user1\", vec![(pools[0].as_str(), 1000)])\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"You can't vote with zero voting power\"\n    );\n\n    helper.escrow_helper.mint_xastro(\u0026mut router, \"owner\", 100);\n    helper.escrow_helper.mint_xastro(\u0026mut router, \"user1\", 100);\n    // Create short lock\n    helper\n        .escrow_helper\n        .create_lock(\u0026mut router, \"user1\", WEEK, 100f32)\n        .unwrap();\n\n    helper\n        .update_whitelist(\n            \u0026mut router,\n            \"owner\",\n            Some(pools.iter().map(|el| el.to_string()).collect()),\n            None,\n        )\n        .unwrap();\n\n    // Votes from user1\n    helper\n        .vote(\u0026mut router, \"user1\", vec![(pools[0].as_str(), 1000)])\n        .unwrap();\n\n    helper.escrow_helper.mint_xastro(\u0026mut router, \"user2\", 100);\n    helper\n        .escrow_helper\n        .create_lock(\u0026mut router, \"user2\", 10 * WEEK, 100f32)\n        .unwrap();\n\n    // Votes from user2\n    helper\n        .vote(\n            \u0026mut router,\n            \"user2\",\n            vec![(pools[0].as_str(), 3000), (pools[1].as_str(), 7000)],\n        )\n        .unwrap();\n\n    let ve_slope = helper\n        .escrow_helper\n        .query_lock_info(\u0026mut router, \"user2\")\n        .unwrap()\n        .slope;\n    let ve_power = helper\n        .escrow_helper\n        .query_user_vp(\u0026mut router, \"user2\")\n        .unwrap();\n    let user_info = helper.query_user_info(\u0026mut router, \"user2\").unwrap();\n    assert_eq!(ve_slope, user_info.slope);\n    assert_eq!(router.block_info().time.seconds(), user_info.vote_ts);\n    assert_eq!(\n        ve_power,\n        user_info.voting_power.u128() as f32 / MULTIPLIER as f32\n    );\n    let resp_votes = user_info\n        .votes\n        .clone()\n        .into_iter()\n        .map(|(addr, bps)| (addr.to_string(), bps.into()))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(\n        vec![(pools[0].to_string(), 3000), (pools[1].to_string(), 7000)],\n        resp_votes\n    );\n\n    // Add user2 to the blacklist\n    let res = helper\n        .escrow_helper\n        .update_blacklist(\u0026mut router, Some(vec![\"user2\".to_string()]), None)\n        .unwrap();\n    assert_eq!(\n        res.events[1].attributes[1],\n        attr(\"action\", \"update_blacklist\")\n    );\n\n    // Let's take the period for which the vote was applied.\n    let current_period = router.block_period() + 1u64;\n\n    // Get pools info before kick holder\n    let res = helper\n        .query_voted_pool_info_at_period(\u0026mut router, pools[0].as_str(), current_period)\n        .unwrap();\n    assert_eq!(Uint128::new(13_576_922), res.slope);\n    assert_eq!(Uint128::new(44_471_151), res.vxastro_amount);\n\n    let res = helper\n        .query_voted_pool_info_at_period(\u0026mut router, pools[1].as_str(), current_period)\n        .unwrap();\n    assert_eq!(Uint128::new(8_009_614), res.slope);\n    assert_eq!(Uint128::new(80_096_149), res.vxastro_amount);\n\n    // check if blacklisted voters limit exceeded for kick operation\n    let err = helper\n        .kick_holders(\n            \u0026mut router,\n            \"user1\",\n            vec![\"user2\".to_string(); (VOTERS_MAX_LIMIT + 1) as usize],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"Exceeded voters limit for kick blacklisted voters operation!\",\n        err.root_cause().to_string()\n    );\n\n    // Removes votes for user2\n    helper\n        .kick_holders(\u0026mut router, \"user1\", vec![\"user2\".to_string()])\n        .unwrap();\n\n    let ve_slope = helper\n        .escrow_helper\n        .query_lock_info(\u0026mut router, \"user2\")\n        .unwrap()\n        .slope;\n    let ve_power = helper\n        .escrow_helper\n        .query_user_vp(\u0026mut router, \"user2\")\n        .unwrap();\n\n    let user_info = helper.query_user_info(\u0026mut router, \"user2\").unwrap();\n    assert_eq!(ve_slope, user_info.slope);\n    assert_eq!(router.block_info().time.seconds(), user_info.vote_ts);\n    assert_eq!(\n        ve_power,\n        user_info.voting_power.u128() as f32 / MULTIPLIER as f32\n    );\n    assert_eq!(user_info.votes, vec![]);\n\n    // Get pool info after kick holder\n    let res = helper\n        .query_voted_pool_info_at_period(\u0026mut router, pools[0].as_str(), current_period)\n        .unwrap();\n    assert_eq!(Uint128::new(10_144_230), res.slope);\n    assert_eq!(Uint128::new(10_144_230), res.vxastro_amount);\n\n    let res1 = helper\n        .query_voted_pool_info_at_period(\u0026mut router, pools[1].as_str(), current_period)\n        .unwrap();\n    assert_eq!(Uint128::new(0), res1.slope);\n    assert_eq!(Uint128::new(0), res1.vxastro_amount);\n}\n\n#[test]\nfn check_vote_works() {\n    let mut router = mock_app();\n    let owner = Addr::unchecked(\"owner\");\n    let helper = ControllerHelper::init(\u0026mut router, \u0026owner);\n    let pools = vec![\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"FOO\", \"BAR\")\n            .unwrap(),\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"BAR\", \"ADN\")\n            .unwrap(),\n    ];\n\n    let err = helper\n        .vote(\u0026mut router, \"user1\", vec![(pools[0].as_str(), 1000)])\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"You can't vote with zero voting power\"\n    );\n\n    helper.escrow_helper.mint_xastro(\u0026mut router, \"owner\", 100);\n    helper.escrow_helper.mint_xastro(\u0026mut router, \"user1\", 100);\n    // Create short lock\n    helper\n        .escrow_helper\n        .create_lock(\u0026mut router, \"user1\", WEEK, 100f32)\n        .unwrap();\n    let err = helper\n        .vote(\u0026mut router, \"user1\", vec![(pools[0].as_str(), 1000)])\n        .unwrap_err();\n    assert_eq!(\"Whitelist cannot be empty!\", err.root_cause().to_string());\n\n    let err = helper\n        .update_whitelist(\u0026mut router, \"user1\", Some(vec![pools[0].to_string()]), None)\n        .unwrap_err();\n    assert_eq!(\"Unauthorized\", err.root_cause().to_string());\n\n    helper\n        .update_whitelist(\n            \u0026mut router,\n            \"owner\",\n            Some(pools.iter().map(|el| el.to_string()).collect()),\n            None,\n        )\n        .unwrap();\n\n    helper\n        .vote(\u0026mut router, \"user1\", vec![(pools[0].as_str(), 1000)])\n        .unwrap();\n\n    helper.escrow_helper.mint_xastro(\u0026mut router, \"user2\", 100);\n    helper\n        .escrow_helper\n        .create_lock(\u0026mut router, \"user2\", 10 * WEEK, 100f32)\n        .unwrap();\n\n    // Bps is \u003e 10000\n    let err = helper\n        .vote(\u0026mut router, \"user2\", vec![(pools[1].as_str(), 10001)])\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Basic points conversion error. 10001 \u003e 10000\"\n    );\n\n    // Bps sum is \u003e 10000\n    let err = helper\n        .vote(\n            \u0026mut router,\n            \"user2\",\n            vec![(pools[0].as_str(), 3000), (pools[1].as_str(), 8000)],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Basic points sum exceeds limit\"\n    );\n\n    // Duplicated pools\n    let err = helper\n        .vote(\n            \u0026mut router,\n            \"user2\",\n            vec![(pools[0].as_str(), 3000), (pools[0].as_str(), 7000)],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Votes contain duplicated pool addresses\"\n    );\n\n    // Valid votes\n    helper\n        .vote(\n            \u0026mut router,\n            \"user2\",\n            vec![(pools[0].as_str(), 3000), (pools[1].as_str(), 7000)],\n        )\n        .unwrap();\n\n    let err = helper\n        .vote(\n            \u0026mut router,\n            \"user2\",\n            vec![(pools[0].as_str(), 7000), (pools[1].as_str(), 3000)],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"You can only run this action every 10 days\"\n    );\n\n    let ve_slope = helper\n        .escrow_helper\n        .query_lock_info(\u0026mut router, \"user2\")\n        .unwrap()\n        .slope;\n    let ve_power = helper\n        .escrow_helper\n        .query_user_vp(\u0026mut router, \"user2\")\n        .unwrap();\n    let user_info = helper.query_user_info(\u0026mut router, \"user2\").unwrap();\n    assert_eq!(ve_slope, user_info.slope);\n    assert_eq!(router.block_info().time.seconds(), user_info.vote_ts);\n    assert_eq!(\n        ve_power,\n        user_info.voting_power.u128() as f32 / MULTIPLIER as f32\n    );\n    let resp_votes = user_info\n        .votes\n        .into_iter()\n        .map(|(addr, bps)| (addr.to_string(), bps.into()))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(\n        vec![(pools[0].to_string(), 3000), (pools[1].to_string(), 7000)],\n        resp_votes\n    );\n\n    router.next_block(86400 * 10);\n    // In 10 days user will be able to vote again\n    helper\n        .vote(\n            \u0026mut router,\n            \"user2\",\n            vec![(pools[0].as_str(), 500), (pools[1].as_str(), 9500)],\n        )\n        .unwrap();\n}\n\nfn create_unregistered_pool(\n    router: \u0026mut App,\n    helper: \u0026mut ControllerHelper,\n) -\u003e StdResult\u003cPairInfo\u003e {\n    let pair_contract = Box::new(\n        ContractWrapper::new_with_empty(\n            astroport_pair::contract::execute,\n            astroport_pair::contract::instantiate,\n            astroport_pair::contract::query,\n        )\n        .with_reply_empty(astroport_pair::contract::reply),\n    );\n\n    let pair_code_id = router.store_code(pair_contract);\n\n    let test_token1 = helper.init_cw20_token(router, \"TST\").unwrap();\n    let test_token2 = helper.init_cw20_token(router, \"TSB\").unwrap();\n\n    let pair_addr = router\n        .instantiate_contract(\n            pair_code_id,\n            Addr::unchecked(\"owner\"),\n            \u0026astroport::pair::InstantiateMsg {\n                asset_infos: vec![\n                    AssetInfo::Token {\n                        contract_addr: test_token1.clone(),\n                    },\n                    AssetInfo::Token {\n                        contract_addr: test_token2.clone(),\n                    },\n                ],\n                token_code_id: 1,\n                factory_addr: helper.factory.to_string(),\n                init_params: None,\n            },\n            \u0026[],\n            \"Unregistered pair\".to_string(),\n            None,\n        )\n        .unwrap();\n\n    let res: PairInfo = router\n        .wrap()\n        .query_wasm_smart(pair_addr, \u0026astroport::pair::QueryMsg::Pair {})?;\n\n    Ok(res)\n}\n\n#[test]\nfn check_tuning() {\n    let mut router = mock_app();\n    let owner = \"owner\";\n    let owner_addr = Addr::unchecked(owner);\n    let mut helper = ControllerHelper::init(\u0026mut router, \u0026owner_addr);\n    let user1 = \"user1\";\n    let user2 = \"user2\";\n    let user3 = \"user3\";\n    let ve_locks = vec![(user1, 10), (user2, 5), (user3, 50)];\n\n    let pools = vec![\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"FOO\", \"BAR\")\n            .unwrap(),\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"BAR\", \"ADN\")\n            .unwrap(),\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"FOO\", \"ADN\")\n            .unwrap(),\n    ];\n\n    helper\n        .update_whitelist(\n            \u0026mut router,\n            \"owner\",\n            Some(pools.iter().map(|el| el.to_string()).collect()),\n            None,\n        )\n        .unwrap();\n\n    let err = helper\n        .update_whitelist(\u0026mut router, \"owner\", Some(vec![pools[0].to_string()]), None)\n        .unwrap_err();\n    assert_eq!(\"Generic error: The resulting whitelist contains duplicated pools. It's either provided 'add' list contains duplicated pools or some of the added pools are already whitelisted.\", err.root_cause().to_string());\n\n    let config_resp = helper.query_config(\u0026mut router).unwrap();\n    assert_eq!(config_resp.whitelisted_pools, pools);\n\n    for (user, duration) in ve_locks {\n        helper.escrow_helper.mint_xastro(\u0026mut router, user, 1000);\n        helper\n            .escrow_helper\n            .create_lock(\u0026mut router, user, duration * WEEK, 100f32)\n            .unwrap();\n    }\n\n    let res = create_unregistered_pool(\u0026mut router, \u0026mut helper).unwrap();\n    let err = helper\n        .vote(\n            \u0026mut router,\n            user1,\n            vec![\n                (pools[0].as_str(), 5000),\n                (pools[1].as_str(), 4000),\n                (res.liquidity_token.as_str(), 1000),\n            ],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"Pool is not whitelisted: contract23\",\n        err.root_cause().to_string()\n    );\n\n    let err = helper\n        .vote(\n            \u0026mut router,\n            user1,\n            vec![\n                (pools[0].as_str(), 5000),\n                (pools[1].as_str(), 2000),\n                (pools[1].as_str(), 2000),\n            ],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"Votes contain duplicated pool addresses\",\n        err.root_cause().to_string()\n    );\n\n    helper\n        .vote(\n            \u0026mut router,\n            user1,\n            vec![(pools[0].as_str(), 5000), (pools[1].as_str(), 5000)],\n        )\n        .unwrap();\n\n    helper\n        .vote(\n            \u0026mut router,\n            user2,\n            vec![\n                (pools[0].as_str(), 5000),\n                (pools[1].as_str(), 2000),\n                (pools[2].as_str(), 3000),\n            ],\n        )\n        .unwrap();\n    helper\n        .vote(\n            \u0026mut router,\n            user3,\n            vec![\n                (pools[0].as_str(), 2000),\n                (pools[1].as_str(), 3000),\n                (pools[2].as_str(), 5000),\n            ],\n        )\n        .unwrap();\n\n    // The contract was just created so we need to wait for 2 weeks\n    let err = helper.tune(\u0026mut router).unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"You can only run this action every 14 days\"\n    );\n\n    router.next_block(WEEK);\n    let err = helper.tune(\u0026mut router).unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"You can only run this action every 14 days\"\n    );\n\n    router.next_block(WEEK);\n\n    helper.tune(\u0026mut router).unwrap();\n\n    let resp: TuneInfo = router\n        .wrap()\n        .query_wasm_smart(helper.controller.clone(), \u0026QueryMsg::TuneInfo {})\n        .unwrap();\n    assert_eq!(get_period(resp.tune_ts).unwrap(), router.block_period());\n    assert_eq!(resp.pool_alloc_points.len(), pools.len());\n    let total_apoints: u128 = resp\n        .pool_alloc_points\n        .iter()\n        .cloned()\n        .map(|(_, apoints)| apoints.u128())\n        .sum();\n    assert_eq!(total_apoints, 357423036);\n\n    router.next_block(2 * WEEK);\n    // Reduce pools limit 5 -\u003e 2 (5 is initial limit in integration tests)\n    let limit = 2u64;\n    let err = router\n        .execute_contract(\n            Addr::unchecked(\"somebody\"),\n            helper.controller.clone(),\n            \u0026ExecuteMsg::ChangePoolsLimit { limit },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Unauthorized\");\n\n    router\n        .execute_contract(\n            owner_addr.clone(),\n            helper.controller.clone(),\n            \u0026ExecuteMsg::ChangePoolsLimit { limit },\n            \u0026[],\n        )\n        .unwrap();\n\n    let err = router\n        .execute_contract(\n            owner_addr.clone(),\n            helper.controller.clone(),\n            \u0026ExecuteMsg::ChangePoolsLimit { limit: 101 },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Invalid pool number: 101. Must be within [2, 100] range\"\n    );\n\n    helper.tune(\u0026mut router).unwrap();\n\n    let resp: TuneInfo = router\n        .wrap()\n        .query_wasm_smart(helper.controller.clone(), \u0026QueryMsg::TuneInfo {})\n        .unwrap();\n    assert_eq!(get_period(resp.tune_ts).unwrap(), router.block_period());\n    assert_eq!(resp.pool_alloc_points.len(), limit as usize);\n    let total_apoints: u128 = resp\n        .pool_alloc_points\n        .iter()\n        .cloned()\n        .map(|(_, apoints)| apoints.u128())\n        .sum();\n    assert_eq!(total_apoints, 191009600);\n\n    // Check alloc points are properly set in generator\n    for (pool_addr, apoints) in resp.pool_alloc_points {\n        let resp: PoolInfoResponse = router\n            .wrap()\n            .query_wasm_smart(\n                helper.generator.clone(),\n                \u0026astroport::generator::QueryMsg::PoolInfo {\n                    lp_token: pool_addr.to_string(),\n                },\n            )\n            .unwrap();\n        assert_eq!(apoints, resp.alloc_point)\n    }\n\n    // Check the last pool did not receive alloc points\n    let generator_resp: PoolInfoResponse = router\n        .wrap()\n        .query_wasm_smart(\n            helper.generator.clone(),\n            \u0026astroport::generator::QueryMsg::PoolInfo {\n                lp_token: pools[2].to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(generator_resp.alloc_point.u128(), 0)\n}\n\n#[test]\nfn check_bad_pools_filtering() {\n    let mut router = mock_app();\n    let owner = \"owner\";\n    let owner_addr = Addr::unchecked(owner);\n    let helper = ControllerHelper::init(\u0026mut router, \u0026owner_addr);\n    let user = \"user1\";\n\n    let foo_token = helper.init_cw20_token(\u0026mut router, \"FOO\").unwrap();\n    let bar_token = helper.init_cw20_token(\u0026mut router, \"BAR\").unwrap();\n    let adn_token = helper.init_cw20_token(\u0026mut router, \"ADN\").unwrap();\n    let pools = vec![\n        helper\n            .create_pool(\u0026mut router, \u0026foo_token, \u0026bar_token)\n            .unwrap(),\n        helper\n            .create_pool(\u0026mut router, \u0026foo_token, \u0026adn_token)\n            .unwrap(),\n        helper\n            .create_pool(\u0026mut router, \u0026bar_token, \u0026adn_token)\n            .unwrap(),\n    ];\n\n    helper.escrow_helper.mint_xastro(\u0026mut router, user, 1000);\n    helper\n        .escrow_helper\n        .create_lock(\u0026mut router, user, 10 * WEEK, 100f32)\n        .unwrap();\n\n    let err = helper\n        .update_whitelist(\n            \u0026mut router,\n            \"owner\",\n            Some(vec![(\"random_pool\".to_string())]),\n            None,\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Invalid lp token address: random_pool\"\n    );\n\n    helper\n        .update_whitelist(\n            \u0026mut router,\n            \"owner\",\n            Some(pools.iter().map(|el| el.to_string()).collect()),\n            None,\n        )\n        .unwrap();\n\n    helper\n        .vote(\u0026mut router, user, vec![(pools[0].as_str(), 5000)])\n        .unwrap();\n\n    router.next_block(2 * WEEK);\n\n    helper.tune(\u0026mut router).unwrap();\n    let resp: TuneInfo = router\n        .wrap()\n        .query_wasm_smart(helper.controller.clone(), \u0026QueryMsg::TuneInfo {})\n        .unwrap();\n    // There was only one valid pool\n    assert_eq!(resp.pool_alloc_points.len(), 1);\n\n    router.next_block(2 * WEEK);\n\n    // Deregister first pair\n    let asset_infos = vec![\n        AssetInfo::Token {\n            contract_addr: foo_token.clone(),\n        },\n        AssetInfo::Token {\n            contract_addr: bar_token.clone(),\n        },\n    ];\n    router\n        .execute_contract(\n            owner_addr.clone(),\n            helper.factory.clone(),\n            \u0026astroport::factory::ExecuteMsg::Deregister {\n                asset_infos: asset_infos.to_vec(),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // We cannot vote for deregistered pool\n    let err = helper\n        .vote(\u0026mut router, user, vec![(pools[0].as_str(), 10000)])\n        .unwrap_err();\n    assert_eq!(\n        \"The pair aren't registered: contract8-contract9\",\n        err.root_cause().to_string()\n    );\n\n    let err = helper.tune(\u0026mut router).unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"There are no pools to tune\");\n\n    router.next_block(2 * WEEK);\n\n    // Blocking FOO token so pair[0] and pair[1] become blocked as well\n    let foo_asset_info = AssetInfo::Token {\n        contract_addr: foo_token.clone(),\n    };\n    router\n        .execute_contract(\n            owner_addr.clone(),\n            helper.generator.clone(),\n            \u0026astroport::generator::ExecuteMsg::UpdateBlockedTokenslist {\n                add: Some(vec![foo_asset_info]),\n                remove: None,\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Voting for 2 valid pools\n    helper\n        .vote(\n            \u0026mut router,\n            user,\n            vec![(pools[1].as_str(), 1000), (pools[2].as_str(), 8000)],\n        )\n        .unwrap();\n\n    router.next_block(WEEK);\n    helper.tune(\u0026mut router).unwrap();\n\n    let resp: TuneInfo = router\n        .wrap()\n        .query_wasm_smart(helper.controller.clone(), \u0026QueryMsg::TuneInfo {})\n        .unwrap();\n    // Only one pool is eligible to receive alloc points\n    assert_eq!(resp.pool_alloc_points.len(), 1);\n    let total_apoints: u128 = resp\n        .pool_alloc_points\n        .iter()\n        .cloned()\n        .map(|(_, apoints)| apoints.u128())\n        .sum();\n    assert_eq!(total_apoints, 36615382)\n}\n\n#[test]\nfn check_update_owner() {\n    let mut app = mock_app();\n    let owner = Addr::unchecked(\"owner\");\n    let helper = ControllerHelper::init(\u0026mut app, \u0026owner);\n\n    let new_owner = String::from(\"new_owner\");\n\n    // New owner\n    let msg = ExecuteMsg::ProposeNewOwner {\n        new_owner: new_owner.clone(),\n        expires_in: 100, // seconds\n    };\n\n    // Unauthed check\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"not_owner\"),\n            helper.controller.clone(),\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Generic error: Unauthorized\");\n\n    // Claim before proposal\n    let err = app\n        .execute_contract(\n            Addr::unchecked(new_owner.clone()),\n            helper.controller.clone(),\n            \u0026ExecuteMsg::ClaimOwnership {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Ownership proposal not found\"\n    );\n\n    // Propose new owner\n    app.execute_contract(\n        Addr::unchecked(\"owner\"),\n        helper.controller.clone(),\n        \u0026msg,\n        \u0026[],\n    )\n    .unwrap();\n\n    // Claim from invalid addr\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"invalid_addr\"),\n            helper.controller.clone(),\n            \u0026ExecuteMsg::ClaimOwnership {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Generic error: Unauthorized\");\n\n    // Claim ownership\n    app.execute_contract(\n        Addr::unchecked(new_owner.clone()),\n        helper.controller.clone(),\n        \u0026ExecuteMsg::ClaimOwnership {},\n        \u0026[],\n    )\n    .unwrap();\n\n    // Let's query the contract state\n    let msg = QueryMsg::Config {};\n    let res: ConfigResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026helper.controller, \u0026msg)\n        .unwrap();\n\n    assert_eq!(res.owner, new_owner)\n}\n\n#[test]\nfn check_main_pool() {\n    let mut router = mock_app();\n    let owner_addr = Addr::unchecked(\"owner\");\n    let helper = ControllerHelper::init(\u0026mut router, \u0026owner_addr);\n    let pools = vec![\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"FOO\", \"BAR\")\n            .unwrap(),\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"BAR\", \"ADN\")\n            .unwrap(),\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"FOO\", \"ADN\")\n            .unwrap(),\n    ];\n\n    helper.escrow_helper.mint_xastro(\u0026mut router, \"owner\", 100);\n\n    for user in [\"user1\", \"user2\"] {\n        helper.escrow_helper.mint_xastro(\u0026mut router, user, 100);\n        helper\n            .escrow_helper\n            .create_lock(\u0026mut router, user, MAX_LOCK_TIME, 100f32)\n            .unwrap();\n    }\n\n    helper\n        .update_whitelist(\n            \u0026mut router,\n            \"owner\",\n            Some(pools.iter().map(|el| el.to_string()).collect()),\n            None,\n        )\n        .unwrap();\n\n    helper\n        .vote(\n            \u0026mut router,\n            \"user1\",\n            vec![\n                (pools[0].as_str(), 1000),\n                (pools[1].as_str(), 5000),\n                (pools[2].as_str(), 4000),\n            ],\n        )\n        .unwrap();\n    let block_period = router.block_period();\n    let main_pool_info = helper\n        .query_voted_pool_info_at_period(\u0026mut router, pools[0].as_str(), block_period + 2)\n        .unwrap();\n    assert_eq!(main_pool_info.vxastro_amount.u128(), 24759614);\n\n    let err = helper\n        .update_main_pool(\n            \u0026mut router,\n            \"owner\",\n            Some(\u0026pools[0]),\n            Some(Decimal::zero()),\n            false,\n        )\n        .unwrap_err();\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"main_pool_min_alloc should be more than 0 and less than 1\"\n    );\n    let err = helper\n        .update_main_pool(\n            \u0026mut router,\n            \"owner\",\n            Some(\u0026pools[0]),\n            Some(Decimal::one()),\n            false,\n        )\n        .unwrap_err();\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"main_pool_min_alloc should be more than 0 and less than 1\"\n    );\n    helper\n        .update_main_pool(\n            \u0026mut router,\n            \"owner\",\n            Some(\u0026pools[0]),\n            Decimal::from_str(\"0.3\").ok(),\n            false,\n        )\n        .unwrap();\n\n    // From now users can't vote for the main pool\n    let err = helper\n        .vote(\n            \u0026mut router,\n            \"user2\",\n            vec![(pools[0].as_str(), 1000), (pools[1].as_str(), 9000)],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"contract11 is the main pool. Voting or whitelisting the main pool is prohibited.\"\n    );\n\n    router\n        .execute_contract(\n            owner_addr.clone(),\n            helper.controller.clone(),\n            \u0026ExecuteMsg::ChangePoolsLimit { limit: 2 },\n            \u0026[],\n        )\n        .unwrap();\n\n    router.next_block(2 * WEEK);\n    helper.tune(\u0026mut router).unwrap();\n\n    let resp: TuneInfo = router\n        .wrap()\n        .query_wasm_smart(helper.controller.clone(), \u0026QueryMsg::TuneInfo {})\n        .unwrap();\n    // 2 (limit) + 1 (main pool)\n    assert_eq!(resp.pool_alloc_points.len(), 3 as usize);\n    let total_apoints: Uint128 = resp\n        .pool_alloc_points\n        .iter()\n        .map(|(_, apoints)| apoints)\n        .sum();\n    assert_eq!(total_apoints.u128(), 318337891);\n    let main_pool_contribution = resp\n        .pool_alloc_points\n        .iter()\n        .find(|(pool, _)| pool == \u0026pools[0]);\n    assert_eq!(\n        main_pool_contribution.unwrap().1,\n        (total_apoints * Decimal::from_str(\"0.3\").unwrap())\n    );\n\n    // Remove the main pool\n    helper\n        .update_main_pool(\u0026mut router, \"owner\", None, None, true)\n        .unwrap();\n\n    router.next_block(2 * WEEK);\n    helper.tune(\u0026mut router).unwrap();\n\n    let resp: TuneInfo = router\n        .wrap()\n        .query_wasm_smart(helper.controller.clone(), \u0026QueryMsg::TuneInfo {})\n        .unwrap();\n    // The main pool was removed\n    assert_eq!(resp.pool_alloc_points.len(), 2 as usize);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","generator_controller","tests","math_test.rs"],"content":"use std::cmp::Ordering;\nuse std::collections::HashMap;\n\nuse anyhow::Result;\nuse cosmwasm_std::{Addr, Uint128};\nuse cw_multi_test::{App, AppResponse, Executor};\nuse itertools::Itertools;\nuse proptest::prelude::*;\n\nuse astroport_governance::generator_controller::ExecuteMsg;\nuse astroport_governance::utils::{calc_voting_power, MAX_LOCK_TIME, WEEK};\nuse generator_controller::bps::BasicPoints;\nuse Event::*;\nuse VeEvent::*;\n\nuse astroport_tests::{\n    controller_helper::ControllerHelper, escrow_helper::MULTIPLIER, mock_app, TerraAppExtension,\n};\n\n#[derive(Clone, Debug)]\nenum Event {\n    Vote(Vec\u003c((String, String), u16)\u003e),\n    TunePools,\n    ChangePoolLimit(u64),\n}\n\n#[derive(Clone, Debug)]\nenum VeEvent {\n    CreateLock(f64, u64),\n    IncreaseTime(u64),\n    ExtendLock(f64),\n    Withdraw,\n}\n\nstruct Simulator {\n    user_votes: HashMap\u003cString, HashMap\u003cString, u16\u003e\u003e,\n    locks: HashMap\u003cString, (Uint128, u64, f32)\u003e,\n    helper: ControllerHelper,\n    router: App,\n    owner: Addr,\n    limit: u64,\n    pairs: HashMap\u003c(String, String), Addr\u003e,\n}\n\nimpl Simulator {\n    pub fn init\u003cT: Clone + Into\u003cString\u003e\u003e(users: \u0026[T]) -\u003e Self {\n        let mut router = mock_app();\n        let owner = Addr::unchecked(\"owner\");\n        Self {\n            helper: ControllerHelper::init(\u0026mut router, \u0026owner),\n            user_votes: users\n                .iter()\n                .cloned()\n                .map(|user| (user.into(), HashMap::new()))\n                .collect(),\n            locks: HashMap::new(),\n            limit: 5,\n            pairs: HashMap::new(),\n            router,\n            owner,\n        }\n    }\n\n    fn escrow_events_router(\u0026mut self, user: \u0026str, event: VeEvent) {\n        // We don't check voting escrow errors\n        let _ = match event {\n            CreateLock(amount, interval) =\u003e {\n                self.helper\n                    .escrow_helper\n                    .mint_xastro(\u0026mut self.router, user, amount as u64);\n                self.helper.escrow_helper.create_lock(\n                    \u0026mut self.router,\n                    user,\n                    interval,\n                    amount as f32,\n                )\n            }\n            IncreaseTime(interval) =\u003e {\n                self.helper\n                    .escrow_helper\n                    .extend_lock_time(\u0026mut self.router, user, interval)\n            }\n            ExtendLock(amount) =\u003e {\n                self.helper\n                    .escrow_helper\n                    .mint_xastro(\u0026mut self.router, user, amount as u64);\n                self.helper\n                    .escrow_helper\n                    .extend_lock_amount(\u0026mut self.router, user, amount as f32)\n            }\n            Withdraw =\u003e self.helper.escrow_helper.withdraw(\u0026mut self.router, user),\n        };\n    }\n\n    fn vote(\u0026mut self, user: \u0026str, votes: Vec\u003c((String, String), u16)\u003e) -\u003e Result\u003cAppResponse\u003e {\n        let votes: Vec\u003c_\u003e = votes\n            .iter()\n            .map(|(tokens, bps)| {\n                let addr = self\n                    .pairs\n                    .get(tokens)\n                    .cloned()\n                    .expect(\u0026format!(\"Pair {}-{} was not found\", tokens.0, tokens.1));\n                (addr, *bps)\n            })\n            .collect();\n        self.helper\n            .vote(\u0026mut self.router, user, votes.clone())\n            .map(|response| {\n                let lock_info = self\n                    .helper\n                    .escrow_helper\n                    .query_lock_info(\u0026mut self.router, user)\n                    .unwrap();\n                let vp = self\n                    .helper\n                    .escrow_helper\n                    .query_user_vp(\u0026mut self.router, user)\n                    .unwrap();\n                self.locks.insert(\n                    user.to_string(),\n                    (lock_info.slope, self.router.block_period(), vp),\n                );\n                self.user_votes.insert(user.to_string(), HashMap::new());\n                for (pool, bps) in votes {\n                    self.user_votes\n                        .get_mut(user)\n                        .expect(\"User not found!\")\n                        .insert(pool.to_string(), bps);\n                }\n                let user_info = self.helper.query_user_info(\u0026mut self.router, user).unwrap();\n                let total_apoints: u16 = user_info\n                    .votes\n                    .iter()\n                    .cloned()\n                    .map(|pair| u16::from(pair.1))\n                    .sum();\n                if total_apoints \u003e 10000 {\n                    panic!(\"{} \u003e 10000\", total_apoints)\n                }\n                assert_eq!(user_info.vote_ts, self.router.block_info().time.seconds());\n                response\n            })\n    }\n\n    fn change_pool_limit(\u0026mut self, limit: u64) -\u003e Result\u003cAppResponse\u003e {\n        self.router\n            .execute_contract(\n                self.owner.clone(),\n                self.helper.controller.clone(),\n                \u0026ExecuteMsg::ChangePoolsLimit { limit },\n                \u0026[],\n            )\n            .map(|response| {\n                self.limit = limit;\n                response\n            })\n    }\n\n    pub fn event_router(\u0026mut self, user: \u0026str, event: Event) {\n        println!(\"User {} Event {:?}\", user, event);\n        match event {\n            Vote(votes) =\u003e {\n                if let Err(err) = self.vote(user, votes) {\n                    println!(\"{}\", err);\n                }\n            }\n            TunePools =\u003e {\n                if let Err(err) = self.helper.tune(\u0026mut self.router) {\n                    println!(\"{}\", err);\n                }\n            }\n            ChangePoolLimit(limit) =\u003e {\n                if let Err(err) = self.change_pool_limit(limit) {\n                    println!(\"{}\", err);\n                }\n            }\n        }\n    }\n\n    pub fn register_pools(\u0026mut self, tokens: \u0026[String]) {\n        for token1 in tokens {\n            for token2 in tokens {\n                if matches!(token1.cmp(token2), Ordering::Less) {\n                    self.pairs.insert(\n                        (token1.to_string(), token2.to_string()),\n                        self.helper\n                            .create_pool_with_tokens(\u0026mut self.router, token1, token2)\n                            .unwrap(),\n                    );\n                }\n            }\n        }\n    }\n\n    pub fn simulate_case(\n        \u0026mut self,\n        tokens: \u0026[String],\n        ve_events_tuples: \u0026[(usize, String, VeEvent)],\n        events_tuples: \u0026[(usize, String, Event)],\n    ) {\n        self.register_pools(tokens);\n        let pools = self\n            .pairs\n            .values()\n            .map(|pool_addr| pool_addr.to_string())\n            .collect_vec();\n\n        let mut events: Vec\u003cVec\u003c(String, Event)\u003e\u003e = vec![vec![]; MAX_PERIOD + 1];\n        let mut ve_events: Vec\u003cVec\u003c(String, VeEvent)\u003e\u003e = vec![vec![]; MAX_PERIOD + 1];\n\n        for (period, user, event) in events_tuples.iter().cloned() {\n            events[period].push((user, event));\n        }\n        for (period, user, event) in ve_events_tuples.iter().cloned() {\n            ve_events[period].push((user, event))\n        }\n\n        for period in 0..events.len() {\n            // vxASTRO events\n            if let Some(period_events) = ve_events.get(period) {\n                for (user, event) in period_events {\n                    self.escrow_events_router(user, event.clone())\n                }\n            }\n            // Generator controller events\n            if let Some(period_events) = events.get(period) {\n                if !period_events.is_empty() {\n                    println!(\"Period {}:\", period);\n                }\n                for (user, event) in period_events {\n                    self.event_router(user, event.clone())\n                }\n            }\n\n            let mut voted_pools: HashMap\u003cString, f32\u003e = HashMap::new();\n\n            // Checking calculations\n            for user in self.user_votes.keys() {\n                let votes = self.user_votes.get(user).unwrap();\n                if let Some((slope, start, vp)) = self.locks.get(user) {\n                    let user_vp = calc_voting_power(\n                        *slope,\n                        Uint128::from((*vp * MULTIPLIER as f32) as u128),\n                        *start,\n                        period as u64,\n                    );\n                    let user_vp = user_vp.u128() as f32 / MULTIPLIER as f32;\n                    votes.iter().for_each(|(pool, \u0026bps)| {\n                        let vp = voted_pools.entry(pool.clone()).or_default();\n                        *vp += (bps as f32 / BasicPoints::MAX as f32) * user_vp\n                    })\n                }\n            }\n            let block_period = self.router.block_period();\n            for pool_addr in \u0026pools {\n                let pool_vp = self\n                    .helper\n                    .query_voted_pool_info_at_period(\u0026mut self.router, pool_addr, block_period + 1)\n                    .unwrap()\n                    .vxastro_amount\n                    .u128() as f32\n                    / MULTIPLIER as f32;\n                let real_vp = voted_pools.get(pool_addr).cloned().unwrap_or(0f32);\n                if (pool_vp - real_vp).abs() \u003e= 10e-3 {\n                    assert_eq!(pool_vp, real_vp, \"Period: {}, pool: {}\", period, pool_addr)\n                }\n            }\n            self.router.next_block(WEEK);\n        }\n    }\n}\n\nconst MAX_PERIOD: usize = 20;\nconst MAX_USERS: usize = 10;\nconst MAX_POOLS: usize = 5;\nconst MAX_EVENTS: usize = 100;\n\nfn escrow_events_strategy() -\u003e impl Strategy\u003cValue = VeEvent\u003e {\n    prop_oneof![\n        Just(VeEvent::Withdraw),\n        (1f64..=100f64).prop_map(VeEvent::ExtendLock),\n        (WEEK..MAX_LOCK_TIME).prop_map(VeEvent::IncreaseTime),\n        ((1f64..=100f64), WEEK..MAX_LOCK_TIME).prop_map(|(a, b)| VeEvent::CreateLock(a, b)),\n    ]\n}\n\nfn vote_strategy(tokens: Vec\u003cString\u003e) -\u003e impl Strategy\u003cValue = Event\u003e {\n    prop::collection::vec(\n        (prop::sample::subsequence(tokens, 2), 1..=2500u16),\n        1..MAX_POOLS,\n    )\n    .prop_filter_map(\n        \"Accepting only BPS sum \u003c= 10000\",\n        |vec: Vec\u003c(Vec\u003cString\u003e, u16)\u003e| {\n            let votes = vec\n                .iter()\n                .into_grouping_map_by(|(pair, _)| {\n                    let mut pair = pair.clone();\n                    pair.sort();\n                    (pair[0].clone(), pair[1].clone())\n                })\n                .aggregate(|acc, _, (_, val)| Some(acc.unwrap_or(0) + *val))\n                .into_iter()\n                .collect_vec();\n            if votes.iter().map(|(_, bps)| bps).sum::\u003cu16\u003e() \u003c= 10000 {\n                Some(Event::Vote(votes))\n            } else {\n                None\n            }\n        },\n    )\n}\n\nfn controller_events_strategy(tokens: Vec\u003cString\u003e) -\u003e impl Strategy\u003cValue = Event\u003e {\n    prop_oneof![\n        Just(Event::TunePools),\n        (2..=MAX_POOLS as u64).prop_map(Event::ChangePoolLimit),\n        vote_strategy(tokens)\n    ]\n}\n\nfn generate_cases() -\u003e impl Strategy\u003c\n    Value = (\n        Vec\u003cString\u003e,\n        Vec\u003cString\u003e,\n        Vec\u003c(usize, String, VeEvent)\u003e,\n        Vec\u003c(usize, String, Event)\u003e,\n    ),\n\u003e {\n    let tokens_strategy =\n        prop::collection::hash_set(\"[A-Z]{3}\", MAX_POOLS * MAX_POOLS / 2 - MAX_POOLS);\n    let users_strategy = prop::collection::vec(\"[a-z]{10}\", 1..MAX_USERS);\n    (users_strategy, tokens_strategy).prop_flat_map(|(users, tokens)| {\n        (\n            Just(users.clone()),\n            Just(tokens.iter().cloned().collect()),\n            prop::collection::vec(\n                (\n                    1..=MAX_PERIOD,\n                    prop::sample::select(users.clone()),\n                    escrow_events_strategy(),\n                ),\n                0..MAX_EVENTS,\n            ),\n            prop::collection::vec(\n                (\n                    1..=MAX_PERIOD,\n                    prop::sample::select(users),\n                    controller_events_strategy(tokens.iter().cloned().collect_vec()),\n                ),\n                0..MAX_EVENTS,\n            ),\n        )\n    })\n}\n\nproptest! {\n    #[test]\n    fn run_simulations(\n        case in generate_cases()\n    ) {\n        let (users, tokens, ve_events_tuples, events_tuples) = case;\n        let mut simulator = Simulator::init(\u0026users);\n        simulator.simulate_case(\u0026tokens, \u0026ve_events_tuples[..], \u0026events_tuples[..]);\n    }\n}\n\n#[test]\nfn exact_simulation() {\n    let case = (\n        [\"rsgnawburh\", \"kxhuagnkvo\"],\n        [\"FOO\", \"BAR\"],\n        [\n            (4, \"rsgnawburh\", CreateLock(100.0, 1809600)),\n            (5, \"rsgnawburh\", IncreaseTime(604800)),\n            (6, \"kxhuagnkvo\", CreateLock(100.0, 604800)),\n        ],\n        [\n            (\n                4,\n                \"rsgnawburh\",\n                Vote(vec![((\"BAR\".to_string(), \"FOO\".to_string()), 10000)]),\n            ),\n            (\n                6,\n                \"kxhuagnkvo\",\n                Vote(vec![((\"BAR\".to_string(), \"FOO\".to_string()), 10000)]),\n            ),\n            (\n                6,\n                \"rsgnawburh\",\n                Vote(vec![((\"BAR\".to_string(), \"FOO\".to_string()), 10000)]),\n            ),\n        ],\n    );\n\n    let (users, tokens, ve_events_tuples, events_tuples) = case;\n    let tokens = tokens.iter().map(|item| item.to_string()).collect_vec();\n    let ve_events_tuples = ve_events_tuples\n        .iter()\n        .map(|(period, user, event)| (*period, user.to_string(), event.clone()))\n        .collect_vec();\n    let events_tuples = events_tuples\n        .iter()\n        .map(|(period, user, event)| (*period, user.to_string(), event.clone()))\n        .collect_vec();\n\n    let mut simulator = Simulator::init(\u0026users);\n    simulator.simulate_case(\u0026tokens, \u0026ve_events_tuples[..], \u0026events_tuples[..]);\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","contract.rs"],"content":"use cosmwasm_std::{entry_point, DepsMut, Env, MessageInfo, Response};\nuse cw2::set_contract_version;\n\nuse astroport::staking::{ConfigResponse, QueryMsg};\nuse astroport_governance::hub::{Config, InstantiateMsg, MigrateMsg};\n\nuse crate::{error::ContractError, state::CONFIG};\n\n/// Contract name that is used for migration.\nconst CONTRACT_NAME: \u0026str = \"astroport-hub\";\n/// Contract version that is used for migration.\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Instantiates the contract, storing the config and querying the staking contract.\n/// Returns a `Response` object on successful execution or a `ContractError` on failure.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    // Query staking contract for ASTRO and xASTRO address\n    let staking_config: ConfigResponse = deps\n        .querier\n        .query_wasm_smart(\u0026msg.staking_addr, \u0026QueryMsg::Config {})?;\n\n    let config = Config {\n        owner: deps.api.addr_validate(\u0026msg.owner)?,\n        assembly_addr: deps.api.addr_validate(\u0026msg.assembly_addr)?,\n        cw20_ics20_addr: deps.api.addr_validate(\u0026msg.cw20_ics20_addr)?,\n        staking_addr: deps.api.addr_validate(\u0026msg.staking_addr)?,\n        token_addr: staking_config.deposit_token_addr,\n        xtoken_addr: staking_config.share_token_addr,\n        generator_controller_addr: deps.api.addr_validate(\u0026msg.generator_controller_addr)?,\n        ibc_timeout_seconds: msg.ibc_timeout_seconds,\n    };\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::default())\n}\n\n/// Migrates the contract to a new version.\n#[entry_point]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    // TODO: Return error\n    Ok(Response::default())\n}\n","traces":[{"line":17,"address":[15214476,15213184,15217558],"length":1,"stats":{"Line":7},"fn_name":"instantiate"},{"line":23,"address":[994250,994366,994472],"length":1,"stats":{"Line":12},"fn_name":null},{"line":26,"address":[994598,994442,994888,994434],"length":1,"stats":{"Line":19},"fn_name":null},{"line":28,"address":[994438,994824],"length":1,"stats":{"Line":7},"fn_name":null},{"line":31,"address":[15213766,15214222,15214014],"length":1,"stats":{"Line":15},"fn_name":null},{"line":32,"address":[995391,995158,995491,995605],"length":1,"stats":{"Line":21},"fn_name":null},{"line":33,"address":[996016,995818,995555],"length":1,"stats":{"Line":14},"fn_name":null},{"line":34,"address":[995966,996292,996574],"length":1,"stats":{"Line":15},"fn_name":null},{"line":35,"address":[996444],"length":1,"stats":{"Line":8},"fn_name":null},{"line":36,"address":[996484],"length":1,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[997037,996524,997352,996907],"length":1,"stats":{"Line":23},"fn_name":null},{"line":38,"address":[997069],"length":1,"stats":{"Line":6},"fn_name":null},{"line":40,"address":[997304,997848,997930],"length":1,"stats":{"Line":15},"fn_name":null},{"line":42,"address":[998295,997900],"length":1,"stats":{"Line":14},"fn_name":null},{"line":47,"address":[998680,998544],"length":1,"stats":{"Line":0},"fn_name":"migrate"},{"line":49,"address":[998625,998566],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":14,"coverable":16},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse serde_json_wasm::de::Error as SerdeError;\nuse thiserror::Error;\n\n/// This enum describes Hub's contract errors\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unable to parse: {0}\")]\n    ParseError(#[from] std::num::ParseIntError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"You can not send 0 tokens\")]\n    ZeroAmount {},\n\n    #[error(\"The provided address does not have any funds\")]\n    NoFunds {},\n\n    #[error(\"The action {} is not allowed via an IBC memo\", action)]\n    NotMemoAction { action: String },\n\n    #[error(\n        \"The action {} is not allowed via IBC and must be actioned via a tranfer memo\",\n        action\n    )]\n    NotIBCAction { action: String },\n\n    #[error(\"Memo does not conform to the expected format: {}\", reason)]\n    InvalidMemo { reason: SerdeError },\n\n    #[error(\"Got a submessage reply with unknown id: {id}\")]\n    UnknownReplyId { id: u64 },\n\n    #[error(\"Invalid submessage {0}\", reason)]\n    InvalidSubmessage { reason: String },\n\n    #[error(\"Outpost already added, remove it first: {0}\", address)]\n    OutpostAlreadyAdded { address: String },\n\n    #[error(\"No Outpost found that matches the message channels\")]\n    UnknownOutpost {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","execute.rs"],"content":"use cosmwasm_std::{\n    entry_point, from_binary, to_binary, Addr, CosmosMsg, DepsMut, Env, MessageInfo, Response,\n    StdError, StdResult, SubMsg, WasmMsg,\n};\nuse cw20::{Cw20ExecuteMsg, Cw20ReceiveMsg};\n\nuse astroport::common::{claim_ownership, drop_ownership_proposal, propose_new_owner};\nuse astroport_governance::{\n    hub::{Config, Cw20HookMsg, ExecuteMsg},\n    interchain::Hub,\n};\n\nuse crate::{\n    error::ContractError,\n    reply::STAKE_ID,\n    state::{\n        OutpostChannels, ReplyData, CONFIG, OUTPOSTS, OWNERSHIP_PROPOSAL, REPLY_DATA, USER_FUNDS,\n    },\n};\n\n/// Exposes all the execute functions available in the contract.\n///\n/// ## Execute messages\n/// * **ExecuteMsg::Receive(msg)** Receives a message of type [`Cw20ReceiveMsg`] and processes\n/// it depending on the received template.\n///\n/// * **ExecuteMsg::UpdateConfig { assembly_addr, cw20_ics20_addr }** Update parameters in the Hub contract. Only the owner is allowed to\n/// update the config\n///\n/// * **ExecuteMsg::AddOutpost { outpost_addr, cw20_ics20_channel }** Add an Outpost to the contract,\n/// allowing new IBC connections and IBC messages\n///\n/// * **ExecuteMsg::RemoveOutpost { outpost_addr }** Removes an Outpost from the contract,\n/// blocking new IBC connections as well as any IBC messages\n///\n/// * **ExecuteMsg::ProposeNewOwner { new_owner, expires_in }** Creates a new request to change\n/// contract ownership.\n///\n/// * **ExecuteMsg::DropOwnershipProposal {}** Removes a request to change contract ownership.\n///\n/// * **ExecuteMsg::ClaimOwnership {}** Claims contract ownership.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::Receive(msg) =\u003e receive_cw20(deps, env, info, msg),\n        ExecuteMsg::UpdateConfig {\n            assembly_addr,\n            cw20_ics20_addr,\n        } =\u003e update_config(deps, env, info, assembly_addr, cw20_ics20_addr),\n        ExecuteMsg::AddOutpost {\n            outpost_addr,\n            cw20_ics20_channel,\n        } =\u003e add_outpost(deps, env, info, outpost_addr, cw20_ics20_channel),\n        ExecuteMsg::RemoveOutpost { outpost_addr } =\u003e remove_outpost(deps, env, info, outpost_addr),\n        ExecuteMsg::ProposeNewOwner {\n            new_owner,\n            expires_in,\n        } =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n\n            propose_new_owner(\n                deps,\n                info,\n                env,\n                new_owner,\n                expires_in,\n                config.owner,\n                OWNERSHIP_PROPOSAL,\n            )\n            .map_err(Into::into)\n        }\n        ExecuteMsg::DropOwnershipProposal {} =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n\n            drop_ownership_proposal(deps, info, config.owner, OWNERSHIP_PROPOSAL)\n                .map_err(Into::into)\n        }\n        ExecuteMsg::ClaimOwnership {} =\u003e {\n            claim_ownership(deps, info, env, OWNERSHIP_PROPOSAL, |deps, new_owner| {\n                CONFIG\n                    .update::\u003c_, StdError\u003e(deps.storage, |mut v| {\n                        v.owner = new_owner;\n                        Ok(v)\n                    })\n                    .map(|_| ())\n            })\n            .map_err(Into::into)\n        }\n    }\n}\n\n/// Receives a message of type [`Cw20ReceiveMsg`] and processes it depending on\n/// the received template\n///\n/// Funds received here must be from the CW20-ICS20 contract and is used for\n/// actions initiated from an Outpost that require ASTRO tokens\n///\n/// * **cw20_msg** CW20 message to process\nfn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // We only allow ASTRO tokens to be sent here\n    if info.sender != config.token_addr {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    // The sender of the ASTRO tokens must be the CW20-ICS20 contract\n    if cw20_msg.sender != config.cw20_ics20_addr {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    // We can't do anything with no tokens\n    if cw20_msg.amount.is_zero() {\n        return Err(ContractError::ZeroAmount {});\n    }\n\n    // Match the CW20 template\n    match from_binary(\u0026cw20_msg.msg)? {\n        Cw20HookMsg::OutpostMemo {\n            channel,\n            sender,\n            receiver,\n            memo,\n        } =\u003e handle_outpost_memo(deps, env, cw20_msg, channel, sender, receiver, memo),\n        Cw20HookMsg::TransferFailure { receiver } =\u003e {\n            handle_transfer_failure(deps, info, cw20_msg, receiver)\n        }\n    }\n}\n\n/// Handle the JSON memo from an Outpost by matching against the available\n/// actions.\n///\n/// If the memo is not in a valid format for the actions it is\n/// considered invalid.\n///\n/// If the memo wasn't intended for us we forward it to the original\n/// intended receiver\nfn handle_outpost_memo(\n    deps: DepsMut,\n    env: Env,\n    msg: Cw20ReceiveMsg,\n    receiving_channel: String,\n    original_sender: String,\n    original_receiver: String,\n    memo: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // If the receiver is not our contract we assume this is a transfer\n    // and the memo wasn't intended for us and the transfer should be completed\n    if env.contract.address != original_receiver {\n        let msg = handle_message_memo(deps, msg, original_receiver)?;\n        return Ok(Response::default()\n            .add_message(msg)\n            .add_attribute(\"hub\", \"handle_memo\")\n            .add_attribute(\"memo_type\", \"message\")\n            .add_attribute(\"sender\", original_sender));\n    }\n\n    // But if this was intended for us, parse and handle the memo\n    let sub_msg: SubMsg = match serde_json_wasm::from_str::\u003cHub\u003e(memo.as_str()) {\n        Ok(hub) =\u003e match hub {\n            Hub::Stake {} =\u003e handle_stake_instruction(\n                deps,\n                env,\n                msg,\n                receiving_channel,\n                original_sender.clone(),\n            )?,\n            _ =\u003e {\n                return Err(ContractError::NotMemoAction {\n                    action: hub.to_string(),\n                })\n            }\n        },\n        Err(reason) =\u003e {\n            // This memo doesn't match any of our action formats\n            // In case the receiver is set to our handler contract we\n            // assume the funds were intended to have a valid action but\n            // are invalid, thus we need to fail the transaction and return\n            // the funds\n            return Err(ContractError::InvalidMemo { reason });\n        }\n    };\n\n    Ok(Response::default()\n        .add_submessage(sub_msg)\n        .add_attribute(\"hub\", \"handle_memo\")\n        .add_attribute(\"memo_type\", \"instruction\")\n        .add_attribute(\"sender\", original_sender))\n}\n\n/// Handle a stake instruction sent via memo from an Outpost\n///\n/// The full amount is staked and the resulting xASTRO is sent to the\n/// original sender on the Outpost\nfn handle_stake_instruction(\n    deps: DepsMut,\n    _env: Env,\n    msg: Cw20ReceiveMsg,\n    receiving_channel: String,\n    original_sender: String,\n) -\u003e Result\u003cSubMsg, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Stake all the received ASTRO tokens\n    // We need a SubMessage here to ensure we only mint the actual\n    // amount of ASTRO that was staked, which *might* not the full amount sent\n    let enter_msg = astroport::staking::Cw20HookMsg::Enter {};\n    let send_msg = Cw20ExecuteMsg::Send {\n        contract: config.staking_addr.to_string(),\n        amount: msg.amount,\n        msg: to_binary(\u0026enter_msg)?,\n    };\n\n    // Execute the message, we're using a CW20, so no funds added here\n    let stake_msg = WasmMsg::Execute {\n        contract_addr: config.token_addr.to_string(),\n        msg: to_binary(\u0026send_msg)?,\n        funds: vec![],\n    };\n\n    // Temporarily save the data needed for the SubMessage reply\n    let reply_data = ReplyData {\n        receiver: original_sender,\n        receiving_channel,\n    };\n    REPLY_DATA.save(deps.storage, \u0026reply_data)?;\n\n    Ok(SubMsg::reply_always(stake_msg, STAKE_ID))\n}\n\n/// Handle a memo that were sent to a different recipient and doesn't require\n/// us to action\nfn handle_message_memo(\n    deps: DepsMut,\n    msg: Cw20ReceiveMsg,\n    original_receiver: String,\n) -\u003e Result\u003cCosmosMsg, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Transfer the ASTRO to the original receiver\n    let msg = Cw20ExecuteMsg::Transfer {\n        recipient: original_receiver,\n        amount: msg.amount,\n    };\n    Ok(WasmMsg::Execute {\n        contract_addr: config.token_addr.to_string(),\n        msg: to_binary(\u0026msg)?,\n        funds: vec![],\n    }\n    .into())\n}\n\n/// Update the Hub config\nfn update_config(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    assembly_addr: Option\u003cString\u003e,\n    cw20_ics20_addr: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    // Only owner can update the config\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(assembly_addr) = assembly_addr {\n        config.assembly_addr = deps.api.addr_validate(\u0026assembly_addr)?;\n    }\n\n    if let Some(cw20_ics20_addr) = cw20_ics20_addr {\n        config.cw20_ics20_addr = deps.api.addr_validate(\u0026cw20_ics20_addr)?;\n    }\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::default())\n}\n\n/// Add an Outpost to the Hub\n///\n/// Adding an Outpost requires the Outpost address and the CW20-ICS20 channel\n/// where funds will be sent through. Adding an Outpost will allow a new IBC\n/// channel to be established with the Outpost and the Hub\nfn add_outpost(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    outpost_addr: String,\n    cw20_ics20_channel: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Only owner can add Outposts\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let result = OUTPOSTS.load(deps.storage, outpost_addr.clone());\n    if result.is_ok() {\n        return Err(ContractError::OutpostAlreadyAdded {\n            address: outpost_addr,\n        });\n    }\n\n    // The Outpost channel will be determined during the IBC handshake\n    let outpost = OutpostChannels {\n        outpost: determine_outpost_channel(),\n        cw20_ics20: cw20_ics20_channel.clone(),\n    };\n\n    // Store the CW20-ICS20 transfer channel for the Outpost\n    OUTPOSTS.save(deps.storage, outpost_addr.clone(), \u0026outpost)?;\n\n    Ok(Response::default()\n        .add_attribute(\"action\", \"add_outpost\")\n        .add_attribute(\"address\", outpost_addr)\n        .add_attribute(\"cw20_ics20_channel\", cw20_ics20_channel))\n}\n\n/// Remove and Outpost from the Hub\n///\n/// Removing an Outpost will block new IBC channels to be established between the\n/// Hub and the provided Outpost. All IBC messages will also fail\n///\n/// IMPORTANT: This does not close any existing IBC channels\nfn remove_outpost(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    outpost_addr: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Only owner can remove Outposts\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    OUTPOSTS.remove(deps.storage, outpost_addr.clone());\n\n    Ok(Response::default()\n        .add_attribute(\"action\", \"remove_outpost\")\n        .add_attribute(\"address\", outpost_addr))\n}\n\n/// Handle failed CW20-ICS20 IBC transfers\n///\n/// If a CW20-ICS20 IBC transfer fails that we initiated, we receive the original\n/// tokens back and need to store them for the user to retrieve manually\n///\n/// Once funds are held here, the original user will need to issue a withdraw\n/// transaction on the Outpost to retrieve their funds.\nfn handle_transfer_failure(\n    deps: DepsMut,\n    info: MessageInfo,\n    msg: Cw20ReceiveMsg,\n    receiver: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let user_addr = Addr::unchecked(receiver.clone());\n    USER_FUNDS.update(deps.storage, user_addr, |balance| -\u003e StdResult\u003c_\u003e {\n        Ok(balance.unwrap_or_default().checked_add(msg.amount)?)\n    })?;\n\n    Ok(Response::default()\n        .add_attribute(\"outpost_handler\", \"handle_transfer_failure\")\n        .add_attribute(\"sender\", info.sender)\n        .add_attribute(\"og_receiver\", receiver))\n}\n\n/// Determine the channel for an Outpost contract\n///\n/// This is only used for testing and must return None when deployed on-chain\n/// The channel will be determined and stored during the creation of the channel\n#[cfg(not(feature = \"mock-channels\"))]\nfn determine_outpost_channel() -\u003e Option\u003cString\u003e {\n    None\n}\n\n/// Determine the channel for an Outpost contract\n///\n/// This is only used for testing and sets the channel to a known value\n/// to be able to mock incoming messages\n#[cfg(feature = \"mock-channels\")]\nfn determine_outpost_channel() -\u003e Option\u003cString\u003e {\n    Some(\"channel-3\".to_string())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::{testing::mock_info, Uint128};\n\n    use crate::{\n        contract::instantiate,\n        execute::execute,\n        mock::{\n            mock_all, ASSEMBLY, ASTRO_TOKEN, GENERATOR_CONTROLLER, OWNER, STAKING, XASTRO_TOKEN,\n        },\n        query::query,\n    };\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Adding and removing Outposts work correctly\n    //\n    // Expect Error\n    //      - Adding an Outpost with duplicate address\n    //      - Adding an Outpost when not the owner\n    //      - Removing an Outpost when not the owner\n    //\n    #[test]\n    fn add_remove_outpost() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"wasm1contractaddress1\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"wasm1contractaddress2\".to_string(),\n                cw20_ics20_channel: \"channel-2\".to_string(),\n            },\n        )\n        .unwrap();\n\n        let outposts = query(\n            deps.as_ref(),\n            env.clone(),\n            astroport_governance::hub::QueryMsg::Outposts {},\n        )\n        .unwrap();\n\n        assert_eq!(\n            outposts,\n            to_binary(\u0026vec![\n                astroport_governance::hub::OutpostConfig {\n                    address: \"wasm1contractaddress1\".to_string(),\n                    channel: \"channel-3\".to_string(),\n                    cw20_ics20_channel: \"channel-1\".to_string(),\n                },\n                astroport_governance::hub::OutpostConfig {\n                    address: \"wasm1contractaddress2\".to_string(),\n                    channel: \"channel-3\".to_string(),\n                    cw20_ics20_channel: \"channel-2\".to_string(),\n                }\n            ])\n            .unwrap()\n        );\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::RemoveOutpost {\n                outpost_addr: \"wasm1contractaddress1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        let outposts = query(\n            deps.as_ref(),\n            env.clone(),\n            astroport_governance::hub::QueryMsg::Outposts {},\n        )\n        .unwrap();\n\n        assert_eq!(\n            outposts,\n            to_binary(\u0026vec![astroport_governance::hub::OutpostConfig {\n                address: \"wasm1contractaddress2\".to_string(),\n                channel: \"channel-3\".to_string(),\n                cw20_ics20_channel: \"channel-2\".to_string(),\n            },])\n            .unwrap()\n        );\n\n        // Must not allow duplicate Outpost addresses\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"wasm1contractaddress2\".to_string(),\n                cw20_ics20_channel: \"channel-2\".to_string(),\n            },\n        )\n        .unwrap_err();\n        assert!(matches!(\n            err,\n            ContractError::OutpostAlreadyAdded { address: _ }\n        ));\n\n        // Must not allow adding if not the owner\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(\"not_owner\", \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"wasm1contractaddress3\".to_string(),\n                cw20_ics20_channel: \"channel-4\".to_string(),\n            },\n        )\n        .unwrap_err();\n        assert!(matches!(err, ContractError::Unauthorized {}));\n\n        // Must not allow removing if not the owner\n        let err = execute(\n            deps.as_mut(),\n            env,\n            mock_info(\"not_owner\", \u0026[]),\n            astroport_governance::hub::ExecuteMsg::RemoveOutpost {\n                outpost_addr: \"wasm1contractaddress2\".to_string(),\n            },\n        )\n        .unwrap_err();\n        assert!(matches!(err, ContractError::Unauthorized {}));\n    }\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Updating config works\n    //\n    // Expect Error\n    //      - Updating config with invalid addresses\n    //      - Updating config when not the owner\n    //\n    #[test]\n    fn update_config() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        let config = query(\n            deps.as_ref(),\n            env.clone(),\n            astroport_governance::hub::QueryMsg::Config {},\n        )\n        .unwrap();\n\n        // Ensure the config set during instantiation is correct\n        assert_eq!(\n            config,\n            to_binary(\u0026astroport_governance::hub::Config {\n                owner: Addr::unchecked(OWNER),\n                assembly_addr: Addr::unchecked(ASSEMBLY),\n                cw20_ics20_addr: Addr::unchecked(\"cw20_ics20\"),\n                staking_addr: Addr::unchecked(STAKING),\n                token_addr: Addr::unchecked(ASTRO_TOKEN),\n                xtoken_addr: Addr::unchecked(XASTRO_TOKEN),\n                generator_controller_addr: Addr::unchecked(GENERATOR_CONTROLLER),\n                ibc_timeout_seconds: 10,\n            })\n            .unwrap()\n        );\n\n        // Update the Assembly and CW20-ICS20 addresses\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::UpdateConfig {\n                assembly_addr: Some(\"new_assembly\".to_string()),\n                cw20_ics20_addr: Some(\"new_cw20_ics20\".to_string()),\n            },\n        )\n        .unwrap();\n\n        // Query the new config\n        let config = query(\n            deps.as_ref(),\n            env.clone(),\n            astroport_governance::hub::QueryMsg::Config {},\n        )\n        .unwrap();\n\n        assert_eq!(\n            config,\n            to_binary(\u0026astroport_governance::hub::Config {\n                owner: Addr::unchecked(OWNER),\n                assembly_addr: Addr::unchecked(\"new_assembly\"),\n                cw20_ics20_addr: Addr::unchecked(\"new_cw20_ics20\"),\n                staking_addr: Addr::unchecked(STAKING),\n                token_addr: Addr::unchecked(ASTRO_TOKEN),\n                xtoken_addr: Addr::unchecked(XASTRO_TOKEN),\n                generator_controller_addr: Addr::unchecked(GENERATOR_CONTROLLER),\n                ibc_timeout_seconds: 10,\n            })\n            .unwrap()\n        );\n\n        // Must not allow updating with invalid addresses\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::UpdateConfig {\n                assembly_addr: Some(\"\".to_string()),\n                cw20_ics20_addr: None,\n            },\n        )\n        .unwrap_err();\n\n        assert!(matches!(err, ContractError::Std(_)));\n\n        // Must not allow updating if not the owner\n        let err = execute(\n            deps.as_mut(),\n            env,\n            mock_info(\"not_owner\", \u0026[]),\n            astroport_governance::hub::ExecuteMsg::UpdateConfig {\n                assembly_addr: Some(\"\".to_string()),\n                cw20_ics20_addr: None,\n            },\n        )\n        .unwrap_err();\n\n        assert!(matches!(err, ContractError::Unauthorized {}));\n    }\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Sending the funds results in correct balances\n    //\n    // Expect Error\n    //      - When not sent by the CW20-ICS20 contract\n    //      - When tokens are not ASTRO\n    //      - When amount is zero\n    //\n    // This tests that balances are correctly tracked by the contract in case of\n    // IBC failures that result in funds getting stuck on the Hub\n    #[test]\n    fn cw20_ics20_transfer_failure() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        let user1 = \"user1\";\n        let user2 = \"user2\";\n        let user1_funds = Uint128::from(100u128);\n        let user2_funds = Uint128::from(300u128);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        // Add an allowed Outpost\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"outpost\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        // Transfer failures are only allowed to be recorded when sent by the\n        // CW20-ICS20 contract\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::Receive(Cw20ReceiveMsg {\n                sender: \"cw20_ics20\".to_string(),\n                amount: user1_funds,\n                msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::TransferFailure {\n                    receiver: user1.to_owned(),\n                })\n                .unwrap(),\n            }),\n        )\n        .unwrap_err();\n\n        assert!(matches!(err, ContractError::Unauthorized {}));\n\n        // Transfer failures must only accept ASTRO tokens\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(\"cw20_ics20\", \u0026[]),\n            astroport_governance::hub::ExecuteMsg::Receive(Cw20ReceiveMsg {\n                sender: \"cw20_ics20\".to_string(),\n                amount: user1_funds,\n                msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::TransferFailure {\n                    receiver: user1.to_owned(),\n                })\n                .unwrap(),\n            }),\n        )\n        .unwrap_err();\n\n        assert!(matches!(err, ContractError::Unauthorized {}));\n\n        // Transfer failures will must not accept zero amounts\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(ASTRO_TOKEN, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::Receive(Cw20ReceiveMsg {\n                sender: \"cw20_ics20\".to_string(),\n                amount: Uint128::zero(),\n                msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::TransferFailure {\n                    receiver: user1.to_owned(),\n                })\n                .unwrap(),\n            }),\n        )\n        .unwrap_err();\n\n        assert!(matches!(err, ContractError::ZeroAmount {}));\n\n        // Add a valid failure for user\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(ASTRO_TOKEN, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::Receive(Cw20ReceiveMsg {\n                sender: \"cw20_ics20\".to_string(),\n                amount: user1_funds,\n                msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::TransferFailure {\n                    receiver: user1.to_owned(),\n                })\n                .unwrap(),\n            }),\n        )\n        .unwrap();\n\n        // Verify that the amount was added to the user's balance\n        let stuck_funds = USER_FUNDS\n            .load(\u0026deps.storage, Addr::unchecked(user1))\n            .unwrap();\n\n        assert_eq!(stuck_funds, user1_funds);\n\n        execute(\n            deps.as_mut(),\n            env,\n            mock_info(ASTRO_TOKEN, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::Receive(Cw20ReceiveMsg {\n                sender: \"cw20_ics20\".to_string(),\n                amount: user2_funds,\n                msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::TransferFailure {\n                    receiver: user2.to_owned(),\n                })\n                .unwrap(),\n            }),\n        )\n        .unwrap();\n\n        // Verify that the amount was added to the user's balance\n        let stuck_funds = USER_FUNDS\n            .load(\u0026deps.storage, Addr::unchecked(user2))\n            .unwrap();\n\n        assert_eq!(stuck_funds, user2_funds);\n    }\n}\n","traces":[{"line":43,"address":[791776,793669,795353],"length":1,"stats":{"Line":8},"fn_name":"execute"},{"line":49,"address":[791816],"length":1,"stats":{"Line":6},"fn_name":null},{"line":50,"address":[795329,791934],"length":1,"stats":{"Line":5},"fn_name":null},{"line":51,"address":[792151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[792376],"length":1,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[792601,795314],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[792811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[792828,794151,794562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[794289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[794332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[794399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[794439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[793178,792865,793442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[793306,793602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[793134,792912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[1700137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[1700192,1700095,1700390],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":87,"address":[1700315,1700222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[1700342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[1700416,1700417],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":104,"address":[777914,776128,776904],"length":1,"stats":{"Line":2},"fn_name":"receive_cw20"},{"line":110,"address":[776165,776299,776438],"length":1,"stats":{"Line":5},"fn_name":null},{"line":113,"address":[776407,776590],"length":1,"stats":{"Line":5},"fn_name":null},{"line":114,"address":[776633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[776701,776601],"length":1,"stats":{"Line":5},"fn_name":null},{"line":119,"address":[776732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[776712,776783],"length":1,"stats":{"Line":5},"fn_name":null},{"line":124,"address":[776818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[776915,776794,776884],"length":1,"stats":{"Line":8},"fn_name":null},{"line":129,"address":[777305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[777611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[777643,777813],"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[777968,779047,781166],"length":1,"stats":{"Line":2},"fn_name":"handle_outpost_memo"},{"line":160,"address":[778249,778056],"length":1,"stats":{"Line":3},"fn_name":null},{"line":161,"address":[778575,778301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[778545,778781,778928],"length":1,"stats":{"Line":3},"fn_name":null},{"line":163,"address":[778717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[778897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[778263,779098],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[779130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[779396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[779471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[779534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[779573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[779670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[779611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[779187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[779251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[780735,780611,780882],"length":1,"stats":{"Line":3},"fn_name":null},{"line":196,"address":[780671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[780851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[781804,783710,781200],"length":1,"stats":{"Line":1},"fn_name":"handle_stake_instruction"},{"line":213,"address":[781242,781514,781368],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[781471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[781479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[781667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[781699,781747,781983,781824],"length":1,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[781948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[782259,782211,782402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[782375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[782879,782956,783168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[783012,783558],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[784376,785122,783728],"length":1,"stats":{"Line":1},"fn_name":"handle_message_memo"},{"line":249,"address":[783857,784107,783755],"length":1,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[784005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[784890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[784072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[784497,784322,784406,784274],"length":1,"stats":{"Line":3},"fn_name":null},{"line":259,"address":[784470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[785152,787683,786340],"length":1,"stats":{"Line":1},"fn_name":"update_config"},{"line":272,"address":[785489,785344,785206],"length":1,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[785664,785455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[785713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[785796,785675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[785973,786211,785827],"length":1,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[785875,786364],"length":1,"stats":{"Line":2},"fn_name":null},{"line":284,"address":[786788,786550,786395],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[786999,786446,786917],"length":1,"stats":{"Line":2},"fn_name":null},{"line":289,"address":[787368,786969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[788761,787712,789646],"length":1,"stats":{"Line":4},"fn_name":"add_outpost"},{"line":304,"address":[787754,788014,787872],"length":1,"stats":{"Line":11},"fn_name":null},{"line":307,"address":[788169,787983],"length":1,"stats":{"Line":10},"fn_name":null},{"line":308,"address":[788226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[788185,788303],"length":1,"stats":{"Line":11},"fn_name":null},{"line":312,"address":[788341,788396],"length":1,"stats":{"Line":10},"fn_name":null},{"line":313,"address":[788473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[788430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[788410],"length":1,"stats":{"Line":6},"fn_name":null},{"line":321,"address":[788589],"length":1,"stats":{"Line":4},"fn_name":null},{"line":325,"address":[788938,788726,788821],"length":1,"stats":{"Line":11},"fn_name":null},{"line":327,"address":[789225,788911,789396,789313],"length":1,"stats":{"Line":19},"fn_name":null},{"line":329,"address":[789282],"length":1,"stats":{"Line":6},"fn_name":null},{"line":330,"address":[789365],"length":1,"stats":{"Line":6},"fn_name":null},{"line":339,"address":[790701,789664,790639],"length":1,"stats":{"Line":1},"fn_name":"remove_outpost"},{"line":345,"address":[789803,789701,789939],"length":1,"stats":{"Line":2},"fn_name":null},{"line":348,"address":[789911,790091],"length":1,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[790150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[790363,790107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[790385,790492],"length":1,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[790461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[791673,790720,791606],"length":1,"stats":{"Line":1},"fn_name":"handle_transfer_failure"},{"line":372,"address":[790764,790853],"length":1,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[790883,791119],"length":1,"stats":{"Line":2},"fn_name":null},{"line":374,"address":[1700000,1699877],"length":1,"stats":{"Line":2},"fn_name":null},{"line":377,"address":[791362,791034,791441,791274],"length":1,"stats":{"Line":4},"fn_name":null},{"line":379,"address":[791331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[791410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":397,"address":[791696],"length":1,"stats":{"Line":5},"fn_name":"determine_outpost_channel"},{"line":398,"address":[791709],"length":1,"stats":{"Line":6},"fn_name":null}],"covered":93,"coverable":109},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","ibc.rs"],"content":"use cosmwasm_std::{\n    entry_point, from_binary, to_binary, Deps, DepsMut, Env, Ibc3ChannelOpenResponse,\n    IbcBasicResponse, IbcChannelCloseMsg, IbcChannelConnectMsg, IbcChannelOpenMsg,\n    IbcChannelOpenResponse, IbcOrder, IbcPacketAckMsg, IbcPacketReceiveMsg, IbcPacketTimeoutMsg,\n    IbcReceiveResponse, StdError, StdResult, SubMsg,\n};\n\nuse astroport_governance::interchain::{get_contract_from_ibc_port, Hub, Outpost, Response};\n\nuse crate::{\n    error::ContractError,\n    ibc_governance::{\n        handle_ibc_cast_assembly_vote, handle_ibc_cast_emissions_vote, handle_ibc_unlock,\n    },\n    ibc_misc::handle_ibc_withdraw_stuck_funds,\n    ibc_query::handle_ibc_query_proposal,\n    ibc_staking::{construct_unstake_msg, handle_ibc_unstake},\n    reply::UNSTAKE_ID,\n    state::OUTPOSTS,\n};\n\npub const IBC_APP_VERSION: \u0026str = \"astroport-outpost-v1\";\npub const IBC_ORDERING: IbcOrder = IbcOrder::Unordered;\n\n/// Handle the opening of a new IBC channel\n///\n/// We verify that the connection is using the correct configuration\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_channel_open(\n    _deps: DepsMut,\n    _env: Env,\n    msg: IbcChannelOpenMsg,\n) -\u003e Result\u003cIbcChannelOpenResponse, ContractError\u003e {\n    let channel = msg.channel();\n\n    if channel.order != IBC_ORDERING {\n        return Err(ContractError::Std(StdError::generic_err(\n            \"Ordering is invalid. The channel must be unordered\".to_string(),\n        )));\n    }\n    if channel.version != IBC_APP_VERSION {\n        return Err(ContractError::Std(StdError::generic_err(format!(\n            \"Must set version to `{IBC_APP_VERSION}`\"\n        ))));\n    }\n\n    if let Some(counter_version) = msg.counterparty_version() {\n        if counter_version != IBC_APP_VERSION {\n            return Err(ContractError::Std(StdError::generic_err(format!(\n                \"Counterparty version must be `{IBC_APP_VERSION}`\"\n            ))));\n        }\n    }\n\n    Ok(Some(Ibc3ChannelOpenResponse {\n        version: IBC_APP_VERSION.to_string(),\n    }))\n}\n\n/// Handle the connection of a new IBC channel\n///\n/// We verify that the connection is being made to an allowed Outpost and\n/// if the channel has not been set, add it\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_channel_connect(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcChannelConnectMsg,\n) -\u003e Result\u003cIbcBasicResponse, ContractError\u003e {\n    let channel = msg.channel();\n\n    // Ensure only a listed Outpost can connect, if allowed and not added yet - add it now\n    let counterparty_port =\n        get_contract_from_ibc_port(channel.counterparty_endpoint.port_id.as_str());\n    OUTPOSTS.update(deps.storage, counterparty_port.to_string(), |outpost| {\n        outpost\n            .ok_or(ContractError::Std(StdError::generic_err(format!(\n                \"Connection with `{}` is not allowed\",\n                counterparty_port\n            ))))\n            .and_then(|mut channels| match channels.outpost {\n                // If we already have the channel set, fail\n                Some(_) =\u003e Err(ContractError::Std(StdError::generic_err(format!(\n                    \"Channel with `{}` has already been set\",\n                    counterparty_port\n                )))),\n                None =\u003e {\n                    channels.outpost = Some(channel.endpoint.channel_id.clone());\n                    Ok(channels)\n                }\n            })\n    })?;\n\n    Ok(IbcBasicResponse::new()\n        .add_attribute(\"action\", \"ibc_connect\")\n        .add_attribute(\"channel_id\", \u0026channel.endpoint.channel_id))\n}\n\n/// Handle the receiving the packets while wrapping the actual call to provide\n/// returning errors as an acknowledgement.\n///\n/// This allows the original caller from another chain to handle the failure\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_packet_receive(\n    deps: DepsMut,\n    env: Env,\n    msg: IbcPacketReceiveMsg,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    block_unauthorized_packets(deps.as_ref(), msg.packet.src.port_id.clone())?;\n\n    do_packet_receive(deps, env, msg).or_else(|err| {\n        // Construct an error acknowledgement that can be handled on the Outpost\n        let ack_data = to_binary(\u0026Response::new_error(err.to_string())).unwrap();\n\n        Ok(IbcReceiveResponse::new()\n            .add_attribute(\"action\", \"ibc_packet_receive\")\n            .add_attribute(\"error\", err.to_string())\n            .set_ack(ack_data))\n    })\n}\n\n/// Process the received packet and return the response\n///\n/// Packets are expected to be wrapped in the Hub format, if it doesn't conform\n/// it will be failed.\n///\n/// If a ContractError is returned, it will be wrapped into a Response\n/// containing the error to be handled on the Outpost\nfn do_packet_receive(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcPacketReceiveMsg,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    // Parse the packet data into a Hub message\n    let outpost_msg: Hub = from_binary(\u0026msg.packet.data)?;\n    match outpost_msg {\n        Hub::QueryProposal { id } =\u003e handle_ibc_query_proposal(deps, id),\n        Hub::CastAssemblyVote {\n            proposal_id,\n            voter,\n            vote_option,\n            voting_power,\n        } =\u003e handle_ibc_cast_assembly_vote(deps, proposal_id, voter, vote_option, voting_power),\n        Hub::CastEmissionsVote {\n            voter,\n            voting_power,\n            votes,\n        } =\u003e handle_ibc_cast_emissions_vote(deps, voter, voting_power, votes),\n        Hub::Unstake { receiver, amount } =\u003e {\n            handle_ibc_unstake(deps, msg.packet.dest.channel_id, receiver, amount)\n        }\n        Hub::KickUnlockedVoter { voter } =\u003e handle_ibc_unlock(deps, voter),\n        Hub::WithdrawFunds { user } =\u003e {\n            handle_ibc_withdraw_stuck_funds(deps, msg.packet.dest.channel_id, user)\n        }\n        _ =\u003e Err(ContractError::NotIBCAction {\n            action: outpost_msg.to_string(),\n        }),\n    }\n}\n\n/// Handle IBC packet timeouts for messages we sent\n///\n/// Timeouts will cause certain actions to be reversed and, when applicable, return\n/// funds to the user\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_packet_timeout(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcPacketTimeoutMsg,\n) -\u003e Result\u003cIbcBasicResponse, ContractError\u003e {\n    // We check the destination port for timeouts as that is where the original\n    // packet was sent to\n    block_unauthorized_packets(deps.as_ref(), msg.packet.dest.port_id)?;\n\n    let failed_msg: Outpost = from_binary(\u0026msg.packet.data)?;\n    match failed_msg {\n        Outpost::MintXAstro { receiver, amount } =\u003e {\n            // If we get a timeout on a packet to mint remote xASTRO\n            // we need to undo the transaction and return the original ASTRO\n            // If we get another timeout returning the original ASTRO the funds\n            // will be held in this contract to withdraw later\n            let msg =\n                construct_unstake_msg(deps, msg.packet.dest.channel_id, receiver.clone(), amount)?;\n            let sub_msg = SubMsg::reply_always(msg, UNSTAKE_ID);\n\n            Ok(IbcBasicResponse::new()\n                .add_attribute(\"action\", \"ibc_packet_timeout\")\n                .add_submessage(sub_msg)\n                .add_attribute(\"original_action\", \"mint_remote_xastro\")\n                .add_attribute(\"original_receiver\", receiver)\n                .add_attribute(\"original_amount\", amount.to_string()))\n        }\n    }\n}\n\n/// Handle IBC packet acknowledgements for messages we sent\n///\n/// We don't need acks for now, we handle failures instead\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_packet_ack(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcPacketAckMsg,\n) -\u003e Result\u003cIbcBasicResponse, ContractError\u003e {\n    // We check the destination port for acks as that is where the original\n    // packet was sent to\n    block_unauthorized_packets(deps.as_ref(), msg.original_packet.dest.port_id)?;\n    Ok(IbcBasicResponse::new().add_attribute(\"action\", \"ibc_packet_ack\"))\n}\n\n/// Handle the closing of IBC channels, which we don't allow\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_channel_close(\n    _deps: DepsMut,\n    _env: Env,\n    _channel: IbcChannelCloseMsg,\n) -\u003e StdResult\u003cIbcBasicResponse\u003e {\n    Err(StdError::generic_err(\"Closing channel is not allowed\"))\n}\n\n/// Checks the provided port against the Outpost list.\n///\n/// If the port doesn't exist, this function will  return an error, effectively blocking the packet.\nfn block_unauthorized_packets(deps: Deps, port_id: String) -\u003e Result\u003c(), ContractError\u003e {\n    let counterparty_port = get_contract_from_ibc_port(port_id.as_str());\n    OUTPOSTS\n        .load(deps.storage, counterparty_port.to_string())\n        .map(|_| ())\n        .map_err(|_| ContractError::Unauthorized {})\n}\n","traces":[{"line":29,"address":[1716734,1715584,1716707],"length":1,"stats":{"Line":0},"fn_name":"ibc_channel_open"},{"line":34,"address":[1715619,1715681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1715689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[1715782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[1715755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[1715875,1715733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[1715910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[1715886,1716151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[1716228,1716292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[1716298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[1716602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[1716258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[1717633,1716752,1717606],"length":1,"stats":{"Line":0},"fn_name":"ibc_channel_connect"},{"line":70,"address":[1716854,1716792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[1716862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[1065371,1065344,1064880],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":76,"address":[1065305,1065234,1064906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[1065031,1064954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[1065392,1065279,1065424,1066034],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":83,"address":[1065585,1065512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[1065481,1065791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[1065957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[1717483,1717403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[1717479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[1717648,1718210],"length":1,"stats":{"Line":4},"fn_name":"ibc_packet_receive"},{"line":109,"address":[1717777,1718024,1717680],"length":1,"stats":{"Line":6},"fn_name":null},{"line":111,"address":[1066411,1066192,1066828],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":113,"address":[1066213,1066280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[1066761,1066602,1066699,1066463],"length":1,"stats":{"Line":7},"fn_name":null},{"line":116,"address":[1066538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[1066734,1066554,1066657],"length":1,"stats":{"Line":4},"fn_name":null},{"line":118,"address":[1066665],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[1712768,1714392,1715234],"length":1,"stats":{"Line":4},"fn_name":"do_packet_receive"},{"line":135,"address":[1712808,1713233,1712952],"length":1,"stats":{"Line":6},"fn_name":null},{"line":136,"address":[1713187],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[1713481,1714292],"length":1,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[1713514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[1713761,1714288],"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[1713786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[1713846,1714286],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[1713914,1714284],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[1713981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[1714282,1714015],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[1714144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[1713461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[1721115,1719248,1718256],"length":1,"stats":{"Line":0},"fn_name":"ibc_packet_timeout"},{"line":174,"address":[1718565,1718288,1718437],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[1718541,1718680,1718980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[1718825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[1719229,1719699,1719281,1719081,1718905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[1719543,1720174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[1720652,1720456,1720239,1720182,1720579,1720337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[1720291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[1720503,1720416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[1720511,1720644,1720769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[1721136,1721522,1722381],"length":1,"stats":{"Line":0},"fn_name":"ibc_packet_ack"},{"line":208,"address":[1721241,1721162,1721367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[1721822,1721340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[1722548,1722612,1722400],"length":1,"stats":{"Line":0},"fn_name":"ibc_channel_close"},{"line":219,"address":[1722424,1722494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[1715264,1715550],"length":1,"stats":{"Line":2},"fn_name":"block_unauthorized_packets"},{"line":226,"address":[1715299,1715367],"length":1,"stats":{"Line":6},"fn_name":null},{"line":227,"address":[1715459],"length":1,"stats":{"Line":4},"fn_name":null},{"line":228,"address":[1715419],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[1064816,1064817],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":230,"address":[1064832,1064855],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"}],"covered":24,"coverable":66},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","ibc_governance.rs"],"content":"use cosmwasm_std::{to_binary, Addr, DepsMut, IbcReceiveResponse, Uint128, WasmMsg};\n\nuse astroport_governance::{\n    assembly::ProposalVoteOption, generator_controller_lite, interchain::Response,\n};\n\nuse crate::{error::ContractError, state::CONFIG};\n\n/// Handle an IBC message to cast a vote on an Assembly proposal from an Outpost\n/// and return an IBC acknowledgement\n///\n/// The Outpost is responsible for checking and sending the voting power of the\n/// voter, we add an additional check to make sure that the voting power is not\n/// more than the xASTRO minted remotely via this channel\npub fn handle_ibc_cast_assembly_vote(\n    deps: DepsMut,\n    proposal_id: u64,\n    voter: Addr,\n    vote_option: ProposalVoteOption,\n    voting_power: Uint128,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // TODO Invariant check, voting power can't be more than the xASTRO sent via this channel\n\n    // Cast the vote in the Assembly\n    let vote_msg = astroport_governance::assembly::ExecuteMsg::CastOutpostVote {\n        proposal_id,\n        voter: voter.clone(),\n        vote: vote_option,\n        voting_power,\n    };\n    let msg = WasmMsg::Execute {\n        contract_addr: config.assembly_addr.to_string(),\n        msg: to_binary(\u0026vote_msg)?,\n        funds: vec![],\n    };\n\n    // If the vote succeeds, the ack will be sent back to the Outpost\n    let ack_data = to_binary(\u0026Response::new_success(\n        \"cast_assembly_vote\".to_owned(),\n        voter.to_string(),\n    ))?;\n\n    Ok(IbcReceiveResponse::new().add_message(msg).set_ack(ack_data))\n}\n\n/// Handle an IBC message to cast a vote on emissions during a voting period\n/// from an Outpost and return an IBC acknowledgement\n///\n/// The Outpost is responsible for checking and sending the voting power of the\n/// voter, we add an additional check to make sure that the voting power is not\n/// more than the xASTRO minted remotely via this channel. vxASTRO lite does\n/// not boost voting power and must be equal to the deposit\npub fn handle_ibc_cast_emissions_vote(\n    deps: DepsMut,\n    voter: Addr,\n    voting_power: Uint128,\n    votes: Vec\u003c(String, u16)\u003e,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // TODO Invariant check, voting power can't be more than the xASTRO sent via this channel\n\n    // Cast the emissions vote\n    let vote_msg = generator_controller_lite::ExecuteMsg::OutpostVote {\n        voter: voter.clone(),\n        votes,\n        voting_power,\n    };\n    let msg = WasmMsg::Execute {\n        contract_addr: config.generator_controller_addr.to_string(),\n        msg: to_binary(\u0026vote_msg)?,\n        funds: vec![],\n    };\n\n    // If the vote succeeds, the ack will be sent back to the Outpost\n    let ack_data = to_binary(\u0026Response::new_success(\n        \"cast_emissions_vote\".to_owned(),\n        voter.to_string(),\n    ))?;\n\n    Ok(IbcReceiveResponse::new().add_message(msg).set_ack(ack_data))\n}\n\n/// Handle an IBC message to kick an unlocked voter from the Outpost.\n///\n/// We rely on the Outpost to verify the unlock before sending it here. If this\n/// transaction succeeds, the voting power will be removed immediately\npub fn handle_ibc_unlock(deps: DepsMut, user: Addr) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Remove the vxASTRO voter's voting power\n    let unlock_msg = generator_controller_lite::ExecuteMsg::KickUnlockedOutpostVoter {\n        unlocked_voter: user.clone(),\n    };\n    let msg = WasmMsg::Execute {\n        contract_addr: config.generator_controller_addr.to_string(),\n        msg: to_binary(\u0026unlock_msg)?,\n        funds: vec![],\n    };\n\n    // If the vote succeeds, the ack will be sent back to the Outpost\n    let ack_data = to_binary(\u0026Response::new_success(\n        \"kick_unlocked\".to_owned(),\n        user.to_string(),\n    ))?;\n\n    Ok(IbcReceiveResponse::new().add_message(msg).set_ack(ack_data))\n}\n\n#[cfg(test)]\nmod tests {\n    use astroport_governance::interchain::Hub;\n    use cosmwasm_std::{from_binary, testing::mock_info, IbcPacketReceiveMsg, ReplyOn, SubMsg};\n\n    use super::*;\n    use crate::{\n        contract::instantiate,\n        execute::execute,\n        ibc::ibc_packet_receive,\n        mock::{mock_all, mock_ibc_packet, ASSEMBLY, GENERATOR_CONTROLLER, OWNER, STAKING},\n    };\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Submitting the vote results in an Assembly message\n    //\n    // Expect Error\n    //      - An error is returned instead\n    #[test]\n    fn ibc_assembly_vote() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        let voter = \"voter1234\";\n        let voting_power = Uint128::from(100u128);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"outpost\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        let proposal_id = 1u64;\n        let vote_option = ProposalVoteOption::For;\n\n        let ibc_unstake = to_binary(\u0026Hub::CastAssemblyVote {\n            proposal_id,\n            voter: Addr::unchecked(voter),\n            vote_option,\n            voting_power,\n        })\n        .unwrap();\n        let recv_packet = mock_ibc_packet(\"default\", ibc_unstake);\n\n        let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n        let res = ibc_packet_receive(deps.as_mut(), env, msg).unwrap();\n\n        let hub_respone: Response = from_binary(\u0026res.acknowledgement).unwrap();\n        match hub_respone {\n            Response::Result { error, .. } =\u003e {\n                assert!(error.is_none());\n            }\n            _ =\u003e panic!(\"Wrong response type\"),\n        }\n\n        assert_eq!(res.messages.len(), 1);\n\n        let assembly_msg = to_binary(\n            \u0026astroport_governance::assembly::ExecuteMsg::CastOutpostVote {\n                proposal_id,\n                vote: ProposalVoteOption::For,\n                voter: Addr::unchecked(voter),\n                voting_power,\n            },\n        )\n        .unwrap();\n\n        assert_eq!(\n            res.messages[0],\n            SubMsg {\n                id: 0,\n                gas_limit: None,\n                reply_on: ReplyOn::Never,\n                msg: WasmMsg::Execute {\n                    contract_addr: ASSEMBLY.to_string(),\n                    msg: assembly_msg,\n                    funds: vec![],\n                }\n                .into(),\n            }\n        );\n    }\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Submitting the vote results in a Generator controller message\n    //\n    // Expect Error\n    //      - An error is returned instead\n    #[test]\n    fn ibc_emissions_vote() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        let voter = \"voter1234\";\n        let voting_power = Uint128::from(100u128);\n        let votes = vec![(\"pooladdress\".to_string(), 10000)];\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"outpost\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        let ibc_unstake = to_binary(\u0026Hub::CastEmissionsVote {\n            voter: Addr::unchecked(voter),\n            voting_power,\n            votes: votes.clone(),\n        })\n        .unwrap();\n        let recv_packet = mock_ibc_packet(\"channel-3\", ibc_unstake);\n\n        let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n        let res = ibc_packet_receive(deps.as_mut(), env, msg).unwrap();\n\n        let hub_respone: Response = from_binary(\u0026res.acknowledgement).unwrap();\n        match hub_respone {\n            Response::Result { error, .. } =\u003e {\n                assert!(error.is_none());\n            }\n            _ =\u003e panic!(\"Wrong response type\"),\n        }\n\n        assert_eq!(res.messages.len(), 1);\n\n        let generator_controller_msg = to_binary(\n            \u0026astroport_governance::generator_controller_lite::ExecuteMsg::OutpostVote {\n                voter: Addr::unchecked(voter),\n                voting_power,\n                votes,\n            },\n        )\n        .unwrap();\n\n        assert_eq!(\n            res.messages[0],\n            SubMsg {\n                id: 0,\n                gas_limit: None,\n                reply_on: ReplyOn::Never,\n                msg: WasmMsg::Execute {\n                    contract_addr: GENERATOR_CONTROLLER.to_string(),\n                    msg: generator_controller_msg,\n                    funds: vec![],\n                }\n                .into(),\n            }\n        );\n    }\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Kicking the user results in a Generator controller message\n    //\n    // Expect Error\n    //      - An error is returned instead\n    #[test]\n    fn ibc_kick_unlocked() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        let voter = \"voter1234\";\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        // Add an allowed Outpost\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"outpost\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        // Kick the voter\n        let ibc_kick_unlocked = to_binary(\u0026Hub::KickUnlockedVoter {\n            voter: Addr::unchecked(voter),\n        })\n        .unwrap();\n        let recv_packet = mock_ibc_packet(\"channel-3\", ibc_kick_unlocked);\n\n        let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n        let res = ibc_packet_receive(deps.as_mut(), env, msg).unwrap();\n\n        let hub_respone: Response = from_binary(\u0026res.acknowledgement).unwrap();\n        match hub_respone {\n            Response::Result { error, .. } =\u003e {\n                assert!(error.is_none());\n            }\n            _ =\u003e panic!(\"Wrong response type\"),\n        }\n\n        // We must have one message\n        assert_eq!(res.messages.len(), 1);\n\n        // Verify that the message matches the expected message\n        let controller_msg = to_binary(\n        \u0026astroport_governance::generator_controller_lite::ExecuteMsg::KickUnlockedOutpostVoter {\n            unlocked_voter: Addr::unchecked(voter),\n        },\n        )\n        .unwrap();\n\n        assert_eq!(\n            res.messages[0],\n            SubMsg {\n                id: 0,\n                gas_limit: None,\n                reply_on: ReplyOn::Never,\n                msg: WasmMsg::Execute {\n                    contract_addr: GENERATOR_CONTROLLER.to_string(),\n                    msg: controller_msg,\n                    funds: vec![],\n                }\n                .into(),\n            }\n        );\n    }\n}\n","traces":[{"line":15,"address":[1272828,1271325,1270576],"length":1,"stats":{"Line":1},"fn_name":"handle_ibc_cast_assembly_vote"},{"line":22,"address":[1270772,1270662,1270901],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[1270886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[1271139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[1271271,1271223,1271336,1271427],"length":1,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[1271400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[1272037,1272252,1271897,1271964],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[1271763,1271836],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[1271844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[1272396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[1272848,1273633,1275225],"length":1,"stats":{"Line":1},"fn_name":"handle_ibc_cast_emissions_vote"},{"line":61,"address":[1273027,1272901,1273158],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[1273143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1273444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[1273644,1273735,1273579,1273531],"length":1,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[1273708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[1274560,1274272,1274345,1274205],"length":1,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[1274144,1274071],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[1274152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[1274774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[1275887,1277390,1275248],"length":1,"stats":{"Line":1},"fn_name":"handle_ibc_unlock"},{"line":91,"address":[1275380,1275270,1275509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[1275494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[1275698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[1275785,1275898,1275989,1275833],"length":1,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[1275962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[1276526,1276599,1276814,1276459],"length":1,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[1276325,1276398],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[1276406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[1276958],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":30,"coverable":30},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","ibc_misc.rs"],"content":"use cosmwasm_std::{to_binary, Addr, DepsMut, IbcReceiveResponse, WasmMsg};\nuse cw20::Cw20ExecuteMsg;\n\nuse astroport_governance::interchain::{Response, TransferMsg};\n\nuse crate::{\n    error::ContractError,\n    state::{get_transfer_channel_from_outpost_channel, CONFIG, USER_FUNDS},\n};\n\n/// Handle an IBC message to withdraw funds stuck on the Hub\n///\n/// In some cases where the CW20-ICS20 IBC transfer to the Outpost user fails\n/// (due to timeout or otherwise), the funds will be stuck on the Hub chain. In\n/// such a case the CW20-ICS20 contract will send the funds back here and this\n/// function will attempt to send them back to the user.\npub fn handle_ibc_withdraw_stuck_funds(\n    deps: DepsMut,\n    receive_channel: String,\n    user: Addr,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Check if this user has any funds stuck on the Hub chain\n    let balance = USER_FUNDS.load(deps.storage, user.clone())?;\n    if balance.is_zero() {\n        return Err(ContractError::NoFunds {});\n    }\n\n    // Map the channel the request was received on to the channel used in the\n    // CW20-ICS20 transfer\n    // We can use the request channel safely as the Outpost contract enforces the\n    // address, we can't receive a request for funds for a different address from an\n    // incorrect Outpost\n    // Example, and Injective address can't request funds from a Neutron channel\n    let outpost_channels =\n        get_transfer_channel_from_outpost_channel(deps.as_ref(), \u0026receive_channel)?;\n\n    // User has funds, try to send it back to them\n    let transfer_msg = TransferMsg {\n        channel: outpost_channels.cw20_ics20,\n        remote_address: user.to_string(),\n        timeout: Some(config.ibc_timeout_seconds),\n        memo: None,\n    };\n\n    let send_msg = Cw20ExecuteMsg::Send {\n        contract: config.cw20_ics20_addr.to_string(),\n        amount: balance,\n        msg: to_binary(\u0026transfer_msg)?,\n    };\n\n    let msg = WasmMsg::Execute {\n        contract_addr: config.token_addr.to_string(),\n        msg: to_binary(\u0026send_msg)?,\n        funds: vec![],\n    };\n\n    // This acknowledgement only indicates that the withdraw was processed without\n    // error, not that the funds were successfully transferred over IBC to the user\n    let ack_data = to_binary(\u0026Response::new_success(\n        \"withdraw_funds\".to_owned(),\n        user.to_string(),\n    ))?;\n\n    // We're sending everything back to the user, so we can delete their balance\n    // If this fails again, the balance will be re-added from the CW20-ICS20 contract\n    USER_FUNDS.remove(deps.storage, user);\n\n    Ok(IbcReceiveResponse::new().set_ack(ack_data).add_message(msg))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use astroport_governance::interchain::{self, Hub, TransferMsg};\n    use cosmwasm_std::{\n        from_binary, testing::mock_info, IbcPacketReceiveMsg, ReplyOn, SubMsg, Uint128,\n    };\n    use cw20::Cw20ReceiveMsg;\n\n    use crate::{\n        contract::instantiate,\n        execute::execute,\n        ibc::ibc_packet_receive,\n        mock::{mock_all, mock_ibc_packet, ASSEMBLY, GENERATOR_CONTROLLER, OWNER, STAKING},\n    };\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Withdrawing stuck funds results in IBC message\n    //\n    // Expect Error\n    //      - When address has no funds stuck\n    //\n    // This tests that balances are correctly tracked by the contract in case of\n    // IBC failures that result in funds getting stuck on the Hub\n    #[test]\n    fn ibc_withdraw_stuck_funds() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        let stuck_amount = Uint128::from(100u128);\n        let user = \"user1\";\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"outpost\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        // Add a valid failure\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(\"astro\", \u0026[]),\n            astroport_governance::hub::ExecuteMsg::Receive(Cw20ReceiveMsg {\n                sender: \"cw20_ics20\".to_string(),\n                amount: stuck_amount,\n                msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::TransferFailure {\n                    receiver: user.to_owned(),\n                })\n                .unwrap(),\n            }),\n        )\n        .unwrap();\n\n        // Withdraw must fail if the user has no funds stuck\n        let ibc_withdraw = to_binary(\u0026Hub::WithdrawFunds {\n            user: Addr::unchecked(\"not_user\"),\n        })\n        .unwrap();\n        let recv_packet = mock_ibc_packet(\"channel-3\", ibc_withdraw);\n        let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n        let res = ibc_packet_receive(deps.as_mut(), env.clone(), msg).unwrap();\n\n        let hub_respone: interchain::Response = from_binary(\u0026res.acknowledgement).unwrap();\n        match hub_respone {\n            interchain::Response::Result { error, .. } =\u003e {\n                assert!(error.is_some());\n                assert_eq!(\n                    error.unwrap(),\n                    \"cosmwasm_std::math::uint128::Uint128 not found\"\n                );\n            }\n            _ =\u003e panic!(\"Wrong response type\"),\n        }\n\n        // Our user has funds stuck, so withdrawal must succeed\n        let ibc_withdraw = to_binary(\u0026Hub::WithdrawFunds {\n            user: Addr::unchecked(user),\n        })\n        .unwrap();\n        let recv_packet = mock_ibc_packet(\"channel-3\", ibc_withdraw);\n\n        let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n        let res = ibc_packet_receive(deps.as_mut(), env, msg).unwrap();\n\n        let hub_respone: interchain::Response = from_binary(\u0026res.acknowledgement).unwrap();\n        match hub_respone {\n            interchain::Response::Result { address, error, .. } =\u003e {\n                assert!(error.is_none());\n                assert_eq!(address.unwrap(), user);\n            }\n            _ =\u003e panic!(\"Wrong response type\"),\n        }\n\n        // We must see one message being emitted from the withdraw\n        assert_eq!(res.messages.len(), 1);\n\n        // It must be a CW20-ICS20 transfer message\n        let ibc_transfer_msg = to_binary(\u0026TransferMsg {\n            remote_address: user.to_string(),\n            channel: \"channel-1\".to_string(),\n            timeout: Some(10),\n            memo: None,\n        })\n        .unwrap();\n        let cw_send_msg = to_binary(\u0026Cw20ExecuteMsg::Send {\n            contract: \"cw20_ics20\".to_string(),\n            amount: stuck_amount,\n            msg: ibc_transfer_msg,\n        })\n        .unwrap();\n\n        assert_eq!(\n            res.messages[0],\n            SubMsg {\n                id: 0,\n                gas_limit: None,\n                reply_on: ReplyOn::Never,\n                msg: WasmMsg::Execute {\n                    contract_addr: \"astro\".to_string(),\n                    msg: cw_send_msg,\n                    funds: vec![],\n                }\n                .into(),\n            }\n        );\n    }\n}\n","traces":[{"line":17,"address":[1712743,1708832,1710303],"length":1,"stats":{"Line":1},"fn_name":"handle_ibc_withdraw_stuck_funds"},{"line":22,"address":[1708998,1709154,1708864],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[1709315,1709114,1709483],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[1709597,1709455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[1709632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1709963,1709608,1709685],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[1709896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[1709936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[1710108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[1710276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[1710393,1710441,1710666],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[1710631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[1711088,1710945,1710897],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[1711061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[1711625,1711558,1711698,1711913],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[1711424,1711497],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[1711505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[1712147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1712207],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":18,"coverable":19},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","ibc_query.rs"],"content":"use cosmwasm_std::{to_binary, DepsMut, IbcReceiveResponse};\n\nuse astroport_governance::{assembly::Proposal, assembly::QueryMsg, interchain::Response};\n\nuse crate::{error::ContractError, state::CONFIG};\n\n/// Query the Assembly for a proposal and return the result in an\n/// IBC acknowledgement\n///\n/// If the proposal doesn't exist, the Outpost will see a generic ABCI error\n/// and not \"proposal not found\" due to limitations in wasmd\npub fn handle_ibc_query_proposal(\n    deps: DepsMut,\n    id: u64,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    let mut proposal: Proposal = deps.querier.query_wasm_smart(\n        config.assembly_addr,\n        \u0026QueryMsg::Proposal { proposal_id: id },\n    )?;\n\n    // TODO Check if we can retrieve the proposal even with thousands of voters\n    proposal.for_voters = vec![];\n    proposal.against_voters = vec![];\n\n    let ack_data = to_binary(\u0026Response::QueryProposal(Box::new(proposal)))?;\n    Ok(IbcReceiveResponse::new()\n        .set_ack(ack_data)\n        .add_attribute(\"query\", \"proposal\")\n        .add_attribute(\"proposal_id\", id.to_string()))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use astroport_governance::interchain::Hub;\n    use cosmwasm_std::{from_binary, testing::mock_info, Addr, IbcPacketReceiveMsg, Uint64};\n\n    use crate::{\n        contract::instantiate,\n        execute::execute,\n        ibc::ibc_packet_receive,\n        mock::{mock_all, mock_ibc_packet, ASSEMBLY, GENERATOR_CONTROLLER, OWNER, STAKING},\n    };\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Proposal should not be queried without Assembly\n\n    #[test]\n    fn query_proposal_fails_invalid_assembly() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: \"invalid\".to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"outpost\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        let ibc_query_proposal = to_binary(\u0026Hub::QueryProposal { id: 1 }).unwrap();\n        let recv_packet = mock_ibc_packet(\"channel-3\", ibc_query_proposal);\n\n        let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n        let res = ibc_packet_receive(deps.as_mut(), env, msg).unwrap();\n\n        let ack: Response = from_binary(\u0026res.acknowledgement).unwrap();\n        match ack {\n            Response::Result { error, .. } =\u003e {\n                assert!(error.is_some());\n            }\n            _ =\u003e panic!(\"Wrong response type\"),\n        }\n\n        // No messages should be emitted\n        assert_eq!(res.messages.len(), 0);\n    }\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - An IBC ack contains the correct information\n\n    #[test]\n    fn query_proposal() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"outpost\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        let ibc_query_proposal = to_binary(\u0026Hub::QueryProposal { id: 1 }).unwrap();\n        let recv_packet = mock_ibc_packet(\"channel-3\", ibc_query_proposal);\n\n        let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n        let res = ibc_packet_receive(deps.as_mut(), env, msg).unwrap();\n\n        let ack: Response = from_binary(\u0026res.acknowledgement).unwrap();\n        match ack {\n            Response::QueryProposal(proposal) =\u003e {\n                assert_eq!(proposal.proposal_id, Uint64::from(1u64));\n            }\n            _ =\u003e panic!(\"Wrong response type\"),\n        }\n\n        // No message must be emitted, the ack contains the data\n        assert_eq!(res.messages.len(), 0);\n    }\n}\n","traces":[{"line":12,"address":[1162610,1163934,1161888],"length":1,"stats":{"Line":2},"fn_name":"handle_ibc_query_proposal"},{"line":16,"address":[1162224,1161915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[1162352,1162124,1162569,1162217],"length":1,"stats":{"Line":7},"fn_name":null},{"line":19,"address":[1162128],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[1162168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[1162780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[1162937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[1163274,1163086],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[1164222,1164290,1164062,1164003],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[1164022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[1164149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[1164157,1164282,1164415],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":12,"coverable":12},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","ibc_staking.rs"],"content":"use cosmwasm_std::{to_binary, DepsMut, IbcReceiveResponse, SubMsg, Uint128, WasmMsg};\nuse cw20::Cw20ExecuteMsg;\n\nuse astroport_governance::interchain::Response;\n\nuse crate::{\n    error::ContractError,\n    reply::UNSTAKE_ID,\n    state::{ReplyData, CONFIG, REPLY_DATA},\n};\n\n/// Handle an unstake command from an Outpost\n///\n/// Once the xASTRO has been unstaked, the resulting ASTRO will be sent back\n/// to the user on the Outpost\npub fn handle_ibc_unstake(\n    deps: DepsMut,\n    receive_channel: String,\n    receiver: String,\n    amount: Uint128,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    let msg = construct_unstake_msg(deps, receive_channel, receiver.clone(), amount)?;\n    // Add to SubMessage to handle the reply\n    let sub_msg = SubMsg::reply_always(msg, UNSTAKE_ID);\n\n    // Set the acknowledgement. This is only to indicate that the unstake\n    // was processed without error, not that the funds were successfully\n    let ack_data = to_binary(\u0026Response::new_success(\"unstake\".to_owned(), receiver))?;\n\n    // TODO Invariant check, can't unstake more than the xASTRO in this contract\n\n    Ok(IbcReceiveResponse::new()\n        .set_ack(ack_data)\n        .add_submessage(sub_msg))\n}\n\n/// Create the messages and state to correctly handle the unstaking of xASTRO\npub fn construct_unstake_msg(\n    deps: DepsMut,\n    receiving_channel: String,\n    receiver: String,\n    amount: Uint128,\n) -\u003e Result\u003cWasmMsg, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Unstake the received xASTRO amount\n    // We need a SubMessage here to ensure that we send the correct amount\n    // of ASTRO to the receiver as the ratio isn't 1:1\n    let leave_msg = astroport::staking::Cw20HookMsg::Leave {};\n    let send_msg = Cw20ExecuteMsg::Send {\n        contract: config.staking_addr.to_string(),\n        amount,\n        msg: to_binary(\u0026leave_msg)?,\n    };\n\n    // Send the xASTRO held in the contract to the Staking contract\n    let msg = WasmMsg::Execute {\n        contract_addr: config.xtoken_addr.to_string(),\n        msg: to_binary(\u0026send_msg)?,\n        funds: vec![],\n    };\n\n    // Temporarily save the data needed for the SubMessage reply\n    let reply_data = ReplyData {\n        receiver,\n        receiving_channel,\n    };\n    REPLY_DATA.save(deps.storage, \u0026reply_data)?;\n\n    Ok(msg)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use astroport_governance::interchain::{Hub, TransferMsg};\n    use cosmwasm_std::{\n        from_binary, testing::mock_info, Addr, Event, IbcPacketReceiveMsg, Reply, ReplyOn,\n        SubMsgResponse, SubMsgResult,\n    };\n\n    use crate::{\n        contract::instantiate,\n        execute::execute,\n        ibc::ibc_packet_receive,\n        mock::{\n            mock_all, mock_ibc_packet, ASSEMBLY, ASTRO_TOKEN, GENERATOR_CONTROLLER, OWNER, STAKING,\n            XASTRO_TOKEN,\n        },\n        reply::reply,\n    };\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Proposal should not be queried without Assembly\n\n    #[test]\n    fn ibc_unstake() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        let unstaker = \"unstaker\";\n        let unstake_amount = Uint128::from(100u128);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"outpost\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        let ibc_unstake = to_binary(\u0026Hub::Unstake {\n            receiver: unstaker.to_owned(),\n            amount: unstake_amount,\n        })\n        .unwrap();\n        let recv_packet = mock_ibc_packet(\"channel-3\", ibc_unstake);\n\n        let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n        let res = ibc_packet_receive(deps.as_mut(), env.clone(), msg).unwrap();\n\n        let ack: Response = from_binary(\u0026res.acknowledgement).unwrap();\n        match ack {\n            Response::Result { error, .. } =\u003e {\n                assert!(error.is_none());\n            }\n            _ =\u003e panic!(\"Wrong response type\"),\n        }\n\n        // Should have exactly one message\n        assert_eq!(res.messages.len(), 1);\n\n        // Verify that the unstake message matches the expected message\n        let unstake_msg = to_binary(\u0026astroport::staking::Cw20HookMsg::Leave {}).unwrap();\n        let send_msg = to_binary(\u0026Cw20ExecuteMsg::Send {\n            contract: STAKING.to_string(),\n            amount: unstake_amount,\n            msg: unstake_msg,\n        })\n        .unwrap();\n\n        // We should see the unstake SubMessagge\n        assert_eq!(\n            res.messages[0],\n            SubMsg {\n                id: 9001,\n                gas_limit: None,\n                reply_on: ReplyOn::Always,\n                msg: WasmMsg::Execute {\n                    contract_addr: XASTRO_TOKEN.to_string(),\n                    msg: send_msg,\n                    funds: vec![],\n                }\n                .into(),\n            }\n        );\n\n        // Construct the reply from the staking contract that will be returned\n        // to the contract\n        let unstake_event = Event::new(\"unstake\".to_string())\n            .add_attribute(\"astro_amount\", unstake_amount.to_string());\n        let unstake_reply = Reply {\n            id: 9001,\n            result: SubMsgResult::Ok(SubMsgResponse {\n                events: vec![unstake_event],\n                data: None,\n            }),\n        };\n\n        let res = reply(deps.as_mut(), env, unstake_reply).unwrap();\n\n        // We must have one CW20-ICS20 transfer message\n        assert_eq!(res.messages.len(), 1);\n\n        // Contruct the CW20-ICS20 ASTRO token transfer we expect to see\n        let transfer_msg = to_binary(\u0026TransferMsg {\n            channel: \"channel-1\".to_string(),\n            remote_address: unstaker.to_string(),\n            timeout: Some(10),\n            memo: None,\n        })\n        .unwrap();\n        let send_msg = to_binary(\u0026Cw20ExecuteMsg::Send {\n            contract: \"cw20_ics20\".to_string(),\n            amount: unstake_amount,\n            msg: transfer_msg,\n        })\n        .unwrap();\n\n        // We should see the ASTRO token transfer\n        assert_eq!(\n            res.messages[0],\n            SubMsg {\n                id: 0,\n                gas_limit: None,\n                reply_on: ReplyOn::Never,\n                msg: WasmMsg::Execute {\n                    contract_addr: ASTRO_TOKEN.to_string(),\n                    msg: send_msg,\n                    funds: vec![],\n                }\n                .into(),\n            }\n        );\n    }\n}\n","traces":[{"line":16,"address":[1586880,1587200,1588641],"length":1,"stats":{"Line":1},"fn_name":"handle_ibc_unstake"},{"line":22,"address":[1586941,1587233,1587627,1587181],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[1587783,1587483],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[1587791,1587861],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[1588499,1588357,1588416],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[1588376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[1588451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[1589269,1588672,1591052],"length":1,"stats":{"Line":1},"fn_name":"construct_unstake_msg"},{"line":44,"address":[1588730,1589000,1588856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[1588957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[1588965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1589164,1589212,1589449,1589290],"length":1,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[1589414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[1589868,1589725,1589677],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[1589841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[1590345,1590709,1590422],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[1590483],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":17,"coverable":17},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","lib.rs"],"content":"pub mod contract;\npub mod error;\npub mod execute;\npub mod ibc;\npub mod ibc_governance;\npub mod ibc_misc;\npub mod ibc_query;\npub mod ibc_staking;\npub mod query;\npub mod reply;\npub mod state;\n\n#[cfg(test)]\nmod mock;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","mock.rs"],"content":"#[cfg(test)]\n// use crate::execute;\n// use crate::{contract::instantiate, execute::execute, ibc::ibc_packet_receive};\n// use crate::{\n//     ibc::{ibc_channel_connect, ibc_channel_open, IBC_APP_VERSION},\n//     testing_querier::{mock_dependencies, WasmMockQuerier},\n// };\nuse astroport_core::token::BalanceResponse;\nuse astroport_cw20_ics20::{\n    ibc::{Ics20Packet, ICS20_ORDERING, ICS20_VERSION},\n    state::ChannelInfo,\n};\nuse astroport_governance::assembly::ProposalVoteOption;\nuse astroport_governance::interchain::{Hub, Response};\nuse cosmwasm_std::{from_binary, IbcPacketReceiveMsg, ReplyOn, SubMsg, Uint64, WasmMsg};\nuse cosmwasm_std::{\n    testing::{mock_env, mock_info, MockApi, MockQuerier, MockStorage},\n    to_binary, Addr, Binary, DepsMut, Env, IbcChannel, IbcChannelConnectMsg, IbcChannelOpenMsg,\n    IbcEndpoint, IbcOrder, IbcPacket, MessageInfo, OwnedDeps, StdResult, Timestamp, Uint128,\n};\nuse cw20::Cw20QueryMsg;\nuse cw_multi_test::{App, AppBuilder, BankKeeper};\n\nuse cosmwasm_std::testing::MOCK_CONTRACT_ADDR;\nuse cosmwasm_std::{\n    from_slice, Coin, Empty, Querier, QuerierResult, QueryRequest, SystemError, SystemResult,\n    WasmQuery,\n};\nuse std::collections::HashMap;\n\npub const DEFAULT_TIMEOUT: u64 = 3600; // 1 hour,\npub const CONTRACT_PORT: \u0026str = \"ibc:wasm1234567890abcdef\";\npub const REMOTE_PORT: \u0026str = \"wasm.outpost\";\npub const CONNECTION_ID: \u0026str = \"connection-2\";\npub const OWNER: \u0026str = \"owner\";\npub const ASSEMBLY: \u0026str = \"assembly\";\npub const GENERATOR_CONTROLLER: \u0026str = \"generator_controller\";\npub const STAKING: \u0026str = \"staking\";\npub const ASTRO_TOKEN: \u0026str = \"astro\";\npub const XASTRO_TOKEN: \u0026str = \"xastro\";\n\npub fn mock_app() -\u003e App {\n    let mut env = mock_env();\n    env.block.time = Timestamp::from_seconds(1689152294);\n    let api = MockApi::default();\n    let bank = BankKeeper::new();\n    let storage = MockStorage::new();\n\n    AppBuilder::new()\n        .with_api(api)\n        .with_block(env.block)\n        .with_bank(bank)\n        .with_storage(storage)\n        .build(|_, _, _| {})\n}\n\n/// mock_dependencies is a drop-in replacement for cosmwasm_std::testing::mock_dependencies.\n/// This uses the Astroport CustomQuerier.\n#[cfg(test)]\npub fn mock_dependencies() -\u003e OwnedDeps\u003cMockStorage, MockApi, WasmMockQuerier\u003e {\n    let custom_querier: WasmMockQuerier =\n        WasmMockQuerier::new(MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026[])]));\n\n    OwnedDeps {\n        storage: MockStorage::default(),\n        api: MockApi::default(),\n        querier: custom_querier,\n        custom_query_type: Default::default(),\n    }\n}\n\npub struct WasmMockQuerier {\n    base: MockQuerier\u003cEmpty\u003e,\n}\n\nimpl Querier for WasmMockQuerier {\n    fn raw_query(\u0026self, bin_request: \u0026[u8]) -\u003e QuerierResult {\n        // MockQuerier doesn't support Custom, so we ignore it completely\n        let request: QueryRequest\u003cEmpty\u003e = match from_slice(bin_request) {\n            Ok(v) =\u003e v,\n            Err(e) =\u003e {\n                return SystemResult::Err(SystemError::InvalidRequest {\n                    error: format!(\"Parsing query request: {}\", e),\n                    request: bin_request.into(),\n                })\n            }\n        };\n        self.handle_query(\u0026request)\n    }\n}\n\nimpl WasmMockQuerier {\n    pub fn handle_query(\u0026self, request: \u0026QueryRequest\u003cEmpty\u003e) -\u003e QuerierResult {\n        match \u0026request {\n            QueryRequest::Wasm(WasmQuery::Smart { contract_addr, msg }) =\u003e {\n                if contract_addr == STAKING {\n                    match from_binary(\u0026msg).unwrap() {\n                        astroport_core::staking::QueryMsg::Config {} =\u003e {\n                            let config = astroport_core::staking::ConfigResponse {\n                                deposit_token_addr: Addr::unchecked(\"astro\"),\n                                share_token_addr: Addr::unchecked(\"xastro\"),\n                            };\n\n                            SystemResult::Ok(to_binary(\u0026config).into())\n                        }\n                        _ =\u003e {\n                            panic!(\"DO NOT ENTER HERE\")\n                        }\n                    }\n                } else {\n                    if contract_addr != ASSEMBLY {\n                        return SystemResult::Err(SystemError::Unknown {});\n                    }\n                    match from_binary(\u0026msg).unwrap() {\n                        astroport_governance::assembly::QueryMsg::Proposal { proposal_id } =\u003e {\n                            let proposal = astroport_governance::assembly::Proposal {\n                                proposal_id: Uint64::from(proposal_id),\n                                submitter: Addr::unchecked(\"submitter\"),\n                                status: astroport_governance::assembly::ProposalStatus::Active,\n                                for_power: Uint128::zero(),\n                                against_power: Uint128::zero(),\n                                for_voters: vec![],\n                                against_voters: vec![],\n                                start_block: 1,\n                                start_time: 12345,\n                                end_block: 5,\n                                delayed_end_block: 10,\n                                expiration_block: 15,\n                                title: \"Test title\".to_string(),\n                                description: \"Test description\".to_string(),\n                                link: None,\n                                messages: None,\n                                deposit_amount: Uint128::one(),\n                                ibc_channel: None,\n                            };\n                            SystemResult::Ok(to_binary(\u0026proposal).into())\n                        }\n                        _ =\u003e {\n                            panic!(\"DO NOT ENTER HERE\")\n                        }\n                    }\n                }\n            }\n            _ =\u003e self.base.handle_query(request),\n        }\n    }\n}\n\nimpl WasmMockQuerier {\n    pub fn new(base: MockQuerier\u003cEmpty\u003e) -\u003e Self {\n        WasmMockQuerier { base }\n    }\n}\n\npub fn mock_all(\n    sender: \u0026str,\n) -\u003e (\n    OwnedDeps\u003cMockStorage, MockApi, WasmMockQuerier\u003e,\n    Env,\n    MessageInfo,\n) {\n    let deps = mock_dependencies();\n    let env = mock_env();\n    let info = mock_info(sender, \u0026[]);\n    (deps, env, info)\n}\n\npub fn check_token_balance(app: \u0026mut App, token: \u0026Addr, address: \u0026Addr, expected: u128) {\n    let msg = Cw20QueryMsg::Balance {\n        address: address.to_string(),\n    };\n    let res: StdResult\u003cBalanceResponse\u003e = app.wrap().query_wasm_smart(token, \u0026msg);\n    assert_eq!(res.unwrap().balance, Uint128::from(expected));\n}\n\n// pub fn mock_channel(channel_id: \u0026str) -\u003e IbcChannel {\n//     IbcChannel::new(\n//         IbcEndpoint {\n//             port_id: CONTRACT_PORT.into(),\n//             channel_id: channel_id.into(),\n//         },\n//         IbcEndpoint {\n//             port_id: REMOTE_PORT.into(),\n//             channel_id: format!(\"{}5\", channel_id),\n//         },\n//         IbcOrder::Unordered,\n//         IBC_APP_VERSION,\n//         CONNECTION_ID,\n//     )\n// }\n\n// pub fn mock_channel_info(channel_id: \u0026str) -\u003e ChannelInfo {\n//     ChannelInfo {\n//         id: channel_id.to_string(),\n//         counterparty_endpoint: IbcEndpoint {\n//             port_id: REMOTE_PORT.into(),\n//             channel_id: format!(\"{}5\", channel_id),\n//         },\n//         connection_id: CONNECTION_ID.into(),\n//     }\n// }\n\n// we simulate instantiate and ack here\n// pub fn add_channel(mut deps: DepsMut, channel_id: \u0026str) {\n//     let channel = mock_channel(channel_id);\n//     let open_msg = IbcChannelOpenMsg::new_init(channel.clone());\n//     ibc_channel_open(deps.branch(), mock_env(), open_msg).unwrap();\n//     let connect_msg = IbcChannelConnectMsg::new_ack(channel, IBC_APP_VERSION);\n//     ibc_channel_connect(deps.branch(), mock_env(), connect_msg).unwrap();\n// }\n\n// pub fn mock_receive_packet(\n//     my_channel: \u0026str,\n//     amount: u128,\n//     denom: \u0026str,\n//     receiver: \u0026str,\n//     memo: Option\u003cString\u003e,\n// ) -\u003e IbcPacket {\n//     let data = Ics20Packet {\n//         // this is returning a foreign (our) token, thus denom is \u003cport\u003e/\u003cchannel\u003e/\u003cdenom\u003e\n//         denom: format!(\"{}/{}/{}\", REMOTE_PORT, \"channel-1234\", denom),\n//         amount: amount.into(),\n//         sender: \"remote-sender\".to_string(),\n//         receiver: receiver.to_string(),\n//         memo,\n//     };\n//     print!(\"Packet denom: {}\", \u0026data.denom);\n//     IbcPacket::new(\n//         to_binary(\u0026data).unwrap(),\n//         IbcEndpoint {\n//             port_id: REMOTE_PORT.to_string(),\n//             channel_id: \"channel-1234\".to_string(),\n//         },\n//         IbcEndpoint {\n//             port_id: CONTRACT_PORT.to_string(),\n//             channel_id: my_channel.to_string(),\n//         },\n//         3,\n//         Timestamp::from_seconds(1665321069).into(),\n//     )\n// }\n\npub fn mock_ibc_packet(my_channel: \u0026str, data: Binary) -\u003e IbcPacket {\n    IbcPacket::new(\n        data,\n        IbcEndpoint {\n            port_id: REMOTE_PORT.to_string(),\n            channel_id: \"channel-3\".to_string(),\n        },\n        IbcEndpoint {\n            port_id: CONTRACT_PORT.to_string(),\n            channel_id: my_channel.to_string(),\n        },\n        3,\n        Timestamp::from_seconds(1665321069).into(),\n    )\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","query.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{to_binary, Binary, Deps, Env, Order, StdResult};\n\nuse crate::state::{CONFIG, OUTPOSTS};\nuse astroport_governance::hub::{OutpostConfig, QueryMsg};\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::Config {}** Returns core contract settings stored in the [`Config`] structure.\n///\n/// * **QueryMsg::Outposts { }** Returns a [`Vec\u003cOutpostResponse\u003e`] containing the active Outposts\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Config {} =\u003e to_binary(\u0026CONFIG.load(deps.storage)?),\n        QueryMsg::Outposts {} =\u003e query_outposts(deps),\n    }\n}\n\n/// Return a list of Outpost in the format of `OutpostConfig`\nfn query_outposts(deps: Deps) -\u003e StdResult\u003cBinary\u003e {\n    let outposts: Vec\u003cOutpostConfig\u003e = OUTPOSTS\n        .range(deps.storage, None, None, Order::Ascending)\n        .map(|item| {\n            let (key, value) = item.unwrap();\n            OutpostConfig {\n                address: key,\n                channel: value.outpost.unwrap_or_default(),\n                cw20_ics20_channel: value.cw20_ics20,\n            }\n        })\n        .collect();\n    to_binary(\u0026outposts)\n}\n","traces":[{"line":15,"address":[994158,993632],"length":1,"stats":{"Line":2},"fn_name":"query"},{"line":16,"address":[993667],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[993851,994098,993687],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[993817,993726],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[993597,993424],"length":1,"stats":{"Line":2},"fn_name":"query_outposts"},{"line":24,"address":[993469],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[993444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[833504,833968,834031],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":27,"address":[833542],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[833837],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[833653],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[833687],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[833798],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[993536],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":14,"coverable":14},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","reply.rs"],"content":"use cosmwasm_std::{\n    entry_point, to_binary, CosmosMsg, DepsMut, Env, IbcMsg, Reply, Response, SubMsgResult,\n    Uint128, WasmMsg,\n};\nuse cw20::Cw20ExecuteMsg;\n\nuse astroport_governance::interchain::{Outpost, TransferMsg};\n\nuse crate::{\n    error::ContractError,\n    state::{\n        get_outpost_from_cw20ics20_channel, get_transfer_channel_from_outpost_channel, CONFIG,\n        REPLY_DATA,\n    },\n};\n\n/// Reply ID when staking tokens\npub const STAKE_ID: u64 = 9000;\n/// Reply ID when unstaking tokens\npub const UNSTAKE_ID: u64 = 9001;\n\n/// Handle SubMessage replies\n///\n/// To correctly handle staking and unstaking amount we execute the calls using\n/// SubMessages and the replies are handled here\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(deps: DepsMut, env: Env, reply: Reply) -\u003e Result\u003cResponse, ContractError\u003e {\n    match reply.id {\n        STAKE_ID =\u003e handle_stake_reply(deps, env, reply),\n        UNSTAKE_ID =\u003e handle_unstake_reply(deps, reply),\n        _ =\u003e Err(ContractError::UnknownReplyId { id: reply.id }),\n    }\n}\n\n/// Handle the reply from a staking transaction\nfn handle_stake_reply(deps: DepsMut, env: Env, reply: Reply) -\u003e Result\u003cResponse, ContractError\u003e {\n    match reply.result {\n        SubMsgResult::Ok(response) =\u003e {\n            // TODO response.data is blank on Terra, investigate why this is\n            // let Some(response_data) = \u0026response.data else {\n            //     return Err(ContractError::InvalidSubmessage{reason: \"No data in staking response\".to_string()});\n            // };\n\n            let config = CONFIG.load(deps.storage)?;\n\n            // Extract the correct xASTRO amount minted from the staking\n            // transaction. xASTRO isn't *always* minted at a 1:1 ratio\n            let mut xastro_amount: Uint128 = Uint128::zero();\n            for event in response.events {\n                for attribute in event.attributes {\n                    if attribute.key == \"xastro_amount\" {\n                        let val = attribute.value.parse::\u003cu64\u003e()?;\n                        xastro_amount = Uint128::from(val);\n                        break;\n                    }\n                }\n            }\n\n            // Load the temporary data stored before the SubMessage was executed\n            let reply_data = REPLY_DATA.load(deps.storage)?;\n\n            // The channel we received the ASTRO to stake on was the CW20-ICS20\n            // channel, we need to determine the channel to use for minting the\n            // xASTRO be checking the known Outposts\n            let outpost_channels =\n                get_outpost_from_cw20ics20_channel(deps.as_ref(), \u0026reply_data.receiving_channel)?;\n            let outpost_channel = outpost_channels\n                .outpost\n                .ok_or(ContractError::UnknownOutpost {})?;\n\n            // Submit an IBC transaction to mint the same amount of xASTRO\n            // we received from staking on the Outpost\n            let mint_remote = Outpost::MintXAstro {\n                amount: xastro_amount,\n                receiver: reply_data.receiver.clone(),\n            };\n            let msg = CosmosMsg::Ibc(IbcMsg::SendPacket {\n                channel_id: outpost_channel.clone(),\n                data: to_binary(\u0026mint_remote)?,\n                timeout: env\n                    .block\n                    .time\n                    .plus_seconds(config.ibc_timeout_seconds)\n                    .into(),\n            });\n\n            Ok(Response::new()\n                .add_message(msg)\n                .add_attribute(\"action\", \"mint_remote_xastro\")\n                .add_attribute(\"amount\", xastro_amount)\n                .add_attribute(\"channel\", outpost_channel)\n                .add_attribute(\"receiver\", reply_data.receiver))\n        }\n        // In the case where staking fails, the funds will either automatically be returned\n        // through the CW20-ICS20 contract or the user will need to manually withdraw them\n        // from this contract. In either case, we don't need to do anything here as the\n        // original staking memo is already a SubMessage in the CW20-ICS20 contract\n        SubMsgResult::Err(err) =\u003e Err(ContractError::InvalidSubmessage { reason: err }),\n    }\n}\n\n/// Handle the reply from an unstaking transaction\nfn handle_unstake_reply(deps: DepsMut, reply: Reply) -\u003e Result\u003cResponse, ContractError\u003e {\n    match reply.result {\n        SubMsgResult::Ok(response) =\u003e {\n            // TODO response.data is blank on Terra, investigate why this is\n            // let Some(response_data) = \u0026response.data else {\n            //     return Err(ContractError::InvalidSubmessage{reason: \"No data in staking response\".to_string()});\n            // };\n\n            let config = CONFIG.load(deps.storage)?;\n\n            // Extract the correct ASTRO amount returned from the unstaking\n            // transaction. ASTRO isn't returned at a 1:1 ratio, the returned\n            // ASTRO will most likely be more\n            let mut astro_amount: Uint128 = Uint128::zero();\n            for event in response.events {\n                for attribute in event.attributes {\n                    if attribute.key == \"astro_amount\" {\n                        let val = attribute.value.parse::\u003cu64\u003e()?;\n                        astro_amount = Uint128::from(val);\n                        break;\n                    }\n                }\n            }\n\n            // Load the temporary data stored before the SubMessage was executed\n            let reply_data = REPLY_DATA.load(deps.storage)?;\n\n            // The channel we received the unstaking from was the Outpost contract\n            // channel, we need to determine the channel to use for sending the\n            // ASTRO back using the CW20-ICS20 contract\n            let outpost_channels = get_transfer_channel_from_outpost_channel(\n                deps.as_ref(),\n                \u0026reply_data.receiving_channel,\n            )?;\n\n            // Send the ASTRO back to the unstaking user on the Outpost chain\n            // via the CW20-ICS20 contract\n            let transfer_msg = TransferMsg {\n                channel: outpost_channels.cw20_ics20.clone(),\n                remote_address: reply_data.receiver.clone(),\n                timeout: Some(config.ibc_timeout_seconds),\n                memo: None,\n            };\n\n            let transfer = Cw20ExecuteMsg::Send {\n                contract: config.cw20_ics20_addr.to_string(),\n                amount: astro_amount,\n                msg: to_binary(\u0026transfer_msg)?,\n            };\n\n            let wasm_msg = WasmMsg::Execute {\n                contract_addr: config.token_addr.to_string(),\n                msg: to_binary(\u0026transfer)?,\n                funds: vec![],\n            };\n\n            // TODO: Invariant checks\n            // TODO: We probably need to keep track of the channel balance\n            // and ensure we don't send more than the channel has\n            // Same mechanism as the CW20-ICS20 contract\n\n            Ok(Response::new()\n                .add_message(wasm_msg)\n                .add_attribute(\"action\", \"return_unstaked_astro\")\n                .add_attribute(\"amount\", astro_amount)\n                .add_attribute(\"channel\", outpost_channels.cw20_ics20)\n                .add_attribute(\"receiver\", reply_data.receiver))\n        }\n        // If unstaking fails the error will be returned to the Outpost that would undo\n        // the burning of xASTRO and return the tokens to the user\n        SubMsgResult::Err(err) =\u003e Err(ContractError::InvalidSubmessage { reason: err }),\n    }\n}\n","traces":[{"line":27,"address":[1559456,1559938,1559969],"length":1,"stats":{"Line":2},"fn_name":"reply"},{"line":28,"address":[1559487],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[1559647,1559909],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[1559907,1559791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[1559566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1554504,1551432,1549648],"length":1,"stats":{"Line":1},"fn_name":"handle_stake_reply"},{"line":37,"address":[1549695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[1549776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[1550074,1549819,1550211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[1550180,1550375],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[1550391,1551355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[1550676,1550779,1551309],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[1551087,1551013],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[1551258,1551115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1551226,1551394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[1551473,1551696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1552145,1551838,1551666],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[1552052,1552316,1552552,1552127],"length":1,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[1552488,1552092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[1552450],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[1553430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[1552705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[1552792,1552840,1553003],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[1552964,1553411,1552976],"length":1,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[1552968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[1553702,1553976,1553901,1554063,1553826],"length":1,"stats":{"Line":5},"fn_name":null},{"line":88,"address":[1553762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[1553885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[1553936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[1554023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[1549867],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[1556272,1558414,1554528],"length":1,"stats":{"Line":1},"fn_name":"handle_unstake_reply"},{"line":104,"address":[1554561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[1554628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[1555054,1554671,1554920],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[1555026,1555215],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[1556195,1555231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[1555619,1555516,1556149],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[1555853,1555927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[1555955,1556098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[1556234,1556066],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[1556310,1556530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[1556500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[1556672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[1556886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[1557082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[1557150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[1557318],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[1557478,1557705,1557430],"length":1,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[1557667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[1557936,1557984,1558130],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[1558100],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[1558868,1558943,1558589,1558793,1559030],"length":1,"stats":{"Line":5},"fn_name":null},{"line":165,"address":[1558649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[1558852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[1558903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[1558990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[1554716],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":56,"coverable":58},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","state.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Deps, Order, Uint128};\nuse cw_storage_plus::{Item, Map};\n\nuse astroport::common::OwnershipProposal;\nuse astroport_governance::hub::Config;\n\nuse crate::error::ContractError;\n\n/// Holds temporary data used in the staking/unstaking replies\n#[cw_serde]\npub struct ReplyData {\n    /// The address that should receive the staked/unstaked tokens\n    pub receiver: String,\n    /// The IBC channel the original request was received on\n    pub receiving_channel: String,\n}\n\n/// Holds the IBC channels that are allowed to communicate with the Hub\n#[cw_serde]\npub struct OutpostChannels {\n    /// The channel of the Outpost contract on the remote chain\n    pub outpost: Option\u003cString\u003e,\n    /// The channel to send ASTRO CW20-ICS20 tokens through\n    pub cw20_ics20: String,\n}\n\n/// Stores the contract config\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n\n/// Stores data for reply endpoint.\npub const REPLY_DATA: Item\u003cReplyData\u003e = Item::new(\"reply_data\");\n\n/// Stores funds that got stuck on the Hub chain due to IBC transfer failures\n/// when using cross-chain actions\npub const USER_FUNDS: Map\u003cAddr, Uint128\u003e = Map::new(\"user_funds\");\n\n/// Contains a proposal to change contract ownership\npub const OWNERSHIP_PROPOSAL: Item\u003cOwnershipProposal\u003e = Item::new(\"ownership_proposal\");\n\n/// Contains a map of outpost addresses to their IBC channels that are allowed\n/// to communicate with the Hub over IBC\npub const OUTPOSTS: Map\u003cString, OutpostChannels\u003e = Map::new(\"channel_map\");\n\n/// Get the Outpost channels for a given CW20-ICS20 channel\n///\n/// The Outposts must be configured and connected before this will return any values\npub fn get_outpost_from_cw20ics20_channel(\n    deps: Deps,\n    cw20ics20_channel: \u0026str,\n) -\u003e Result\u003cOutpostChannels, ContractError\u003e {\n    let outpost_opt = OUTPOSTS\n        .range(deps.storage, None, None, Order::Ascending)\n        .find_map(|item| {\n            let (_, value) = item.ok()?;\n            if value.cw20_ics20 == cw20ics20_channel {\n                Some(value)\n            } else {\n                None\n            }\n        });\n\n    match outpost_opt {\n        Some(outpost) =\u003e Ok(outpost),\n        None =\u003e Err(ContractError::UnknownOutpost {}),\n    }\n}\n\n/// Get the Outpost channels for a given contract channel\n///\n/// The Outposts must be configured and connected before this will return any values\npub fn get_transfer_channel_from_outpost_channel(\n    deps: Deps,\n    outpost_channel: \u0026str,\n) -\u003e Result\u003cOutpostChannels, ContractError\u003e {\n    let outpost_opt = OUTPOSTS\n        .range(deps.storage, None, None, Order::Ascending)\n        .find_map(|item| {\n            let (_, value) = item.ok()?;\n            if value.outpost == Some(outpost_channel.to_string()) {\n                Some(value)\n            } else {\n                None\n            }\n        });\n\n    match outpost_opt {\n        Some(outpost) =\u003e Ok(outpost),\n        None =\u003e Err(ContractError::UnknownOutpost {}),\n    }\n}\n","traces":[{"line":48,"address":[1229568,1229750],"length":1,"stats":{"Line":1},"fn_name":"get_outpost_from_cw20ics20_channel"},{"line":52,"address":[15803641,15803699],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[15803613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[15803691],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[15424699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[15425057,15425125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[15425127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[915158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[1229810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[1229871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1229840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[1230175,1229952],"length":1,"stats":{"Line":1},"fn_name":"get_transfer_channel_from_outpost_channel"},{"line":76,"address":[1230096,1230026],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[1229998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[15804116],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[15425275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[915855,915661,915821],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[915857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[915847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[1230235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[1230297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[1230266],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":18,"coverable":22},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","tests","helper.rs"],"content":"// #[cfg(test)]\n// // use crate::execute;\n// // use crate::{contract::instantiate, execute::execute, ibc::ibc_packet_receive};\n// // use crate::{\n// //     ibc::{ibc_channel_connect, ibc_channel_open, IBC_APP_VERSION},\n// //     testing_querier::{mock_dependencies, WasmMockQuerier},\n// // };\n// use astroport_core::token::BalanceResponse;\n// use astroport_cw20_ics20::{\n//     ibc::{Ics20Packet, ICS20_ORDERING, ICS20_VERSION},\n//     state::ChannelInfo,\n// };\n// use astroport_governance::assembly::ProposalVoteOption;\n// use astroport_governance::interchain::{Hub, Response};\n// use cosmwasm_std::{from_binary, IbcPacketReceiveMsg, ReplyOn, SubMsg, Uint64, WasmMsg};\n// use cosmwasm_std::{\n//     testing::{mock_env, mock_info, MockApi, MockQuerier, MockStorage},\n//     to_binary, Addr, Binary, DepsMut, Env, IbcChannel, IbcChannelConnectMsg, IbcChannelOpenMsg,\n//     IbcEndpoint, IbcOrder, IbcPacket, MessageInfo, OwnedDeps, StdResult, Timestamp, Uint128,\n// };\n// use cw20::Cw20QueryMsg;\n// use cw_multi_test::{App, AppBuilder, BankKeeper};\n\n// use cosmwasm_std::testing::MOCK_CONTRACT_ADDR;\n// use cosmwasm_std::{\n//     from_slice, Coin, Empty, Querier, QuerierResult, QueryRequest, SystemError, SystemResult,\n//     WasmQuery,\n// };\n// use std::collections::HashMap;\n\n// pub const DEFAULT_TIMEOUT: u64 = 3600; // 1 hour,\n// pub const CONTRACT_PORT: \u0026str = \"ibc:wasm1234567890abcdef\";\n// pub const REMOTE_PORT: \u0026str = \"wasm.outpost\";\n// pub const CONNECTION_ID: \u0026str = \"connection-2\";\n\n// pub fn mock_app() -\u003e App {\n//     let mut env = mock_env();\n//     env.block.time = Timestamp::from_seconds(1689152294);\n//     let api = MockApi::default();\n//     let bank = BankKeeper::new();\n//     let storage = MockStorage::new();\n\n//     AppBuilder::new()\n//         .with_api(api)\n//         .with_block(env.block)\n//         .with_bank(bank)\n//         .with_storage(storage)\n//         .build(|_, _, _| {})\n// }\n\n// /// mock_dependencies is a drop-in replacement for cosmwasm_std::testing::mock_dependencies.\n// /// This uses the Astroport CustomQuerier.\n// #[cfg(test)]\n// pub fn mock_dependencies() -\u003e OwnedDeps\u003cMockStorage, MockApi, WasmMockQuerier\u003e {\n//     let custom_querier: WasmMockQuerier =\n//         WasmMockQuerier::new(MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026[])]));\n\n//     OwnedDeps {\n//         storage: MockStorage::default(),\n//         api: MockApi::default(),\n//         querier: custom_querier,\n//         custom_query_type: Default::default(),\n//     }\n// }\n\n// pub struct WasmMockQuerier {\n//     base: MockQuerier\u003cEmpty\u003e,\n// }\n\n// impl Querier for WasmMockQuerier {\n//     fn raw_query(\u0026self, bin_request: \u0026[u8]) -\u003e QuerierResult {\n//         // MockQuerier doesn't support Custom, so we ignore it completely\n//         let request: QueryRequest\u003cEmpty\u003e = match from_slice(bin_request) {\n//             Ok(v) =\u003e v,\n//             Err(e) =\u003e {\n//                 return SystemResult::Err(SystemError::InvalidRequest {\n//                     error: format!(\"Parsing query request: {}\", e),\n//                     request: bin_request.into(),\n//                 })\n//             }\n//         };\n//         self.handle_query(\u0026request)\n//     }\n// }\n\n// impl WasmMockQuerier {\n//     pub fn handle_query(\u0026self, request: \u0026QueryRequest\u003cEmpty\u003e) -\u003e QuerierResult {\n//         match \u0026request {\n//             QueryRequest::Wasm(WasmQuery::Smart { contract_addr, msg }) =\u003e {\n//                 if contract_addr == \"staking\" {\n//                     match from_binary(\u0026msg).unwrap() {\n//                         astroport_core::staking::QueryMsg::Config {} =\u003e {\n//                             let config = astroport_core::staking::ConfigResponse {\n//                                 deposit_token_addr: Addr::unchecked(\"astro\"),\n//                                 share_token_addr: Addr::unchecked(\"xastro\"),\n//                             };\n\n//                             SystemResult::Ok(to_binary(\u0026config).into())\n//                         }\n//                         _ =\u003e {\n//                             panic!(\"DO NOT ENTER HERE\")\n//                         }\n//                     }\n//                 } else {\n//                     match from_binary(\u0026msg).unwrap() {\n//                         astroport_governance::assembly::QueryMsg::Proposal { proposal_id } =\u003e {\n//                             let proposal = astroport_governance::assembly::Proposal {\n//                                 proposal_id: Uint64::from(proposal_id),\n//                                 submitter: Addr::unchecked(\"submitter\"),\n//                                 status: astroport_governance::assembly::ProposalStatus::Active,\n//                                 for_power: Uint128::zero(),\n//                                 against_power: Uint128::zero(),\n//                                 for_voters: vec![],\n//                                 against_voters: vec![],\n//                                 start_block: 1,\n//                                 start_time: 12345,\n//                                 end_block: 5,\n//                                 delayed_end_block: 10,\n//                                 expiration_block: 15,\n//                                 title: \"Test title\".to_string(),\n//                                 description: \"Test description\".to_string(),\n//                                 link: None,\n//                                 messages: None,\n//                                 deposit_amount: Uint128::one(),\n//                                 ibc_channel: None,\n//                             };\n//                             SystemResult::Ok(to_binary(\u0026proposal).into())\n//                         }\n//                         _ =\u003e {\n//                             println!(\"===========================\");\n//                             println!(\"{}\", msg);\n//                             panic!(\"DO NOT ENTER HEREzz\")\n//                         }\n//                     }\n//                 }\n//             }\n//             _ =\u003e self.base.handle_query(request),\n//         }\n//     }\n// }\n\n// impl WasmMockQuerier {\n//     pub fn new(base: MockQuerier\u003cEmpty\u003e) -\u003e Self {\n//         WasmMockQuerier { base }\n//     }\n// }\n\n// pub fn mock_all(\n//     sender: \u0026str,\n// ) -\u003e (\n//     OwnedDeps\u003cMockStorage, MockApi, WasmMockQuerier\u003e,\n//     Env,\n//     MessageInfo,\n// ) {\n//     let deps = mock_dependencies();\n//     let env = mock_env();\n//     let info = mock_info(sender, \u0026[]);\n//     (deps, env, info)\n// }\n\n// pub fn check_token_balance(app: \u0026mut App, token: \u0026Addr, address: \u0026Addr, expected: u128) {\n//     let msg = Cw20QueryMsg::Balance {\n//         address: address.to_string(),\n//     };\n//     let res: StdResult\u003cBalanceResponse\u003e = app.wrap().query_wasm_smart(token, \u0026msg);\n//     assert_eq!(res.unwrap().balance, Uint128::from(expected));\n// }\n\n// // pub fn mock_channel(channel_id: \u0026str) -\u003e IbcChannel {\n// //     IbcChannel::new(\n// //         IbcEndpoint {\n// //             port_id: CONTRACT_PORT.into(),\n// //             channel_id: channel_id.into(),\n// //         },\n// //         IbcEndpoint {\n// //             port_id: REMOTE_PORT.into(),\n// //             channel_id: format!(\"{}5\", channel_id),\n// //         },\n// //         IbcOrder::Unordered,\n// //         IBC_APP_VERSION,\n// //         CONNECTION_ID,\n// //     )\n// // }\n\n// // pub fn mock_channel_info(channel_id: \u0026str) -\u003e ChannelInfo {\n// //     ChannelInfo {\n// //         id: channel_id.to_string(),\n// //         counterparty_endpoint: IbcEndpoint {\n// //             port_id: REMOTE_PORT.into(),\n// //             channel_id: format!(\"{}5\", channel_id),\n// //         },\n// //         connection_id: CONNECTION_ID.into(),\n// //     }\n// // }\n\n// // we simulate instantiate and ack here\n// // pub fn add_channel(mut deps: DepsMut, channel_id: \u0026str) {\n// //     let channel = mock_channel(channel_id);\n// //     let open_msg = IbcChannelOpenMsg::new_init(channel.clone());\n// //     ibc_channel_open(deps.branch(), mock_env(), open_msg).unwrap();\n// //     let connect_msg = IbcChannelConnectMsg::new_ack(channel, IBC_APP_VERSION);\n// //     ibc_channel_connect(deps.branch(), mock_env(), connect_msg).unwrap();\n// // }\n\n// // pub fn mock_receive_packet(\n// //     my_channel: \u0026str,\n// //     amount: u128,\n// //     denom: \u0026str,\n// //     receiver: \u0026str,\n// //     memo: Option\u003cString\u003e,\n// // ) -\u003e IbcPacket {\n// //     let data = Ics20Packet {\n// //         // this is returning a foreign (our) token, thus denom is \u003cport\u003e/\u003cchannel\u003e/\u003cdenom\u003e\n// //         denom: format!(\"{}/{}/{}\", REMOTE_PORT, \"channel-1234\", denom),\n// //         amount: amount.into(),\n// //         sender: \"remote-sender\".to_string(),\n// //         receiver: receiver.to_string(),\n// //         memo,\n// //     };\n// //     print!(\"Packet denom: {}\", \u0026data.denom);\n// //     IbcPacket::new(\n// //         to_binary(\u0026data).unwrap(),\n// //         IbcEndpoint {\n// //             port_id: REMOTE_PORT.to_string(),\n// //             channel_id: \"channel-1234\".to_string(),\n// //         },\n// //         IbcEndpoint {\n// //             port_id: CONTRACT_PORT.to_string(),\n// //             channel_id: my_channel.to_string(),\n// //         },\n// //         3,\n// //         Timestamp::from_seconds(1665321069).into(),\n// //     )\n// // }\n\n// pub fn mock_ibc_packet(my_channel: \u0026str, data: Binary) -\u003e IbcPacket {\n//     IbcPacket::new(\n//         data,\n//         IbcEndpoint {\n//             port_id: REMOTE_PORT.to_string(),\n//             channel_id: \"channel-3\".to_string(),\n//         },\n//         IbcEndpoint {\n//             port_id: CONTRACT_PORT.to_string(),\n//             channel_id: my_channel.to_string(),\n//         },\n//         3,\n//         Timestamp::from_seconds(1665321069).into(),\n//     )\n// }\n\n// // pub fn setup_channels(channels: \u0026[\u0026str]) -\u003e OwnedDeps\u003cMockStorage, MockApi, WasmMockQuerier\u003e {\n// //     let mut deps = mock_dependencies();\n\n// //     for channel in channels {\n// //         add_channel(deps.as_mut(), channel);\n// //     }\n// //     deps\n// // }\n\n// // #[test]\n// // fn ibc_assembly_vote() {\n// //     pub const OWNER: \u0026str = \"owner\";\n\n// //     let (mut deps, env, info) = mock_all(OWNER);\n\n// //     let token_contract = \"astro\";\n// //     let assembly_contract = \"assembly\";\n// //     let cw20_ics20_contract = \"cw20_ics20\";\n// //     let voter = \"voter1234\";\n// //     let voting_power = Uint128::from(100u128);\n\n// //     instantiate(\n// //         deps.as_mut(),\n// //         env.clone(),\n// //         info,\n// //         astroport_governance::hub::InstantiateMsg {\n// //             owner: \"owner\".to_string(),\n// //             assembly_addr: assembly_contract.to_string(),\n// //             cw20_ics20_addr: \"cw20_ics20\".to_string(),\n// //             staking_addr: \"staking\".to_string(),\n// //             generator_controller_addr: \"generator_controller\".to_string(),\n// //             ibc_timeout_seconds: 10,\n// //         },\n// //     )\n// //     .unwrap();\n\n// //     execute(\n// //         deps.as_mut(),\n// //         env.clone(),\n// //         mock_info(\"owner\", \u0026[]),\n// //         astroport_governance::hub::ExecuteMsg::AddOutpost {\n// //             outpost_addr: \"outpost\".to_string(),\n// //             cw20_ics20_channel: \"channel-1\".to_string(),\n// //         },\n// //     )\n// //     .unwrap();\n\n// //     let proposal_id = 1u64;\n// //     let vote_option = ProposalVoteOption::For;\n\n// //     let ibc_unstake = to_binary(\u0026Hub::CastAssemblyVote {\n// //         proposal_id,\n// //         voter: Addr::unchecked(voter),\n// //         vote_option,\n// //         voting_power,\n// //     })\n// //     .unwrap();\n// //     let recv_packet = mock_ibc_packet(\"channel-3\", ibc_unstake);\n\n// //     let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n// //     let res = ibc_packet_receive(deps.as_mut(), env.clone(), msg).unwrap();\n\n// //     let hub_respone: Response = from_binary(\u0026res.acknowledgement).unwrap();\n// //     match hub_respone {\n// //         Response::Result {\n// //             action,\n// //             address,\n// //             error,\n// //         } =\u003e {\n// //             assert!(error.is_none());\n// //             // assert!(generic.success);\n// //             // assert_eq!(generic.address, voter.to_string());\n// //             // assert_eq!(generic.action, \"cast_assembly_vote\");\n// //             // assert_eq!(generic.message, \"Success\");\n// //         }\n// //         _ =\u003e panic!(\"Wrong response type\"),\n// //     }\n\n// //     assert_eq!(res.messages.len(), 1);\n\n// //     let assembly_msg = to_binary(\n// //         \u0026astroport_governance::assembly::ExecuteMsg::CastOutpostVote {\n// //             proposal_id,\n// //             vote: ProposalVoteOption::For,\n// //             voter: Addr::unchecked(voter),\n// //             voting_power,\n// //         },\n// //     )\n// //     .unwrap();\n\n// //     assert_eq!(\n// //         res.messages[0],\n// //         SubMsg {\n// //             id: 0,\n// //             gas_limit: None,\n// //             reply_on: ReplyOn::Never,\n// //             msg: WasmMsg::Execute {\n// //                 contract_addr: assembly_contract.to_string(),\n// //                 msg: assembly_msg,\n// //                 funds: vec![],\n// //             }\n// //             .into(),\n// //         }\n// //     );\n// // }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","tests","memo.rs"],"content":"use astroport_hub;\n\nuse std::ops::RangeInclusive;\n\nuse astroport_core::token::Cw20Coin;\nuse astroport_cw20_ics20::msg::AllowMsg;\nuse cosmwasm_std::{to_binary, Addr, QueryRequest, Uint128, WasmQuery};\nuse cw20::Cw20ExecuteMsg;\nuse cw_multi_test::{ContractWrapper, Executor};\n\nmod mock;\nuse crate::mock::{check_token_balance, mock_app};\n\nconst VOTING_PERIOD_INTERVAL: RangeInclusive\u003cu64\u003e = 200..=7 * 12342;\nconst DEPOSIT_INTERVAL: RangeInclusive\u003cu128\u003e = 1000..=60000000000;\nconst PROPOSAL_VOTING_PERIOD: u64 = *VOTING_PERIOD_INTERVAL.start();\nconst PROPOSAL_EFFECTIVE_DELAY: u64 = 12_342;\nconst PROPOSAL_EXPIRATION_PERIOD: u64 = 86_399;\nconst PROPOSAL_REQUIRED_DEPOSIT: u128 = *DEPOSIT_INTERVAL.start();\nconst PROPOSAL_REQUIRED_QUORUM: \u0026str = \"0.50\";\nconst PROPOSAL_REQUIRED_THRESHOLD: \u0026str = \"0.60\";\n\n#[test]\nfn receive_invalid_memo() {\n    let send_channel = \"channel-9\";\n\n    let owner = Addr::unchecked(\"terraowner01\");\n\n    let mut router = mock_app();\n\n    let token_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_token::contract::execute,\n        astroport_token::contract::instantiate,\n        astroport_token::contract::query,\n    ));\n\n    let token_code = router.store_code(token_contract);\n\n    let token_default_instantiate_msg = astroport_core::token::InstantiateMsg {\n        name: \"Astroport Token\".to_string(),\n        symbol: \"ASTRO\".to_string(),\n        decimals: 6,\n        initial_balances: vec![Cw20Coin {\n            address: owner.to_string(),\n            amount: Uint128::from(1_000_000_000_000u64),\n        }],\n        mint: None,\n        marketing: None,\n    };\n\n    let token_instance = router\n        .instantiate_contract(\n            token_code,\n            owner.clone(),\n            \u0026token_default_instantiate_msg,\n            \u0026[],\n            \"ASTRO Token\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n        astro_assembly::contract::execute,\n        astro_assembly::contract::instantiate,\n        astro_assembly::contract::query,\n    ));\n\n    let assembly_code = router.store_code(assembly_contract);\n\n    let assembly_default_instantiate_msg = astroport_governance::assembly::InstantiateMsg {\n        xastro_token_addr: \"nocontract\".to_string(), //escrow_helper.xastro_token.to_string(),\n        vxastro_token_addr: None,\n        voting_escrow_delegator_addr: None,\n        ibc_controller: None,\n        generator_controller_addr: None,\n        hub_addr: None,\n        builder_unlock_addr: \"nocontract\".to_string(),\n        proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n        proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n        proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n        proposal_required_deposit: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n        proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n        proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n        whitelisted_links: vec![\"https://some.link/\".to_string()],\n    };\n\n    let assembly_instance = router\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026assembly_default_instantiate_msg,\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let cw20_ics20_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_cw20_ics20::contract::execute,\n        astroport_cw20_ics20::contract::instantiate,\n        astroport_cw20_ics20::contract::query,\n    ));\n\n    let cw20_ics20_code = router.store_code(cw20_ics20_contract);\n\n    let cw20_ics20_instantiate_msg = astroport_cw20_ics20::msg::InitMsg {\n        default_timeout: 10,\n        gov_contract: owner.to_string(),\n        allowlist: vec![AllowMsg {\n            contract: token_instance.to_string(),\n            gas_limit: None,\n        }],\n        default_gas_limit: None,\n        memo_handler: None,\n    };\n\n    let cw20_ics20_instance = router\n        .instantiate_contract(\n            cw20_ics20_code,\n            owner.clone(),\n            \u0026cw20_ics20_instantiate_msg,\n            \u0026[],\n            \"CW20-ICS20\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    // Set up staking\n    let staking_contract = Box::new(\n        ContractWrapper::new_with_empty(\n            astroport_staking::contract::execute,\n            astroport_staking::contract::instantiate,\n            astroport_staking::contract::query,\n        )\n        .with_reply_empty(astroport_staking::contract::reply),\n    );\n\n    let staking_code_id = router.store_code(staking_contract);\n\n    let msg = astroport_core::staking::InstantiateMsg {\n        owner: owner.to_string(),\n        token_code_id: token_code,\n        deposit_token_addr: token_instance.to_string(),\n        marketing: None,\n    };\n    let staking_instance = router\n        .instantiate_contract(\n            staking_code_id,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            String::from(\"xASTRO\"),\n            None,\n        )\n        .unwrap();\n\n    let outpost_handler_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_hub::execute::execute,\n        astroport_hub::contract::instantiate,\n        astroport_hub::query::query,\n    ));\n\n    let outpost_handler_code = router.store_code(outpost_handler_contract);\n\n    let outpost_handler_instantiate_msg = astroport_governance::hub::InstantiateMsg {\n        owner: owner.to_string(),\n        assembly_addr: assembly_instance.to_string(),\n        cw20_ics20_addr: cw20_ics20_instance.to_string(),\n        staking_addr: staking_instance.to_string(),\n        generator_controller_addr: \"generator_controller\".to_string(),\n        ibc_timeout_seconds: 10,\n    };\n\n    let outpost_handler_instance = router\n        .instantiate_contract(\n            outpost_handler_code,\n            owner.clone(),\n            \u0026outpost_handler_instantiate_msg,\n            \u0026[],\n            \"Outpost handler\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let msg = Cw20ExecuteMsg::Transfer {\n        recipient: cw20_ics20_instance.to_string(),\n        amount: Uint128::from(100u64),\n    };\n\n    router\n        .execute_contract(owner.clone(), token_instance.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    check_token_balance(\u0026mut router, \u0026token_instance, \u0026cw20_ics20_instance, 100u128);\n\n    let msg = Cw20ExecuteMsg::Send {\n        contract: outpost_handler_instance.to_string(),\n        msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::OutpostMemo {\n            channel: send_channel.to_string(),\n            sender: owner.to_string(),\n            receiver: outpost_handler_instance.to_string(),\n            memo: \"{invalid_json\".to_string(),\n        })\n        .unwrap(),\n        amount: Uint128::from(100u64),\n    };\n\n    let res = router\n        .execute_contract(\n            Addr::unchecked(cw20_ics20_instance),\n            token_instance.clone(),\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        res.root_cause().to_string(),\n        \"Memo does not conform to the expected format: Invalid type\"\n    );\n    // TODO Update outpost handler config\n\n    // Try to send an invalid Memo\n    // The contract must hold nothing\n    check_token_balance(\n        \u0026mut router,\n        \u0026token_instance,\n        \u0026outpost_handler_instance,\n        0u128,\n    );\n\n    // Instantiate all the contracts we need to load this contract\n}\n\n#[test]\nfn receive_standard_transfer_memo() {\n    let send_channel = \"channel-9\";\n    let cw20_addr = \"token-addr\";\n    let cw20_denom = \"cw20:token-addr\";\n    let gas_limit = 1234567;\n\n    // let recv_packet = mock_receive_packet(send_channel, 100000, cw20_denom, \"local-rcpt\", None);\n\n    let owner = Addr::unchecked(\"terraowner01\");\n    let hub_user = Addr::unchecked(\"terrauser01\");\n    let outpost_user = Addr::unchecked(\"injuser01\");\n\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n\n    let token_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_token::contract::execute,\n        astroport_token::contract::instantiate,\n        astroport_token::contract::query,\n    ));\n\n    let token_code = router.store_code(token_contract);\n\n    let token_default_instantiate_msg = astroport_core::token::InstantiateMsg {\n        name: \"Astroport Token\".to_string(),\n        symbol: \"ASTRO\".to_string(),\n        decimals: 6,\n        initial_balances: vec![Cw20Coin {\n            address: owner.to_string(),\n            amount: Uint128::from(1_000_000_000_000u64),\n        }],\n        mint: None,\n        marketing: None,\n    };\n\n    let token_instance = router\n        .instantiate_contract(\n            token_code,\n            owner.clone(),\n            \u0026token_default_instantiate_msg,\n            \u0026[],\n            \"ASTRO Token\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n        astro_assembly::contract::execute,\n        astro_assembly::contract::instantiate,\n        astro_assembly::contract::query,\n    ));\n\n    let assembly_code = router.store_code(assembly_contract);\n\n    let assembly_default_instantiate_msg = astroport_governance::assembly::InstantiateMsg {\n        xastro_token_addr: \"nocontract\".to_string(), //escrow_helper.xastro_token.to_string(),\n        vxastro_token_addr: None,\n        voting_escrow_delegator_addr: None,\n        ibc_controller: None,\n        generator_controller_addr: None,\n        hub_addr: None,\n        builder_unlock_addr: \"nocontract\".to_string(),\n        proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n        proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n        proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n        proposal_required_deposit: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n        proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n        proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n        whitelisted_links: vec![\"https://some.link/\".to_string()],\n    };\n\n    let assembly_instance = router\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026assembly_default_instantiate_msg,\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let cw20_ics20_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_cw20_ics20::contract::execute,\n        astroport_cw20_ics20::contract::instantiate,\n        astroport_cw20_ics20::contract::query,\n    ));\n\n    let cw20_ics20_code = router.store_code(cw20_ics20_contract);\n\n    let cw20_ics20_instantiate_msg = astroport_cw20_ics20::msg::InitMsg {\n        default_timeout: 10,\n        gov_contract: owner.to_string(),\n        allowlist: vec![AllowMsg {\n            contract: token_instance.to_string(),\n            gas_limit: None,\n        }],\n        default_gas_limit: None,\n        memo_handler: None,\n    };\n\n    let cw20_ics20_instance = router\n        .instantiate_contract(\n            cw20_ics20_code,\n            owner.clone(),\n            \u0026cw20_ics20_instantiate_msg,\n            \u0026[],\n            \"CW20-ICS20\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let msg = Cw20ExecuteMsg::Transfer {\n        recipient: cw20_ics20_instance.to_string(),\n        amount: Uint128::from(100u64),\n    };\n\n    router\n        .execute_contract(owner.clone(), token_instance.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    // Set up staking\n    let staking_contract = Box::new(\n        ContractWrapper::new_with_empty(\n            astroport_staking::contract::execute,\n            astroport_staking::contract::instantiate,\n            astroport_staking::contract::query,\n        )\n        .with_reply_empty(astroport_staking::contract::reply),\n    );\n\n    let staking_code_id = router.store_code(staking_contract);\n\n    let msg = astroport_core::staking::InstantiateMsg {\n        owner: owner.to_string(),\n        token_code_id: token_code,\n        deposit_token_addr: token_instance.to_string(),\n        marketing: None,\n    };\n    let staking_instance = router\n        .instantiate_contract(\n            staking_code_id,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            String::from(\"xASTRO\"),\n            None,\n        )\n        .unwrap();\n\n    let outpost_handler_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_hub::execute::execute,\n        astroport_hub::contract::instantiate,\n        astroport_hub::query::query,\n    ));\n\n    let outpost_handler_code = router.store_code(outpost_handler_contract);\n\n    let outpost_handler_instantiate_msg = astroport_governance::hub::InstantiateMsg {\n        owner: owner.to_string(),\n        assembly_addr: assembly_instance.to_string(),\n        cw20_ics20_addr: cw20_ics20_instance.to_string(),\n        staking_addr: staking_instance.to_string(),\n        generator_controller_addr: \"assembly\".to_string(),\n        ibc_timeout_seconds: 10,\n    };\n\n    check_token_balance(\u0026mut router, \u0026token_instance, \u0026hub_user, 0u128);\n\n    let outpost_handler_instance = router\n        .instantiate_contract(\n            outpost_handler_code,\n            owner.clone(),\n            \u0026outpost_handler_instantiate_msg,\n            \u0026[],\n            \"Outpost handler\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let msg = Cw20ExecuteMsg::Send {\n        contract: outpost_handler_instance.to_string(),\n        msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::OutpostMemo {\n            channel: send_channel.to_string(),\n            sender: owner.to_string(),\n            receiver: hub_user.to_string(),\n            memo: \"Standard memo that should not be processed\".to_string(),\n        })\n        .unwrap(),\n        amount: Uint128::from(100u64),\n    };\n\n    let res = router.execute_contract(\n        Addr::unchecked(cw20_ics20_instance),\n        token_instance.clone(),\n        \u0026msg,\n        \u0026[],\n    );\n    assert!(res.is_ok());\n\n    // Check that the balance of Hub user increased\n    check_token_balance(\u0026mut router, \u0026token_instance, \u0026hub_user, 100u128);\n    // The contract must hold nothing\n    check_token_balance(\n        \u0026mut router,\n        \u0026token_instance,\n        \u0026outpost_handler_instance,\n        0u128,\n    );\n}\n\n#[test]\n#[cfg(test)]\nfn receive_stake_memo() {\n    let send_channel = \"channel-9\";\n    let cw20_addr = \"token-addr\";\n    let cw20_denom = \"cw20:token-addr\";\n    let gas_limit = 1234567;\n\n    // let recv_packet = mock_receive_packet(send_channel, 100000, cw20_denom, \"local-rcpt\", None);\n\n    let owner = Addr::unchecked(\"terraowner01\");\n    let hub_user = Addr::unchecked(\"terrauser01\");\n    let outpost_user = Addr::unchecked(\"injuser01\");\n\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n\n    let token_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_token::contract::execute,\n        astroport_token::contract::instantiate,\n        astroport_token::contract::query,\n    ));\n\n    let token_code = router.store_code(token_contract);\n\n    let token_default_instantiate_msg = astroport_core::token::InstantiateMsg {\n        name: \"Astroport Token\".to_string(),\n        symbol: \"ASTRO\".to_string(),\n        decimals: 6,\n        initial_balances: vec![Cw20Coin {\n            address: owner.to_string(),\n            amount: Uint128::from(1_000_000_000_000u64),\n        }],\n        mint: None,\n        marketing: None,\n    };\n\n    let token_instance = router\n        .instantiate_contract(\n            token_code,\n            owner.clone(),\n            \u0026token_default_instantiate_msg,\n            \u0026[],\n            \"ASTRO Token\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n        astro_assembly::contract::execute,\n        astro_assembly::contract::instantiate,\n        astro_assembly::contract::query,\n    ));\n\n    let assembly_code = router.store_code(assembly_contract);\n\n    let assembly_default_instantiate_msg = astroport_governance::assembly::InstantiateMsg {\n        xastro_token_addr: \"nocontract\".to_string(), //escrow_helper.xastro_token.to_string(),\n        vxastro_token_addr: None,\n        voting_escrow_delegator_addr: None,\n        ibc_controller: None,\n        generator_controller_addr: None,\n        hub_addr: None,\n        builder_unlock_addr: \"nocontract\".to_string(),\n        proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n        proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n        proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n        proposal_required_deposit: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n        proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n        proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n        whitelisted_links: vec![\"https://some.link/\".to_string()],\n    };\n\n    let assembly_instance = router\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026assembly_default_instantiate_msg,\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let cw20_ics20_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_cw20_ics20::contract::execute,\n        astroport_cw20_ics20::contract::instantiate,\n        astroport_cw20_ics20::contract::query,\n    ));\n\n    let cw20_ics20_code = router.store_code(cw20_ics20_contract);\n\n    let cw20_ics20_instantiate_msg = astroport_cw20_ics20::msg::InitMsg {\n        default_timeout: 10,\n        gov_contract: owner.to_string(),\n        allowlist: vec![AllowMsg {\n            contract: token_instance.to_string(),\n            gas_limit: None,\n        }],\n        default_gas_limit: None,\n        memo_handler: None,\n    };\n\n    let cw20_ics20_instance = router\n        .instantiate_contract(\n            cw20_ics20_code,\n            owner.clone(),\n            \u0026cw20_ics20_instantiate_msg,\n            \u0026[],\n            \"CW20-ICS20\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let msg = Cw20ExecuteMsg::Transfer {\n        recipient: cw20_ics20_instance.to_string(),\n        amount: Uint128::from(100000u64),\n    };\n\n    router\n        .execute_contract(owner.clone(), token_instance.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    // let (astro_token_instance, staking_instance, _) =\n    //     instantiate_contracts(\u0026mut router, owner.clone());\n\n    // Set up staking\n    let staking_contract = Box::new(\n        ContractWrapper::new_with_empty(\n            astroport_staking::contract::execute,\n            astroport_staking::contract::instantiate,\n            astroport_staking::contract::query,\n        )\n        .with_reply_empty(astroport_staking::contract::reply),\n    );\n\n    let staking_code_id = router.store_code(staking_contract);\n\n    let msg = astroport_core::staking::InstantiateMsg {\n        owner: owner.to_string(),\n        token_code_id: token_code,\n        deposit_token_addr: token_instance.to_string(),\n        marketing: None,\n    };\n    let staking_instance = router\n        .instantiate_contract(\n            staking_code_id,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            String::from(\"xASTRO\"),\n            None,\n        )\n        .unwrap();\n\n    let msg = astroport_core::staking::QueryMsg::Config {};\n    let res = router\n        .wrap()\n        .query::\u003castroport_core::staking::ConfigResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: staking_instance.to_string(),\n            msg: to_binary(\u0026msg).unwrap(),\n        }))\n        .unwrap();\n    let x_astro_token_instance = res.share_token_addr;\n\n    let outpost_handler_contract = Box::new(\n        ContractWrapper::new_with_empty(\n            astroport_hub::execute::execute,\n            astroport_hub::contract::instantiate,\n            astroport_hub::query::query,\n        )\n        .with_reply(astroport_hub::reply::reply),\n    );\n\n    let outpost_handler_code = router.store_code(outpost_handler_contract);\n\n    let outpost_handler_instantiate_msg = astroport_governance::hub::InstantiateMsg {\n        owner: owner.to_string(),\n        assembly_addr: assembly_instance.to_string(),\n        cw20_ics20_addr: cw20_ics20_instance.to_string(),\n        staking_addr: staking_instance.to_string(),\n        generator_controller_addr: \"generator_controller\".to_string(),\n        ibc_timeout_seconds: 10,\n    };\n\n    let outpost_handler_instance = router\n        .instantiate_contract(\n            outpost_handler_code,\n            owner.clone(),\n            \u0026outpost_handler_instantiate_msg,\n            \u0026[],\n            \"Outpost handler\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let msg = astroport_governance::hub::ExecuteMsg::AddOutpost {\n        outpost_addr: \"outpost\".to_owned(),\n        cw20_ics20_channel: \"channel-1\".to_owned(),\n    };\n\n    // Add an outpost\n    let res = router\n        .execute_contract(\n            Addr::unchecked(owner.clone()),\n            outpost_handler_instance.clone(),\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let msg = Cw20ExecuteMsg::Send {\n        contract: outpost_handler_instance.to_string(),\n        msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::OutpostMemo {\n            channel: \"channel-1\".to_string(),\n            sender: owner.to_string(),\n            receiver: outpost_handler_instance.to_string(),\n            memo: \"{\\\"stake\\\": {}}\".to_string(),\n        })\n        .unwrap(),\n        amount: Uint128::from(100u64),\n    };\n\n    // First staker must send more that 1000astro, otherwise staking will fail, we test for fail here\n    let res = router\n        .execute_contract(\n            Addr::unchecked(cw20_ics20_instance.clone()),\n            token_instance.clone(),\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n            res.root_cause().to_string(),\n        \"Invalid submessage error executing WasmMsg:\\nsender: contract5\\nExecute { contract_addr: \\\"contract0\\\", msg: {\\\"send\\\":{\\\"contract\\\":\\\"contract3\\\",\\\"amount\\\":\\\"100\\\",\\\"msg\\\":\\\"eyJlbnRlciI6e319\\\"}}, funds: [] }\");\n\n    let msg = Cw20ExecuteMsg::Send {\n        contract: outpost_handler_instance.to_string(),\n        msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::OutpostMemo {\n            channel: \"channel-1\".to_string(),\n            sender: owner.to_string(),\n            receiver: outpost_handler_instance.to_string(),\n            memo: \"{\\\"stake\\\": {}}\".to_string(),\n        })\n        .unwrap(),\n        amount: Uint128::from(10000u64),\n    };\n\n    // Check that the contract blocks anyone else\n    let res = router\n        .execute_contract(owner.clone(), token_instance.clone(), \u0026msg, \u0026[])\n        .unwrap_err();\n    assert_eq!(res.root_cause().to_string(), \"Unauthorized\");\n\n    let query_msg = astroport_governance::hub::QueryMsg::Outposts {};\n    let res: Vec\u003castroport_governance::hub::OutpostConfig\u003e = router\n        .wrap()\n        .query_wasm_smart(outpost_handler_instance, \u0026query_msg)\n        .unwrap();\n\n    // Check that the contract emits a mint IBC message\n    // cw-multitest doesn't support IBC yet, and thus will return the IBC message as an error\n    // We check the format against that error\n    let res = router\n        .execute_contract(\n            Addr::unchecked(cw20_ics20_instance),\n            token_instance,\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n            res.root_cause().to_string(),\n            \"Unexpected exec msg SendPacket { channel_id: \\\"channel-3\\\", data: Binary(7b226d696e745f785f617374726f223a7b227265636569766572223a2274657272616f776e65723031222c22616d6f756e74223a2239303030227d7d), timeout: IbcTimeout { block: None, timestamp: Some(Timestamp(Uint64(1689152304000000000))) } } from Addr(\\\"contract5\\\")\"\n        );\n\n    // We will always receive this error since we can't actually establish an IBC connection that would\n    // construct the valid outpost link\n    // let res = router\n    //     .execute_contract(Addr::unchecked(cw20_ics20_instance), token_instance, \u0026msg, \u0026[])\n    //     .unwrap_err();\n    // assert_eq!(\n    //     res.root_cause().to_string(),\n    //     \"No Outpost found that matches the message channels\"\n    // );\n}\n\n// use std::ops::RangeInclusive;\n\n// use astroport_cw20_ics20::msg::AllowMsg;\n\n// use astroport_hub::mock::mock_app;\n// use cosmwasm_std::{Addr, Uint128};\n// use cw20::Cw20Coin;\n// use cw_multi_test::ContractWrapper;\n\n// #[cfg(test)]\n// mod helper;\n\n// const VOTING_PERIOD_INTERVAL: RangeInclusive\u003cu64\u003e = 200..=7 * 12342;\n// const DEPOSIT_INTERVAL: RangeInclusive\u003cu128\u003e = 1000..=60000000000;\n// const PROPOSAL_VOTING_PERIOD: u64 = *VOTING_PERIOD_INTERVAL.start();\n// const PROPOSAL_EFFECTIVE_DELAY: u64 = 12_342;\n// const PROPOSAL_EXPIRATION_PERIOD: u64 = 86_399;\n// const PROPOSAL_REQUIRED_DEPOSIT: u128 = *DEPOSIT_INTERVAL.start();\n// const PROPOSAL_REQUIRED_QUORUM: \u0026str = \"0.50\";\n// const PROPOSAL_REQUIRED_THRESHOLD: \u0026str = \"0.60\";\n\n// #[test]\n// fn update_config() {\n//     let send_channel = \"channel-9\";\n//     let cw20_addr = \"token-addr\";\n//     let cw20_denom = \"cw20:token-addr\";\n//     let gas_limit = 1234567;\n\n//     // let recv_packet = mock_receive_packet(send_channel, 100000, cw20_denom, \"local-rcpt\", None);\n\n//     let owner = Addr::unchecked(\"terraowner01\");\n//     let hub_user = Addr::unchecked(\"terrauser01\");\n//     let outpost_user = Addr::unchecked(\"injuser01\");\n\n//     let mut router = mock_app();\n//     let router_ref = \u0026mut router;\n\n//     let token_contract = Box::new(ContractWrapper::new_with_empty(\n//         astroport_token::contract::execute,\n//         astroport_token::contract::instantiate,\n//         astroport_token::contract::query,\n//     ));\n\n//     let token_code = router.store_code(token_contract);\n\n//     let token_default_instantiate_msg = astroport_core::token::InstantiateMsg {\n//         name: \"Astroport Token\".to_string(),\n//         symbol: \"ASTRO\".to_string(),\n//         decimals: 6,\n//         initial_balances: vec![Cw20Coin {\n//             address: owner.to_string(),\n//             amount: Uint128::from(1_000_000_000_000u64),\n//         }],\n//         mint: None,\n//         marketing: None,\n//     };\n\n//     let token_instance = router\n//         .instantiate_contract(\n//             token_code,\n//             owner.clone(),\n//             \u0026token_default_instantiate_msg,\n//             \u0026[],\n//             \"ASTRO Token\".to_string(),\n//             Some(owner.to_string()),\n//         )\n//         .unwrap();\n\n//     let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n//         astro_assembly::contract::execute,\n//         astro_assembly::contract::instantiate,\n//         astro_assembly::contract::query,\n//     ));\n\n//     let assembly_code = router.store_code(assembly_contract);\n\n//     let assembly_default_instantiate_msg = astroport_governance::assembly::InstantiateMsg {\n//         xastro_token_addr: \"nocontract\".to_string(), //escrow_helper.xastro_token.to_string(),\n//         vxastro_token_addr: None,\n//         voting_escrow_delegator_addr: None,\n//         ibc_controller: None,\n//         generator_controller_addr: None,\n//         hub_addr: None,\n//         builder_unlock_addr: \"nocontract\".to_string(),\n//         proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n//         proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n//         proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n//         proposal_required_deposit: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n//         proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n//         proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n//         whitelisted_links: vec![\"https://some.link/\".to_string()],\n//     };\n\n//     let assembly_instance = router\n//         .instantiate_contract(\n//             assembly_code,\n//             owner.clone(),\n//             \u0026assembly_default_instantiate_msg,\n//             \u0026[],\n//             \"Assembly\".to_string(),\n//             Some(owner.to_string()),\n//         )\n//         .unwrap();\n\n//     let cw20_ics20_contract = Box::new(ContractWrapper::new_with_empty(\n//         astroport_cw20_ics20::contract::execute,\n//         astroport_cw20_ics20::contract::instantiate,\n//         astroport_cw20_ics20::contract::query,\n//     ));\n\n//     let cw20_ics20_code = router.store_code(cw20_ics20_contract);\n\n//     let cw20_ics20_instantiate_msg = astroport_cw20_ics20::msg::InitMsg {\n//         default_timeout: 10,\n//         gov_contract: owner.to_string(),\n//         allowlist: vec![AllowMsg {\n//             contract: token_instance.to_string(),\n//             gas_limit: None,\n//         }],\n//         default_gas_limit: None,\n//         memo_handler: None,\n//     };\n\n//     let cw20_ics20_instance = router\n//         .instantiate_contract(\n//             cw20_ics20_code,\n//             owner.clone(),\n//             \u0026cw20_ics20_instantiate_msg,\n//             \u0026[],\n//             \"CW20-ICS20\".to_string(),\n//             Some(owner.to_string()),\n//         )\n//         .unwrap();\n\n//     // Set up staking\n//     let staking_contract = Box::new(\n//         ContractWrapper::new_with_empty(\n//             astroport_staking::contract::execute,\n//             astroport_staking::contract::instantiate,\n//             astroport_staking::contract::query,\n//         )\n//         .with_reply_empty(astroport_staking::contract::reply),\n//     );\n\n//     let staking_code_id = router.store_code(staking_contract);\n\n//     let msg = astroport_core::staking::InstantiateMsg {\n//         owner: owner.to_string(),\n//         token_code_id: token_code,\n//         deposit_token_addr: token_instance.to_string(),\n//         marketing: None,\n//     };\n//     let staking_instance = router\n//         .instantiate_contract(\n//             staking_code_id,\n//             owner.clone(),\n//             \u0026msg,\n//             \u0026[],\n//             String::from(\"xASTRO\"),\n//             None,\n//         )\n//         .unwrap();\n\n//     let outpost_handler_contract = Box::new(ContractWrapper::new_with_empty(\n//         astroport_hub::execute::execute,\n//         astroport_hub::contract::instantiate,\n//         astroport_hub::query::query,\n//     ));\n\n//     let outpost_handler_code = router.store_code(outpost_handler_contract);\n\n//     let outpost_handler_instantiate_msg = astroport_governance::hub::InstantiateMsg {\n//         owner: owner.to_string(),\n//         assembly_addr: assembly_instance.to_string(),\n//         cw20_ics20_addr: cw20_ics20_instance.to_string(),\n//         staking_addr: staking_instance.to_string(),\n//         generator_controller_addr: \"generator_controller\".to_string(),\n//         ibc_timeout_seconds: 10,\n//     };\n\n//     let outpost_handler_instance = router\n//         .instantiate_contract(\n//             outpost_handler_code,\n//             owner.clone(),\n//             \u0026outpost_handler_instantiate_msg,\n//             \u0026[],\n//             \"Outpost handler\".to_string(),\n//             Some(owner.to_string()),\n//         )\n//         .unwrap();\n// }\n\n// // #[cfg(test)]\n// // mod tests {\n// // use super::*;\n\n// //     use std::{cell::RefCell, ops::RangeInclusive, rc::Rc};\n\n// //     use astroport_core::{\n// //         querier::query_balance,\n// //         token::{BalanceResponse, Cw20Coin},\n// //     };\n// //     use astroport_cw20_ics20::msg::AllowMsg;\n// //     use astroport_governance::hub;\n// //     use cosmwasm_std::{\n// //         testing::{mock_env, MockApi, MockStorage},\n// //         to_binary, Addr, Coin, QueryRequest, StdResult, Timestamp, Uint128, WasmQuery,\n// //     };\n// //     use cw20::{Cw20ExecuteMsg, Cw20QueryMsg};\n// //     use cw_multi_test::{App, AppBuilder, BankKeeper, BasicApp, ContractWrapper, Executor};\n\n// //     use crate::helper::{check_token_balance, mock_app};\n\n// //     const VOTING_PERIOD_INTERVAL: RangeInclusive\u003cu64\u003e = 200..=7 * 12342;\n// //     const DEPOSIT_INTERVAL: RangeInclusive\u003cu128\u003e = 1000..=60000000000;\n// //     const PROPOSAL_VOTING_PERIOD: u64 = *VOTING_PERIOD_INTERVAL.start();\n// //     const PROPOSAL_EFFECTIVE_DELAY: u64 = 12_342;\n// //     const PROPOSAL_EXPIRATION_PERIOD: u64 = 86_399;\n// //     const PROPOSAL_REQUIRED_DEPOSIT: u128 = *DEPOSIT_INTERVAL.start();\n// //     const PROPOSAL_REQUIRED_QUORUM: \u0026str = \"0.50\";\n// //     const PROPOSAL_REQUIRED_THRESHOLD: \u0026str = \"0.60\";\n\n// //     #[test]\n// //     fn receive_invalid_memo() {\n// //         let send_channel = \"channel-9\";\n// //         let cw20_addr = \"token-addr\";\n// //         let cw20_denom = \"cw20:token-addr\";\n// //         let gas_limit = 1234567;\n\n// //         // let recv_packet = mock_receive_packet(send_channel, 100000, cw20_denom, \"local-rcpt\", None);\n\n// //         let owner = Addr::unchecked(\"terraowner01\");\n// //         let hub_user = Addr::unchecked(\"terrauser01\");\n// //         let outpost_user = Addr::unchecked(\"injuser01\");\n\n// //         let mut router = mock_app();\n// //         let router_ref = \u0026mut router;\n\n// //         let token_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astroport_token::contract::execute,\n// //             astroport_token::contract::instantiate,\n// //             astroport_token::contract::query,\n// //         ));\n\n// //         let token_code = router.store_code(token_contract);\n\n// //         let token_default_instantiate_msg = astroport_core::token::InstantiateMsg {\n// //             name: \"Astroport Token\".to_string(),\n// //             symbol: \"ASTRO\".to_string(),\n// //             decimals: 6,\n// //             initial_balances: vec![Cw20Coin {\n// //                 address: owner.to_string(),\n// //                 amount: Uint128::from(1_000_000_000_000u64),\n// //             }],\n// //             mint: None,\n// //             marketing: None,\n// //         };\n\n// //         let token_instance = router\n// //             .instantiate_contract(\n// //                 token_code,\n// //                 owner.clone(),\n// //                 \u0026token_default_instantiate_msg,\n// //                 \u0026[],\n// //                 \"ASTRO Token\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astro_assembly::contract::execute,\n// //             astro_assembly::contract::instantiate,\n// //             astro_assembly::contract::query,\n// //         ));\n\n// //         let assembly_code = router.store_code(assembly_contract);\n\n// //         let assembly_default_instantiate_msg = astroport_governance::assembly::InstantiateMsg {\n// //             xastro_token_addr: \"nocontract\".to_string(), //escrow_helper.xastro_token.to_string(),\n// //             vxastro_token_addr: None,\n// //             voting_escrow_delegator_addr: None,\n// //             ibc_controller: None,\n// //             generator_controller_addr: None,\n// //             hub_addr: None,\n// //             builder_unlock_addr: \"nocontract\".to_string(),\n// //             proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n// //             proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n// //             proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n// //             proposal_required_deposit: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n// //             proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n// //             proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n// //             whitelisted_links: vec![\"https://some.link/\".to_string()],\n// //         };\n\n// //         let assembly_instance = router\n// //             .instantiate_contract(\n// //                 assembly_code,\n// //                 owner.clone(),\n// //                 \u0026assembly_default_instantiate_msg,\n// //                 \u0026[],\n// //                 \"Assembly\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let cw20_ics20_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astroport_cw20_ics20::contract::execute,\n// //             astroport_cw20_ics20::contract::instantiate,\n// //             astroport_cw20_ics20::contract::query,\n// //         ));\n\n// //         let cw20_ics20_code = router.store_code(cw20_ics20_contract);\n\n// //         let cw20_ics20_instantiate_msg = astroport_cw20_ics20::msg::InitMsg {\n// //             default_timeout: 10,\n// //             gov_contract: owner.to_string(),\n// //             allowlist: vec![AllowMsg {\n// //                 contract: token_instance.to_string(),\n// //                 gas_limit: None,\n// //             }],\n// //             default_gas_limit: None,\n// //             memo_handler: None,\n// //         };\n\n// //         let cw20_ics20_instance = router\n// //             .instantiate_contract(\n// //                 cw20_ics20_code,\n// //                 owner.clone(),\n// //                 \u0026cw20_ics20_instantiate_msg,\n// //                 \u0026[],\n// //                 \"CW20-ICS20\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         // Set up staking\n// //         let staking_contract = Box::new(\n// //             ContractWrapper::new_with_empty(\n// //                 astroport_staking::contract::execute,\n// //                 astroport_staking::contract::instantiate,\n// //                 astroport_staking::contract::query,\n// //             )\n// //             .with_reply_empty(astroport_staking::contract::reply),\n// //         );\n\n// //         let staking_code_id = router.store_code(staking_contract);\n\n// //         let msg = astroport_core::staking::InstantiateMsg {\n// //             owner: owner.to_string(),\n// //             token_code_id: token_code,\n// //             deposit_token_addr: token_instance.to_string(),\n// //             marketing: None,\n// //         };\n// //         let staking_instance = router\n// //             .instantiate_contract(\n// //                 staking_code_id,\n// //                 owner.clone(),\n// //                 \u0026msg,\n// //                 \u0026[],\n// //                 String::from(\"xASTRO\"),\n// //                 None,\n// //             )\n// //             .unwrap();\n\n// //         let outpost_handler_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astroport_hub::execute::execute,\n// //             astroport_hub::contract::instantiate,\n// //             astroport_hub::query::query,\n// //         ));\n\n// //         let outpost_handler_code = router.store_code(outpost_handler_contract);\n\n// //         let outpost_handler_instantiate_msg = astroport_governance::hub::InstantiateMsg {\n// //             owner: owner.to_string(),\n// //             assembly_addr: assembly_instance.to_string(),\n// //             cw20_ics20_addr: cw20_ics20_instance.to_string(),\n// //             staking_addr: staking_instance.to_string(),\n// //             generator_controller_addr: \"generator_controller\".to_string(),\n// //             ibc_timeout_seconds: 10,\n// //         };\n\n// //         let outpost_handler_instance = router\n// //             .instantiate_contract(\n// //                 outpost_handler_code,\n// //                 owner.clone(),\n// //                 \u0026outpost_handler_instantiate_msg,\n// //                 \u0026[],\n// //                 \"Outpost handler\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let msg = Cw20ExecuteMsg::Transfer {\n// //             recipient: cw20_ics20_instance.to_string(),\n// //             amount: Uint128::from(100u64),\n// //         };\n\n// //         router.execute_contract(owner.clone(), token_instance.clone(), \u0026msg, \u0026[]).unwrap();\n\n// //         check_token_balance(\n// //             \u0026mut router,\n// //             \u0026token_instance,\n// //             \u0026cw20_ics20_instance,\n// //             100u128,\n// //         );\n\n// //         let msg = Cw20ExecuteMsg::Send {\n// //             contract: outpost_handler_instance.to_string(),\n// //             msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::OutpostMemo {\n// //                 channel: send_channel.to_string(),\n// //                 sender: owner.to_string(),\n// //                 receiver: outpost_handler_instance.to_string(),\n// //                 memo: \"{invalid_json\".to_string(),\n// //             })\n// //             .unwrap(),\n// //             amount: Uint128::from(100u64),\n// //         };\n\n// //         let res = router\n// //             .execute_contract(Addr::unchecked(cw20_ics20_instance), token_instance.clone(), \u0026msg, \u0026[])\n// //             .unwrap_err();\n// //         assert_eq!(\n// //             res.root_cause().to_string(),\n// //             \"Memo does not conform to the expected format: Invalid type\"\n// //         );\n// //         // TODO Update outpost handler config\n\n// //         // Try to send an invalid Memo\n// //         // The contract must hold nothing\n// //         check_token_balance(\n// //             \u0026mut router,\n// //             \u0026token_instance,\n// //             \u0026outpost_handler_instance,\n// //             0u128,\n// //         );\n\n// //         // Instantiate all the contracts we need to load this contract\n// //     }\n\n// //     #[test]\n// //     fn receive_standard_transfer_memo() {\n// //         let send_channel = \"channel-9\";\n// //         let cw20_addr = \"token-addr\";\n// //         let cw20_denom = \"cw20:token-addr\";\n// //         let gas_limit = 1234567;\n\n// //         // let recv_packet = mock_receive_packet(send_channel, 100000, cw20_denom, \"local-rcpt\", None);\n\n// //         let owner = Addr::unchecked(\"terraowner01\");\n// //         let hub_user = Addr::unchecked(\"terrauser01\");\n// //         let outpost_user = Addr::unchecked(\"injuser01\");\n\n// //         let mut router = mock_app();\n// //         let router_ref = \u0026mut router;\n\n// //         let token_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astroport_token::contract::execute,\n// //             astroport_token::contract::instantiate,\n// //             astroport_token::contract::query,\n// //         ));\n\n// //         let token_code = router.store_code(token_contract);\n\n// //         let token_default_instantiate_msg = astroport_core::token::InstantiateMsg {\n// //             name: \"Astroport Token\".to_string(),\n// //             symbol: \"ASTRO\".to_string(),\n// //             decimals: 6,\n// //             initial_balances: vec![Cw20Coin {\n// //                 address: owner.to_string(),\n// //                 amount: Uint128::from(1_000_000_000_000u64),\n// //             }],\n// //             mint: None,\n// //             marketing: None,\n// //         };\n\n// //         let token_instance = router\n// //             .instantiate_contract(\n// //                 token_code,\n// //                 owner.clone(),\n// //                 \u0026token_default_instantiate_msg,\n// //                 \u0026[],\n// //                 \"ASTRO Token\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astro_assembly::contract::execute,\n// //             astro_assembly::contract::instantiate,\n// //             astro_assembly::contract::query,\n// //         ));\n\n// //         let assembly_code = router.store_code(assembly_contract);\n\n// //         let assembly_default_instantiate_msg = astroport_governance::assembly::InstantiateMsg {\n// //             xastro_token_addr: \"nocontract\".to_string(), //escrow_helper.xastro_token.to_string(),\n// //             vxastro_token_addr: None,\n// //             voting_escrow_delegator_addr: None,\n// //             ibc_controller: None,\n// //             generator_controller_addr: None,\n// //             hub_addr: None,\n// //             builder_unlock_addr: \"nocontract\".to_string(),\n// //             proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n// //             proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n// //             proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n// //             proposal_required_deposit: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n// //             proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n// //             proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n// //             whitelisted_links: vec![\"https://some.link/\".to_string()],\n// //         };\n\n// //         let assembly_instance = router\n// //             .instantiate_contract(\n// //                 assembly_code,\n// //                 owner.clone(),\n// //                 \u0026assembly_default_instantiate_msg,\n// //                 \u0026[],\n// //                 \"Assembly\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let cw20_ics20_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astroport_cw20_ics20::contract::execute,\n// //             astroport_cw20_ics20::contract::instantiate,\n// //             astroport_cw20_ics20::contract::query,\n// //         ));\n\n// //         let cw20_ics20_code = router.store_code(cw20_ics20_contract);\n\n// //         let cw20_ics20_instantiate_msg = astroport_cw20_ics20::msg::InitMsg {\n// //             default_timeout: 10,\n// //             gov_contract: owner.to_string(),\n// //             allowlist: vec![AllowMsg {\n// //                 contract: token_instance.to_string(),\n// //                 gas_limit: None,\n// //             }],\n// //             default_gas_limit: None,\n// //             memo_handler: None,\n// //         };\n\n// //         let cw20_ics20_instance = router\n// //             .instantiate_contract(\n// //                 cw20_ics20_code,\n// //                 owner.clone(),\n// //                 \u0026cw20_ics20_instantiate_msg,\n// //                 \u0026[],\n// //                 \"CW20-ICS20\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let msg = Cw20ExecuteMsg::Transfer {\n// //             recipient: cw20_ics20_instance.to_string(),\n// //             amount: Uint128::from(100u64),\n// //         };\n\n// //         router.execute_contract(owner.clone(), token_instance.clone(), \u0026msg, \u0026[]).unwrap();\n\n// //         // Set up staking\n// //         let staking_contract = Box::new(\n// //             ContractWrapper::new_with_empty(\n// //                 astroport_staking::contract::execute,\n// //                 astroport_staking::contract::instantiate,\n// //                 astroport_staking::contract::query,\n// //             )\n// //             .with_reply_empty(astroport_staking::contract::reply),\n// //         );\n\n// //         let staking_code_id = router.store_code(staking_contract);\n\n// //         let msg = astroport_core::staking::InstantiateMsg {\n// //             owner: owner.to_string(),\n// //             token_code_id: token_code,\n// //             deposit_token_addr: token_instance.to_string(),\n// //             marketing: None,\n// //         };\n// //         let staking_instance = router\n// //             .instantiate_contract(\n// //                 staking_code_id,\n// //                 owner.clone(),\n// //                 \u0026msg,\n// //                 \u0026[],\n// //                 String::from(\"xASTRO\"),\n// //                 None,\n// //             )\n// //             .unwrap();\n\n// //         let outpost_handler_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astroport_hub::execute::execute,\n// //             astroport_hub::contract::instantiate,\n// //             astroport_hub::query::query,\n// //         ));\n\n// //         let outpost_handler_code = router.store_code(outpost_handler_contract);\n\n// //         let outpost_handler_instantiate_msg = astroport_governance::hub::InstantiateMsg {\n// //             owner: owner.to_string(),\n// //             assembly_addr: assembly_instance.to_string(),\n// //             cw20_ics20_addr: cw20_ics20_instance.to_string(),\n// //             staking_addr: staking_instance.to_string(),\n// //             generator_controller_addr: \"assembly\".to_string(),\n// //             ibc_timeout_seconds: 10,\n// //         };\n\n// //         check_token_balance(\u0026mut router, \u0026token_instance, \u0026hub_user, 0u128);\n\n// //         let outpost_handler_instance = router\n// //             .instantiate_contract(\n// //                 outpost_handler_code,\n// //                 owner.clone(),\n// //                 \u0026outpost_handler_instantiate_msg,\n// //                 \u0026[],\n// //                 \"Outpost handler\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let msg = Cw20ExecuteMsg::Send {\n// //             contract: outpost_handler_instance.to_string(),\n// //             msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::OutpostMemo {\n// //                 channel: send_channel.to_string(),\n// //                 sender: owner.to_string(),\n// //                 receiver: hub_user.to_string(),\n// //                 memo: \"Standard memo that should not be processed\".to_string(),\n// //             })\n// //             .unwrap(),\n// //             amount: Uint128::from(100u64),\n// //         };\n\n// //         let res = router.execute_contract(Addr::unchecked(cw20_ics20_instance), token_instance.clone(), \u0026msg, \u0026[]);\n// //         assert!(res.is_ok());\n\n// //         // Check that the balance of Hub user increased\n// //         check_token_balance(\u0026mut router, \u0026token_instance, \u0026hub_user, 100u128);\n// //         // The contract must hold nothing\n// //         check_token_balance(\n// //             \u0026mut router,\n// //             \u0026token_instance,\n// //             \u0026outpost_handler_instance,\n// //             0u128,\n// //         );\n// //     }\n\n// //     #[test]\n// //     #[cfg(test)]\n// //     fn receive_stake_memo() {\n// //         let send_channel = \"channel-9\";\n// //         let cw20_addr = \"token-addr\";\n// //         let cw20_denom = \"cw20:token-addr\";\n// //         let gas_limit = 1234567;\n\n// //         // let recv_packet = mock_receive_packet(send_channel, 100000, cw20_denom, \"local-rcpt\", None);\n\n// //         let owner = Addr::unchecked(\"terraowner01\");\n// //         let hub_user = Addr::unchecked(\"terrauser01\");\n// //         let outpost_user = Addr::unchecked(\"injuser01\");\n\n// //         let mut router = mock_app();\n// //         let router_ref = \u0026mut router;\n\n// //         let token_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astroport_token::contract::execute,\n// //             astroport_token::contract::instantiate,\n// //             astroport_token::contract::query,\n// //         ));\n\n// //         let token_code = router.store_code(token_contract);\n\n// //         let token_default_instantiate_msg = astroport_core::token::InstantiateMsg {\n// //             name: \"Astroport Token\".to_string(),\n// //             symbol: \"ASTRO\".to_string(),\n// //             decimals: 6,\n// //             initial_balances: vec![Cw20Coin {\n// //                 address: owner.to_string(),\n// //                 amount: Uint128::from(1_000_000_000_000u64),\n// //             }],\n// //             mint: None,\n// //             marketing: None,\n// //         };\n\n// //         let token_instance = router\n// //             .instantiate_contract(\n// //                 token_code,\n// //                 owner.clone(),\n// //                 \u0026token_default_instantiate_msg,\n// //                 \u0026[],\n// //                 \"ASTRO Token\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astro_assembly::contract::execute,\n// //             astro_assembly::contract::instantiate,\n// //             astro_assembly::contract::query,\n// //         ));\n\n// //         let assembly_code = router.store_code(assembly_contract);\n\n// //         let assembly_default_instantiate_msg = astroport_governance::assembly::InstantiateMsg {\n// //             xastro_token_addr: \"nocontract\".to_string(), //escrow_helper.xastro_token.to_string(),\n// //             vxastro_token_addr: None,\n// //             voting_escrow_delegator_addr: None,\n// //             ibc_controller: None,\n// //             generator_controller_addr: None,\n// //             hub_addr: None,\n// //             builder_unlock_addr: \"nocontract\".to_string(),\n// //             proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n// //             proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n// //             proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n// //             proposal_required_deposit: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n// //             proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n// //             proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n// //             whitelisted_links: vec![\"https://some.link/\".to_string()],\n// //         };\n\n// //         let assembly_instance = router\n// //             .instantiate_contract(\n// //                 assembly_code,\n// //                 owner.clone(),\n// //                 \u0026assembly_default_instantiate_msg,\n// //                 \u0026[],\n// //                 \"Assembly\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let cw20_ics20_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astroport_cw20_ics20::contract::execute,\n// //             astroport_cw20_ics20::contract::instantiate,\n// //             astroport_cw20_ics20::contract::query,\n// //         ));\n\n// //         let cw20_ics20_code = router.store_code(cw20_ics20_contract);\n\n// //         let cw20_ics20_instantiate_msg = astroport_cw20_ics20::msg::InitMsg {\n// //             default_timeout: 10,\n// //             gov_contract: owner.to_string(),\n// //             allowlist: vec![AllowMsg {\n// //                 contract: token_instance.to_string(),\n// //                 gas_limit: None,\n// //             }],\n// //             default_gas_limit: None,\n// //             memo_handler: None,\n// //         };\n\n// //         let cw20_ics20_instance = router\n// //             .instantiate_contract(\n// //                 cw20_ics20_code,\n// //                 owner.clone(),\n// //                 \u0026cw20_ics20_instantiate_msg,\n// //                 \u0026[],\n// //                 \"CW20-ICS20\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let msg = Cw20ExecuteMsg::Transfer {\n// //             recipient: cw20_ics20_instance.to_string(),\n// //             amount: Uint128::from(100000u64),\n// //         };\n\n// //         router.execute_contract(owner.clone(), token_instance.clone(), \u0026msg, \u0026[]).unwrap();\n\n// //         // let (astro_token_instance, staking_instance, _) =\n// //         //     instantiate_contracts(\u0026mut router, owner.clone());\n\n// //         // Set up staking\n// //         let staking_contract = Box::new(\n// //             ContractWrapper::new_with_empty(\n// //                 astroport_staking::contract::execute,\n// //                 astroport_staking::contract::instantiate,\n// //                 astroport_staking::contract::query,\n// //             )\n// //             .with_reply_empty(astroport_staking::contract::reply),\n// //         );\n\n// //         let staking_code_id = router.store_code(staking_contract);\n\n// //         let msg = astroport_core::staking::InstantiateMsg {\n// //             owner: owner.to_string(),\n// //             token_code_id: token_code,\n// //             deposit_token_addr: token_instance.to_string(),\n// //             marketing: None,\n// //         };\n// //         let staking_instance = router\n// //             .instantiate_contract(\n// //                 staking_code_id,\n// //                 owner.clone(),\n// //                 \u0026msg,\n// //                 \u0026[],\n// //                 String::from(\"xASTRO\"),\n// //                 None,\n// //             )\n// //             .unwrap();\n\n// //         let msg = astroport_core::staking::QueryMsg::Config {};\n// //         let res = router\n// //             .wrap()\n// //             .query::\u003castroport_core::staking::ConfigResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n// //                 contract_addr: staking_instance.to_string(),\n// //                 msg: to_binary(\u0026msg).unwrap(),\n// //             }))\n// //             .unwrap();\n// //         let x_astro_token_instance = res.share_token_addr;\n\n// //         let outpost_handler_contract = Box::new(\n// //             ContractWrapper::new_with_empty(\n// //                 astroport_hub::execute::execute,\n// //                 astroport_hub::contract::instantiate,\n// //                 astroport_hub::query::query,\n// //             )\n// //             .with_reply(astroport_hub::reply::reply),\n// //         );\n\n// //         let outpost_handler_code = router.store_code(outpost_handler_contract);\n\n// //         let outpost_handler_instantiate_msg = astroport_governance::hub::InstantiateMsg {\n// //             owner: owner.to_string(),\n// //             assembly_addr: assembly_instance.to_string(),\n// //             cw20_ics20_addr: cw20_ics20_instance.to_string(),\n// //             staking_addr: staking_instance.to_string(),\n// //             generator_controller_addr: \"generator_controller\".to_string(),\n// //             ibc_timeout_seconds: 10,\n// //         };\n\n// //         let outpost_handler_instance = router\n// //             .instantiate_contract(\n// //                 outpost_handler_code,\n// //                 owner.clone(),\n// //                 \u0026outpost_handler_instantiate_msg,\n// //                 \u0026[],\n// //                 \"Outpost handler\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let msg = hub::ExecuteMsg::AddOutpost { outpost_addr: \"outpost\".to_owned(), cw20_ics20_channel: \"channel-1\".to_owned() };\n\n// //         // Add an outpost\n// //         let res = router\n// //             .execute_contract(Addr::unchecked(owner.clone()), outpost_handler_instance.clone(), \u0026msg, \u0026[])\n// //             .unwrap();\n\n// //         let msg = Cw20ExecuteMsg::Send {\n// //             contract: outpost_handler_instance.to_string(),\n// //             msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::OutpostMemo {\n// //                 channel: \"channel-1\".to_string(),\n// //                 sender: owner.to_string(),\n// //                 receiver: outpost_handler_instance.to_string(),\n// //                 memo: \"{\\\"stake\\\": {}}\".to_string(),\n// //             })\n// //             .unwrap(),\n// //             amount: Uint128::from(100u64),\n// //         };\n\n// //         // First staker must send more that 1000astro, otherwise staking will fail, we test for fail here\n// //         let res = router\n// //             .execute_contract(Addr::unchecked(cw20_ics20_instance.clone()), token_instance.clone(), \u0026msg, \u0026[])\n// //             .unwrap_err();\n// //         assert_eq!(\n// //             res.root_cause().to_string(),\n// //         \"Invalid submessage error executing WasmMsg:\\nsender: contract5\\nExecute { contract_addr: \\\"contract0\\\", msg: {\\\"send\\\":{\\\"contract\\\":\\\"contract3\\\",\\\"amount\\\":\\\"100\\\",\\\"msg\\\":\\\"eyJlbnRlciI6e319\\\"}}, funds: [] }\");\n\n// //         let msg = Cw20ExecuteMsg::Send {\n// //             contract: outpost_handler_instance.to_string(),\n// //             msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::OutpostMemo {\n// //                 channel: \"channel-1\".to_string(),\n// //                 sender: owner.to_string(),\n// //                 receiver: outpost_handler_instance.to_string(),\n// //                 memo: \"{\\\"stake\\\": {}}\".to_string(),\n// //             })\n// //             .unwrap(),\n// //             amount: Uint128::from(10000u64),\n// //         };\n\n// //         // Check that the contract blocks anyone else\n// //         let res = router\n// //             .execute_contract(owner.clone(), token_instance.clone(), \u0026msg, \u0026[])\n// //             .unwrap_err();\n// //         assert_eq!(\n// //             res.root_cause().to_string(),\n// //             \"Unauthorized\"\n// //         );\n\n// //         let query_msg = astroport_governance::hub::QueryMsg::Outposts {  };\n// //         let res: Vec\u003chub::OutpostConfig\u003e = router.wrap().query_wasm_smart(outpost_handler_instance, \u0026query_msg).unwrap();\n// //         println!(\"Outposts: {:?}\", res);\n\n// //         // Check that the contract emits a mint IBC message\n// //         // cw-multitest doesn't support IBC yet, and thus will return the IBC message as an error\n// //         // We check the format against that error\n// //         let res = router\n// //             .execute_contract(Addr::unchecked(cw20_ics20_instance), token_instance, \u0026msg, \u0026[])\n// //             .unwrap_err();\n// //         assert_eq!(\n// //             res.root_cause().to_string(),\n// //             \"Unexpected exec msg SendPacket { channel_id: \\\"channel-1\\\", data: Binary(7b226d696e74223a7b227265636569766572223a2274657272616f776e65723031222c22616d6f756e74223a2239303030227d7d), timeout: IbcTimeout { block: None, timestamp: Some(Timestamp(Uint64(1689152304000000000))) } } from Addr(\\\"contract5\\\")\"\n// //         );\n\n// //         // We will always receive this error since we can't actually establish an IBC connection that would\n// //         // construct the valid outpost link\n// //         // let res = router\n// //         //     .execute_contract(Addr::unchecked(cw20_ics20_instance), token_instance, \u0026msg, \u0026[])\n// //         //     .unwrap_err();\n// //         // assert_eq!(\n// //         //     res.root_cause().to_string(),\n// //         //     \"No Outpost found that matches the message channels\"\n// //         // );\n// //     }\n\n// // }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","tests","mock.rs"],"content":"// use crate::execute;\n// use crate::{contract::instantiate, execute::execute, ibc::ibc_packet_receive};\n// use crate::{\n//     ibc::{ibc_channel_connect, ibc_channel_open, IBC_APP_VERSION},\n//     testing_querier::{mock_dependencies, WasmMockQuerier},\n// };\nuse astroport_core::token::BalanceResponse;\nuse astroport_cw20_ics20::{\n    ibc::{Ics20Packet, ICS20_ORDERING, ICS20_VERSION},\n    state::ChannelInfo,\n};\nuse astroport_governance::assembly::ProposalVoteOption;\nuse astroport_governance::interchain::{Hub, Response};\nuse cosmwasm_std::{from_binary, IbcPacketReceiveMsg, ReplyOn, SubMsg, Uint64, WasmMsg};\nuse cosmwasm_std::{\n    testing::{mock_env, mock_info, MockApi, MockQuerier, MockStorage},\n    to_binary, Addr, Binary, DepsMut, Env, IbcChannel, IbcChannelConnectMsg, IbcChannelOpenMsg,\n    IbcEndpoint, IbcOrder, IbcPacket, MessageInfo, OwnedDeps, StdResult, Timestamp, Uint128,\n};\nuse cw20::Cw20QueryMsg;\nuse cw_multi_test::{App, AppBuilder, BankKeeper};\n\nuse cosmwasm_std::testing::MOCK_CONTRACT_ADDR;\nuse cosmwasm_std::{\n    from_slice, Coin, Empty, Querier, QuerierResult, QueryRequest, SystemError, SystemResult,\n    WasmQuery,\n};\nuse std::collections::HashMap;\n\npub const DEFAULT_TIMEOUT: u64 = 3600; // 1 hour,\npub const CONTRACT_PORT: \u0026str = \"ibc:wasm1234567890abcdef\";\npub const REMOTE_PORT: \u0026str = \"wasm.outpost\";\npub const CONNECTION_ID: \u0026str = \"connection-2\";\n\n// TODO: Move here\n// const VOTING_PERIOD_INTERVAL: RangeInclusive\u003cu64\u003e = 200..=7 * 12342;\n//     const DEPOSIT_INTERVAL: RangeInclusive\u003cu128\u003e = 1000..=60000000000;\n//     const PROPOSAL_VOTING_PERIOD: u64 = *VOTING_PERIOD_INTERVAL.start();\n//     const PROPOSAL_EFFECTIVE_DELAY: u64 = 12_342;\n//     const PROPOSAL_EXPIRATION_PERIOD: u64 = 86_399;\n//     const PROPOSAL_REQUIRED_DEPOSIT: u128 = *DEPOSIT_INTERVAL.start();\n//     const PROPOSAL_REQUIRED_QUORUM: \u0026str = \"0.50\";\n//     const PROPOSAL_REQUIRED_THRESHOLD: \u0026str = \"0.60\";\n\npub fn mock_app() -\u003e App {\n    let mut env = mock_env();\n    env.block.time = Timestamp::from_seconds(1689152294);\n    let api = MockApi::default();\n    let bank = BankKeeper::new();\n    let storage = MockStorage::new();\n\n    AppBuilder::new()\n        .with_api(api)\n        .with_block(env.block)\n        .with_bank(bank)\n        .with_storage(storage)\n        .build(|_, _, _| {})\n}\n\npub fn check_token_balance(app: \u0026mut App, token: \u0026Addr, address: \u0026Addr, expected: u128) {\n    let msg = Cw20QueryMsg::Balance {\n        address: address.to_string(),\n    };\n    let res: StdResult\u003cBalanceResponse\u003e = app.wrap().query_wasm_smart(token, \u0026msg);\n    assert_eq!(res.unwrap().balance, Uint128::from(expected));\n}\n","traces":[{"line":45,"address":[795469,795512,794944],"length":1,"stats":{"Line":2},"fn_name":"mock_app"},{"line":46,"address":[794961],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[795066,794999],"length":1,"stats":{"Line":5},"fn_name":null},{"line":48,"address":[795071],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[795098],"length":1,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[795109],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[795291,795379,795125,795213],"length":1,"stats":{"Line":9},"fn_name":null},{"line":54,"address":[795220],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[795321],"length":1,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[878173,878144],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":60,"address":[795536,796142],"length":1,"stats":{"Line":1},"fn_name":"check_token_balance"},{"line":62,"address":[795616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[795678,795751],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[796096,795795],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":14,"coverable":14},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","nft","examples","nft_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, export_schema_with_title, remove_schemas, schema_for};\nuse cosmwasm_std::Empty;\n\nuse cw721::{\n    AllNftInfoResponse, ApprovalResponse, ApprovalsResponse, ContractInfoResponse, NftInfoResponse,\n    NumTokensResponse, OperatorsResponse, OwnerOfResponse, TokensResponse,\n};\n\nuse cw721_base::{ExecuteMsg, Extension, InstantiateMsg, MinterResponse, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema_with_title(\n        \u0026schema_for!(ExecuteMsg\u003cExtension, Empty\u003e),\n        \u0026out_dir,\n        \"ExecuteMsg\",\n    );\n    export_schema(\u0026schema_for!(QueryMsg\u003cEmpty\u003e), \u0026out_dir);\n    export_schema_with_title(\n        \u0026schema_for!(AllNftInfoResponse\u003cExtension\u003e),\n        \u0026out_dir,\n        \"AllNftInfoResponse\",\n    );\n    export_schema(\u0026schema_for!(ApprovalResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(ApprovalsResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(OperatorsResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(ContractInfoResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(MinterResponse), \u0026out_dir);\n    export_schema_with_title(\n        \u0026schema_for!(NftInfoResponse\u003cExtension\u003e),\n        \u0026out_dir,\n        \"NftInfoResponse\",\n    );\n    export_schema(\u0026schema_for!(NumTokensResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(OwnerOfResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(TokensResponse), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","nft","src","contract.rs"],"content":"use cosmwasm_std::{\n    entry_point, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,\n};\n\nuse astroport_governance::nft::MigrateMsg;\nuse cw2::set_contract_version;\nuse cw721::ContractInfoResponse;\nuse cw721_base::msg::{ExecuteMsg, InstantiateMsg};\nuse cw721_base::state::Cw721Contract;\nuse cw721_base::{ContractError, Extension, QueryMsg};\n\n/// Contract name that is used for migration.\nconst CONTRACT_NAME: \u0026str = \"astroport-nft\";\n/// Contract version that is used for migration.\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Creates a new contract with the specified parameters in the [`InstantiateMsg`].\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    let info = ContractInfoResponse {\n        name: msg.name,\n        symbol: msg.symbol,\n    };\n    let tract = Cw721Contract::\u003cExtension, Empty, Empty, Empty\u003e::default();\n    tract.contract_info.save(deps.storage, \u0026info)?;\n\n    let minter = deps.api.addr_validate(msg.minter.as_str())?;\n    tract.minter.save(deps.storage, \u0026minter)?;\n    Ok(Response::default())\n}\n\n/// Exposes execute functions available in the contract.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg\u003cExtension, Empty\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let tract = Cw721Contract::\u003cExtension, Empty, Empty, Empty\u003e::default();\n    tract.execute(deps, env, info, msg)\n}\n\n/// Exposes queries available in the contract.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg\u003cEmpty\u003e) -\u003e StdResult\u003cBinary\u003e {\n    let tract = Cw721Contract::\u003cExtension, Empty, Empty, Empty\u003e::default();\n    tract.query(deps, env, msg)\n}\n\n/// Used for contract migration. Returns a default object of type [`Response`].\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    Ok(Response::default())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","nft","src","lib.rs"],"content":"pub mod contract;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","contract.rs"],"content":"use cosmwasm_std::{entry_point, Addr, DepsMut, Env, MessageInfo, Response};\nuse cw2::set_contract_version;\n\nuse astroport_governance::outpost::{Config, InstantiateMsg, MigrateMsg};\n\nuse crate::error::ContractError;\nuse crate::state::CONFIG;\n\n/// Contract name that is used for migration.\nconst CONTRACT_NAME: \u0026str = \"astroport-outpost\";\n/// Contract version that is used for migration.\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Instantiates the contract, storing the config.\n/// Returns a `Response` object on successful execution or a `ContractError` on failure.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    let config = Config {\n        owner: deps.api.addr_validate(\u0026msg.owner)?,\n        hub_addr: Addr::unchecked(msg.hub_addr),\n        // The Hub channel will be set when the connection is established\n        hub_channel: None,\n        xastro_token_addr: deps.api.addr_validate(\u0026msg.xastro_token_addr)?,\n        vxastro_token_addr: deps.api.addr_validate(\u0026msg.vxastro_token_addr)?,\n        ibc_timeout_seconds: msg.ibc_timeout_seconds,\n    };\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::default())\n}\n\n/// Migrates the contract to a new version.\n#[entry_point]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    // TODO: Return error\n    Ok(Response::default())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","error.rs"],"content":"use cosmwasm_std::{OverflowError, StdError};\nuse thiserror::Error;\n\n/// This enum describes bribes contract errors\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"You can not send 0 tokens\")]\n    ZeroAmount {},\n\n    #[error(\n        \"Proposal {0} is being queried from the Hub, please try again in a few minutes\",\n        proposal_id\n    )]\n    PendingVoteExists { proposal_id: u64 },\n\n    #[error(\n        \"The address has no voting power at the start of the proposal: {0}\",\n        address\n    )]\n    NoVotingPower { address: String },\n\n    #[error(\"The IBC channel to the Hub has not been set\")]\n    MissingHubChannel {},\n}\n\nimpl From\u003cOverflowError\u003e for ContractError {\n    fn from(o: OverflowError) -\u003e Self {\n        StdError::from(o).into()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","execute.rs"],"content":"use cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    from_binary, to_binary, Addr, CosmosMsg, DepsMut, Env, IbcMsg, MessageInfo, Response, StdError,\n    WasmMsg,\n};\nuse cw20::{Cw20ExecuteMsg, Cw20ReceiveMsg};\n\nuse astroport::common::{claim_ownership, drop_ownership_proposal, propose_new_owner};\nuse astroport_governance::outpost::Config;\nuse astroport_governance::{\n    assembly::ProposalVoteOption,\n    interchain::Hub,\n    outpost::{Cw20HookMsg, ExecuteMsg},\n    voting_escrow_lite::get_emissions_voting_power,\n};\n\nuse crate::query::get_user_voting_power;\nuse crate::{\n    error::ContractError,\n    state::{PendingVote, CONFIG, OWNERSHIP_PROPOSAL, PENDING_VOTES, PROPOSALS_CACHE},\n};\n\n/// Exposes all the execute functions available in the contract.\n///\n/// ## Execute messages\n/// * **ExecuteMsg::Receive(cw20_msg)** Receives a message of type [`Cw20ReceiveMsg`] and processes\n/// it depending on the received template.\n///\n/// RemoveOutpost { outpost_addr } Removes an outpost from the hub but does not close the channel, but all messages will be rejected\n///\n/// * **ExecuteMsg::Receive(msg)** Receives a message of type [`Cw20ReceiveMsg`] and processes\n/// it depending on the received template.\n///\n/// * **ExecuteMsg::UpdateConfig { hub_addr }** Update parameters in the Outpost contract. Only the owner is allowed to\n/// update the config\n///\n/// * **ExecuteMsg::CastAssemblyVote { proposal_id, vote }** Cast a vote on an Assembly proposal from an Outpost\n///\n/// * **ExecuteMsg::CastEmissionsVote { votes }** Cast a vote during an emissions voting period\n///\n/// * **ExecuteMsg::KickUnlocked { user }** Kick an unlocked voter's voting power from the Generator Controller on the Hub\n///\n/// * **ExecuteMsg::WithdrawHubFunds {}** Withdraw stuck funds from the Hub in case of specific IBC failures\n///\n/// * **ExecuteMsg::ProposeNewOwner { new_owner, expires_in }** Creates a new request to change\n/// contract ownership.\n///\n/// * **ExecuteMsg::DropOwnershipProposal {}** Removes a request to change contract ownership.\n///\n/// * **ExecuteMsg::ClaimOwnership {}** Claims contract ownership.\n///\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::Receive(msg) =\u003e receive_cw20(deps, env, info, msg),\n        ExecuteMsg::UpdateConfig { hub_addr } =\u003e update_config(deps, env, info, hub_addr),\n        ExecuteMsg::CastAssemblyVote { proposal_id, vote } =\u003e {\n            cast_assembly_vote(deps, env, info, proposal_id, vote)\n        }\n        ExecuteMsg::CastEmissionsVote { votes } =\u003e cast_emissions_vote(deps, env, info, votes),\n        ExecuteMsg::KickUnlocked { user } =\u003e kick_unlocked(deps, env, info, user),\n        ExecuteMsg::WithdrawHubFunds {} =\u003e withdraw_hub_funds(deps, env, info),\n        ExecuteMsg::ProposeNewOwner {\n            new_owner,\n            expires_in,\n        } =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n\n            propose_new_owner(\n                deps,\n                info,\n                env,\n                new_owner,\n                expires_in,\n                config.owner,\n                OWNERSHIP_PROPOSAL,\n            )\n            .map_err(Into::into)\n        }\n        ExecuteMsg::DropOwnershipProposal {} =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n\n            drop_ownership_proposal(deps, info, config.owner, OWNERSHIP_PROPOSAL)\n                .map_err(Into::into)\n        }\n        ExecuteMsg::ClaimOwnership {} =\u003e {\n            claim_ownership(deps, info, env, OWNERSHIP_PROPOSAL, |deps, new_owner| {\n                CONFIG\n                    .update::\u003c_, StdError\u003e(deps.storage, |mut v| {\n                        v.owner = new_owner;\n                        Ok(v)\n                    })\n                    .map(|_| ())\n            })\n            .map_err(Into::into)\n        }\n    }\n}\n\n/// Receives a message of type [`Cw20ReceiveMsg`] and processes it depending on\n/// the received template\n///\n/// Funds received here must be from the xASTRO contract and is used for\n/// unstaking.\n///\n/// * **cw20_msg** CW20 message to process\nfn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // We only allow xASTRO tokens to be sent here\n    if info.sender != config.xastro_token_addr {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    match from_binary(\u0026cw20_msg.msg)? {\n        Cw20HookMsg::Unstake {} =\u003e execute_remote_unstake(deps, env, info, cw20_msg),\n    }\n}\n\n/// Start the process of unstaking xASTRO from the Hub\n///\n/// This burns the xASTRO we previously received and sends the unstake message\n/// to the Hub where to original xASTRO will be unstaked and ASTRO returned\n/// to the sender of this transaction.\n///\n/// Note: Incase of IBC failures they xASTRO will be returned to the user or\n/// they'll need to withdraw the unstaked ASTRO from the Hub using ExecuteMsg::WithdrawHubFunds\nfn execute_remote_unstake(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    msg: Cw20ReceiveMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Tokens must be sent\n    if msg.amount.is_zero() {\n        return Err(ContractError::ZeroAmount {});\n    }\n\n    // Burn the xASTRO tokens we previously minted\n    let burn_msg = Cw20ExecuteMsg::Burn { amount: msg.amount };\n    let wasm_msg = WasmMsg::Execute {\n        contract_addr: config.xastro_token_addr.to_string(),\n        msg: to_binary(\u0026burn_msg)?,\n        funds: vec![],\n    };\n\n    let hub_channel = config\n        .hub_channel\n        .ok_or(ContractError::MissingHubChannel {})?;\n\n    // Construct the unstake message to send to the Hub\n    let unstake = Hub::Unstake {\n        receiver: msg.sender.to_string(),\n        amount: msg.amount,\n    };\n    let hub_unstake_msg: CosmosMsg = CosmosMsg::Ibc(IbcMsg::SendPacket {\n        channel_id: hub_channel.clone(),\n        data: to_binary(\u0026unstake)?,\n        timeout: env\n            .block\n            .time\n            .plus_seconds(config.ibc_timeout_seconds)\n            .into(),\n    });\n\n    Ok(Response::default()\n        .add_message(wasm_msg)\n        .add_message(hub_unstake_msg)\n        .add_attribute(\"action\", unstake.to_string())\n        .add_attribute(\"amount\", msg.amount.to_string())\n        .add_attribute(\"channel\", hub_channel))\n}\n\n/// Update the Outpost config\nfn update_config(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    hub_addr: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    // Only owner can update the config\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(hub_addr) = hub_addr {\n        // We can't validate the Hub address\n        config.hub_addr = Addr::unchecked(hub_addr);\n        // If a new Hub address is set, we clear the channel to allow a\n        // new channel to be set\n        config.hub_channel = None;\n    }\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::default())\n}\n\n/// Cast a vote on a proposal from an Outpost\n///\n/// To validate the xASTRO holdings at the time the proposal was created we first\n/// query the Hub for the proposal information if it hasn't been queried yet. Once\n/// the proposal information is received we validate the vote and submit it\nfn cast_assembly_vote(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    proposal_id: u64,\n    vote_option: ProposalVoteOption,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // If we have this proposal in our local cached already, we can continue\n    // with fetching the voting power and submitting the vote\n    if let Some(proposal) = PROPOSALS_CACHE.may_load(deps.storage, proposal_id)? {\n        let voting_power =\n            get_user_voting_power(deps.as_ref(), info.sender.clone(), proposal.start_time)?;\n\n        if voting_power.is_zero() {\n            return Err(ContractError::NoVotingPower {\n                address: info.sender.to_string(),\n            });\n        }\n\n        let hub_channel = config\n            .hub_channel\n            .ok_or(ContractError::MissingHubChannel {})?;\n\n        // Construct the vote message and submit it to the Hub\n        let cast_vote = Hub::CastAssemblyVote {\n            proposal_id: proposal.proposal_id.u64(),\n            vote_option,\n            voter: info.sender.clone(),\n            voting_power,\n        };\n        let hub_msg = CosmosMsg::Ibc(IbcMsg::SendPacket {\n            channel_id: hub_channel,\n            data: to_binary(\u0026cast_vote)?,\n            timeout: env\n                .block\n                .time\n                .plus_seconds(config.ibc_timeout_seconds)\n                .into(),\n        });\n        return Ok(Response::new()\n            .add_message(hub_msg)\n            .add_attribute(\"action\", cast_vote.to_string())\n            .add_attribute(\"user\", info.sender.to_string()));\n    }\n\n    // If we don't have the proposal in our local cache it means that no\n    // vote has been cast from this Outpost for this proposal\n    // In this case we temporarily store the vote and submit an IBC transaction\n    // to fetch the proposal information. When the information is received via\n    // an IBC reply, we validate the data and submit the actual vote\n\n    // If we already have a pending vote for this proposal we return an error\n    // as we're waiting for the proposal IBC query to return. We can't store\n    // lots of votes as we have no way to automatically submit them without\n    // the risk of running out of gas\n    if (PENDING_VOTES.may_load(deps.storage, proposal_id)?).is_some() {\n        return Err(ContractError::PendingVoteExists { proposal_id });\n    }\n\n    // Temporarily store the vote\n    let pending_vote = PendingVote {\n        proposal_id,\n        voter: info.sender,\n        vote_option,\n    };\n    PENDING_VOTES.save(deps.storage, proposal_id, \u0026pending_vote)?;\n\n    let hub_channel = config\n        .hub_channel\n        .ok_or(ContractError::MissingHubChannel {})?;\n\n    // Query for proposal\n    let query_proposal = Hub::QueryProposal { id: proposal_id };\n    let hub_query_msg = CosmosMsg::Ibc(IbcMsg::SendPacket {\n        channel_id: hub_channel,\n        data: to_binary(\u0026query_proposal)?,\n        timeout: env\n            .block\n            .time\n            .plus_seconds(config.ibc_timeout_seconds)\n            .into(),\n    });\n\n    Ok(Response::default()\n        .add_message(hub_query_msg)\n        .add_attribute(\"action\", query_proposal.to_string())\n        .add_attribute(\"id\", proposal_id.to_string()))\n}\n\n/// Cast a vote on emissions during a vxASTRO voting period\n///\n/// We validate the voting power by checking the vxASTRO power at this\n/// moment as vxASTRO lite does not have any warmup period\nfn cast_emissions_vote(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    votes: Vec\u003c(String, u16)\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Validate vxASTRO voting power\n    let vxastro_voting_power = get_emissions_voting_power(\n        \u0026deps.querier,\n        config.vxastro_token_addr,\n        info.sender.clone(),\n    )?;\n\n    if vxastro_voting_power.is_zero() {\n        return Err(ContractError::NoVotingPower {\n            address: info.sender.to_string(),\n        });\n    }\n\n    let hub_channel = config\n        .hub_channel\n        .ok_or(ContractError::MissingHubChannel {})?;\n\n    // Construct the vote message and submit it to the Hub\n    let cast_vote = Hub::CastEmissionsVote {\n        voter: info.sender.clone(),\n        voting_power: vxastro_voting_power,\n        votes,\n    };\n    let hub_msg = CosmosMsg::Ibc(IbcMsg::SendPacket {\n        channel_id: hub_channel,\n        data: to_binary(\u0026cast_vote)?,\n        timeout: env\n            .block\n            .time\n            .plus_seconds(config.ibc_timeout_seconds)\n            .into(),\n    });\n    Ok(Response::new()\n        .add_message(hub_msg)\n        .add_attribute(\"action\", cast_vote.to_string())\n        .add_attribute(\"user\", info.sender.to_string()))\n}\n\n/// Kick an unlocked voter from the Generator Controller on the Hub\n/// which will remove their voting power immediately.\n///\n/// We only finalise the unlock in the vxASTRO contract when this kick is\n/// successful\nfn kick_unlocked(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    user: Addr,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // This may only be called from the vxASTRO lite contract\n    if info.sender != config.vxastro_token_addr {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let hub_channel = config\n        .hub_channel\n        .ok_or(ContractError::MissingHubChannel {})?;\n\n    // Construct the kick message and submit it to the Hub\n    let kick_unlocked = Hub::KickUnlockedVoter {\n        voter: user.clone(),\n    };\n    let hub_msg = CosmosMsg::Ibc(IbcMsg::SendPacket {\n        channel_id: hub_channel,\n        data: to_binary(\u0026kick_unlocked)?,\n        timeout: env\n            .block\n            .time\n            .plus_seconds(config.ibc_timeout_seconds)\n            .into(),\n    });\n\n    Ok(Response::new()\n        .add_message(hub_msg)\n        .add_attribute(\"action\", kick_unlocked.to_string())\n        .add_attribute(\"user\", user))\n}\n\n/// Submit a request to withdraw / retry sending funds stuck on the Hub\n/// back to the sender address. This is possible because of IBC failures.\n///\n/// This will only return the funds of the user executing this transaction.\nfn withdraw_hub_funds(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    let hub_channel = config\n        .hub_channel\n        .ok_or(ContractError::MissingHubChannel {})?;\n\n    // Construct the withdraw message and submit it to the Hub\n    let withdraw = Hub::WithdrawFunds {\n        user: info.sender.clone(),\n    };\n    let hub_msg = CosmosMsg::Ibc(IbcMsg::SendPacket {\n        channel_id: hub_channel,\n        data: to_binary(\u0026withdraw)?,\n        timeout: env\n            .block\n            .time\n            .plus_seconds(config.ibc_timeout_seconds)\n            .into(),\n    });\n\n    Ok(Response::new()\n        .add_message(hub_msg)\n        .add_attribute(\"action\", withdraw.to_string())\n        .add_attribute(\"user\", info.sender.to_string()))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","ibc.rs"],"content":"use cosmwasm_std::{\n    ensure, entry_point, from_binary, to_binary, CosmosMsg, Deps, DepsMut, Env,\n    Ibc3ChannelOpenResponse, IbcBasicResponse, IbcChannelCloseMsg, IbcChannelConnectMsg,\n    IbcChannelOpenMsg, IbcChannelOpenResponse, IbcMsg, IbcOrder, IbcPacketAckMsg,\n    IbcPacketReceiveMsg, IbcPacketTimeoutMsg, IbcReceiveResponse, StdError, StdResult,\n};\n\nuse astroport_governance::interchain::{get_contract_from_ibc_port, Hub, Outpost, Response};\n\nuse crate::{\n    error::ContractError,\n    ibc_failure::handle_failed_messages,\n    ibc_mint::handle_ibc_xastro_mint,\n    query::get_user_voting_power,\n    state::{CachedProposal, CONFIG, PENDING_VOTES, PROPOSALS_CACHE},\n};\n\npub const IBC_APP_VERSION: \u0026str = \"astroport-outpost-v1\";\npub const IBC_ORDERING: IbcOrder = IbcOrder::Unordered;\n\n/// Handle the opening of a new IBC channel\n///\n/// We verify that the connection is using the correct configuration\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_channel_open(\n    _deps: DepsMut,\n    _env: Env,\n    msg: IbcChannelOpenMsg,\n) -\u003e Result\u003cIbcChannelOpenResponse, ContractError\u003e {\n    let channel = msg.channel();\n\n    if channel.order != IBC_ORDERING {\n        return Err(ContractError::Std(StdError::generic_err(\n            \"Ordering is invalid. The channel must be unordered\".to_string(),\n        )));\n    }\n    if channel.version != IBC_APP_VERSION {\n        return Err(ContractError::Std(StdError::generic_err(format!(\n            \"Must set version to `{IBC_APP_VERSION}`\"\n        ))));\n    }\n\n    if let Some(counter_version) = msg.counterparty_version() {\n        if counter_version != IBC_APP_VERSION {\n            return Err(ContractError::Std(StdError::generic_err(format!(\n                \"Counterparty version must be `{IBC_APP_VERSION}`\"\n            ))));\n        }\n    }\n\n    Ok(Some(Ibc3ChannelOpenResponse {\n        version: IBC_APP_VERSION.to_string(),\n    }))\n}\n\n/// Handle the connection of a new IBC channel\n///\n/// We verify that the connection is being made to the configured Hub and\n/// if the channel has not been set, add it\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_channel_connect(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcChannelConnectMsg,\n) -\u003e Result\u003cIbcBasicResponse, ContractError\u003e {\n    let channel = msg.channel();\n\n    // Only a connection to the Hub is allowed\n    let counterparty_port =\n        get_contract_from_ibc_port(channel.counterparty_endpoint.port_id.as_str());\n\n    CONFIG.update(deps.storage, |mut config| {\n        // Block unauthorised connections\n        if config.hub_addr != counterparty_port {\n            return Err(ContractError::Std(StdError::generic_err(format!(\n                \"Connection with `{}` is not allowed\",\n                counterparty_port\n            ))));\n        }\n\n        // If the channel is already set, fail\n        if config.hub_channel.is_some() {\n            return Err(ContractError::Std(StdError::generic_err(\n                \"Hub channel is already set\".to_string(),\n            )));\n        }\n\n        // Update the known channel to the Hub\n        config.hub_channel = Some(channel.endpoint.channel_id.to_string());\n        Ok(config)\n    })?;\n\n    Ok(IbcBasicResponse::new()\n        .add_attribute(\"action\", \"ibc_connect\")\n        .add_attribute(\"channel_id\", \u0026channel.endpoint.channel_id))\n}\n\n/// Handle the receiving the packets while wrapping the actual call to provide\n/// returning errors as an acknowledgement.\n///\n/// This allows the original caller from another chain to handle the failure\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_packet_receive(\n    deps: DepsMut,\n    env: Env,\n    msg: IbcPacketReceiveMsg,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    block_unauthorized_packets(deps.as_ref(), msg.packet.src.port_id.clone())?;\n\n    do_packet_receive(deps, env, msg).or_else(|err| {\n        // Construct an error acknowledgement that can be handled on the Outpost\n        let ack_data = to_binary(\u0026Response::new_error(err.to_string())).unwrap();\n\n        Ok(IbcReceiveResponse::new()\n            .add_attribute(\"action\", \"ibc_packet_receive\")\n            .add_attribute(\"error\", err.to_string())\n            .set_ack(ack_data))\n    })\n}\n\n/// Process the received packet and return the response\n///\n/// Packets are expected to be wrapped in the Outpost format, if it doesn't conform\n/// it will be failed.\n///\n/// If a ContractError is returned, it will be wrapped into a Response\n/// containing the error to be handled on the Outpost\nfn do_packet_receive(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcPacketReceiveMsg,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    // Parse the packet data into a Hub message\n    let hub_msg: Outpost = from_binary(\u0026msg.packet.data)?;\n    match hub_msg {\n        Outpost::MintXAstro { receiver, amount } =\u003e handle_ibc_xastro_mint(deps, receiver, amount),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_packet_timeout(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcPacketTimeoutMsg,\n) -\u003e Result\u003cIbcBasicResponse, ContractError\u003e {\n    // We check the destination port for timeouts as that is where the original\n    // packet was sent to\n    block_unauthorized_packets(deps.as_ref(), msg.packet.dest.port_id.clone())?;\n\n    let mut response = IbcBasicResponse::new().add_attribute(\"action\", \"ibc_packet_timeout\");\n\n    // In case of an IBC timeout we might need to reverse actions similar\n    // to failed messages.\n    // We look at the original packet to determine what failed and take\n    // the appropriate action\n    let failed_msg: Hub = from_binary(\u0026msg.packet.data)?;\n    response = handle_failed_messages(deps, failed_msg, response)?;\n\n    Ok(response)\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_packet_ack(\n    deps: DepsMut,\n    env: Env,\n    msg: IbcPacketAckMsg,\n) -\u003e Result\u003cIbcBasicResponse, ContractError\u003e {\n    // We check the destination port for acks as that is where the original\n    // packet was sent to\n    block_unauthorized_packets(deps.as_ref(), msg.original_packet.dest.port_id)?;\n\n    let mut response = IbcBasicResponse::new().add_attribute(\"action\", \"ibc_packet_ack\");\n\n    let ack: Result\u003cResponse, StdError\u003e = from_binary(\u0026msg.acknowledgement.data);\n    match ack {\n        Ok(hub_response) =\u003e {\n            match hub_response {\n                Response::QueryProposal(proposal) =\u003e {\n                    // We cache the proposal ID and start time for future vote\n                    // checks without needing to query the Hub again\n                    let cached_proposal = CachedProposal {\n                        proposal_id: proposal.proposal_id,\n                        start_time: proposal.start_time,\n                    };\n\n                    PROPOSALS_CACHE.save(\n                        deps.storage,\n                        cached_proposal.proposal_id.u64(),\n                        \u0026cached_proposal,\n                    )?;\n\n                    // We need to submit the initial vote that triggered this\n                    // proposal to be queried from the pending vote cache\n                    if let Some(pending_vote) =\n                        PENDING_VOTES.may_load(deps.storage, proposal.proposal_id.u64())?\n                    {\n                        let config = CONFIG.load(deps.storage)?;\n\n                        let voting_power = get_user_voting_power(\n                            deps.as_ref(),\n                            pending_vote.voter.clone(),\n                            proposal.start_time,\n                        )?;\n\n                        if voting_power.is_zero() {\n                            return Err(ContractError::NoVotingPower {\n                                address: pending_vote.voter.to_string(),\n                            });\n                        }\n\n                        let hub_channel = config\n                            .hub_channel\n                            .ok_or(ContractError::MissingHubChannel {})?;\n\n                        // Construct the vote message and submit it to the Hub\n                        let cast_vote = Hub::CastAssemblyVote {\n                            proposal_id: proposal.proposal_id.u64(),\n                            vote_option: pending_vote.vote_option,\n                            voter: pending_vote.voter.clone(),\n                            voting_power,\n                        };\n                        let hub_msg = CosmosMsg::Ibc(IbcMsg::SendPacket {\n                            channel_id: hub_channel,\n                            data: to_binary(\u0026cast_vote)?,\n                            timeout: env\n                                .block\n                                .time\n                                .plus_seconds(config.ibc_timeout_seconds)\n                                .into(),\n                        });\n                        response = response\n                            .add_message(hub_msg)\n                            .add_attribute(\"action\", cast_vote.to_string())\n                            .add_attribute(\"user\", pending_vote.voter.to_string());\n\n                        // Remove this pending vote from the cache\n                        PENDING_VOTES.remove(deps.storage, proposal.proposal_id.u64());\n                    }\n\n                    response = response\n                        .add_attribute(\"hub_response\", \"query_response\")\n                        .add_attribute(\"response_type\", \"proposal\")\n                        .add_attribute(\"proposal_id\", proposal.proposal_id.to_string())\n                        .add_attribute(\"proposal_start\", proposal.start_time.to_string())\n                }\n                Response::Result {\n                    action,\n                    address,\n                    error,\n                } =\u003e {\n                    response = response\n                        .add_attribute(\"action\", action.unwrap_or(\"unknown\".to_string()))\n                        .add_attribute(\"user\", address.unwrap_or(\"unknown\".to_string()))\n                        .add_attribute(\"err\", error.unwrap_or(\"none\".to_string()))\n                }\n            }\n        }\n        Err(err) =\u003e {\n            // In case of error, ack.data will be in the format similar to\n            // {\"error\":\"ABCI code: 5: error handling packet: see events for details\"}\n            // but the events do not contain the details\n            //\n            // Instead we look at the original packet to determine what failed,\n            // the reason for the failure can't be determined at this time due\n            // to a limitation in wasmd/wasmvm. For us we just need to know what failed,\n            // the reason is not required to continue\n            // See https://github.com/CosmWasm/cosmwasm/issues/1707\n\n            let raw_error = base64::encode(\u0026msg.acknowledgement.data);\n            // Attach the errors to the response\n            response = response\n                .add_attribute(\"raw_error\", raw_error)\n                .add_attribute(\"ack_error\", err.to_string());\n\n            // Handle the possible failures\n            let original: Hub = from_binary(\u0026msg.original_packet.data)?;\n            response = handle_failed_messages(deps, original, response)?;\n        }\n    }\n    Ok(response)\n}\n\n/// Handle the closing of IBC channels, which we don't allow\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_channel_close(\n    _deps: DepsMut,\n    _env: Env,\n    _channel: IbcChannelCloseMsg,\n) -\u003e StdResult\u003cIbcBasicResponse\u003e {\n    Err(StdError::generic_err(\"Closing channel is not allowed\"))\n}\n\n/// Checks the provided port against the known Hub.\n///\n/// If the port doesn't exist, this function will  return an error, effectively blocking the packet.\nfn block_unauthorized_packets(deps: Deps, port_id: String) -\u003e Result\u003c(), ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n    let counterparty_port = get_contract_from_ibc_port(port_id.as_str());\n    ensure!(\n        config.hub_addr == counterparty_port,\n        ContractError::Unauthorized {}\n    );\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","ibc_failure.rs"],"content":"use cosmwasm_std::{DepsMut, IbcBasicResponse};\n\nuse astroport_governance::interchain::Hub;\n\nuse crate::{error::ContractError, ibc_mint::mint_xastro_msg, state::PENDING_VOTES};\n\npub fn handle_failed_messages(\n    deps: DepsMut,\n    failed_msg: Hub,\n    mut response: IbcBasicResponse,\n) -\u003e Result\u003cIbcBasicResponse, ContractError\u003e {\n    match failed_msg.clone() {\n        Hub::CastAssemblyVote { voter, .. } =\u003e {\n            response = response\n                .add_attribute(\"action\", failed_msg.to_string())\n                .add_attribute(\"user\", voter.to_string());\n        }\n        Hub::CastEmissionsVote { voter, .. } =\u003e {\n            response = response\n                .add_attribute(\"action\", failed_msg.to_string())\n                .add_attribute(\"user\", voter.to_string());\n        }\n        Hub::QueryProposal { id } =\u003e {\n            // If the proposal query failed we need to remove the pending vote\n            // otherwise no other vote will be possible for this proposal\n            let pending_vote = PENDING_VOTES.load(deps.storage, id)?;\n            PENDING_VOTES.remove(deps.storage, id);\n\n            response = response\n                .add_attribute(\"action\", failed_msg.to_string())\n                .add_attribute(\"user\", pending_vote.voter.to_string());\n        }\n\n        Hub::Unstake { receiver, amount } =\u003e {\n            // Unstaking involves us burning the received xASTRO before\n            // sending the unstake message to the Hub. If the unstaking\n            // fails we need to mint the xASTRO back to the user\n            let msg = mint_xastro_msg(deps.as_ref(), receiver.clone(), amount)?;\n            response = response\n                .add_message(msg)\n                .add_attribute(\"action\", failed_msg.to_string())\n                .add_attribute(\"user\", receiver);\n        }\n        Hub::KickUnlockedVoter { .. } =\u003e {\n            // TODO: If this failed, we _must_ relock, or actually, without success, unlock must not complete\n        }\n        Hub::WithdrawFunds { user } =\u003e {\n            response = response\n                .add_attribute(\"action\", failed_msg.to_string())\n                .add_attribute(\"user\", user.to_string());\n        }\n        // Not all Hub responses will be received here, we only handle the ones we have\n        // control over\n        _ =\u003e {\n            response = response.add_attribute(\"action\", failed_msg.to_string());\n        }\n    }\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","ibc_mint.rs"],"content":"use astroport_governance::interchain::Response;\nuse cosmwasm_std::{to_binary, Deps, DepsMut, IbcReceiveResponse, Uint128, WasmMsg};\nuse cw20::Cw20ExecuteMsg;\n\nuse crate::{error::ContractError, state::CONFIG};\n\n/// Mint new xASTRO based on the message received from the Hub, it cannot be\n/// called directly.\n///\n/// This is called in response to a staking message sent to the Hub\npub fn handle_ibc_xastro_mint(\n    deps: DepsMut,\n    recipient: String,\n    amount: Uint128,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Mint the new amount of xASTRO to the recipient that originally initiated\n    // the ASTRO staking\n    let mint_msg = Cw20ExecuteMsg::Mint {\n        recipient: recipient.clone(),\n        amount,\n    };\n    let msg = WasmMsg::Execute {\n        contract_addr: config.xastro_token_addr.to_string(),\n        msg: to_binary(\u0026mint_msg)?,\n        funds: vec![],\n    };\n\n    // If the minting succeeds, the ack will be sent back to the Hub\n    let ack_data = to_binary(\u0026Response::new_success(\n        \"mint_xastro\".to_owned(),\n        recipient.to_string(),\n    ))?;\n\n    let response = IbcReceiveResponse::new()\n        .add_message(msg)\n        .set_ack(ack_data)\n        .add_attribute(\"action\", \"mint_xastro\")\n        .add_attribute(\"user\", recipient)\n        .add_attribute(\"amount\", amount);\n\n    Ok(response)\n}\n\n/// Create a new message to mint xASTRO to a specific address\npub fn mint_xastro_msg(\n    deps: Deps,\n    recipient: String,\n    amount: Uint128,\n) -\u003e Result\u003cWasmMsg, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    let mint_msg = Cw20ExecuteMsg::Mint { recipient, amount };\n    Ok(WasmMsg::Execute {\n        contract_addr: config.xastro_token_addr.to_string(),\n        msg: to_binary(\u0026mint_msg)?,\n        funds: vec![],\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","lib.rs"],"content":"pub mod contract;\npub mod error;\npub mod execute;\npub mod ibc;\npub mod ibc_failure;\npub mod ibc_mint;\npub mod query;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","query.rs"],"content":"use cosmwasm_std::{entry_point, to_binary, Addr, Binary, Deps, Env, StdResult, Uint128};\n\nuse astroport::xastro_outpost_token::get_voting_power_at_time;\nuse astroport_governance::outpost::QueryMsg;\nuse astroport_governance::voting_escrow_lite::get_user_deposit_at_time;\n\nuse crate::error::ContractError;\nuse crate::state::CONFIG;\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::Config {}** Returns the config of the Outpost\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Config {} =\u003e to_binary(\u0026CONFIG.load(deps.storage)?),\n    }\n}\n\npub fn get_user_voting_power(\n    deps: Deps,\n    user: Addr,\n    proposal_start: u64,\n) -\u003e Result\u003cUint128, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Get the user's xASTRO balance at the time the proposal was added\n    let voting_power = get_voting_power_at_time(\n        \u0026deps.querier,\n        config.xastro_token_addr.clone(),\n        user.clone(),\n        proposal_start,\n    )\n    .unwrap_or(Uint128::zero());\n\n    // Get the user's underlying xASTRO deposit at the time the proposal was added\n    let vxastro_balance = get_user_deposit_at_time(\n        \u0026deps.querier,\n        config.vxastro_token_addr,\n        user,\n        proposal_start,\n    )\n    .unwrap_or(Uint128::zero());\n\n    Ok(voting_power.checked_add(vxastro_balance)?)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","state.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Uint64};\nuse cw_storage_plus::{Item, Map};\n\nuse astroport::common::OwnershipProposal;\nuse astroport_governance::{assembly::ProposalVoteOption, outpost::Config};\n\n#[cw_serde]\npub struct CachedProposal {\n    /// Unique proposal ID\n    pub proposal_id: Uint64,\n    /// Start time of proposal\n    pub start_time: u64,\n}\n\n#[cw_serde]\npub struct PendingVote {\n    /// The proposal ID to vote on\n    pub proposal_id: u64,\n    /// The user voting\n    pub voter: Addr,\n    /// The choice in vote\n    pub vote_option: ProposalVoteOption,\n}\n\n/// Store the contract config\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n\n/// Store a local cache of proposals to verify votes are allowed\npub const PROPOSALS_CACHE: Map\u003cu64, CachedProposal\u003e = Map::new(\"proposals_cache\");\n\n/// Store the pending votes for a proposal while the information is being\n/// retrieved from the Hub\npub const PENDING_VOTES: Map\u003cu64, PendingVote\u003e = Map::new(\"pending_votes\");\n\n/// Contains a proposal to change contract ownership\npub const OWNERSHIP_PROPOSAL: Item\u003cOwnershipProposal\u003e = Item::new(\"ownership_proposal\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","examples","schema.rs"],"content":"use astroport_governance::voting_escrow::{ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};\nuse cosmwasm_schema::write_api;\n\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        query: QueryMsg,\n        execute: ExecuteMsg,\n        migrate: MigrateMsg,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","src","contract.rs"],"content":"use crate::astroport;\nuse astroport::common::{claim_ownership, drop_ownership_proposal, propose_new_owner};\nuse astroport_governance::astroport::DecimalCheckedOps;\n\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    attr, from_binary, to_binary, Addr, Binary, CosmosMsg, Deps, DepsMut, Env, MessageInfo,\n    Response, StdError, StdResult, Storage, Uint128, WasmMsg,\n};\nuse cw2::set_contract_version;\nuse cw20::{\n    BalanceResponse, Cw20ExecuteMsg, Cw20QueryMsg, Cw20ReceiveMsg, Logo, LogoInfo,\n    MarketingInfoResponse, MinterResponse, TokenInfoResponse,\n};\nuse cw20_base::contract::{\n    execute_update_marketing, execute_upload_logo, query_download_logo, query_marketing_info,\n};\nuse cw20_base::state::{MinterData, TokenInfo, LOGO, MARKETING_INFO, TOKEN_INFO};\n\nuse crate::astroport::asset::addr_opt_validate;\nuse crate::astroport::common::validate_addresses;\nuse astroport_governance::utils::{get_period, get_periods_count, EPOCH_START, WEEK};\nuse astroport_governance::voting_escrow::{\n    BlacklistedVotersResponse, ConfigResponse, Cw20HookMsg, ExecuteMsg, InstantiateMsg,\n    LockInfoResponse, MigrateMsg, QueryMsg, VotingPowerResponse, DEFAULT_LIMIT, MAX_LIMIT,\n};\n\nuse crate::error::ContractError;\nuse crate::marketing_validation::{validate_marketing_info, validate_whitelist_links};\nuse crate::state::{\n    Config, Lock, Point, BLACKLIST, CONFIG, HISTORY, LAST_SLOPE_CHANGE, LOCKED, OWNERSHIP_PROPOSAL,\n};\nuse crate::utils::{\n    adjust_vp_and_slope, blacklist_check, calc_coefficient, calc_voting_power,\n    cancel_scheduled_slope, fetch_last_checkpoint, fetch_slope_changes, schedule_slope_change,\n    time_limits_check, xastro_token_check,\n};\n\n/// Contract name that is used for migration.\nconst CONTRACT_NAME: \u0026str = \"astro-voting-escrow\";\n/// Contract version that is used for migration.\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Creates a new contract with the specified parameters in [`InstantiateMsg`].\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n    let deposit_token_addr = deps.api.addr_validate(\u0026msg.deposit_token_addr)?;\n\n    let xastro_minter_resp: MinterResponse = deps\n        .querier\n        .query_wasm_smart(\u0026deposit_token_addr, \u0026Cw20QueryMsg::Minter {})?;\n    let staking_config: crate::astroport::staking::ConfigResponse = deps.querier.query_wasm_smart(\n        \u0026xastro_minter_resp.minter,\n        \u0026crate::astroport::staking::QueryMsg::Config {},\n    )?;\n\n    validate_whitelist_links(\u0026msg.logo_urls_whitelist)?;\n    let guardian_addr = addr_opt_validate(deps.api, \u0026msg.guardian_addr)?;\n\n    let config = Config {\n        owner: deps.api.addr_validate(\u0026msg.owner)?,\n        guardian_addr,\n        deposit_token_addr,\n        astro_addr: staking_config.deposit_token_addr,\n        xastro_staking_addr: deps.api.addr_validate(\u0026xastro_minter_resp.minter)?,\n        logo_urls_whitelist: msg.logo_urls_whitelist.clone(),\n    };\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    let cur_period = get_period(env.block.time.seconds())?;\n    let point = Point {\n        power: Uint128::zero(),\n        start: cur_period,\n        end: 0,\n        slope: Default::default(),\n    };\n    HISTORY.save(\n        deps.storage,\n        (env.contract.address.clone(), cur_period),\n        \u0026point,\n    )?;\n    BLACKLIST.save(deps.storage, \u0026vec![])?;\n\n    if let Some(marketing) = msg.marketing {\n        if msg.logo_urls_whitelist.is_empty() {\n            return Err(StdError::generic_err(\"Logo URLs whitelist can not be empty\").into());\n        }\n\n        validate_marketing_info(\n            marketing.project.as_ref(),\n            marketing.description.as_ref(),\n            marketing.logo.as_ref(),\n            \u0026config.logo_urls_whitelist,\n        )?;\n\n        let logo = if let Some(logo) = marketing.logo {\n            LOGO.save(deps.storage, \u0026logo)?;\n\n            match logo {\n                Logo::Url(url) =\u003e Some(LogoInfo::Url(url)),\n                Logo::Embedded(_) =\u003e Some(LogoInfo::Embedded),\n            }\n        } else {\n            None\n        };\n\n        let data = MarketingInfoResponse {\n            project: marketing.project,\n            description: marketing.description,\n            marketing: addr_opt_validate(deps.api, \u0026marketing.marketing)?,\n            logo,\n        };\n        MARKETING_INFO.save(deps.storage, \u0026data)?;\n    }\n\n    // Store token info\n    let data = TokenInfo {\n        name: \"Vote Escrowed xASTRO\".to_string(),\n        symbol: \"vxASTRO\".to_string(),\n        decimals: 6,\n        total_supply: Uint128::zero(),\n        mint: Some(MinterData {\n            minter: env.contract.address,\n            cap: None,\n        }),\n    };\n\n    TOKEN_INFO.save(deps.storage, \u0026data)?;\n\n    Ok(Response::default())\n}\n\n/// Exposes all the execute functions available in the contract.\n///\n/// ## Execute messages\n/// * **ExecuteMsg::ExtendLockTime { time }** Increase a staker's lock time.\n///\n/// * **ExecuteMsg::Receive(msg)** Parse incoming messages coming from the xASTRO token contract.\n///\n/// * **ExecuteMsg::Withdraw {}** Withdraw all xASTRO from a lock position if the lock has expired.\n///\n/// * **ExecuteMsg::ProposeNewOwner { owner, expires_in }** Creates a new request to change contract ownership.\n///\n/// * **ExecuteMsg::DropOwnershipProposal {}** Removes a request to change contract ownership.\n///\n/// * **ExecuteMsg::ClaimOwnership {}** Claims contract ownership.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::ExtendLockTime { time } =\u003e extend_lock_time(deps, env, info, time),\n        ExecuteMsg::Receive(msg) =\u003e receive_cw20(deps, env, info, msg),\n        ExecuteMsg::Withdraw {} =\u003e withdraw(deps, env, info),\n        ExecuteMsg::ProposeNewOwner {\n            new_owner,\n            expires_in,\n        } =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n            propose_new_owner(\n                deps,\n                info,\n                env,\n                new_owner,\n                expires_in,\n                config.owner,\n                OWNERSHIP_PROPOSAL,\n            )\n            .map_err(Into::into)\n        }\n        ExecuteMsg::DropOwnershipProposal {} =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n\n            drop_ownership_proposal(deps, info, config.owner, OWNERSHIP_PROPOSAL)\n                .map_err(Into::into)\n        }\n        ExecuteMsg::ClaimOwnership {} =\u003e {\n            claim_ownership(deps, info, env, OWNERSHIP_PROPOSAL, |deps, new_owner| {\n                CONFIG\n                    .update::\u003c_, StdError\u003e(deps.storage, |mut v| {\n                        v.owner = new_owner;\n                        Ok(v)\n                    })\n                    .map(|_| ())\n            })\n            .map_err(Into::into)\n        }\n        ExecuteMsg::UpdateBlacklist {\n            append_addrs,\n            remove_addrs,\n        } =\u003e update_blacklist(deps, env, info, append_addrs, remove_addrs),\n        ExecuteMsg::UpdateMarketing {\n            project,\n            description,\n            marketing,\n        } =\u003e {\n            validate_marketing_info(project.as_ref(), description.as_ref(), None, \u0026[])?;\n            execute_update_marketing(deps, env, info, project, description, marketing)\n                .map_err(Into::into)\n        }\n        ExecuteMsg::UploadLogo(logo) =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n            validate_marketing_info(None, None, Some(\u0026logo), \u0026config.logo_urls_whitelist)?;\n            execute_upload_logo(deps, env, info, logo).map_err(Into::into)\n        }\n        ExecuteMsg::SetLogoUrlsWhitelist { whitelist } =\u003e {\n            let mut config = CONFIG.load(deps.storage)?;\n            let marketing_info = MARKETING_INFO.load(deps.storage)?;\n            if info.sender != config.owner \u0026\u0026 Some(info.sender) != marketing_info.marketing {\n                Err(ContractError::Unauthorized {})\n            } else {\n                validate_whitelist_links(\u0026whitelist)?;\n                config.logo_urls_whitelist = whitelist;\n                CONFIG.save(deps.storage, \u0026config)?;\n                Ok(Response::default().add_attribute(\"action\", \"set_logo_urls_whitelist\"))\n            }\n        }\n        ExecuteMsg::UpdateConfig { new_guardian } =\u003e {\n            execute_update_config(deps, info, new_guardian)\n        }\n    }\n}\n\n/// Checkpoint the total voting power (total supply of vxASTRO).\n/// This function fetches the last available vxASTRO checkpoint, recalculates passed periods since the checkpoint and until now,\n/// applies slope changes and saves all recalculated periods in [`HISTORY`].\n///\n/// * **add_voting_power** amount of vxASTRO to add to the total.\n///\n/// * **reduce_power** amount of vxASTRO to subtract from the total.\n///\n/// * **old_slope** old slope applied to the total voting power (vxASTRO supply).\n///\n/// * **new_slope** new slope to be applied to the total voting power (vxASTRO supply).\nfn checkpoint_total(\n    storage: \u0026mut dyn Storage,\n    env: Env,\n    add_voting_power: Option\u003cUint128\u003e,\n    reduce_power: Option\u003cUint128\u003e,\n    old_slope: Uint128,\n    new_slope: Uint128,\n) -\u003e StdResult\u003c()\u003e {\n    let cur_period = get_period(env.block.time.seconds())?;\n    let cur_period_key = cur_period;\n    let contract_addr = env.contract.address;\n    let add_voting_power = add_voting_power.unwrap_or_default();\n\n    // Get last checkpoint\n    let last_checkpoint = fetch_last_checkpoint(storage, \u0026contract_addr, cur_period_key)?;\n    let new_point = if let Some((_, mut point)) = last_checkpoint {\n        let last_slope_change = LAST_SLOPE_CHANGE.may_load(storage)?.unwrap_or(0);\n        if last_slope_change \u003c cur_period {\n            let scheduled_slope_changes =\n                fetch_slope_changes(storage, last_slope_change, cur_period)?;\n            // Recalculating passed points\n            for (recalc_period, scheduled_change) in scheduled_slope_changes {\n                point = Point {\n                    power: calc_voting_power(\u0026point, recalc_period),\n                    start: recalc_period,\n                    slope: point.slope - scheduled_change,\n                    ..point\n                };\n                HISTORY.save(storage, (contract_addr.clone(), recalc_period), \u0026point)?\n            }\n\n            LAST_SLOPE_CHANGE.save(storage, \u0026cur_period)?\n        }\n\n        let new_power = (calc_voting_power(\u0026point, cur_period) + add_voting_power)\n            .saturating_sub(reduce_power.unwrap_or_default());\n\n        Point {\n            power: new_power,\n            slope: point.slope - old_slope + new_slope,\n            start: cur_period,\n            ..point\n        }\n    } else {\n        Point {\n            power: add_voting_power,\n            slope: new_slope,\n            start: cur_period,\n            end: 0, // we don't use 'end' in total voting power calculations\n        }\n    };\n    HISTORY.save(storage, (contract_addr, cur_period_key), \u0026new_point)\n}\n\n/// Checkpoint a user's voting power (vxASTRO balance).\n/// This function fetches the user's last available checkpoint, calculates the user's current voting power, applies slope changes based on\n/// `add_amount` and `new_end` parameters, schedules slope changes for total voting power and saves the new checkpoint for the current\n/// period in [`HISTORY`] (using the user's address).\n/// If a user already checkpointed themselves for the current period, then this function uses the current checkpoint as the latest\n/// available one.\n///\n/// * **addr** staker for which we checkpoint the voting power.\n///\n/// * **add_amount** amount of vxASTRO to add to the staker's balance.\n///\n/// * **new_end** new lock time for the staker's vxASTRO position.\nfn checkpoint(\n    deps: DepsMut,\n    env: Env,\n    addr: Addr,\n    add_amount: Option\u003cUint128\u003e,\n    new_end: Option\u003cu64\u003e,\n) -\u003e StdResult\u003c()\u003e {\n    let cur_period = get_period(env.block.time.seconds())?;\n    let cur_period_key = cur_period;\n    let add_amount = add_amount.unwrap_or_default();\n    let mut old_slope = Default::default();\n    let mut add_voting_power = Uint128::zero();\n\n    // Get the last user checkpoint\n    let last_checkpoint = fetch_last_checkpoint(deps.storage, \u0026addr, cur_period_key)?;\n    let new_point = if let Some((_, point)) = last_checkpoint {\n        let end = new_end.unwrap_or(point.end);\n        let dt = end.saturating_sub(cur_period);\n        let current_power = calc_voting_power(\u0026point, cur_period);\n        let new_slope = if dt != 0 {\n            if end \u003e point.end \u0026\u0026 add_amount.is_zero() {\n                // This is extend_lock_time. Recalculating user's voting power\n                let mut lock = LOCKED.load(deps.storage, addr.clone())?;\n                let mut new_voting_power = calc_coefficient(dt).checked_mul_uint128(lock.amount)?;\n                let slope = adjust_vp_and_slope(\u0026mut new_voting_power, dt)?;\n                // new_voting_power should always be \u003e= current_power. saturating_sub is used for extra safety\n                add_voting_power = new_voting_power.saturating_sub(current_power);\n                lock.last_extend_lock_period = cur_period;\n                LOCKED.save(deps.storage, addr.clone(), \u0026lock, env.block.height)?;\n                slope\n            } else {\n                // This is an increase in the user's lock amount\n                let raw_add_voting_power = calc_coefficient(dt).checked_mul_uint128(add_amount)?;\n                let mut new_voting_power = current_power.checked_add(raw_add_voting_power)?;\n                let slope = adjust_vp_and_slope(\u0026mut new_voting_power, dt)?;\n                // new_voting_power should always be \u003e= current_power. saturating_sub is used for extra safety\n                add_voting_power = new_voting_power.saturating_sub(current_power);\n                slope\n            }\n        } else {\n            Uint128::zero()\n        };\n\n        // Cancel the previously scheduled slope change\n        cancel_scheduled_slope(deps.storage, point.slope, point.end)?;\n\n        // We need to subtract the slope point from the total voting power slope\n        old_slope = point.slope;\n\n        Point {\n            power: current_power + add_voting_power,\n            slope: new_slope,\n            start: cur_period,\n            end,\n        }\n    } else {\n        // This error can't happen since this if-branch is intended for checkpoint creation\n        let end =\n            new_end.ok_or_else(|| StdError::generic_err(\"Checkpoint initialization error\"))?;\n        let dt = end - cur_period;\n        add_voting_power = calc_coefficient(dt).checked_mul_uint128(add_amount)?;\n        let slope = adjust_vp_and_slope(\u0026mut add_voting_power, dt)?;\n        Point {\n            power: add_voting_power,\n            slope,\n            start: cur_period,\n            end,\n        }\n    };\n\n    // Schedule a slope change\n    schedule_slope_change(deps.storage, new_point.slope, new_point.end)?;\n\n    HISTORY.save(deps.storage, (addr, cur_period_key), \u0026new_point)?;\n    checkpoint_total(\n        deps.storage,\n        env,\n        Some(add_voting_power),\n        None,\n        old_slope,\n        new_point.slope,\n    )\n}\n\n/// Receives a message of type [`Cw20ReceiveMsg`] and processes it depending on the received template.\n///\n/// * **cw20_msg** CW20 message to process.\nfn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    xastro_token_check(deps.storage, info.sender)?;\n    let sender = Addr::unchecked(cw20_msg.sender);\n    blacklist_check(deps.storage, \u0026sender)?;\n\n    match from_binary(\u0026cw20_msg.msg)? {\n        Cw20HookMsg::CreateLock { time } =\u003e create_lock(deps, env, sender, cw20_msg.amount, time),\n        Cw20HookMsg::ExtendLockAmount {} =\u003e deposit_for(deps, env, cw20_msg.amount, sender),\n        Cw20HookMsg::DepositFor { user } =\u003e {\n            let addr = deps.api.addr_validate(\u0026user)?;\n            blacklist_check(deps.storage, \u0026addr)?;\n            deposit_for(deps, env, cw20_msg.amount, addr)\n        }\n    }\n}\n\n/// Creates a lock for the user that lasts for the specified time duration (in seconds).\n/// Checks that the user is locking xASTRO tokens.\n/// Checks that the lock time is within [`WEEK`]..[`MAX_LOCK_TIME`].\n/// Creates a lock if it doesn't exist and triggers a [`checkpoint`] for the staker.\n/// If a lock already exists, then a [`ContractError`] is returned.\n///\n/// * **user** staker for which we create a lock position.\n///\n/// * **amount** amount of xASTRO deposited in the lock position.\n///\n/// * **time** duration of the lock.\nfn create_lock(\n    deps: DepsMut,\n    env: Env,\n    user: Addr,\n    amount: Uint128,\n    time: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    time_limits_check(time)?;\n\n    let block_period = get_period(env.block.time.seconds())?;\n    let end = block_period + get_periods_count(time);\n\n    LOCKED.update(deps.storage, user.clone(), env.block.height, |lock_opt| {\n        if lock_opt.is_some() \u0026\u0026 !lock_opt.unwrap().amount.is_zero() {\n            return Err(ContractError::LockAlreadyExists {});\n        }\n        Ok(Lock {\n            amount,\n            start: block_period,\n            end,\n            last_extend_lock_period: block_period,\n        })\n    })?;\n\n    checkpoint(deps, env, user, Some(amount), Some(end))?;\n\n    Ok(Response::default().add_attribute(\"action\", \"create_lock\"))\n}\n\n/// Deposits an 'amount' of xASTRO tokens into 'user''s lock.\n/// Checks that the user is transferring and locking xASTRO.\n/// Triggers a [`checkpoint`] for the user.\n/// If the user does not have a lock, then a [`ContractError`] is returned.\n///\n/// * **amount** amount of xASTRO to deposit.\n///\n/// * **user** user who's lock amount will increase.\nfn deposit_for(\n    deps: DepsMut,\n    env: Env,\n    amount: Uint128,\n    user: Addr,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    LOCKED.update(\n        deps.storage,\n        user.clone(),\n        env.block.height,\n        |lock_opt| match lock_opt {\n            Some(mut lock) if !lock.amount.is_zero() =\u003e {\n                if lock.end \u003c= get_period(env.block.time.seconds())? {\n                    Err(ContractError::LockExpired {})\n                } else {\n                    lock.amount += amount;\n                    Ok(lock)\n                }\n            }\n            _ =\u003e Err(ContractError::LockDoesNotExist {}),\n        },\n    )?;\n    checkpoint(deps, env, user, Some(amount), None)?;\n\n    Ok(Response::default().add_attribute(\"action\", \"deposit_for\"))\n}\n\n/// Withdraws the whole amount of locked xASTRO from a specific user lock.\n/// If the user lock doesn't exist or if it has not yet expired, then a [`ContractError`] is returned.\nfn withdraw(deps: DepsMut, env: Env, info: MessageInfo) -\u003e Result\u003cResponse, ContractError\u003e {\n    let sender = info.sender;\n    // 'LockDoesNotExist' is thrown either when a lock does not exist in LOCKED or when a lock exists but lock.amount == 0\n    let mut lock = LOCKED\n        .may_load(deps.storage, sender.clone())?\n        .filter(|lock| !lock.amount.is_zero())\n        .ok_or(ContractError::LockDoesNotExist {})?;\n\n    let cur_period = get_period(env.block.time.seconds())?;\n    if lock.end \u003e cur_period {\n        Err(ContractError::LockHasNotExpired {})\n    } else {\n        let config = CONFIG.load(deps.storage)?;\n        let transfer_msg = CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: config.deposit_token_addr.to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                recipient: sender.to_string(),\n                amount: lock.amount,\n            })?,\n            funds: vec![],\n        });\n        lock.amount = Uint128::zero();\n        LOCKED.save(deps.storage, sender.clone(), \u0026lock, env.block.height)?;\n\n        // We need to checkpoint and eliminate the slope influence on a future lock\n        HISTORY.save(\n            deps.storage,\n            (sender, cur_period),\n            \u0026Point {\n                power: Uint128::zero(),\n                start: cur_period,\n                end: cur_period,\n                slope: Default::default(),\n            },\n        )?;\n\n        Ok(Response::default()\n            .add_message(transfer_msg)\n            .add_attribute(\"action\", \"withdraw\"))\n    }\n}\n\n/// Increase the current lock time for a staker by a specified time period.\n/// Evaluates that the `time` is within [`WEEK`]..[`MAX_LOCK_TIME`]\n/// and then it triggers a [`checkpoint`].\n/// If the user lock doesn't exist or if it expired, then a [`ContractError`] is returned.\n///\n/// ## Note\n/// The time is added to the lock's `end`.\n/// For example, at period 0, the user has their xASTRO locked for 3 weeks.\n/// In 1 week, they increase their lock time by 10 weeks, thus the unlock period becomes 13 weeks.\n///\n/// * **time** increase in lock time applied to the staker's position.\nfn extend_lock_time(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    time: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let user = info.sender;\n    blacklist_check(deps.storage, \u0026user)?;\n    let mut lock = LOCKED\n        .may_load(deps.storage, user.clone())?\n        .filter(|lock| !lock.amount.is_zero())\n        .ok_or(ContractError::LockDoesNotExist {})?;\n\n    // Disable the ability to extend the lock time by less than a week\n    time_limits_check(time)?;\n\n    if lock.end \u003c= get_period(env.block.time.seconds())? {\n        return Err(ContractError::LockExpired {});\n    };\n\n    // Should not exceed MAX_LOCK_TIME\n    time_limits_check(EPOCH_START + lock.end * WEEK + time - env.block.time.seconds())?;\n    lock.end += get_periods_count(time);\n    LOCKED.save(deps.storage, user.clone(), \u0026lock, env.block.height)?;\n\n    checkpoint(deps, env, user, None, Some(lock.end))?;\n\n    Ok(Response::default().add_attribute(\"action\", \"extend_lock_time\"))\n}\n\n/// Update the staker blacklist. Whitelists addresses specified in 'remove_addrs'\n/// and blacklists new addresses specified in 'append_addrs'. Nullifies staker voting power and\n/// cancels their contribution in the total voting power (total vxASTRO supply).\n///\n/// * **append_addrs** array of addresses to blacklist.\n///\n/// * **remove_addrs** array of addresses to whitelist.\nfn update_blacklist(\n    mut deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    append_addrs: Option\u003cVec\u003cString\u003e\u003e,\n    remove_addrs: Option\u003cVec\u003cString\u003e\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n    // Permission check\n    if info.sender != config.owner \u0026\u0026 Some(info.sender) != config.guardian_addr {\n        return Err(ContractError::Unauthorized {});\n    }\n    let append_addrs = append_addrs.unwrap_or_default();\n    let remove_addrs = remove_addrs.unwrap_or_default();\n    let blacklist = BLACKLIST.load(deps.storage)?;\n    let append: Vec\u003c_\u003e = validate_addresses(deps.api, \u0026append_addrs)?\n        .into_iter()\n        .filter(|addr| !blacklist.contains(addr))\n        .collect();\n    let remove: Vec\u003c_\u003e = validate_addresses(deps.api, \u0026remove_addrs)?\n        .into_iter()\n        .filter(|addr| blacklist.contains(addr))\n        .collect();\n\n    if append.is_empty() \u0026\u0026 remove.is_empty() {\n        return Err(StdError::generic_err(\"Append and remove arrays are empty\").into());\n    }\n\n    let cur_period = get_period(env.block.time.seconds())?;\n    let cur_period_key = cur_period;\n    let mut reduce_total_vp = Uint128::zero(); // accumulator for decreasing total voting power\n    let mut old_slopes = Uint128::zero(); // accumulator for old slopes\n\n    for addr in append.iter() {\n        let last_checkpoint = fetch_last_checkpoint(deps.storage, addr, cur_period_key)?;\n        if let Some((_, point)) = last_checkpoint {\n            // We need to checkpoint with zero power and zero slope\n            HISTORY.save(\n                deps.storage,\n                (addr.clone(), cur_period_key),\n                \u0026Point {\n                    power: Uint128::zero(),\n                    slope: Default::default(),\n                    start: cur_period,\n                    end: cur_period,\n                },\n            )?;\n\n            let cur_power = calc_voting_power(\u0026point, cur_period);\n            // User's contribution is already zero. Skipping them\n            if cur_power.is_zero() {\n                continue;\n            }\n\n            // User's contribution in the total voting power calculation\n            reduce_total_vp += cur_power;\n            old_slopes += point.slope;\n            cancel_scheduled_slope(deps.storage, point.slope, point.end)?;\n        }\n    }\n\n    if !reduce_total_vp.is_zero() || !old_slopes.is_zero() {\n        // Trigger a total voting power recalculation\n        checkpoint_total(\n            deps.storage,\n            env.clone(),\n            None,\n            Some(reduce_total_vp),\n            old_slopes,\n            Default::default(),\n        )?;\n    }\n\n    for addr in remove.iter() {\n        let lock_opt = LOCKED.may_load(deps.storage, addr.clone())?;\n        if let Some(Lock { amount, end, .. }) = lock_opt {\n            checkpoint(\n                deps.branch(),\n                env.clone(),\n                addr.clone(),\n                Some(amount),\n                Some(end),\n            )?;\n        }\n    }\n\n    BLACKLIST.update(deps.storage, |blacklist| -\u003e StdResult\u003cVec\u003cAddr\u003e\u003e {\n        let mut updated_blacklist: Vec\u003c_\u003e = blacklist\n            .into_iter()\n            .filter(|addr| !remove.contains(addr))\n            .collect();\n        updated_blacklist.extend(append);\n        Ok(updated_blacklist)\n    })?;\n\n    let mut attrs = vec![attr(\"action\", \"update_blacklist\")];\n    if !append_addrs.is_empty() {\n        attrs.push(attr(\"added_addresses\", append_addrs.join(\",\")))\n    }\n    if !remove_addrs.is_empty() {\n        attrs.push(attr(\"removed_addresses\", remove_addrs.join(\",\")))\n    }\n\n    Ok(Response::default().add_attributes(attrs))\n}\n\n/// Updates contracts' guardian address.\nfn execute_update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    new_guardian: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut cfg = CONFIG.load(deps.storage)?;\n\n    if cfg.owner != info.sender {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(new_guardian) = new_guardian {\n        cfg.guardian_addr = Some(deps.api.addr_validate(\u0026new_guardian)?);\n    }\n\n    CONFIG.save(deps.storage, \u0026cfg)?;\n\n    Ok(Response::default().add_attribute(\"action\", \"execute_update_config\"))\n}\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::TotalVotingPower {}** Fetch the total voting power (vxASTRO supply) at the current block.\n///\n/// * **QueryMsg::UserVotingPower { user }** Fetch the user's voting power (vxASTRO balance) at the current block.\n///\n/// * **QueryMsg::TotalVotingPowerAt { time }** Fetch the total voting power (vxASTRO supply) at a specified timestamp.\n///\n/// * **QueryMsg::UserVotingPowerAt { time }** Fetch the user's voting power (vxASTRO balance) at a specified timestamp.\n///\n/// * **QueryMsg::LockInfo { user }** Fetch a user's lock information.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::CheckVotersAreBlacklisted { voters } =\u003e {\n            to_binary(\u0026check_voters_are_blacklisted(deps, voters)?)\n        }\n        QueryMsg::BlacklistedVoters { start_after, limit } =\u003e {\n            to_binary(\u0026get_blacklisted_voters(deps, start_after, limit)?)\n        }\n        QueryMsg::TotalVotingPower {} =\u003e to_binary(\u0026get_total_voting_power(deps, env, None)?),\n        QueryMsg::UserVotingPower { user } =\u003e {\n            to_binary(\u0026get_user_voting_power(deps, env, user, None)?)\n        }\n        QueryMsg::TotalVotingPowerAt { time } =\u003e {\n            to_binary(\u0026get_total_voting_power(deps, env, Some(time))?)\n        }\n        QueryMsg::TotalVotingPowerAtPeriod { period } =\u003e {\n            to_binary(\u0026get_total_voting_power_at_period(deps, env, period)?)\n        }\n        QueryMsg::UserVotingPowerAt { user, time } =\u003e {\n            to_binary(\u0026get_user_voting_power(deps, env, user, Some(time))?)\n        }\n        QueryMsg::UserVotingPowerAtPeriod { user, period } =\u003e {\n            to_binary(\u0026get_user_voting_power_at_period(deps, user, period)?)\n        }\n        QueryMsg::LockInfo { user } =\u003e to_binary(\u0026get_user_lock_info(deps, env, user)?),\n        QueryMsg::UserDepositAtHeight { user, height } =\u003e {\n            to_binary(\u0026get_user_deposit_at_height(deps, user, height)?)\n        }\n        QueryMsg::Config {} =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n            to_binary(\u0026ConfigResponse {\n                owner: config.owner.to_string(),\n                guardian_addr: config.guardian_addr,\n                deposit_token_addr: config.deposit_token_addr.to_string(),\n                astro_addr: config.astro_addr.to_string(),\n                xastro_staking_addr: config.xastro_staking_addr.to_string(),\n                logo_urls_whitelist: config.logo_urls_whitelist,\n            })\n        }\n        QueryMsg::Balance { address } =\u003e to_binary(\u0026get_user_balance(deps, env, address)?),\n        QueryMsg::TokenInfo {} =\u003e to_binary(\u0026query_token_info(deps, env)?),\n        QueryMsg::MarketingInfo {} =\u003e to_binary(\u0026query_marketing_info(deps)?),\n        QueryMsg::DownloadLogo {} =\u003e to_binary(\u0026query_download_logo(deps)?),\n    }\n}\n\n/// Checks if specified addresses are blacklisted.\n///\n/// * **voters** addresses to check if they are blacklisted.\npub fn check_voters_are_blacklisted(\n    deps: Deps,\n    voters: Vec\u003cString\u003e,\n) -\u003e StdResult\u003cBlacklistedVotersResponse\u003e {\n    let black_list = BLACKLIST.load(deps.storage)?;\n\n    for voter in voters {\n        let voter_addr = deps.api.addr_validate(voter.as_str())?;\n        if !black_list.contains(\u0026voter_addr) {\n            return Ok(BlacklistedVotersResponse::VotersNotBlacklisted { voter });\n        }\n    }\n\n    Ok(BlacklistedVotersResponse::VotersBlacklisted {})\n}\n\n/// Returns a list of blacklisted voters.\n///\n/// * **start_after** is an optional field that specifies whether the function should return\n/// a list of voters starting from a specific address onward.\n///\n/// * **limit** max amount of voters addresses to return.\npub fn get_blacklisted_voters(\n    deps: Deps,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cVec\u003cAddr\u003e\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let mut black_list = BLACKLIST.load(deps.storage)?;\n\n    if black_list.is_empty() {\n        return Ok(vec![]);\n    }\n\n    black_list.sort();\n\n    let mut start_index = Default::default();\n    if let Some(start_after) = start_after {\n        let start_addr = deps.api.addr_validate(start_after.as_str())?;\n        start_index = black_list\n            .iter()\n            .position(|addr| *addr == start_addr)\n            .ok_or_else(|| {\n                StdError::generic_err(format!(\n                    \"The {} address is not blacklisted\",\n                    start_addr.as_str()\n                ))\n            })?\n            + 1; // start from the next element of the slice\n    }\n\n    // validate end index of the slice\n    let end_index = (start_index + limit).min(black_list.len());\n\n    Ok(black_list[start_index..end_index].to_vec())\n}\n\n/// Return a user's lock information.\n///\n/// * **user** user for which we return lock information.\nfn get_user_lock_info(deps: Deps, env: Env, user: String) -\u003e StdResult\u003cLockInfoResponse\u003e {\n    let addr = deps.api.addr_validate(\u0026user)?;\n    if let Some(lock) = LOCKED.may_load(deps.storage, addr.clone())? {\n        let cur_period = get_period(env.block.time.seconds())?;\n        let slope = fetch_last_checkpoint(deps.storage, \u0026addr, cur_period)?\n            .map(|(_, point)| point.slope)\n            .unwrap_or_default();\n        let resp = LockInfoResponse {\n            amount: lock.amount,\n            coefficient: calc_coefficient(lock.end - lock.last_extend_lock_period),\n            start: lock.start,\n            end: lock.end,\n            slope,\n        };\n        Ok(resp)\n    } else {\n        Err(StdError::generic_err(\"User is not found\"))\n    }\n}\n\n/// Return a user's staked xASTRO amount at a given block height.\n///\n/// * **user** user for which we return lock information.\n///\n/// * **block_height** block height at which we return the staked xASTRO amount.\nfn get_user_deposit_at_height(deps: Deps, user: String, block_height: u64) -\u003e StdResult\u003cUint128\u003e {\n    let addr = deps.api.addr_validate(\u0026user)?;\n    let locked_opt = LOCKED.may_load_at_height(deps.storage, addr, block_height)?;\n    if let Some(lock) = locked_opt {\n        Ok(lock.amount)\n    } else {\n        Ok(Uint128::zero())\n    }\n}\n\n/// Calculates a user's voting power at a given timestamp.\n/// If time is None, then it calculates the user's voting power at the current block.\n///\n/// * **user** user/staker for which we fetch the current voting power (vxASTRO balance).\n///\n/// * **time** timestamp at which to fetch the user's voting power (vxASTRO balance).\nfn get_user_voting_power(\n    deps: Deps,\n    env: Env,\n    user: String,\n    time: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cVotingPowerResponse\u003e {\n    let period = get_period(time.unwrap_or_else(|| env.block.time.seconds()))?;\n    get_user_voting_power_at_period(deps, user, period)\n}\n\n/// Calculates a user's voting power at a given period number.\n///\n/// * **user** user/staker for which we fetch the current voting power (vxASTRO balance).\n///\n/// * **period** period number at which to fetch the user's voting power (vxASTRO balance).\nfn get_user_voting_power_at_period(\n    deps: Deps,\n    user: String,\n    period: u64,\n) -\u003e StdResult\u003cVotingPowerResponse\u003e {\n    let user = deps.api.addr_validate(\u0026user)?;\n    let last_checkpoint = fetch_last_checkpoint(deps.storage, \u0026user, period)?;\n\n    if let Some(point) = last_checkpoint.map(|(_, point)| point) {\n        // The voting power point at the specified `time` was found\n        let voting_power = if point.start == period {\n            point.power\n        } else {\n            // The point before the intended period was found, thus we can calculate the user's voting power for the period we want\n            calc_voting_power(\u0026point, period)\n        };\n        Ok(VotingPowerResponse { voting_power })\n    } else {\n        // User not found\n        Ok(VotingPowerResponse {\n            voting_power: Uint128::zero(),\n        })\n    }\n}\n\n/// Calculates a user's voting power at the current block.\n///\n/// * **user** user/staker for which we fetch the current voting power (vxASTRO balance).\nfn get_user_balance(deps: Deps, env: Env, user: String) -\u003e StdResult\u003cBalanceResponse\u003e {\n    let vp_response = get_user_voting_power(deps, env, user, None)?;\n    Ok(BalanceResponse {\n        balance: vp_response.voting_power,\n    })\n}\n\n/// Calculates the total voting power (total vxASTRO supply) at the given timestamp.\n/// If `time` is None, then it calculates the total voting power at the current block.\n///\n/// * **time** timestamp at which we fetch the total voting power (vxASTRO supply).\nfn get_total_voting_power(\n    deps: Deps,\n    env: Env,\n    time: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cVotingPowerResponse\u003e {\n    let period = get_period(time.unwrap_or_else(|| env.block.time.seconds()))?;\n    get_total_voting_power_at_period(deps, env, period)\n}\n\n/// Calculates the total voting power (total vxASTRO supply) at the given period number.\n///\n/// * **period** period number at which we fetch the total voting power (vxASTRO supply).\nfn get_total_voting_power_at_period(\n    deps: Deps,\n    env: Env,\n    period: u64,\n) -\u003e StdResult\u003cVotingPowerResponse\u003e {\n    let last_checkpoint = fetch_last_checkpoint(deps.storage, \u0026env.contract.address, period)?;\n\n    let point = last_checkpoint.map_or(\n        Point {\n            power: Uint128::zero(),\n            start: period,\n            end: period,\n            slope: Default::default(),\n        },\n        |(_, point)| point,\n    );\n\n    let voting_power = if point.start == period {\n        point.power\n    } else {\n        let scheduled_slope_changes = fetch_slope_changes(deps.storage, point.start, period)?;\n        let mut init_point = point;\n        for (recalc_period, scheduled_change) in scheduled_slope_changes {\n            init_point = Point {\n                power: calc_voting_power(\u0026init_point, recalc_period),\n                start: recalc_period,\n                slope: init_point.slope - scheduled_change,\n                ..init_point\n            }\n        }\n        calc_voting_power(\u0026init_point, period)\n    };\n\n    Ok(VotingPowerResponse { voting_power })\n}\n\n/// Fetch the vxASTRO token information, such as the token name, symbol, decimals and total supply (total voting power).\nfn query_token_info(deps: Deps, env: Env) -\u003e StdResult\u003cTokenInfoResponse\u003e {\n    let info = TOKEN_INFO.load(deps.storage)?;\n    let total_vp = get_total_voting_power(deps, env, None)?;\n    let res = TokenInfoResponse {\n        name: info.name,\n        symbol: info.symbol,\n        decimals: info.decimals,\n        total_supply: total_vp.voting_power,\n    };\n    Ok(res)\n}\n\n/// Manages contract migration.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    Err(ContractError::MigrationError {})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse cw20_base::ContractError as cw20baseError;\nuse thiserror::Error;\n\n/// This enum describes vxASTRO contract errors\n#[derive(Error, Debug)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"{0}\")]\n    Cw20Base(#[from] cw20baseError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Lock already exists\")]\n    LockAlreadyExists {},\n\n    #[error(\"Lock does not exist\")]\n    LockDoesNotExist {},\n\n    #[error(\"Lock time must be within limits (week \u003c= lock time \u003c 2 years)\")]\n    LockTimeLimitsError {},\n\n    #[error(\"The lock time has not yet expired\")]\n    LockHasNotExpired {},\n\n    #[error(\"The lock expired. Withdraw and create new lock\")]\n    LockExpired {},\n\n    #[error(\"The {0} address is blacklisted\")]\n    AddressBlacklisted(String),\n\n    #[error(\"Marketing info validation error: {0}\")]\n    MarketingInfoValidationError(String),\n\n    #[error(\"Contract can't be migrated!\")]\n    MigrationError {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","src","lib.rs"],"content":"pub mod contract;\npub mod state;\n\n// During development this import could be replaced with another astroport version.\n// However, in production, the astroport version should be the same for all contracts.\npub use astroport_governance::astroport;\n\npub mod error;\nmod marketing_validation;\nmod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","src","marketing_validation.rs"],"content":"use crate::error::ContractError;\nuse crate::error::ContractError::MarketingInfoValidationError;\n\nuse cosmwasm_std::StdError;\nuse cw20::Logo;\n\nconst SAFE_TEXT_CHARS: \u0026str = \"!\u0026?#()*+'-.,/\\\"\";\nconst SAFE_LINK_CHARS: \u0026str = \"-_:/?#@!$\u0026()*+,;=.~[]'%\";\n\nfn validate_text(text: \u0026str, name: \u0026str) -\u003e Result\u003c(), ContractError\u003e {\n    if text.chars().any(|c| {\n        !c.is_ascii_alphanumeric() \u0026\u0026 !c.is_ascii_whitespace() \u0026\u0026 !SAFE_TEXT_CHARS.contains(c)\n    }) {\n        Err(MarketingInfoValidationError(format!(\n            \"{name} contains invalid characters: {text}\"\n        )))\n    } else {\n        Ok(())\n    }\n}\n\npub fn validate_whitelist_links(links: \u0026[String]) -\u003e Result\u003c(), ContractError\u003e {\n    links.iter().try_for_each(|link| {\n        if !link.ends_with('/') {\n            return Err(MarketingInfoValidationError(format!(\n                \"Whitelist link should end with '/': {link}\"\n            )));\n        }\n        validate_link(link)\n    })\n}\n\npub fn validate_link(link: \u0026String) -\u003e Result\u003c(), ContractError\u003e {\n    if link\n        .chars()\n        .any(|c| !c.is_ascii_alphanumeric() \u0026\u0026 !SAFE_LINK_CHARS.contains(c))\n    {\n        Err(StdError::generic_err(format!(\"Link contains invalid characters: {link}\")).into())\n    } else {\n        Ok(())\n    }\n}\n\nfn check_link(link: \u0026String, whitelisted_links: \u0026[String]) -\u003e Result\u003c(), ContractError\u003e {\n    if validate_link(link).is_err() {\n        Err(MarketingInfoValidationError(format!(\n            \"Logo link is invalid: {link}\"\n        )))\n    } else if !whitelisted_links.iter().any(|wl| link.starts_with(wl)) {\n        Err(MarketingInfoValidationError(format!(\n            \"Logo link is not whitelisted: {link}\"\n        )))\n    } else {\n        Ok(())\n    }\n}\n\npub(crate) fn validate_marketing_info(\n    project: Option\u003c\u0026String\u003e,\n    description: Option\u003c\u0026String\u003e,\n    logo: Option\u003c\u0026Logo\u003e,\n    whitelisted_links: \u0026[String],\n) -\u003e Result\u003c(), ContractError\u003e {\n    if let Some(description) = description {\n        validate_text(description, \"description\")?;\n    }\n    if let Some(project) = project {\n        validate_text(project, \"project\")?;\n    }\n    if let Some(Logo::Url(url)) = logo {\n        check_link(url, whitelisted_links)?;\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","src","state.rs"],"content":"use crate::astroport::common::OwnershipProposal;\nuse cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Uint128};\nuse cw_storage_plus::{Item, Map, SnapshotMap, Strategy};\n\n/// This structure stores the main parameters for the voting escrow contract.\n#[cw_serde]\npub struct Config {\n    /// Address that's allowed to change contract parameters\n    pub owner: Addr,\n    /// Address that can only blacklist vxASTRO stakers and remove their governance power\n    pub guardian_addr: Option\u003cAddr\u003e,\n    /// The xASTRO token contract address\n    pub deposit_token_addr: Addr,\n    /// The address of $ASTRO\n    pub astro_addr: Addr,\n    /// The address of $xASTRO staking contract\n    pub xastro_staking_addr: Addr,\n    /// The list of whitelisted logo urls prefixes\n    pub logo_urls_whitelist: Vec\u003cString\u003e,\n}\n\n/// This structure stores points along the checkpoint history for every vxASTRO staker.\n#[cw_serde]\npub struct Point {\n    /// The staker's vxASTRO voting power\n    pub power: Uint128,\n    /// The start period when the staker's voting power start to decrease\n    pub start: u64,\n    /// The period when the lock should expire\n    pub end: u64,\n    /// Weekly voting power decay\n    pub slope: Uint128,\n}\n\n/// This structure stores data about the lockup position for a specific vxASTRO staker.\n#[cw_serde]\npub struct Lock {\n    /// The total amount of xASTRO tokens that were deposited in the vxASTRO position\n    pub amount: Uint128,\n    /// The start period when the lock was created\n    pub start: u64,\n    /// The timestamp when the lock position expires\n    pub end: u64,\n    /// the last period when the lock's time was increased\n    pub last_extend_lock_period: u64,\n}\n\n/// Stores the contract config at the given key\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n\n/// Stores all user lock history\npub const LOCKED: SnapshotMap\u003cAddr, Lock\u003e = SnapshotMap::new(\n    \"locked\",\n    \"locked__checkpoints\",\n    \"locked__changelog\",\n    Strategy::EveryBlock,\n);\n\n/// Stores the checkpoint history for every staker (addr =\u003e period)\n/// Total voting power checkpoints are stored using a (contract_addr =\u003e period) key\npub const HISTORY: Map\u003c(Addr, u64), Point\u003e = Map::new(\"history\");\n\n/// Scheduled slope changes per period (week)\npub const SLOPE_CHANGES: Map\u003cu64, Uint128\u003e = Map::new(\"slope_changes\");\n\n/// Last period when a scheduled slope change was applied\npub const LAST_SLOPE_CHANGE: Item\u003cu64\u003e = Item::new(\"last_slope_change\");\n\n/// Contains a proposal to change contract ownership\npub const OWNERSHIP_PROPOSAL: Item\u003cOwnershipProposal\u003e = Item::new(\"ownership_proposal\");\n\n/// Contains blacklisted staker addresses\npub const BLACKLIST: Item\u003cVec\u003cAddr\u003e\u003e = Item::new(\"blacklist\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","src","utils.rs"],"content":"use crate::error::ContractError;\nuse astroport_governance::utils::{get_periods_count, MAX_LOCK_TIME, WEEK};\n\nuse cosmwasm_std::{Addr, Decimal, Order, StdResult, Storage, Uint128};\nuse cw_storage_plus::Bound;\n\nuse crate::state::{Point, BLACKLIST, CONFIG, HISTORY, LAST_SLOPE_CHANGE, SLOPE_CHANGES};\n\n/// Checks that a timestamp is within limits.\npub(crate) fn time_limits_check(time: u64) -\u003e Result\u003c(), ContractError\u003e {\n    if !(WEEK..=MAX_LOCK_TIME).contains(\u0026time) {\n        Err(ContractError::LockTimeLimitsError {})\n    } else {\n        Ok(())\n    }\n}\n\n/// Checks that the sender is the xASTRO token.\npub(crate) fn xastro_token_check(storage: \u0026dyn Storage, sender: Addr) -\u003e Result\u003c(), ContractError\u003e {\n    let config = CONFIG.load(storage)?;\n    if sender != config.deposit_token_addr {\n        Err(ContractError::Unauthorized {})\n    } else {\n        Ok(())\n    }\n}\n\n/// Checks if the blacklist contains a specific address.\npub(crate) fn blacklist_check(storage: \u0026dyn Storage, addr: \u0026Addr) -\u003e Result\u003c(), ContractError\u003e {\n    let blacklist = BLACKLIST.load(storage)?;\n    if blacklist.contains(addr) {\n        Err(ContractError::AddressBlacklisted(addr.to_string()))\n    } else {\n        Ok(())\n    }\n}\n\n/// Adjusting voting power according to the slope. The maximum loss is 103/104 * 104 which is\n/// 0.000103 vxASTRO.\npub(crate) fn adjust_vp_and_slope(vp: \u0026mut Uint128, dt: u64) -\u003e StdResult\u003cUint128\u003e {\n    let slope = vp.checked_div(Uint128::from(dt))?;\n    *vp = slope * Uint128::from(dt);\n    Ok(slope)\n}\n\n/// Main function used to calculate a user's voting power at a specific period as: previous_power - slope*(x - previous_x).\npub(crate) fn calc_voting_power(point: \u0026Point, period: u64) -\u003e Uint128 {\n    let shift = point\n        .slope\n        .checked_mul(Uint128::from(period - point.start))\n        .unwrap_or_else(|_| Uint128::zero());\n    point\n        .power\n        .checked_sub(shift)\n        .unwrap_or_else(|_| Uint128::zero())\n}\n\n/// Coefficient calculation where 0 [`WEEK`] is equal to 1 and [`MAX_LOCK_TIME`] is 2.5.\npub(crate) fn calc_coefficient(interval: u64) -\u003e Decimal {\n    // coefficient = 1 + 1.5 * (end - start) / MAX_LOCK_TIME\n    Decimal::one() + Decimal::from_ratio(15_u64 * interval, get_periods_count(MAX_LOCK_TIME) * 10)\n}\n\n/// Fetches the last checkpoint in [`HISTORY`] for the given address.\npub(crate) fn fetch_last_checkpoint(\n    storage: \u0026dyn Storage,\n    addr: \u0026Addr,\n    period_key: u64,\n) -\u003e StdResult\u003cOption\u003c(u64, Point)\u003e\u003e {\n    HISTORY\n        .prefix(addr.clone())\n        .range(\n            storage,\n            None,\n            Some(Bound::inclusive(period_key)),\n            Order::Descending,\n        )\n        .next()\n        .transpose()\n}\n\n/// Cancels scheduled slope change of total voting power only if the given period is in future.\n/// Removes scheduled slope change if it became zero.\npub(crate) fn cancel_scheduled_slope(\n    storage: \u0026mut dyn Storage,\n    slope: Uint128,\n    period: u64,\n) -\u003e StdResult\u003c()\u003e {\n    let end_period_key = period;\n    let last_slope_change = LAST_SLOPE_CHANGE.may_load(storage)?.unwrap_or(0);\n    match SLOPE_CHANGES.may_load(storage, end_period_key)? {\n        // We do not need to schedule a slope change in the past\n        Some(old_scheduled_change) if period \u003e last_slope_change =\u003e {\n            let new_slope = old_scheduled_change - slope;\n            if !new_slope.is_zero() {\n                SLOPE_CHANGES.save(storage, end_period_key, \u0026(old_scheduled_change - slope))\n            } else {\n                SLOPE_CHANGES.remove(storage, end_period_key);\n                Ok(())\n            }\n        }\n        _ =\u003e Ok(()),\n    }\n}\n\n/// Schedules slope change of total voting power in the given period.\npub(crate) fn schedule_slope_change(\n    storage: \u0026mut dyn Storage,\n    slope: Uint128,\n    period: u64,\n) -\u003e StdResult\u003c()\u003e {\n    if !slope.is_zero() {\n        SLOPE_CHANGES\n            .update(storage, period, |slope_opt| -\u003e StdResult\u003cUint128\u003e {\n                if let Some(pslope) = slope_opt {\n                    Ok(pslope + slope)\n                } else {\n                    Ok(slope)\n                }\n            })\n            .map(|_| ())\n    } else {\n        Ok(())\n    }\n}\n\n/// Fetches all slope changes between `last_slope_change` and `period`.\npub(crate) fn fetch_slope_changes(\n    storage: \u0026dyn Storage,\n    last_slope_change: u64,\n    period: u64,\n) -\u003e StdResult\u003cVec\u003c(u64, Uint128)\u003e\u003e {\n    SLOPE_CHANGES\n        .range(\n            storage,\n            Some(Bound::exclusive(last_slope_change)),\n            Some(Bound::inclusive(period)),\n            Order::Ascending,\n        )\n        .collect()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","tests","integration.rs"],"content":"use astroport::token as astro;\nuse cosmwasm_std::{attr, to_binary, Addr, Fraction, StdError, Uint128};\nuse cw20::{Cw20ExecuteMsg, Logo, LogoInfo, MarketingInfoResponse, MinterResponse};\nuse cw_multi_test::{next_block, ContractWrapper, Executor};\nuse voting_escrow::astroport;\n\nuse astroport_governance::utils::{get_period, MAX_LOCK_TIME, WEEK};\nuse astroport_governance::voting_escrow::{\n    ConfigResponse, Cw20HookMsg, ExecuteMsg, LockInfoResponse, QueryMsg,\n};\n\nuse crate::test_utils::{mock_app, Helper, MULTIPLIER};\n\nmod test_utils;\n\n#[test]\nfn lock_unlock_logic() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    helper.mint_xastro(router_ref, \"owner\", 100);\n\n    // Mint ASTRO, stake it and mint xASTRO\n    helper.mint_xastro(router_ref, \"user\", 100);\n    helper.check_xastro_balance(router_ref, \"user\", 100);\n\n    // Create invalid vx position\n    let err = helper\n        .create_lock(router_ref, \"user\", WEEK - 1, 1f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Lock time must be within limits (week \u003c= lock time \u003c 2 years)\"\n    );\n    let err = helper\n        .create_lock(router_ref, \"user\", MAX_LOCK_TIME + 1, 1f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Lock time must be within limits (week \u003c= lock time \u003c 2 years)\"\n    );\n    let err = helper\n        .create_lock(router_ref, \"user\", WEEK, 101f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        format!(\n            \"Cannot Sub with {} and {}\",\n            100 * MULTIPLIER,\n            101 * MULTIPLIER\n        )\n    );\n\n    // Try to increase the lock time for a position that doesn't exist\n    let err = helper\n        .extend_lock_time(router_ref, \"user\", MAX_LOCK_TIME)\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Lock does not exist\");\n\n    // Try to withdraw from a non-existent lock\n    let err = helper.withdraw(router_ref, \"user\").unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Lock does not exist\");\n\n    // Try to deposit more xASTRO in a position that does not already exist\n    let err = helper\n        .extend_lock_amount(router_ref, \"user\", 1f32)\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Lock does not exist\");\n\n    // Current total voting power is 0\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 0.0);\n\n    // Create valid voting escrow lock\n    helper\n        .create_lock(router_ref, \"user\", WEEK * 2, 90f32)\n        .unwrap();\n    // Check that 90 xASTRO were actually debited\n    helper.check_xastro_balance(router_ref, \"user\", 10);\n    helper.check_xastro_balance(router_ref, helper.voting_instance.as_str(), 90);\n\n    // A user can have a single vxASTRO position\n    let err = helper\n        .create_lock(router_ref, \"user\", MAX_LOCK_TIME, 1f32)\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Lock already exists\");\n\n    // Try to increase the lock time by less than a week\n    let err = helper\n        .extend_lock_time(router_ref, \"user\", 86400)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Lock time must be within limits (week \u003c= lock time \u003c 2 years)\"\n    );\n\n    // Try to exceed MAX_LOCK_TIME\n    // We locked for 2 weeks so increasing by MAX_LOCK_TIME - week is impossible\n    let err = helper\n        .extend_lock_time(router_ref, \"user\", MAX_LOCK_TIME - WEEK)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Lock time must be within limits (week \u003c= lock time \u003c 2 years)\"\n    );\n\n    // Add more xASTRO to the existing position\n    helper.extend_lock_amount(router_ref, \"user\", 9f32).unwrap();\n    helper.check_xastro_balance(router_ref, \"user\", 1);\n    helper.check_xastro_balance(router_ref, helper.voting_instance.as_str(), 99);\n\n    // Try to withdraw from a non-expired lock\n    let err = helper.withdraw(router_ref, \"user\").unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The lock time has not yet expired\"\n    );\n\n    // Go in the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK));\n\n    // The lock has not yet expired since we locked for 2 weeks\n    let err = helper.withdraw(router_ref, \"user\").unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The lock time has not yet expired\"\n    );\n\n    // Go to the future again\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK));\n\n    // Try to add more xASTRO to an expired position\n    let err = helper\n        .extend_lock_amount(router_ref, \"user\", 1f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The lock expired. Withdraw and create new lock\"\n    );\n    // Try to increase the lock time for an expired position\n    let err = helper\n        .extend_lock_time(router_ref, \"user\", WEEK)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The lock expired. Withdraw and create new lock\"\n    );\n\n    // Imagine the user will withdraw their expired lock in 5 weeks\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(5 * WEEK));\n\n    // Time has passed so we can withdraw\n    helper.withdraw(router_ref, \"user\").unwrap();\n    helper.check_xastro_balance(router_ref, \"user\", 100);\n    helper.check_xastro_balance(router_ref, helper.voting_instance.as_str(), 0);\n\n    // Check that the lock has disappeared\n    let err = helper\n        .extend_lock_amount(router_ref, \"user\", 1f32)\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Lock does not exist\");\n}\n\n#[test]\nfn random_token_lock() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    let random_token_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_token::contract::execute,\n        astroport_token::contract::instantiate,\n        astroport_token::contract::query,\n    ));\n    let random_token_code_id = router.store_code(random_token_contract);\n\n    let msg = astro::InstantiateMsg {\n        name: String::from(\"Random token\"),\n        symbol: String::from(\"FOO\"),\n        decimals: 6,\n        initial_balances: vec![],\n        mint: Some(MinterResponse {\n            minter: helper.owner.to_string(),\n            cap: None,\n        }),\n        marketing: None,\n    };\n\n    let random_token = router\n        .instantiate_contract(\n            random_token_code_id,\n            helper.owner.clone(),\n            \u0026msg,\n            \u0026[],\n            String::from(\"FOO\"),\n            None,\n        )\n        .unwrap();\n\n    let msg = cw20::Cw20ExecuteMsg::Mint {\n        recipient: String::from(\"user\"),\n        amount: Uint128::from(100_u128),\n    };\n\n    router\n        .execute_contract(helper.owner.clone(), random_token.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    let cw20msg = Cw20ExecuteMsg::Send {\n        contract: helper.voting_instance.to_string(),\n        amount: Uint128::from(10_u128),\n        msg: to_binary(\u0026Cw20HookMsg::CreateLock { time: WEEK }).unwrap(),\n    };\n    let err = router\n        .execute_contract(Addr::unchecked(\"user\"), random_token, \u0026cw20msg, \u0026[])\n        .unwrap_err();\n\n    assert_eq!(err.root_cause().to_string(), \"Unauthorized\");\n}\n\n#[test]\nfn new_lock_after_lock_expired() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let helper = Helper::init(router_ref, Addr::unchecked(\"owner\"));\n\n    helper.mint_xastro(router_ref, \"owner\", 100);\n\n    // Mint ASTRO, stake it and mint xASTRO\n    helper.mint_xastro(router_ref, \"user\", 100);\n\n    helper\n        .create_lock(router_ref, \"user\", WEEK * 5, 50f32)\n        .unwrap();\n\n    let vp = helper.query_user_vp(router_ref, \"user\").unwrap();\n    assert_eq!(vp, 53.605762);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 53.605762);\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK * 5));\n\n    helper.withdraw(router_ref, \"user\").unwrap();\n    helper.check_xastro_balance(router_ref, \"user\", 100);\n\n    let vp = helper.query_user_vp(router_ref, \"user\").unwrap();\n    assert_eq!(vp, 0.0);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 0.0);\n\n    // Create a new lock in 3 weeks from now\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK * 3));\n\n    helper\n        .create_lock(router_ref, \"user\", WEEK * 5, 100f32)\n        .unwrap();\n\n    let vp = helper.query_user_vp(router_ref, \"user\").unwrap();\n    assert_eq!(vp, 107.21153);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 107.21153);\n}\n\n/// Plot for this test case generated at tests/plots/constant_decay.png\n#[test]\nfn voting_constant_decay() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let helper = Helper::init(router_ref, Addr::unchecked(\"owner\"));\n\n    // Mint ASTRO, stake it and mint xASTRO\n    helper.mint_xastro(router_ref, \"user\", 100);\n    helper.mint_xastro(router_ref, \"user2\", 50);\n\n    helper\n        .create_lock(router_ref, \"user\", WEEK * 10, 30f32)\n        .unwrap();\n\n    let vp = helper.query_user_vp(router_ref, \"user\").unwrap();\n    assert_eq!(vp, 34.32692);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 34.32692);\n\n    // Since user2 did not lock their xASTRO, the contract does not have any information\n    let vp = helper.query_user_vp(router_ref, \"user2\").unwrap();\n    assert_eq!(vp, 0.0);\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK * 5));\n\n    // We can check voting power in the past\n    let res = helper\n        .query_user_vp_at(\n            router_ref,\n            \"user\",\n            router_ref.block_info().time.seconds() - WEEK,\n        )\n        .unwrap();\n    assert_eq!(res, 20.596151);\n    let res = helper\n        .query_user_vp_at(\n            router_ref,\n            \"user\",\n            router_ref.block_info().time.seconds() - 3 * WEEK,\n        )\n        .unwrap();\n    assert_eq!(res, 27.461536);\n    let res = helper\n        .query_total_vp_at(\n            router_ref,\n            router_ref.block_info().time.seconds() - 5 * WEEK,\n        )\n        .unwrap();\n    assert_eq!(res, 34.32692);\n\n    // And we can even check voting power in the future\n    let res = helper\n        .query_user_vp_at(\n            router_ref,\n            \"user\",\n            router_ref.block_info().time.seconds() + WEEK,\n        )\n        .unwrap();\n    assert_eq!(res, 13.730768);\n    let res = helper\n        .query_user_vp_at(\n            router_ref,\n            \"user\",\n            router_ref.block_info().time.seconds() + 5 * WEEK,\n        )\n        .unwrap();\n    assert_eq!(res, 0.0);\n\n    // Create lock for user2\n    helper\n        .create_lock(router_ref, \"user2\", WEEK * 6, 50f32)\n        .unwrap();\n\n    let vp = helper.query_user_vp(router_ref, \"user\").unwrap();\n    assert_eq!(vp, 17.16346);\n    let vp = helper.query_user_vp(router_ref, \"user2\").unwrap();\n    assert_eq!(vp, 54.32692);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 71.49039);\n    let res = helper\n        .query_total_vp_at(\n            router_ref,\n            router_ref.block_info().time.seconds() + 4 * WEEK,\n        )\n        .unwrap();\n    assert_eq!(res, 21.541666);\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK * 5));\n    let vp = helper.query_user_vp(router_ref, \"user\").unwrap();\n    assert_eq!(vp, 0.0);\n    let vp = helper.query_user_vp(router_ref, \"user2\").unwrap();\n    assert_eq!(vp, 9.054487);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 9.054487);\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK));\n    let vp = helper.query_user_vp(router_ref, \"user2\").unwrap();\n    assert_eq!(vp, 0.0);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 0.0);\n}\n\n/// Plot for this test case is generated at tests/plots/variable_decay.png\n#[test]\nfn voting_variable_decay() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let helper = Helper::init(router_ref, Addr::unchecked(\"owner\"));\n\n    // Mint ASTRO, stake it and mint xASTRO\n    helper.mint_xastro(router_ref, \"owner\", 100);\n    helper.mint_xastro(router_ref, \"user\", 100);\n    helper.mint_xastro(router_ref, \"user2\", 100);\n\n    helper\n        .create_lock(router_ref, \"user\", WEEK * 10, 30f32)\n        .unwrap();\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK * 5));\n\n    // Create lock for user2\n    helper\n        .create_lock(router_ref, \"user2\", WEEK * 6, 50f32)\n        .unwrap();\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 71.49039);\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK * 4));\n\n    helper\n        .extend_lock_amount(router_ref, \"user\", 70f32)\n        .unwrap();\n    helper\n        .extend_lock_time(router_ref, \"user2\", WEEK * 8)\n        .unwrap();\n    let vp = helper.query_user_vp(router_ref, \"user\").unwrap();\n    assert_eq!(vp, 74.44231);\n    let vp = helper.query_user_vp(router_ref, \"user2\").unwrap();\n    assert_eq!(vp, 57.21153);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 131.65384);\n\n    let res = helper\n        .query_user_vp_at(\n            router_ref,\n            \"user2\",\n            router_ref.block_info().time.seconds() + 4 * WEEK,\n        )\n        .unwrap();\n    assert_eq!(res, 34.32692);\n    let res = helper\n        .query_total_vp_at(router_ref, router_ref.block_info().time.seconds() + WEEK)\n        .unwrap();\n    assert_eq!(res, 51.490376);\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK));\n    let vp = helper.query_user_vp(router_ref, \"user\").unwrap();\n    assert_eq!(vp, 0.0);\n    let vp = helper.query_user_vp(router_ref, \"user2\").unwrap();\n    assert_eq!(vp, 51.490376);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 51.490376);\n}\n\n#[test]\nfn check_queries() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    helper.mint_xastro(router_ref, \"owner\", 100);\n\n    // Mint ASTRO, stake it and mint xASTRO\n    helper.mint_xastro(router_ref, \"user\", 100);\n    helper.check_xastro_balance(router_ref, \"user\", 100);\n\n    // Create valid voting escrow lock\n    helper\n        .create_lock(router_ref, \"user\", WEEK * 2, 90f32)\n        .unwrap();\n    // Check that 90 xASTRO were actually debited\n    helper.check_xastro_balance(router_ref, \"user\", 10);\n    helper.check_xastro_balance(router_ref, helper.voting_instance.as_str(), 90);\n\n    // Validate user's lock\n    let cur_period = get_period(router_ref.block_info().time.seconds()).unwrap();\n    let user_lock: LockInfoResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\n            helper.voting_instance.clone(),\n            \u0026QueryMsg::LockInfo {\n                user: \"user\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(user_lock.amount.u128(), 90_u128 * MULTIPLIER as u128);\n    assert_eq!(user_lock.start, cur_period);\n    assert_eq!(user_lock.end, cur_period + 2);\n    let coeff = user_lock.coefficient.numerator().u128() as f32\n        / user_lock.coefficient.denominator().u128() as f32;\n    if (coeff - 1.02884f32).abs() \u003e 1e-5 {\n        assert_eq!(coeff, 1.02884f32)\n    }\n\n    let total_vp_at_period = helper\n        .query_total_vp_at_period(router_ref, cur_period)\n        .unwrap();\n    let total_vp_at_ts = helper\n        .query_total_vp_at(router_ref, router_ref.block_info().time.seconds())\n        .unwrap();\n    assert_eq!(total_vp_at_period, total_vp_at_ts);\n\n    let user_vp_at_period = helper\n        .query_user_vp_at_period(router_ref, \"user\", cur_period)\n        .unwrap();\n    let user_vp = helper\n        .query_user_vp_at(router_ref, \"user\", router_ref.block_info().time.seconds())\n        .unwrap();\n    assert_eq!(user_vp_at_period, user_vp);\n\n    // Check users' locked xASTRO balance history\n    helper.mint_xastro(router_ref, \"user\", 90);\n    // SnapshotMap checkpoints the data at the next block\n    let start_height = router_ref.block_info().height + 1;\n    let balance = helper\n        .query_locked_balance_at(router_ref, \"user\", start_height)\n        .unwrap();\n    assert_eq!(balance, 90f32);\n    // Make the lockup to live longer\n    helper\n        .extend_lock_time(router_ref, \"user\", WEEK * 100)\n        .unwrap();\n\n    router_ref.update_block(next_block);\n    helper\n        .extend_lock_amount(router_ref, \"user\", 100f32)\n        .unwrap();\n    let balance = helper\n        .query_locked_balance_at(router_ref, \"user\", start_height)\n        .unwrap();\n    assert_eq!(balance, 90f32);\n\n    router_ref.update_block(|bi| bi.height += 100000);\n    let balance = helper\n        .query_locked_balance_at(router_ref, \"user\", start_height)\n        .unwrap();\n    assert_eq!(balance, 90f32);\n    let balance = helper\n        .query_locked_balance_at(router_ref, \"user\", start_height + 2)\n        .unwrap();\n    assert_eq!(balance, 190f32);\n    // The user still has 190 xASTRO locked\n    let balance = helper\n        .query_locked_balance_at(router_ref, \"user\", router_ref.block_info().height)\n        .unwrap();\n    assert_eq!(balance, 190f32);\n\n    router_ref.update_block(|bi| {\n        bi.height += 1;\n        bi.time = bi.time.plus_seconds(WEEK * 102);\n    });\n    helper.withdraw(router_ref, \"user\").unwrap();\n    // Now the users' balance is zero\n    let cur_height = router_ref.block_info().height + 1;\n    let balance = helper\n        .query_locked_balance_at(router_ref, \"user\", cur_height)\n        .unwrap();\n    // But one block before it had 190 xASTRO locked\n    assert_eq!(balance, 0f32);\n    let balance = helper\n        .query_locked_balance_at(router_ref, \"user\", cur_height - 1)\n        .unwrap();\n    assert_eq!(balance, 190f32);\n\n    // add users to the blacklist\n    helper\n        .update_blacklist(\n            router_ref,\n            Some(vec![\n                \"voter1\".to_string(),\n                \"voter2\".to_string(),\n                \"voter3\".to_string(),\n                \"voter4\".to_string(),\n                \"voter5\".to_string(),\n                \"voter6\".to_string(),\n                \"voter7\".to_string(),\n                \"voter8\".to_string(),\n            ]),\n            None,\n        )\n        .unwrap();\n\n    // query all blacklisted voters\n    let blacklisted_voters = helper\n        .query_blacklisted_voters(router_ref, None, None)\n        .unwrap();\n    assert_eq!(\n        blacklisted_voters,\n        vec![\n            Addr::unchecked(\"voter1\"),\n            Addr::unchecked(\"voter2\"),\n            Addr::unchecked(\"voter3\"),\n            Addr::unchecked(\"voter4\"),\n            Addr::unchecked(\"voter5\"),\n            Addr::unchecked(\"voter6\"),\n            Addr::unchecked(\"voter7\"),\n            Addr::unchecked(\"voter8\"),\n        ]\n    );\n\n    // query not blacklisted voter\n    let err = helper\n        .query_blacklisted_voters(router_ref, Some(\"voter9\".to_string()), Some(10u32))\n        .unwrap_err();\n    assert_eq!(\n        StdError::generic_err(\n            \"Querier contract error: Generic error: The voter9 address is not blacklisted\"\n        ),\n        err\n    );\n\n    // query voters by specified parameters\n    let blacklisted_voters = helper\n        .query_blacklisted_voters(router_ref, Some(\"voter2\".to_string()), Some(2u32))\n        .unwrap();\n    assert_eq!(\n        blacklisted_voters,\n        vec![Addr::unchecked(\"voter3\"), Addr::unchecked(\"voter4\")]\n    );\n\n    // add users to the blacklist\n    helper\n        .update_blacklist(\n            router_ref,\n            Some(vec![\"voter0\".to_string(), \"voter33\".to_string()]),\n            None,\n        )\n        .unwrap();\n\n    // query voters by specified parameters\n    let blacklisted_voters = helper\n        .query_blacklisted_voters(router_ref, Some(\"voter2\".to_string()), Some(2u32))\n        .unwrap();\n    assert_eq!(\n        blacklisted_voters,\n        vec![Addr::unchecked(\"voter3\"), Addr::unchecked(\"voter33\")]\n    );\n\n    let blacklisted_voters = helper\n        .query_blacklisted_voters(router_ref, Some(\"voter4\".to_string()), Some(10u32))\n        .unwrap();\n    assert_eq!(\n        blacklisted_voters,\n        vec![\n            Addr::unchecked(\"voter5\"),\n            Addr::unchecked(\"voter6\"),\n            Addr::unchecked(\"voter7\"),\n            Addr::unchecked(\"voter8\"),\n        ]\n    );\n\n    let empty_blacklist: Vec\u003cAddr\u003e = vec![];\n    let blacklisted_voters = helper\n        .query_blacklisted_voters(router_ref, Some(\"voter8\".to_string()), Some(10u32))\n        .unwrap();\n    assert_eq!(blacklisted_voters, empty_blacklist);\n\n    // check if voters are blacklisted\n    let res = helper\n        .check_voters_are_blacklisted(router_ref, vec![\"voter1\".to_string(), \"voter9\".to_string()])\n        .unwrap();\n    assert_eq!(\"Voter is not blacklisted: voter9\", res.to_string());\n\n    let res = helper\n        .check_voters_are_blacklisted(router_ref, vec![\"voter1\".to_string(), \"voter8\".to_string()])\n        .unwrap();\n    assert_eq!(\"Voters are blacklisted!\", res.to_string());\n}\n\n#[test]\nfn check_deposit_for() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    helper.mint_xastro(router_ref, \"owner\", 100);\n\n    // Mint ASTRO, stake it and mint xASTRO\n    helper.mint_xastro(router_ref, \"user1\", 100);\n    helper.check_xastro_balance(router_ref, \"user1\", 100);\n    helper.mint_xastro(router_ref, \"user2\", 100);\n    helper.check_xastro_balance(router_ref, \"user2\", 100);\n\n    // 104 weeks ~ 2 years\n    helper\n        .create_lock(router_ref, \"user1\", 104 * WEEK, 50f32)\n        .unwrap();\n    let vp = helper.query_user_vp(router_ref, \"user1\").unwrap();\n    assert_eq!(124.99999, vp);\n    helper\n        .deposit_for(router_ref, \"user2\", \"user1\", 50f32)\n        .unwrap();\n    let vp = helper.query_user_vp(router_ref, \"user1\").unwrap();\n    assert_eq!(249.99998, vp);\n    helper.check_xastro_balance(router_ref, \"user1\", 50);\n    helper.check_xastro_balance(router_ref, \"user2\", 50);\n}\n\n#[test]\nfn check_update_owner() {\n    let mut app = mock_app();\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(\u0026mut app, owner);\n\n    let new_owner = String::from(\"new_owner\");\n\n    // New owner\n    let msg = ExecuteMsg::ProposeNewOwner {\n        new_owner: new_owner.clone(),\n        expires_in: 100, // seconds\n    };\n\n    // Unauthed check\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"not_owner\"),\n            helper.voting_instance.clone(),\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Generic error: Unauthorized\");\n\n    // Claim before proposal\n    let err = app\n        .execute_contract(\n            Addr::unchecked(new_owner.clone()),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::ClaimOwnership {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Ownership proposal not found\"\n    );\n\n    // Propose new owner\n    app.execute_contract(\n        Addr::unchecked(\"owner\"),\n        helper.voting_instance.clone(),\n        \u0026msg,\n        \u0026[],\n    )\n    .unwrap();\n\n    // Claim from invalid addr\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"invalid_addr\"),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::ClaimOwnership {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Generic error: Unauthorized\");\n\n    // Claim ownership\n    app.execute_contract(\n        Addr::unchecked(new_owner.clone()),\n        helper.voting_instance.clone(),\n        \u0026ExecuteMsg::ClaimOwnership {},\n        \u0026[],\n    )\n    .unwrap();\n\n    // Let's query the contract state\n    let msg = QueryMsg::Config {};\n    let res: ConfigResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026helper.voting_instance, \u0026msg)\n        .unwrap();\n\n    assert_eq!(res.owner, new_owner)\n}\n\n#[test]\nfn check_blacklist() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    // Mint ASTRO, stake it and mint xASTRO\n    helper.mint_xastro(router_ref, \"user1\", 100);\n    helper.mint_xastro(router_ref, \"user2\", 100);\n    helper.mint_xastro(router_ref, \"user3\", 100);\n\n    // Try to execute with empty arrays\n    let err = helper.update_blacklist(router_ref, None, None).unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Append and remove arrays are empty\"\n    );\n\n    // Blacklisting user2\n    let res = helper\n        .update_blacklist(router_ref, Some(vec![\"user2\".to_string()]), None)\n        .unwrap();\n    assert_eq!(\n        res.events[1].attributes[1],\n        attr(\"action\", \"update_blacklist\")\n    );\n    assert_eq!(\n        res.events[1].attributes[2],\n        attr(\"added_addresses\", \"user2\")\n    );\n\n    helper\n        .create_lock(router_ref, \"user1\", WEEK * 10, 50f32)\n        .unwrap();\n    // Try to create lock from a blacklisted address\n    let err = helper\n        .create_lock(router_ref, \"user2\", WEEK * 10, 100f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The user2 address is blacklisted\"\n    );\n    let err = helper\n        .deposit_for(router_ref, \"user2\", \"user3\", 50f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The user2 address is blacklisted\"\n    );\n\n    // Since user2 is blacklisted, their xASTRO balance was left unchanged\n    helper.check_xastro_balance(router_ref, \"user2\", 100);\n    // And they did not create a lock, thus we have no information to query\n    let vp = helper.query_user_vp(router_ref, \"user2\").unwrap();\n    assert_eq!(vp, 0.0);\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(2 * WEEK));\n\n    // user2 is still blacklisted\n    let err = helper\n        .create_lock(router_ref, \"user2\", WEEK * 10, 100f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The user2 address is blacklisted\"\n    );\n\n    // Blacklisting user1 using the guardian\n    let msg = ExecuteMsg::UpdateBlacklist {\n        append_addrs: Some(vec![\"user1\".to_string()]),\n        remove_addrs: None,\n    };\n    let res = router_ref\n        .execute_contract(\n            Addr::unchecked(\"guardian\"),\n            helper.voting_instance.clone(),\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n    assert_eq!(\n        res.events[1].attributes[1],\n        attr(\"action\", \"update_blacklist\")\n    );\n    assert_eq!(\n        res.events[1].attributes[2],\n        attr(\"added_addresses\", \"user1\")\n    );\n\n    // user1 is now blacklisted\n    let err = helper\n        .extend_lock_time(router_ref, \"user1\", WEEK * 10)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The user1 address is blacklisted\"\n    );\n    let err = helper\n        .extend_lock_amount(router_ref, \"user1\", 10f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The user1 address is blacklisted\"\n    );\n    let err = helper\n        .deposit_for(router_ref, \"user2\", \"user1\", 50f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The user2 address is blacklisted\"\n    );\n    let err = helper\n        .deposit_for(router_ref, \"user3\", \"user1\", 50f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The user1 address is blacklisted\"\n    );\n    // user1 doesn't have voting power now\n    let vp = helper.query_user_vp(router_ref, \"user1\").unwrap();\n    assert_eq!(vp, 0.0);\n    // But they have voting power in the past\n    let vp = helper\n        .query_user_vp_at(\n            router_ref,\n            \"user1\",\n            router_ref.block_info().time.seconds() - WEEK,\n        )\n        .unwrap();\n    assert_eq!(vp, 51.490376);\n    // Total voting power should be zero as well since there was only one vxASTRO position created by user1\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 0.0);\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(20 * WEEK));\n\n    // The only option available for a blacklisted user is to withdraw their funds if their lock expired\n    helper.withdraw(router_ref, \"user1\").unwrap();\n\n    // Remove user1 from the blacklist\n    let res = helper\n        .update_blacklist(router_ref, None, Some(vec![\"user1\".to_string()]))\n        .unwrap();\n    assert_eq!(\n        res.events[1].attributes[1],\n        attr(\"action\", \"update_blacklist\")\n    );\n    assert_eq!(\n        res.events[1].attributes[2],\n        attr(\"removed_addresses\", \"user1\")\n    );\n\n    // Now user1 can create a new lock\n    helper\n        .create_lock(router_ref, \"user1\", WEEK, 10f32)\n        .unwrap();\n}\n\n#[test]\nfn check_residual() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n    let lock_duration = 104;\n    let users_num = 1000;\n    let lock_amount = 100_000_000;\n\n    helper.mint_xastro(router_ref, \"owner\", 100);\n\n    for i in 1..(users_num / 2) {\n        let user = \u0026format!(\"user{}\", i);\n        helper.mint_xastro(router_ref, user, 100);\n        helper\n            .create_lock_u128(router_ref, user, WEEK * lock_duration, lock_amount)\n            .unwrap();\n    }\n\n    let mut sum = 0;\n    for i in 1..=users_num {\n        let user = \u0026format!(\"user{}\", i);\n        sum += helper.query_exact_user_vp(router_ref, user).unwrap();\n    }\n\n    assert_eq!(sum, helper.query_exact_total_vp(router_ref).unwrap());\n\n    router_ref.update_block(|bi| {\n        bi.height += 1;\n        bi.time = bi.time.plus_seconds(WEEK);\n    });\n\n    for i in (users_num / 2)..users_num {\n        let user = \u0026format!(\"user{}\", i);\n        helper.mint_xastro(router_ref, user, 1000000);\n        helper\n            .create_lock_u128(router_ref, user, WEEK * lock_duration, lock_amount)\n            .unwrap();\n    }\n\n    for _ in 1..104 {\n        sum = 0;\n        for i in 1..=users_num {\n            let user = \u0026format!(\"user{}\", i);\n            sum += helper.query_exact_user_vp(router_ref, user).unwrap();\n        }\n\n        let ve_vp = helper.query_exact_total_vp(router_ref).unwrap();\n        let diff = (sum as f64 - ve_vp as f64).abs();\n        assert_eq!(diff, 0.0, \"diff: {}, sum: {}, ve_vp: {}\", diff, sum, ve_vp);\n\n        router_ref.update_block(|bi| {\n            bi.height += 1;\n            bi.time = bi.time.plus_seconds(WEEK);\n        });\n    }\n}\n\n#[test]\nfn total_vp_multiple_slope_subtraction() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    helper.mint_xastro(router_ref, \"user1\", 1000);\n    helper\n        .create_lock(router_ref, \"user1\", 2 * WEEK, 100f32)\n        .unwrap();\n    let total = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(total, 102.88461);\n\n    router_ref.update_block(|bi| bi.time = bi.time.plus_seconds(2 * WEEK));\n    // Slope changes have been applied\n    let total = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(total, 0.0);\n\n    // Try to manipulate over expired lock 2 weeks later\n    router_ref.update_block(|bi| bi.time = bi.time.plus_seconds(2 * WEEK));\n    let err = helper\n        .extend_lock_amount(router_ref, \"user1\", 100f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The lock expired. Withdraw and create new lock\"\n    );\n    let err = helper\n        .create_lock(router_ref, \"user1\", 2 * WEEK, 100f32)\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Lock already exists\");\n    let err = helper\n        .extend_lock_time(router_ref, \"user1\", 2 * WEEK)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The lock expired. Withdraw and create new lock\"\n    );\n    let total = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(total, 0f32);\n}\n\n#[test]\nfn marketing_info() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    let err = router_ref\n        .execute_contract(\n            helper.owner.clone(),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::SetLogoUrlsWhitelist {\n                whitelist: vec![\n                    \"@hello-test-url .com/\".to_string(),\n                    \"example.com/\".to_string(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"Generic error: Link contains invalid characters: @hello-test-url .com/\"\n    );\n\n    let err = router_ref\n        .execute_contract(\n            helper.owner.clone(),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::SetLogoUrlsWhitelist {\n                whitelist: vec![\"example.com\".to_string()],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"Marketing info validation error: Whitelist link should end with '/': example.com\"\n    );\n\n    router_ref\n        .execute_contract(\n            helper.owner.clone(),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::SetLogoUrlsWhitelist {\n                whitelist: vec![\"example.com/\".to_string()],\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    let err = router_ref\n        .execute_contract(\n            helper.owner.clone(),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::UpdateMarketing {\n                project: Some(\"\u003cscript\u003ealert('test')\u003c/script\u003e\".to_string()),\n                description: None,\n                marketing: None,\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"Marketing info validation error: project contains invalid characters: \u003cscript\u003ealert('test')\u003c/script\u003e\"\n    );\n\n    let err = router_ref\n        .execute_contract(\n            helper.owner.clone(),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::UpdateMarketing {\n                project: None,\n                description: Some(\"\u003cscript\u003ealert('test')\u003c/script\u003e\".to_string()),\n                marketing: None,\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"Marketing info validation error: description contains invalid characters: \u003cscript\u003ealert('test')\u003c/script\u003e\"\n    );\n\n    router_ref\n        .execute_contract(\n            helper.owner.clone(),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::UpdateMarketing {\n                project: Some(\"Some project\".to_string()),\n                description: Some(\"Some description\".to_string()),\n                marketing: None,\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    let config: ConfigResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\u0026helper.voting_instance, \u0026QueryMsg::Config {})\n        .unwrap();\n    assert_eq!(config.logo_urls_whitelist, vec![\"example.com/\".to_string()]);\n    let marketing_info: MarketingInfoResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\u0026helper.voting_instance, \u0026QueryMsg::MarketingInfo {})\n        .unwrap();\n    assert_eq!(marketing_info.project, Some(\"Some project\".to_string()));\n    assert_eq!(\n        marketing_info.description,\n        Some(\"Some description\".to_string())\n    );\n\n    let err = router_ref\n        .execute_contract(\n            helper.owner.clone(),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::UploadLogo(Logo::Url(\"https://some-website.com/logo.svg\".to_string())),\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"Marketing info validation error: Logo link is not whitelisted: https://some-website.com/logo.svg\",\n    );\n\n    router_ref\n        .execute_contract(\n            helper.owner.clone(),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::UploadLogo(Logo::Url(\"example.com/logo.svg\".to_string())),\n            \u0026[],\n        )\n        .unwrap();\n\n    let marketing_info: MarketingInfoResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\u0026helper.voting_instance, \u0026QueryMsg::MarketingInfo {})\n        .unwrap();\n    assert_eq!(\n        marketing_info.logo.unwrap(),\n        LogoInfo::Url(\"example.com/logo.svg\".to_string())\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","tests","simulation.rs"],"content":"use crate::test_utils::{mock_app, Helper, MULTIPLIER};\nuse anyhow::Result;\nuse astroport_governance::utils::{\n    get_period, get_periods_count, EPOCH_START, MAX_LOCK_TIME, WEEK,\n};\nuse cosmwasm_std::Addr;\nuse cw_multi_test::{next_block, App, AppResponse};\nuse std::collections::hash_map::Entry;\nuse std::collections::HashMap;\n\nmod test_utils;\n\n#[derive(Clone, Default, Debug)]\nstruct Point {\n    amount: f64,\n    end: u64,\n}\n\n#[derive(Clone, Debug)]\nenum Event {\n    CreateLock(f64, u64),\n    IncreaseTime(u64),\n    ExtendLock(f64),\n    Withdraw,\n    Blacklist,\n    Recover,\n}\n\nuse Event::*;\n\nstruct Simulator {\n    // Point history (history[period][user] = point)\n    points: Vec\u003cHashMap\u003cString, Point\u003e\u003e,\n    // Current user's lock (amount, end)\n    locked: HashMap\u003cString, (f64, u64)\u003e,\n    users: Vec\u003cString\u003e,\n    helper: Helper,\n    router: App,\n}\n\nfn apply_coefficient(amount: f64, interval: u64) -\u003e f64 {\n    let coeff = 1f64 + (1.5 * interval as f64) / get_periods_count(MAX_LOCK_TIME) as f64;\n    // Imitate decimal fraction multiplication\n    (amount * coeff * MULTIPLIER as f64).trunc() / MULTIPLIER as f64\n}\n\nimpl Simulator {\n    fn new\u003cT: Clone + Into\u003cString\u003e\u003e(users: \u0026[T]) -\u003e Self {\n        let mut router = mock_app();\n        Self {\n            points: vec![HashMap::new(); 10000],\n            locked: Default::default(),\n            users: users.iter().cloned().map(|user| user.into()).collect(),\n            helper: Helper::init(\u0026mut router, Addr::unchecked(\"owner\")),\n            router,\n        }\n    }\n\n    fn mint(\u0026mut self, user: \u0026str, amount: u128) {\n        self.helper\n            .mint_xastro(\u0026mut self.router, user, amount as u64)\n    }\n\n    fn block_period(\u0026self) -\u003e u64 {\n        get_period(self.router.block_info().time.seconds()).unwrap()\n    }\n\n    fn app_next_period(\u0026mut self) {\n        self.router.update_block(next_block);\n        self.router\n            .update_block(|block| block.time = block.time.plus_seconds(WEEK));\n    }\n\n    fn create_lock(\u0026mut self, user: \u0026str, amount: f64, interval: u64) -\u003e Result\u003cAppResponse\u003e {\n        let block_period = self.block_period();\n        let periods_interval = get_periods_count(interval);\n        self.helper\n            .create_lock(\u0026mut self.router, user, interval, amount as f32)\n            .map(|response| {\n                self.add_point(\n                    block_period as usize,\n                    user,\n                    apply_coefficient(amount, periods_interval),\n                    block_period + periods_interval,\n                );\n                self.locked.extend(vec![(\n                    user.to_string(),\n                    (amount, block_period + periods_interval),\n                )]);\n                response\n            })\n    }\n\n    fn increase_time(\u0026mut self, user: \u0026str, interval: u64) -\u003e Result\u003cAppResponse\u003e {\n        self.helper\n            .extend_lock_time(\u0026mut self.router, user, interval)\n            .map(|response| {\n                let cur_period = self.block_period() as usize;\n                let periods_interval = get_periods_count(interval);\n                let end = if let Some(point) = self.get_user_point_at(cur_period, user) {\n                    point.end\n                } else {\n                    let prev_point = self\n                        .get_prev_point(user)\n                        .expect(\"We always need previous point!\");\n                    prev_point.end\n                };\n                let dt = end + periods_interval - cur_period as u64;\n                let lock = self.locked.get_mut(user).unwrap();\n                lock.1 += periods_interval;\n                let amount = lock.0.to_owned();\n                self.add_point(\n                    cur_period,\n                    user,\n                    apply_coefficient(amount, dt),\n                    end + periods_interval,\n                );\n                response\n            })\n    }\n\n    fn extend_lock(\u0026mut self, user: \u0026str, amount: f64) -\u003e Result\u003cAppResponse\u003e {\n        self.helper\n            .extend_lock_amount(\u0026mut self.router, user, amount as f32)\n            .map(|response| {\n                let cur_period = self.block_period() as usize;\n                let (user_balance, end) =\n                    if let Some(point) = self.get_user_point_at(cur_period, user) {\n                        (point.amount, point.end)\n                    } else {\n                        let prev_point = self\n                            .get_prev_point(user)\n                            .expect(\"We always need previous point!\");\n                        (self.calc_user_balance_at(cur_period, user), prev_point.end)\n                    };\n                let vp = apply_coefficient(amount, end - cur_period as u64);\n                self.add_point(cur_period, user, user_balance + vp, end);\n                let mut lock = self.locked.get_mut(user).unwrap();\n                lock.0 += amount;\n                response\n            })\n    }\n\n    fn withdraw(\u0026mut self, user: \u0026str) -\u003e Result\u003cAppResponse\u003e {\n        self.helper\n            .withdraw(\u0026mut self.router, user)\n            .map(|response| {\n                let cur_period = self.block_period();\n                self.add_point(cur_period as usize, user, 0.0, cur_period);\n                self.locked.remove(user);\n                response\n            })\n    }\n\n    fn append2blacklist(\u0026mut self, user: \u0026str) -\u003e Result\u003cAppResponse\u003e {\n        self.helper\n            .update_blacklist(\u0026mut self.router, Some(vec![user.to_string()]), None)\n            .map(|response| {\n                let cur_period = self.block_period();\n                self.add_point(cur_period as usize, user, 0.0, cur_period);\n                response\n            })\n    }\n\n    fn remove_from_blacklist(\u0026mut self, user: \u0026str) -\u003e Result\u003cAppResponse\u003e {\n        self.helper\n            .update_blacklist(\u0026mut self.router, None, Some(vec![user.to_string()]))\n            .map(|response| {\n                let cur_period = self.block_period() as usize;\n                if let Some((amount, end)) = self.locked.get(user).copied() {\n                    let dt = end.saturating_sub(cur_period as u64);\n                    let new_amount = if dt != 0 {\n                        apply_coefficient(amount, dt)\n                    } else {\n                        0.0\n                    };\n                    self.add_point(cur_period, user, new_amount, end);\n                }\n                response\n            })\n    }\n\n    fn event_router(\u0026mut self, user: \u0026str, event: Event) {\n        println!(\"User {} Event {:?}\", user, event);\n        match event {\n            Event::CreateLock(amount, interval) =\u003e {\n                if let Err(err) = self.create_lock(user, amount, interval) {\n                    dbg!(err);\n                }\n            }\n            Event::IncreaseTime(interval) =\u003e {\n                if let Err(err) = self.increase_time(user, interval) {\n                    dbg!(err);\n                }\n            }\n            Event::ExtendLock(amount) =\u003e {\n                if let Err(err) = self.extend_lock(user, amount) {\n                    dbg!(err);\n                }\n            }\n            Event::Withdraw =\u003e {\n                if let Err(err) = self.withdraw(user) {\n                    dbg!(err);\n                }\n            }\n            Event::Blacklist =\u003e {\n                if let Err(err) = self.append2blacklist(user) {\n                    dbg!(err);\n                }\n            }\n            Event::Recover =\u003e {\n                if let Err(err) = self.remove_from_blacklist(user) {\n                    dbg!(err);\n                }\n            }\n        }\n        let real_balance = self\n            .get_user_point_at(self.block_period() as usize, user)\n            .map(|point| point.amount)\n            .unwrap_or_else(|| self.calc_user_balance_at(self.block_period() as usize, user));\n        let contract_balance = self\n            .helper\n            .query_user_vp(\u0026mut self.router, user)\n            .unwrap_or(0.0) as f64;\n        if (real_balance - contract_balance).abs() \u003e= 10e-3 {\n            assert_eq!(real_balance, contract_balance)\n        };\n    }\n\n    fn checkpoint_all_users(\u0026mut self) {\n        let cur_period = self.block_period() as usize;\n        self.users.clone().iter().for_each(|user| {\n            // we need to calc point only if it was not calculated yet\n            if self.get_user_point_at(cur_period, user).is_none() {\n                self.checkpoint_user(user)\n            }\n        })\n    }\n\n    fn add_point\u003cT: Into\u003cString\u003e\u003e(\u0026mut self, period: usize, user: T, amount: f64, end: u64) {\n        let map = \u0026mut self.points[period];\n        map.extend(vec![(user.into(), Point { amount, end })]);\n    }\n\n    fn get_prev_point(\u0026mut self, user: \u0026str) -\u003e Option\u003cPoint\u003e {\n        let prev_period = (self.block_period() - 1) as usize;\n        self.get_user_point_at(prev_period, user)\n    }\n\n    fn checkpoint_user(\u0026mut self, user: \u0026str) {\n        let cur_period = self.block_period() as usize;\n        let user_balance = self.calc_user_balance_at(cur_period, user);\n        let prev_point = self\n            .get_prev_point(user)\n            .expect(\"We always need previous point!\");\n        self.add_point(cur_period, user, user_balance, prev_point.end);\n    }\n\n    fn get_user_point_at\u003cT: Into\u003cString\u003e\u003e(\u0026mut self, period: usize, user: T) -\u003e Option\u003cPoint\u003e {\n        let points_map = \u0026mut self.points[period];\n        match points_map.entry(user.into()) {\n            Entry::Occupied(value) =\u003e Some(value.get().clone()),\n            Entry::Vacant(_) =\u003e None,\n        }\n    }\n\n    fn calc_user_balance_at(\u0026mut self, period: usize, user: \u0026str) -\u003e f64 {\n        match self.get_user_point_at(period, user) {\n            Some(point) =\u003e point.amount,\n            None =\u003e {\n                let prev_point = self\n                    .get_user_point_at(period - 1, user)\n                    .expect(\"We always need previous point!\");\n                let dt = prev_point.end.saturating_sub(period as u64 - 1);\n                if dt == 0 {\n                    0.0\n                } else {\n                    prev_point.amount - prev_point.amount / dt as f64\n                }\n            }\n        }\n    }\n\n    fn calc_total_balance_at(\u0026mut self, period: usize) -\u003e f64 {\n        self.users.clone().iter().fold(0.0, |acc, user| {\n            acc + self.get_user_point_at(period, user).unwrap().amount\n        })\n    }\n}\n\nuse proptest::prelude::*;\n\nconst MAX_PERIOD: usize = 10;\nconst MAX_USERS: usize = 6;\nconst MAX_EVENTS: usize = 100;\n\nfn amount_strategy() -\u003e impl Strategy\u003cValue = f64\u003e {\n    (1f64..=100f64).prop_map(|val| (val * MULTIPLIER as f64).trunc() / MULTIPLIER as f64)\n}\n\nfn events_strategy() -\u003e impl Strategy\u003cValue = Event\u003e {\n    prop_oneof![\n        Just(Event::Withdraw),\n        Just(Event::Blacklist),\n        Just(Event::Recover),\n        amount_strategy().prop_map(Event::ExtendLock),\n        (0..MAX_LOCK_TIME).prop_map(Event::IncreaseTime),\n        (amount_strategy(), 0..MAX_LOCK_TIME).prop_map(|(a, b)| Event::CreateLock(a, b)),\n    ]\n}\n\nfn generate_cases() -\u003e impl Strategy\u003cValue = (Vec\u003cString\u003e, Vec\u003c(usize, String, Event)\u003e)\u003e {\n    let users_strategy = prop::collection::vec(\"[a-z]{4,32}\", 1..MAX_USERS);\n    users_strategy.prop_flat_map(|users| {\n        (\n            Just(users.clone()),\n            prop::collection::vec(\n                (\n                    1..=MAX_PERIOD,\n                    prop::sample::select(users),\n                    events_strategy(),\n                ),\n                0..MAX_EVENTS,\n            ),\n        )\n    })\n}\n\nproptest! {\n    #[test]\n    fn run_simulations\n    (\n        case in generate_cases()\n    ) {\n        let mut events: Vec\u003cVec\u003c(String, Event)\u003e\u003e = vec![vec![]; MAX_PERIOD + 1];\n        let (users, events_tuples) = case;\n        for (period, user, event) in events_tuples {\n            events[period].push((user, event));\n        };\n\n        let mut simulator = Simulator::new(\u0026users);\n        for user in users {\n            simulator.mint(\u0026user, 10000);\n            simulator.add_point(0, user, 0.0, 104);\n        }\n        simulator.app_next_period();\n\n        for period in 1..=MAX_PERIOD {\n            if let Some(period_events) = events.get(period) {\n                for (user, event) in period_events {\n                    simulator.event_router(user, event.clone())\n                }\n            }\n            simulator.checkpoint_all_users();\n            let real_balance = simulator.calc_total_balance_at(period);\n            let contract_balance = simulator\n                .helper\n                .query_total_vp(\u0026mut simulator.router)\n                .unwrap_or(0.0) as f64;\n            if (real_balance - contract_balance).abs() \u003e= 10e-3 {\n                assert_eq!(real_balance, contract_balance)\n            };\n            // Evaluate historical periods\n            for check_period in 1..period {\n                let real_balance = simulator.calc_total_balance_at(check_period);\n                let contract_balance = simulator\n                    .helper\n                    .query_total_vp_at(\u0026mut simulator.router, EPOCH_START + check_period as u64 * WEEK)\n                    .unwrap_or(0.0) as f64;\n                if (real_balance - contract_balance).abs() \u003e= 10e-3 {\n                    assert_eq!(real_balance, contract_balance)\n                };\n            }\n            simulator.app_next_period()\n        }\n    }\n}\n\n#[test]\nfn exact_simulation() {\n    let case = (\n        [\"bpcy\"],\n        [\n            (1, \"bpcy\", CreateLock(100.0, 3024000)),\n            (2, \"bpcy\", IncreaseTime(3024000)),\n            (3, \"bpcy\", Blacklist),\n            (3, \"bpcy\", Recover),\n        ],\n    );\n\n    let mut events: Vec\u003cVec\u003c(String, Event)\u003e\u003e = vec![vec![]; MAX_PERIOD + 1];\n    let (users, events_tuples) = case;\n    for (period, user, event) in events_tuples {\n        events[period].push((user.to_string(), event));\n    }\n\n    let mut simulator = Simulator::new(\u0026users);\n    for user in users {\n        simulator.mint(user, 10000);\n        simulator.add_point(0, user, 0.0, 104);\n    }\n    simulator.app_next_period();\n\n    for period in 1..=MAX_PERIOD {\n        if let Some(period_events) = events.get(period) {\n            if !period_events.is_empty() {\n                println!(\"Period {}:\", period);\n            }\n            for (user, event) in period_events {\n                simulator.event_router(user, event.clone())\n            }\n        }\n        simulator.checkpoint_all_users();\n        let real_balance = simulator.calc_total_balance_at(period);\n        let contract_balance = simulator\n            .helper\n            .query_total_vp(\u0026mut simulator.router)\n            .unwrap_or(0.0) as f64;\n        if (real_balance - contract_balance).abs() \u003e= 10e-3 {\n            println!(\"Assert failed at period {}\", period);\n            assert_eq!(real_balance, contract_balance)\n        };\n        // Evaluate historical periods\n        for check_period in 1..period {\n            let real_balance = simulator.calc_total_balance_at(check_period);\n            let contract_balance = simulator\n                .helper\n                .query_total_vp_at(\n                    \u0026mut simulator.router,\n                    EPOCH_START + check_period as u64 * WEEK,\n                )\n                .unwrap_or(0.0) as f64;\n            if (real_balance - contract_balance).abs() \u003e= 10e-3 {\n                assert_eq!(real_balance, contract_balance)\n            };\n        }\n        simulator.app_next_period()\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","tests","test_utils.rs"],"content":"use anyhow::Result;\nuse astroport::{staking as xastro, token as astro};\nuse astroport_governance::escrow_fee_distributor::InstantiateMsg as FeeDistributorInstantiateMsg;\nuse astroport_governance::utils::EPOCH_START;\nuse astroport_governance::voting_escrow::{\n    BlacklistedVotersResponse, Cw20HookMsg, ExecuteMsg, InstantiateMsg, QueryMsg,\n    UpdateMarketingInfo, VotingPowerResponse,\n};\nuse cosmwasm_std::testing::{mock_env, MockApi, MockStorage};\nuse cosmwasm_std::{attr, to_binary, Addr, QueryRequest, StdResult, Timestamp, Uint128, WasmQuery};\nuse cw20::{BalanceResponse, Cw20ExecuteMsg, Cw20QueryMsg, Logo, MinterResponse};\nuse cw_multi_test::{App, AppBuilder, AppResponse, BankKeeper, ContractWrapper, Executor};\nuse voting_escrow::astroport;\n\npub const MULTIPLIER: u64 = 1000000;\n\npub struct Helper {\n    pub owner: Addr,\n    pub astro_token: Addr,\n    pub staking_instance: Addr,\n    pub xastro_token: Addr,\n    pub voting_instance: Addr,\n    pub fee_distributor_instance: Addr,\n}\n\nimpl Helper {\n    pub fn init(router: \u0026mut App, owner: Addr) -\u003e Self {\n        let astro_token_contract = Box::new(ContractWrapper::new_with_empty(\n            astroport_token::contract::execute,\n            astroport_token::contract::instantiate,\n            astroport_token::contract::query,\n        ));\n\n        let astro_token_code_id = router.store_code(astro_token_contract);\n\n        let msg = astro::InstantiateMsg {\n            name: String::from(\"Astro token\"),\n            symbol: String::from(\"ASTRO\"),\n            decimals: 6,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                minter: owner.to_string(),\n                cap: None,\n            }),\n            marketing: None,\n        };\n\n        let astro_token = router\n            .instantiate_contract(\n                astro_token_code_id,\n                owner.clone(),\n                \u0026msg,\n                \u0026[],\n                String::from(\"ASTRO\"),\n                None,\n            )\n            .unwrap();\n\n        let staking_contract = Box::new(\n            ContractWrapper::new_with_empty(\n                astroport_staking::contract::execute,\n                astroport_staking::contract::instantiate,\n                astroport_staking::contract::query,\n            )\n            .with_reply_empty(astroport_staking::contract::reply),\n        );\n\n        let staking_code_id = router.store_code(staking_contract);\n\n        let msg = xastro::InstantiateMsg {\n            owner: owner.to_string(),\n            token_code_id: astro_token_code_id,\n            deposit_token_addr: astro_token.to_string(),\n            marketing: None,\n        };\n        let staking_instance = router\n            .instantiate_contract(\n                staking_code_id,\n                owner.clone(),\n                \u0026msg,\n                \u0026[],\n                String::from(\"xASTRO\"),\n                None,\n            )\n            .unwrap();\n\n        let res = router\n            .wrap()\n            .query::\u003cxastro::ConfigResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                contract_addr: staking_instance.to_string(),\n                msg: to_binary(\u0026xastro::QueryMsg::Config {}).unwrap(),\n            }))\n            .unwrap();\n\n        let voting_contract = Box::new(ContractWrapper::new_with_empty(\n            voting_escrow::contract::execute,\n            voting_escrow::contract::instantiate,\n            voting_escrow::contract::query,\n        ));\n\n        let voting_code_id = router.store_code(voting_contract);\n\n        let marketing_info = UpdateMarketingInfo {\n            project: Some(\"Astroport\".to_string()),\n            description: Some(\"Astroport is a decentralized application for managing the supply of space resources.\".to_string()),\n            marketing: Some(owner.to_string()),\n            logo: Some(Logo::Url(\"https://astroport.com/logo.png\".to_string())),\n        };\n\n        let msg = InstantiateMsg {\n            owner: owner.to_string(),\n            guardian_addr: Some(\"guardian\".to_string()),\n            deposit_token_addr: res.share_token_addr.to_string(),\n            marketing: Some(marketing_info),\n            logo_urls_whitelist: vec![\"https://astroport.com/\".to_string()],\n        };\n        let voting_instance = router\n            .instantiate_contract(\n                voting_code_id,\n                owner.clone(),\n                \u0026msg,\n                \u0026[],\n                String::from(\"vxASTRO\"),\n                None,\n            )\n            .unwrap();\n\n        let fee_distributor_contract = Box::new(ContractWrapper::new_with_empty(\n            astroport_escrow_fee_distributor::contract::execute,\n            astroport_escrow_fee_distributor::contract::instantiate,\n            astroport_escrow_fee_distributor::contract::query,\n        ));\n\n        let fee_distributor_code_id = router.store_code(fee_distributor_contract);\n\n        let msg = FeeDistributorInstantiateMsg {\n            owner: owner.to_string(),\n            astro_token: astro_token.to_string(),\n            voting_escrow_addr: voting_instance.to_string(),\n            claim_many_limit: None,\n            is_claim_disabled: None,\n        };\n\n        let fee_distributor_instance = router\n            .instantiate_contract(\n                fee_distributor_code_id,\n                owner.clone(),\n                \u0026msg,\n                \u0026[],\n                String::from(\"Fee distributor\"),\n                None,\n            )\n            .unwrap();\n\n        Self {\n            owner,\n            xastro_token: res.share_token_addr,\n            astro_token,\n            staking_instance,\n            voting_instance,\n            fee_distributor_instance,\n        }\n    }\n\n    pub fn mint_xastro(\u0026self, router: \u0026mut App, to: \u0026str, amount: u64) {\n        let amount = amount * MULTIPLIER;\n        let msg = cw20::Cw20ExecuteMsg::Mint {\n            recipient: String::from(to),\n            amount: Uint128::from(amount),\n        };\n        let res = router\n            .execute_contract(self.owner.clone(), self.astro_token.clone(), \u0026msg, \u0026[])\n            .unwrap();\n        assert_eq!(res.events[1].attributes[1], attr(\"action\", \"mint\"));\n        assert_eq!(res.events[1].attributes[2], attr(\"to\", String::from(to)));\n        assert_eq!(\n            res.events[1].attributes[3],\n            attr(\"amount\", Uint128::from(amount))\n        );\n\n        let to_addr = Addr::unchecked(to);\n        let msg = Cw20ExecuteMsg::Send {\n            contract: self.staking_instance.to_string(),\n            msg: to_binary(\u0026xastro::Cw20HookMsg::Enter {}).unwrap(),\n            amount: Uint128::from(amount),\n        };\n        router\n            .execute_contract(to_addr, self.astro_token.clone(), \u0026msg, \u0026[])\n            .unwrap();\n    }\n\n    #[allow(dead_code)]\n    pub fn check_xastro_balance(\u0026self, router: \u0026mut App, user: \u0026str, amount: u64) {\n        let amount = amount * MULTIPLIER;\n        let res: BalanceResponse = router\n            .wrap()\n            .query_wasm_smart(\n                self.xastro_token.clone(),\n                \u0026Cw20QueryMsg::Balance {\n                    address: user.to_string(),\n                },\n            )\n            .unwrap();\n        assert_eq!(res.balance.u128(), amount as u128);\n    }\n\n    #[allow(dead_code)]\n    pub fn check_astro_balance(\u0026self, router: \u0026mut App, user: \u0026str, amount: u64) {\n        let amount = amount * MULTIPLIER;\n        let res: BalanceResponse = router\n            .wrap()\n            .query_wasm_smart(\n                self.astro_token.clone(),\n                \u0026Cw20QueryMsg::Balance {\n                    address: user.to_string(),\n                },\n            )\n            .unwrap();\n        assert_eq!(res.balance.u128(), amount as u128);\n    }\n\n    pub fn create_lock(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        time: u64,\n        amount: f32,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let amount = (amount * MULTIPLIER as f32) as u64;\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.voting_instance.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::CreateLock { time }).unwrap(),\n        };\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.xastro_token.clone(),\n            \u0026cw20msg,\n            \u0026[],\n        )\n    }\n\n    #[allow(dead_code)]\n    pub fn create_lock_u128(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        time: u64,\n        amount: u128,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.voting_instance.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::CreateLock { time }).unwrap(),\n        };\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.xastro_token.clone(),\n            \u0026cw20msg,\n            \u0026[],\n        )\n    }\n\n    pub fn extend_lock_amount(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        amount: f32,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let amount = (amount * MULTIPLIER as f32) as u64;\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.voting_instance.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::ExtendLockAmount {}).unwrap(),\n        };\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.xastro_token.clone(),\n            \u0026cw20msg,\n            \u0026[],\n        )\n    }\n\n    #[allow(dead_code)]\n    pub fn deposit_for(\n        \u0026self,\n        router: \u0026mut App,\n        from: \u0026str,\n        to: \u0026str,\n        amount: f32,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let amount = (amount * MULTIPLIER as f32) as u64;\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.voting_instance.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::DepositFor {\n                user: to.to_string(),\n            })\n            .unwrap(),\n        };\n        router.execute_contract(\n            Addr::unchecked(from),\n            self.xastro_token.clone(),\n            \u0026cw20msg,\n            \u0026[],\n        )\n    }\n\n    pub fn extend_lock_time(\u0026self, router: \u0026mut App, user: \u0026str, time: u64) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.voting_instance.clone(),\n            \u0026ExecuteMsg::ExtendLockTime { time },\n            \u0026[],\n        )\n    }\n\n    pub fn withdraw(\u0026self, router: \u0026mut App, user: \u0026str) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.voting_instance.clone(),\n            \u0026ExecuteMsg::Withdraw {},\n            \u0026[],\n        )\n    }\n\n    pub fn update_blacklist(\n        \u0026self,\n        router: \u0026mut App,\n        append_addrs: Option\u003cVec\u003cString\u003e\u003e,\n        remove_addrs: Option\u003cVec\u003cString\u003e\u003e,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(\"owner\"),\n            self.voting_instance.clone(),\n            \u0026ExecuteMsg::UpdateBlacklist {\n                append_addrs,\n                remove_addrs,\n            },\n            \u0026[],\n        )\n    }\n\n    pub fn query_user_vp(\u0026self, router: \u0026mut App, user: \u0026str) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_instance.clone(),\n                \u0026QueryMsg::UserVotingPower {\n                    user: user.to_string(),\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    #[allow(dead_code)]\n    pub fn query_exact_user_vp(\u0026self, router: \u0026mut App, user: \u0026str) -\u003e StdResult\u003cu128\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_instance.clone(),\n                \u0026QueryMsg::UserVotingPower {\n                    user: user.to_string(),\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128())\n    }\n\n    #[allow(dead_code)]\n    pub fn query_user_vp_at(\u0026self, router: \u0026mut App, user: \u0026str, time: u64) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_instance.clone(),\n                \u0026QueryMsg::UserVotingPowerAt {\n                    user: user.to_string(),\n                    time,\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    #[allow(dead_code)]\n    pub fn query_user_vp_at_period(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        period: u64,\n    ) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_instance.clone(),\n                \u0026QueryMsg::UserVotingPowerAtPeriod {\n                    user: user.to_string(),\n                    period,\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_total_vp(\u0026self, router: \u0026mut App) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(self.voting_instance.clone(), \u0026QueryMsg::TotalVotingPower {})\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    #[allow(dead_code)]\n    pub fn query_exact_total_vp(\u0026self, router: \u0026mut App) -\u003e StdResult\u003cu128\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(self.voting_instance.clone(), \u0026QueryMsg::TotalVotingPower {})\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128())\n    }\n\n    pub fn query_total_vp_at(\u0026self, router: \u0026mut App, time: u64) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_instance.clone(),\n                \u0026QueryMsg::TotalVotingPowerAt { time },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    #[allow(dead_code)]\n    pub fn query_total_vp_at_period(\u0026self, router: \u0026mut App, period: u64) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_instance.clone(),\n                \u0026QueryMsg::TotalVotingPowerAtPeriod { period },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    #[allow(dead_code)]\n    pub fn query_locked_balance_at(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        height: u64,\n    ) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_instance.clone(),\n                \u0026QueryMsg::UserDepositAtHeight {\n                    user: user.to_string(),\n                    height,\n                },\n            )\n            .map(|vp: Uint128| vp.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    #[allow(dead_code)]\n    pub fn query_blacklisted_voters(\n        \u0026self,\n        router: \u0026mut App,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cVec\u003cAddr\u003e\u003e {\n        router.wrap().query_wasm_smart(\n            self.voting_instance.clone(),\n            \u0026QueryMsg::BlacklistedVoters { start_after, limit },\n        )\n    }\n\n    #[allow(dead_code)]\n    pub fn check_voters_are_blacklisted(\n        \u0026self,\n        router: \u0026mut App,\n        voters: Vec\u003cString\u003e,\n    ) -\u003e StdResult\u003cBlacklistedVotersResponse\u003e {\n        router.wrap().query_wasm_smart(\n            self.voting_instance.clone(),\n            \u0026QueryMsg::CheckVotersAreBlacklisted { voters },\n        )\n    }\n}\n\npub fn mock_app() -\u003e App {\n    let mut env = mock_env();\n    env.block.time = Timestamp::from_seconds(EPOCH_START);\n    let api = MockApi::default();\n    let bank = BankKeeper::new();\n    let storage = MockStorage::new();\n\n    AppBuilder::new()\n        .with_api(api)\n        .with_block(env.block)\n        .with_bank(bank)\n        .with_storage(storage)\n        .build(|_, _, _| {})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","examples","voting_escrow_delegation_schema.rs"],"content":"use astroport_governance::voting_escrow_delegation::{ExecuteMsg, InstantiateMsg, QueryMsg};\nuse cosmwasm_schema::write_api;\n\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        query: QueryMsg,\n        execute: ExecuteMsg,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","src","contract.rs"],"content":"use astroport_governance::utils::{calc_voting_power, get_period, get_periods_count};\nuse astroport_governance::voting_escrow::{get_voting_power, get_voting_power_at, MAX_LIMIT};\nuse std::marker::PhantomData;\n\nuse crate::error::ContractError;\nuse crate::state::{CONFIG, DELEGATED, OWNERSHIP_PROPOSAL, TOKENS};\nuse astroport_governance::astroport::common::{\n    claim_ownership, drop_ownership_proposal, propose_new_owner,\n};\nuse astroport_governance::voting_escrow_delegation::{\n    Config, ExecuteMsg, InstantiateMsg, QueryMsg,\n};\n\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    attr, to_binary, Addr, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Reply, ReplyOn,\n    Response, StdError, StdResult, SubMsg, Uint128, WasmMsg,\n};\nuse cw2::set_contract_version;\nuse cw721::NftInfoResponse;\nuse cw_utils::parse_reply_instantiate_data;\n\nuse crate::helpers::{\n    calc_delegation, calc_extend_delegation, calc_not_delegated_vp, calc_total_delegated_vp,\n    validate_parameters,\n};\nuse cw721_base::helpers as cw721_helpers;\nuse cw721_base::msg::{ExecuteMsg as ExecuteMsgNFT, InstantiateMsg as InstantiateMsgNFT};\nuse cw721_base::{Extension, MintMsg};\n\n// Version info for contract migration.\nconst CONTRACT_NAME: \u0026str = \"voting-escrow-delegation\";\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Delegated voting power NFT information.\nconst TOKEN_NAME: \u0026str = \"Delegated VP NFT\";\nconst TOKEN_SYMBOL: \u0026str = \"VP-NFT\";\n\n/// Creates a new contract with the specified parameters in the [`InstantiateMsg`].\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    let config = Config {\n        owner: deps.api.addr_validate(\u0026msg.owner)?,\n        nft_addr: Addr::unchecked(\"\"),\n        voting_escrow_addr: deps.api.addr_validate(\u0026msg.voting_escrow_addr)?,\n    };\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    // Create an Astroport NFT\n    let sub_msg = SubMsg {\n        msg: WasmMsg::Instantiate {\n            admin: Some(config.owner.to_string()),\n            code_id: msg.nft_code_id,\n            msg: to_binary(\u0026InstantiateMsgNFT {\n                name: TOKEN_NAME.to_string(),\n                symbol: TOKEN_SYMBOL.to_string(),\n                minter: env.contract.address.to_string(),\n            })?,\n            funds: vec![],\n            label: String::from(\"Delegated VP NFT\"),\n        }\n        .into(),\n        id: 1,\n        gas_limit: None,\n        reply_on: ReplyOn::Success,\n    };\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"instantiate\")\n        .add_attribute(\"owner\", config.owner)\n        .add_submessage(sub_msg))\n}\n\n/// Exposes all the execute functions available in the contract.\n///\n/// ## Execute messages\n/// * **ExecuteMsg::CreateDelegation { percentage, cancel_time, expire_time, token_id, recipient}**\n/// Delegates voting power in percent into other account.\n///\n/// * **ExecuteMsg::ExtendDelegation { percentage, cancel_time, expire_time, token_id, recipient}**\n/// Extends an already created delegation with a new specified parameters\n///\n/// * **ExecuteMsg::ProposeNewOwner { owner, expires_in }** Creates a new request to change\n/// contract ownership.\n///\n/// * **ExecuteMsg::DropOwnershipProposal {}** Removes a request to change contract ownership.\n///\n/// * **ExecuteMsg::ClaimOwnership {}** Claims contract ownership.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::CreateDelegation {\n            bps,\n            expire_time,\n            token_id,\n            recipient,\n        } =\u003e create_delegation(deps, env, info, bps, expire_time, token_id, recipient),\n        ExecuteMsg::ExtendDelegation {\n            bps,\n            expire_time,\n            token_id,\n        } =\u003e extend_delegation(deps, env, info, bps, expire_time, token_id),\n        ExecuteMsg::UpdateConfig { new_voting_escrow } =\u003e {\n            update_config(deps, info, new_voting_escrow)\n        }\n        ExecuteMsg::ProposeNewOwner {\n            new_owner,\n            expires_in,\n        } =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n            propose_new_owner(\n                deps,\n                info,\n                env,\n                new_owner,\n                expires_in,\n                config.owner,\n                OWNERSHIP_PROPOSAL,\n            )\n            .map_err(Into::into)\n        }\n        ExecuteMsg::DropOwnershipProposal {} =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n\n            drop_ownership_proposal(deps, info, config.owner, OWNERSHIP_PROPOSAL)\n                .map_err(Into::into)\n        }\n        ExecuteMsg::ClaimOwnership {} =\u003e {\n            claim_ownership(deps, info, env, OWNERSHIP_PROPOSAL, |deps, new_owner| {\n                CONFIG\n                    .update::\u003c_, StdError\u003e(deps.storage, |mut v| {\n                        v.owner = new_owner;\n                        Ok(v)\n                    })\n                    .map(|_| ())\n            })\n            .map_err(Into::into)\n        }\n    }\n}\n\n/// The entry point to the contract for processing replies from sub-messages. For now it only\n/// sets the NFT contract address.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(deps: DepsMut, _env: Env, msg: Reply) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut config: Config = CONFIG.load(deps.storage)?;\n\n    if config.nft_addr != Addr::unchecked(\"\") {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let res = parse_reply_instantiate_data(msg)?;\n    config.nft_addr = deps.api.addr_validate(res.contract_address.as_str())?;\n\n    CONFIG.save(deps.storage, \u0026config)?;\n    Ok(Response::new())\n}\n\n/// Creates NFT with specified parameters and connect it with delegated voting power\n/// in percent into other account.\n///\n/// * **percentage** is a percentage value to determine the amount of\n/// voting power to delegate\n///\n/// * **expire_time** is a point in time, at least a day in the future, at which the value of the\n/// voting power will reach 0.\n///\n/// * **token_id** is an NFT identifier.\n///\n/// * **recipient** is an account to receive the delegated voting power.\npub fn create_delegation(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    bps: u16,\n    expire_time: u64,\n    token_id: String,\n    recipient: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let recipient_addr = deps.api.addr_validate(recipient.as_str())?;\n    let delegator = info.sender;\n    let cfg = CONFIG.load(deps.storage)?;\n    let block_period = get_period(env.block.time.seconds())?;\n    let exp_period = block_period + get_periods_count(expire_time);\n\n    // We can create only one NFT for a specific token ID\n    let nft_helper = cw721_helpers::Cw721Contract::\u003cEmpty, Empty\u003e(\n        cfg.nft_addr.clone(),\n        PhantomData,\n        PhantomData,\n    );\n\n    let nft_instance: StdResult\u003cNftInfoResponse\u003cExtension\u003e\u003e =\n        nft_helper.nft_info(\u0026deps.querier, \u0026token_id);\n\n    if nft_instance.is_ok() {\n        return Err(ContractError::DelegationTokenAlreadyExists(token_id));\n    }\n\n    let vp = get_voting_power(\u0026deps.querier, \u0026cfg.voting_escrow_addr, \u0026delegator)?;\n    if vp.is_zero() {\n        return Err(ContractError::ZeroVotingPower {});\n    }\n\n    validate_parameters(\n        \u0026deps.querier,\n        \u0026cfg,\n        \u0026delegator,\n        block_period,\n        exp_period,\n        bps,\n        None,\n    )?;\n\n    let not_delegated_vp = calc_not_delegated_vp(deps.as_ref(), \u0026delegator, vp, block_period)?;\n    let delegation = calc_delegation(not_delegated_vp, block_period, exp_period, bps)?;\n\n    DELEGATED.save(deps.storage, (\u0026delegator, token_id.clone()), \u0026delegation)?;\n    TOKENS.save(deps.storage, token_id.clone(), \u0026delegation)?;\n\n    Ok(Response::default()\n        .add_attributes(vec![\n            attr(\"action\", \"create_delegation\"),\n            attr(\"recipient\", recipient),\n            attr(\"token_id\", token_id.clone()),\n            attr(\"expire_time\", expire_time.to_string()),\n            attr(\"bps\", bps.to_string()),\n            attr(\"delegated_voting_power\", delegation.power.to_string()),\n        ])\n        .add_submessage(SubMsg::new(WasmMsg::Execute {\n            contract_addr: cfg.nft_addr.to_string(),\n            msg: to_binary(\u0026ExecuteMsgNFT::\u003cExtension, Empty\u003e::Mint(MintMsg::\u003c\n                Extension,\n            \u003e {\n                token_id,\n                owner: recipient_addr.to_string(),\n                token_uri: None,\n                extension: None,\n            }))?,\n            funds: vec![],\n        })))\n}\n\n/// Extends a previously created delegation by a new specified parameters.\n///\n/// * **percentage** is a percentage value to determine the amount of voting power to delegate.\n///\n/// * **expire_time** is a point in time, at least a day in the future, at which the value of the\n/// voting power will reach 0.\n///\n/// * **token_id** is an NFT identifier.\n///\n/// * **recipient** is an account to receive the delegated voting power.\npub fn extend_delegation(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    bps: u16,\n    expire_time: u64,\n    token_id: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let delegator = info.sender;\n    let cfg = CONFIG.load(deps.storage)?;\n\n    let old_delegation = DELEGATED.load(deps.storage, (\u0026delegator, token_id.clone()))?;\n\n    let vp = get_voting_power(\u0026deps.querier, \u0026cfg.voting_escrow_addr, \u0026delegator)?;\n    if vp.is_zero() {\n        return Err(ContractError::ZeroVotingPower {});\n    }\n\n    let block_period = get_period(env.block.time.seconds())?;\n    let exp_period = block_period + get_periods_count(expire_time);\n\n    validate_parameters(\n        \u0026deps.querier,\n        \u0026cfg,\n        \u0026delegator,\n        block_period,\n        exp_period,\n        bps,\n        Some(\u0026old_delegation),\n    )?;\n\n    let new_delegation = calc_extend_delegation(\n        deps.as_ref(),\n        \u0026delegator,\n        vp,\n        \u0026old_delegation,\n        block_period,\n        exp_period,\n        bps,\n    )?;\n\n    DELEGATED.save(\n        deps.storage,\n        (\u0026delegator, token_id.clone()),\n        \u0026new_delegation,\n    )?;\n    TOKENS.save(deps.storage, token_id.clone(), \u0026new_delegation)?;\n\n    Ok(Response::default().add_attributes(vec![\n        attr(\"action\", \"extend_delegation\"),\n        attr(\"token_id\", token_id),\n        attr(\"expire_time\", expire_time.to_string()),\n        attr(\"bps\", bps.to_string()),\n        attr(\"delegated_voting_power\", new_delegation.power.to_string()),\n    ]))\n}\n\n/// Updates contract parameters.\n///\n/// * **new_voting_escrow** is a new address of Voting Escrow contract.\nfn update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    new_voting_escrow: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut cfg = CONFIG.load(deps.storage)?;\n\n    if info.sender != cfg.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(new_voting_escrow) = new_voting_escrow {\n        cfg.voting_escrow_addr = deps.api.addr_validate(\u0026new_voting_escrow)?;\n    }\n\n    CONFIG.save(deps.storage, \u0026cfg)?;\n\n    Ok(Response::default().add_attribute(\"action\", \"execute_update_config\"))\n}\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::Config {}** Fetch contract config\n///\n/// * **QueryMsg::AdjustedBalance { account, timestamp }** Adjusted voting power balance after\n/// accounting for delegations.\n///\n/// * **QueryMsg::AlreadyDelegatedVP { account, timestamp }** Returns the amount of delegated\n/// voting power according to the given parameters.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Config {} =\u003e to_binary(\u0026CONFIG.load(deps.storage)?),\n        QueryMsg::AdjustedBalance { account, timestamp } =\u003e {\n            to_binary(\u0026adjusted_balance(deps, env, account, timestamp)?)\n        }\n        QueryMsg::DelegatedVotingPower { account, timestamp } =\u003e {\n            to_binary(\u0026delegated_vp(deps, env, account, timestamp)?)\n        }\n    }\n}\n\n/// Returns an adjusted voting power balance after accounting for delegations.\n///\n/// * **account** is an address of the account to return adjusted balance.\n///\n/// * **timestamp** is a point in time, at least a day in the future, at which the value of\n/// the voting power will reach 0.\nfn adjusted_balance(\n    deps: Deps,\n    env: Env,\n    account: String,\n    timestamp: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let account = deps.api.addr_validate(account.as_str())?;\n    let config = CONFIG.load(deps.storage)?;\n\n    let mut current_vp = if let Some(timestamp) = timestamp {\n        get_voting_power_at(\n            \u0026deps.querier,\n            \u0026config.voting_escrow_addr,\n            \u0026account,\n            timestamp,\n        )?\n    } else {\n        get_voting_power(\u0026deps.querier, \u0026config.voting_escrow_addr, \u0026account)?\n    };\n\n    let block_period = get_period(timestamp.unwrap_or_else(|| env.block.time.seconds()))?;\n    let total_delegated_vp = calc_total_delegated_vp(deps, \u0026account, block_period)?;\n\n    // we must to subtract the delegated voting power\n    current_vp = current_vp.checked_sub(total_delegated_vp)?;\n\n    let nft_helper =\n        cw721_helpers::Cw721Contract::\u003cEmpty, Empty\u003e(config.nft_addr, PhantomData, PhantomData);\n\n    let mut account_tokens = vec![];\n    let mut start_after = None;\n\n    // we need to take all tokens for specified account\n    loop {\n        let tokens = nft_helper\n            .tokens(\u0026deps.querier, account.clone(), start_after, Some(MAX_LIMIT))?\n            .tokens;\n        if tokens.is_empty() {\n            break;\n        }\n        start_after = tokens.last().cloned();\n        account_tokens.extend(tokens);\n    }\n\n    for token_id in account_tokens {\n        let token = TOKENS.load(deps.storage, token_id)?;\n\n        if token.start \u003c= block_period \u0026\u0026 token.expire_period \u003e block_period {\n            current_vp += calc_voting_power(token.slope, token.power, token.start, block_period);\n        }\n    }\n\n    Ok(current_vp)\n}\n\n/// Returns an amount of delegated voting power.\n///\n/// * **account** is an address of the account to return adjusted balance.\n///\n/// * **timestamp** is an optional field that specifies the period for which the function\n/// returns voting power.\nfn delegated_vp(\n    deps: Deps,\n    env: Env,\n    account: String,\n    timestamp: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let account = deps.api.addr_validate(account.as_str())?;\n    let block_period = get_period(timestamp.unwrap_or_else(|| env.block.time.seconds()))?;\n\n    calc_total_delegated_vp(deps, \u0026account, block_period)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse cw_utils::ParseReplyError;\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"{0}\")]\n    ParseReplyError(#[from] ParseReplyError),\n\n    #[error(\"You can't delegate with zero voting power\")]\n    ZeroVotingPower {},\n\n    #[error(\"You have already delegated all the voting power.\")]\n    AllVotingPowerIsDelegated {},\n\n    #[error(\"The delegation period must be at least a week and not more than a user lock period.\")]\n    DelegationPeriodError {},\n\n    #[error(\"New expiration date must be greater than previously set and less than or equal to user's end of voting power lock.\")]\n    DelegationExtendPeriodError {},\n\n    #[error(\"Not enough voting power to proceed\")]\n    NotEnoughVotingPower {},\n\n    #[error(\"The percentage range must be from 0 to 100.\")]\n    PercentageError {},\n\n    #[error(\"A delegation with a token {0} already exists.\")]\n    DelegationTokenAlreadyExists(String),\n\n    #[error(\"New delegated voting power can not be less than it was previously.\")]\n    DecreasedDelegatedVotingPower {},\n\n    #[error(\"Basic points conversion error. The basic points must be from 1 to 10000: {0}\")]\n    BPSConversionError(u16),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","src","helpers.rs"],"content":"use crate::state::DELEGATED;\nuse crate::ContractError;\nuse astroport_governance::utils::calc_voting_power;\nuse astroport_governance::voting_escrow::get_lock_info;\nuse astroport_governance::voting_escrow_delegation::{Config, Token};\nuse cosmwasm_std::{Addr, Deps, Order, QuerierWrapper, StdError, StdResult, Uint128};\n\nconst MAX_BPS_AMOUNT: u16 = 10000u16;\nconst MIN_BPS_AMOUNT: u16 = 1u16;\n\n/// Adjusting voting power according to the slope by specified percentage.\npub fn calc_delegation(\n    not_delegated_vp: Uint128,\n    block_period: u64,\n    exp_period: u64,\n    bps: u16,\n) -\u003e Result\u003cToken, ContractError\u003e {\n    let vp_to_delegate = not_delegated_vp.multiply_ratio(bps, MAX_BPS_AMOUNT);\n\n    let dt = Uint128::from(exp_period - block_period);\n    let slope = vp_to_delegate\n        .checked_div(dt)\n        .map_err(|e| ContractError::Std(e.into()))?;\n    let power = slope * dt;\n\n    if power.is_zero() {\n        return Err(ContractError::NotEnoughVotingPower {});\n    }\n\n    Ok(Token {\n        power,\n        slope,\n        start: block_period,\n        expire_period: exp_period,\n    })\n}\n\n/// Calculates the total delegated voting power for specified account.\npub(crate) fn calc_total_delegated_vp(\n    deps: Deps,\n    delegator: \u0026Addr,\n    block_period: u64,\n) -\u003e StdResult\u003cUint128\u003e {\n    let delegates = DELEGATED\n        .prefix(delegator)\n        .range(deps.storage, None, None, Order::Ascending)\n        .filter_map(|pair| {\n            let (_, token) = match pair {\n                Ok(v) =\u003e v,\n                Err(e) =\u003e return Some(Err(e)),\n            };\n            if token.start \u003c= block_period \u0026\u0026 token.expire_period \u003e block_period {\n                Some(Ok(token))\n            } else {\n                None\n            }\n        })\n        .collect::\u003cResult\u003cVec\u003cToken\u003e, StdError\u003e\u003e()?;\n\n    let mut total_delegated_vp = Uint128::zero();\n    for delegate in delegates {\n        total_delegated_vp +=\n            calc_voting_power(delegate.slope, delegate.power, delegate.start, block_period);\n    }\n\n    Ok(total_delegated_vp)\n}\n\n/// Validates input parameters to create or extend a delegation.\npub fn validate_parameters(\n    querier: \u0026QuerierWrapper,\n    cfg: \u0026Config,\n    delegator: \u0026Addr,\n    block_period: u64,\n    exp_period: u64,\n    bps: u16,\n    old_delegate: Option\u003c\u0026Token\u003e,\n) -\u003e Result\u003c(), ContractError\u003e {\n    let user_lock = get_lock_info(querier, \u0026cfg.voting_escrow_addr, delegator)?;\n\n    // vxASTRO delegation must be at least WEEK and no more then lock end period\n    if (exp_period \u003c= block_period) || (exp_period \u003e user_lock.end) {\n        return Err(ContractError::DelegationPeriodError {});\n    }\n\n    if !(MIN_BPS_AMOUNT..=MAX_BPS_AMOUNT).contains(\u0026bps) {\n        return Err(ContractError::BPSConversionError(bps));\n    }\n\n    if let Some(old_token) = old_delegate {\n        if exp_period \u003c= old_token.expire_period {\n            return Err(ContractError::DelegationExtendPeriodError {});\n        }\n    }\n\n    Ok(())\n}\n\n/// Calculates available balance for a new delegation.\npub fn calc_not_delegated_vp(\n    deps: Deps,\n    delegator: \u0026Addr,\n    vp: Uint128,\n    block_period: u64,\n) -\u003e Result\u003cUint128, ContractError\u003e {\n    let total_delegated_vp = calc_total_delegated_vp(deps, delegator, block_period)?;\n\n    if vp \u003c= total_delegated_vp {\n        return Err(ContractError::AllVotingPowerIsDelegated {});\n    }\n\n    Ok(vp - total_delegated_vp)\n}\n\n/// Calculates the available balance for the specified delegation.\npub fn calc_extend_delegation(\n    deps: Deps,\n    delegator: \u0026Addr,\n    vp: Uint128,\n    old_delegation: \u0026Token,\n    block_period: u64,\n    exp_period: u64,\n    bps: u16,\n) -\u003e Result\u003cToken, ContractError\u003e {\n    let not_delegated_vp = calc_not_delegated_vp(deps, delegator, vp, block_period)?;\n\n    // we should deduct the previous delegation balance and assign a new delegation data\n    let new_delegation = if old_delegation.expire_period \u003e block_period {\n        let old_delegation_vp = calc_voting_power(\n            old_delegation.slope,\n            old_delegation.power,\n            old_delegation.start,\n            block_period,\n        );\n\n        let new_delegation = calc_delegation(\n            not_delegated_vp + old_delegation_vp,\n            block_period,\n            exp_period,\n            bps,\n        )?;\n\n        let new_delegation_vp = calc_voting_power(\n            new_delegation.slope,\n            new_delegation.power,\n            new_delegation.start,\n            block_period,\n        );\n\n        if old_delegation_vp \u003e new_delegation_vp {\n            return Err(ContractError::DecreasedDelegatedVotingPower {});\n        }\n\n        new_delegation\n    } else {\n        calc_delegation(not_delegated_vp, block_period, exp_period, bps)?\n    };\n\n    Ok(new_delegation)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","src","lib.rs"],"content":"pub mod contract;\nmod error;\nmod helpers;\npub mod state;\npub use crate::error::ContractError;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","src","state.rs"],"content":"use astroport_governance::astroport::common::OwnershipProposal;\nuse astroport_governance::voting_escrow_delegation::{Config, Token};\nuse cosmwasm_std::Addr;\nuse cw_storage_plus::{Item, Map};\n\n/// Contains a proposal to change contract ownership\npub const OWNERSHIP_PROPOSAL: Item\u003cOwnershipProposal\u003e = Item::new(\"ownership_proposal\");\n\n/// Stores the contract config at the given key\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n\n/// Delegated voting power are stored using a (contract_addr =\u003e token_ID) key\npub const DELEGATED: Map\u003c(\u0026Addr, String), Token\u003e = Map::new(\"delegated\");\n\n/// Delegated token history is stored using a token ID key\npub const TOKENS: Map\u003cString, Token\u003e = Map::new(\"tokens\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","tests","integration.rs"],"content":"use astroport_governance::utils::WEEK;\nuse astroport_governance::voting_escrow_delegation::Config;\nuse astroport_governance::voting_escrow_delegation::QueryMsg;\nuse cosmwasm_std::{to_binary, Addr, Empty, QueryRequest, Uint128, WasmQuery};\nuse cw721_base::{ExecuteMsg as ExecuteMsgNFT, Extension, MintMsg, QueryMsg as QueryMsgNFT};\nuse cw_multi_test::Executor;\n\nuse cw721::{ContractInfoResponse, Cw721ExecuteMsg, NumTokensResponse, TokensResponse};\n\nuse crate::test_helper::{mock_app, Helper};\n\nmod test_helper;\n\nconst EMPTY_TOKENS: Vec\u003cString\u003e = vec![];\nconst USER: \u0026str = \"user\";\n\n#[test]\nfn config() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    let res = router\n        .wrap()\n        .query::\u003cConfig\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: helper.delegation_instance.to_string(),\n            msg: to_binary(\u0026QueryMsg::Config {}).unwrap(),\n        }))\n        .unwrap();\n\n    assert_eq!(\"owner\", res.owner.to_string());\n}\n\n#[test]\nfn mint() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    let resp = router_ref\n        .wrap()\n        .query::\u003cContractInfoResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: helper.nft_instance.to_string(),\n            msg: to_binary(\u0026QueryMsgNFT::\u003cEmpty\u003e::ContractInfo {}).unwrap(),\n        }))\n        .unwrap();\n    assert_eq!(\"Delegated VP NFT\", resp.name);\n    assert_eq!(\"VP-NFT\", resp.symbol);\n\n    // try to mint from random\n    let err = router_ref\n        .execute_contract(\n            Addr::unchecked(\"random\"),\n            helper.nft_instance.clone(),\n            \u0026ExecuteMsgNFT::\u003cExtension, Empty\u003e::Mint(MintMsg::\u003cExtension\u003e {\n                token_id: \"token_1\".to_string(),\n                owner: USER.to_string(),\n                token_uri: None,\n                extension: None,\n            }),\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\"Unauthorized\", err.root_cause().to_string());\n\n    // try to mint from owner\n    router_ref\n        .execute_contract(\n            helper.delegation_instance.clone(),\n            helper.nft_instance.clone(),\n            \u0026ExecuteMsgNFT::\u003cExtension, Empty\u003e::Mint(MintMsg::\u003cExtension\u003e {\n                token_id: \"token_1\".to_string(),\n                owner: USER.to_string(),\n                token_uri: None,\n                extension: None,\n            }),\n            \u0026[],\n        )\n        .unwrap();\n\n    let resp = router_ref\n        .wrap()\n        .query::\u003cNumTokensResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: helper.nft_instance.to_string(),\n            msg: to_binary(\u0026QueryMsgNFT::\u003cEmpty\u003e::NumTokens {}).unwrap(),\n        }))\n        .unwrap();\n    assert_eq!(1, resp.count);\n\n    let resp = router_ref\n        .wrap()\n        .query::\u003cTokensResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: helper.nft_instance.to_string(),\n            msg: to_binary(\u0026QueryMsgNFT::\u003cEmpty\u003e::Tokens {\n                owner: USER.to_string(),\n                start_after: None,\n                limit: None,\n            })\n            .unwrap(),\n        }))\n        .unwrap();\n    assert_eq!(vec![\"token_1\",], resp.tokens);\n\n    // try to mint from owner for the same token ID\n    let err = router_ref\n        .execute_contract(\n            helper.delegation_instance.clone(),\n            helper.nft_instance.clone(),\n            \u0026ExecuteMsgNFT::\u003cExtension, Empty\u003e::Mint(MintMsg::\u003cExtension\u003e {\n                token_id: \"token_1\".to_string(),\n                owner: USER.to_string(),\n                token_uri: None,\n                extension: None,\n            }),\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\"token_id already claimed\", err.root_cause().to_string());\n\n    // try to burn nft by token ID\n    let err = router_ref\n        .execute_contract(\n            helper.delegation_instance.clone(),\n            helper.nft_instance.clone(),\n            \u0026ExecuteMsgNFT::\u003cExtension, Empty\u003e::Burn {\n                token_id: \"token_1\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\"Unauthorized\", err.root_cause().to_string());\n\n    // check if token exists\n    let resp = router_ref\n        .wrap()\n        .query::\u003cTokensResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: helper.nft_instance.to_string(),\n            msg: to_binary(\u0026QueryMsgNFT::\u003cEmpty\u003e::Tokens {\n                owner: USER.to_string(),\n                start_after: None,\n                limit: None,\n            })\n            .unwrap(),\n        }))\n        .unwrap();\n    assert_eq!(vec![\"token_1\",], resp.tokens);\n}\n\n#[test]\nfn create_delegation() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let delegator_helper = Helper::init(router_ref, owner);\n\n    // try to create delegation from user with zero voting power\n    let err = delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            5000,\n            WEEK,\n            \"token_1\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"You can't delegate with zero voting power\",\n        err.root_cause().to_string()\n    );\n\n    // Mint ASTRO, stake it and mint xASTRO\n    delegator_helper\n        .escrow_helper\n        .mint_xastro(router_ref, \"user\", 200);\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user\", 200);\n\n    // Create valid voting escrow lock\n    delegator_helper\n        .escrow_helper\n        .create_lock(router_ref, \"user\", WEEK * 2, 100f32)\n        .unwrap();\n    // Check that 100 xASTRO were actually debited\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user\", 100);\n    delegator_helper.escrow_helper.check_xastro_balance(\n        router_ref,\n        delegator_helper.escrow_helper.escrow_instance.as_str(),\n        100,\n    );\n\n    // Mint ASTRO, stake it and mint xASTRO\n    delegator_helper\n        .escrow_helper\n        .mint_xastro(router_ref, \"user2\", 200);\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user2\", 200);\n\n    // Create valid voting escrow lock\n    delegator_helper\n        .escrow_helper\n        .create_lock(router_ref, \"user2\", WEEK * 2, 100f32)\n        .unwrap();\n    // Check that 100 xASTRO were actually debited\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user2\", 100);\n    delegator_helper.escrow_helper.check_xastro_balance(\n        router_ref,\n        delegator_helper.escrow_helper.escrow_instance.as_str(),\n        200,\n    );\n\n    // check user's adjusted balance before create a delegation\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(102_884_614), resp);\n\n    // check user's nft tokens before create a delegation\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // check user2's adjusted balance before create a delegation\n    let user2_vp_before_delegation = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(102_884_614), user2_vp_before_delegation);\n\n    // check user2's nft tokens before create a delegation\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // try to create delegation with the 10_001 bps\n    let err = delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            10001,\n            WEEK,\n            \"token_1\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"Basic points conversion error. The basic points must be from 1 to 10000: 10001\",\n        err.root_cause().to_string()\n    );\n\n    // try to create delegation with the 10_001 bps\n    let err = delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            0,\n            WEEK,\n            \"token_1\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"Basic points conversion error. The basic points must be from 1 to 10000: 0\",\n        err.root_cause().to_string()\n    );\n\n    // create delegation for one week\n    delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            10000,\n            WEEK,\n            \"token_1\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap();\n\n    // try to create delegation with the same token ID\n    let err = delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            10000,\n            WEEK,\n            \"token_1\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"A delegation with a token token_1 already exists.\",\n        err.root_cause().to_string()\n    );\n\n    // try create delegation without free voting power\n    let err = delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            3000,\n            WEEK,\n            \"token_2\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        \"You have already delegated all the voting power.\",\n        err.root_cause().to_string()\n    );\n\n    // check user's nft tokens\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // check user2's nft tokens\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_1\"], resp.tokens);\n\n    // check user's balance after the delegation\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(0), resp);\n\n    // check user2's balance after the delegation\n    let user2_vp_after_delegation = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(205_769_228), user2_vp_after_delegation);\n\n    let user_delegated_vp = delegator_helper\n        .delegated_balance(router_ref, \"user\", None)\n        .unwrap();\n\n    // check user's user_vp_after_delegation + user_delegated_vp = user_vp_before_delegation\n    assert_eq!(\n        user2_vp_after_delegation,\n        user_delegated_vp + user2_vp_before_delegation\n    );\n\n    router_ref.update_block(|block_info| {\n        block_info.time = block_info.time.plus_seconds(WEEK);\n        block_info.height += 1;\n    });\n\n    // check user's adjusted balance when delegation expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(51_442_307), resp);\n\n    // check user2's adjusted balance when delegation expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(51_442_307), resp);\n\n    // try to transfer NFT to user2\n    let err = router_ref\n        .execute_contract(\n            Addr::unchecked(\"user\"),\n            delegator_helper.nft_instance.clone(),\n            \u0026Cw721ExecuteMsg::TransferNft {\n                recipient: \"user2\".to_string(),\n                token_id: \"token_1\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\"Unauthorized\", err.root_cause().to_string());\n}\n\n#[test]\nfn create_multiple_delegation() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let delegator_helper = Helper::init(router_ref, owner);\n\n    // Mint ASTRO, stake it and mint xASTRO\n    delegator_helper\n        .escrow_helper\n        .mint_xastro(router_ref, \"user\", 200);\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user\", 200);\n\n    // Create valid voting escrow lock\n    delegator_helper\n        .escrow_helper\n        .create_lock(router_ref, \"user\", WEEK * 10, 100f32)\n        .unwrap();\n\n    // Check that 100 xASTRO were actually debited\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user\", 100);\n    delegator_helper.escrow_helper.check_xastro_balance(\n        router_ref,\n        delegator_helper.escrow_helper.escrow_instance.as_str(),\n        100,\n    );\n\n    // Mint ASTRO, stake it and mint xASTRO\n    delegator_helper\n        .escrow_helper\n        .mint_xastro(router_ref, \"user2\", 200);\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user2\", 200);\n\n    // Create valid voting escrow lock\n    delegator_helper\n        .escrow_helper\n        .create_lock(router_ref, \"user2\", WEEK * 5, 100f32)\n        .unwrap();\n    // Check that 100 xASTRO were actually debited\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user2\", 100);\n    delegator_helper.escrow_helper.check_xastro_balance(\n        router_ref,\n        delegator_helper.escrow_helper.escrow_instance.as_str(),\n        200,\n    );\n\n    // Mint ASTRO, stake it and mint xASTRO\n    delegator_helper\n        .escrow_helper\n        .mint_xastro(router_ref, \"user3\", 200);\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user3\", 200);\n\n    // Create valid voting escrow lock\n    delegator_helper\n        .escrow_helper\n        .create_lock(router_ref, \"user3\", WEEK, 100f32)\n        .unwrap();\n\n    // Check that 100 xASTRO were actually debited\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user3\", 100);\n    delegator_helper.escrow_helper.check_xastro_balance(\n        router_ref,\n        delegator_helper.escrow_helper.escrow_instance.as_str(),\n        300,\n    );\n\n    // try to create delegation for 1 week for user2\n    delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            3000,\n            WEEK,\n            \"token_1\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap();\n\n    // try to create delegation for 3 weeks for user3\n    delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            3000,\n            WEEK * 3,\n            \"token_2\".to_string(),\n            \"user3\".to_string(),\n        )\n        .unwrap();\n\n    // try to create delegation for 2 weeks for user1\n    let err = delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user3\",\n            3000,\n            WEEK * 2,\n            \"token_3\".to_string(),\n            \"user\".to_string(),\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        \"The delegation period must be at least a week and not more than a user lock period.\",\n        err.root_cause().to_string()\n    );\n\n    // try to create delegation for 1 week for user1\n    delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user3\",\n            3000,\n            WEEK,\n            \"token_3\".to_string(),\n            \"user\".to_string(),\n        )\n        .unwrap();\n\n    // check the user's NFT.\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_3\"], resp.tokens);\n\n    // check user's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(86_499_999), resp);\n\n    // check the user2's NFT.\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_1\"], resp.tokens);\n\n    // check user2's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(141_538_456), resp);\n\n    // check user3's nft tokens\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user3\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_2\"], resp.tokens);\n\n    // check user3's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user3\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(95_038_457), resp);\n\n    router_ref.update_block(|block_info| {\n        block_info.time = block_info.time.plus_seconds(WEEK);\n        block_info.height += 1;\n    });\n\n    // try to create delegation without free voting power\n    let err = delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user3\",\n            3000,\n            WEEK,\n            \"token_4\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        \"You can't delegate with zero voting power\",\n        err.root_cause().to_string()\n    );\n\n    // check user's adjusted balance when one delegation is expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(86_961_535), resp);\n\n    // check user2's adjusted balance when delegation expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(85_769_228), resp);\n\n    // check user3's adjusted balance when lock is expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user3\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(16_019_228), resp);\n\n    // try to transfer NFT with ID `token_1` from user1 to user3\n    let err = router_ref\n        .execute_contract(\n            Addr::unchecked(\"user1\"),\n            delegator_helper.nft_instance.clone(),\n            \u0026Cw721ExecuteMsg::TransferNft {\n                recipient: \"user3\".to_string(),\n                token_id: \"token_1\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\"Unauthorized\", err.root_cause().to_string());\n\n    // try to transfer NFT with ID `token_1` from user2 to user3\n    router_ref\n        .execute_contract(\n            Addr::unchecked(\"user2\"),\n            delegator_helper.nft_instance.clone(),\n            \u0026Cw721ExecuteMsg::TransferNft {\n                recipient: \"user3\".to_string(),\n                token_id: \"token_1\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // check the user's NFT.\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_3\"], resp.tokens);\n\n    // check the user2's NFT.\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // check the user3's NFT.\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user3\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_1\", \"token_2\"], resp.tokens);\n\n    // check user's adjusted balance after transferred token\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(86_961_535), resp);\n\n    // check user2's adjusted balance when delegation expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(85_769_228), resp);\n\n    // check user3's adjusted balance when lock is expired and token_1 is expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user3\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(16_019_228), resp);\n\n    router_ref.update_block(|block_info| {\n        block_info.time = block_info.time.plus_seconds(WEEK * 8);\n        block_info.height += 1;\n    });\n\n    // check the user's NFT.\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_3\"], resp.tokens);\n\n    // check the user2's NFT.\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // check the user3's NFT.\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user3\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_1\", \"token_2\"], resp.tokens);\n\n    // check user's adjusted balance after transferred token\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(11_442_307), resp);\n\n    // check user2's adjusted balance when user2's lock and tokens are expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(0), resp);\n\n    // check user3's adjusted balance when user3's lock and tokens are expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user3\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(0), resp);\n}\n\n#[test]\nfn extend_delegation() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let delegator_helper = Helper::init(router_ref, owner);\n\n    // Mint ASTRO, stake it and mint xASTRO\n    delegator_helper\n        .escrow_helper\n        .mint_xastro(router_ref, \"user\", 100);\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user\", 100);\n\n    // Create valid voting escrow lock\n    delegator_helper\n        .escrow_helper\n        .create_lock(router_ref, \"user\", WEEK * 5, 100f32)\n        .unwrap();\n\n    // Check that 90 xASTRO were actually debited\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user\", 0);\n    delegator_helper.escrow_helper.check_xastro_balance(\n        router_ref,\n        delegator_helper.escrow_helper.escrow_instance.as_str(),\n        100,\n    );\n\n    // Mint ASTRO, stake it and mint xASTRO\n    delegator_helper\n        .escrow_helper\n        .mint_xastro(router_ref, \"user2\", 100);\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user2\", 100);\n\n    // Create valid voting escrow lock\n    delegator_helper\n        .escrow_helper\n        .create_lock(router_ref, \"user2\", WEEK * 2, 100f32)\n        .unwrap();\n    // Check that 90 xASTRO were actually debited\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user2\", 0);\n    delegator_helper.escrow_helper.check_xastro_balance(\n        router_ref,\n        delegator_helper.escrow_helper.escrow_instance.as_str(),\n        200,\n    );\n\n    // try to create delegation to user2\n    delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            5000,\n            WEEK * 3,\n            \"token_1\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap();\n\n    // check user's nft token\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // check user2's nft token\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_1\"], resp.tokens);\n\n    // check user's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(53_605_768), resp);\n\n    // check user2's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(156_490_381), resp);\n\n    router_ref.update_block(|block_info| {\n        block_info.time = block_info.time.plus_seconds(WEEK);\n        block_info.height += 1;\n    });\n\n    // check user's nft token\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // check user2's nft token\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_1\"], resp.tokens);\n\n    // check user's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(50_032_050), resp);\n\n    // check user2's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(87_179_485), resp);\n\n    // check's that we cannot create a delegation for a smaller amount\n    let err = delegator_helper\n        .extend_delegation(router_ref, \"user\", 4000, WEEK * 3, \"token_1\".to_string())\n        .unwrap_err();\n    assert_eq!(\n        \"New delegated voting power can not be less than it was previously.\",\n        err.root_cause().to_string()\n    );\n\n    // try to extend delegation period\n    delegator_helper\n        .extend_delegation(router_ref, \"user\", 6000, WEEK * 3, \"token_1\".to_string())\n        .unwrap();\n\n    // check user's nft token\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // check user2's nft token\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_1\"], resp.tokens);\n\n    // check user's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(34_307_693), resp);\n\n    // check user2's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(102_903_842), resp);\n\n    router_ref.update_block(|block_info| {\n        block_info.time = block_info.time.plus_seconds(WEEK * 3);\n        block_info.height += 1;\n    });\n\n    // check user's nft token\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // check user2's nft token\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_1\"], resp.tokens);\n\n    // check user's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(21_442_307), resp);\n\n    // check user2's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(0), resp);\n\n    // try to extend delegation period\n    let err = delegator_helper\n        .extend_delegation(router_ref, \"user\", 9000, WEEK * 3, \"token_1\".to_string())\n        .unwrap_err();\n    assert_eq!(\n        \"The delegation period must be at least a week and not more than a user lock period.\",\n        err.root_cause().to_string()\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","tests","simulation.rs"],"content":"use anyhow::Result;\nuse astroport_governance::utils::WEEK;\n\nuse crate::test_helper::{mock_app, Helper};\nuse cosmwasm_std::Addr;\nuse cw_multi_test::{next_block, App, AppResponse};\n\nmod test_helper;\n\n#[derive(Clone, Debug)]\nenum Event {\n    CreateDelegation(u16, u64, String, String),\n    ExtendDelegation(u16, u64, String),\n}\n\nuse Event::*;\n\nstruct Simulator {\n    helper: Helper,\n    router: App,\n}\n\nimpl Simulator {\n    fn new() -\u003e Self {\n        let mut router = mock_app();\n        Self {\n            helper: Helper::init(\u0026mut router, Addr::unchecked(\"owner\")),\n            router,\n        }\n    }\n\n    fn mint(\u0026mut self, user: \u0026str, amount: u128) {\n        self.helper\n            .escrow_helper\n            .mint_xastro(\u0026mut self.router, user, amount as u64)\n    }\n\n    fn create_lock(\u0026mut self, user: \u0026str, amount: f64, interval: u64) -\u003e Result\u003cAppResponse\u003e {\n        self.helper\n            .escrow_helper\n            .create_lock(\u0026mut self.router, user, interval, amount as f32)\n    }\n\n    fn app_next_period(\u0026mut self) {\n        self.router.update_block(next_block);\n        self.router\n            .update_block(|block| block.time = block.time.plus_seconds(WEEK));\n    }\n\n    fn create_delegation(\n        \u0026mut self,\n        user: \u0026str,\n        bps: u16,\n        expire_time: u64,\n        token_id: String,\n        recipient: String,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        self.helper.create_delegation(\n            \u0026mut self.router,\n            user,\n            bps,\n            expire_time,\n            token_id,\n            recipient,\n        )\n    }\n\n    fn extend_delegation(\n        \u0026mut self,\n        user: \u0026str,\n        bps: u16,\n        expire_time: u64,\n        token_id: String,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        self.helper\n            .extend_delegation(\u0026mut self.router, user, bps, expire_time, token_id)\n    }\n\n    fn event_router(\u0026mut self, user: \u0026str, event: Event) {\n        println!(\"User {} Event {:?}\", user, event);\n        match event {\n            Event::CreateDelegation(bps, expire_time, token_id, recipient) =\u003e {\n                if let Err(err) =\n                    self.create_delegation(user, bps, expire_time, token_id, recipient)\n                {\n                    dbg!(err);\n                }\n            }\n            Event::ExtendDelegation(percentage, expire_time, token_id) =\u003e {\n                if let Err(err) = self.extend_delegation(user, percentage, expire_time, token_id) {\n                    dbg!(err);\n                }\n            }\n        }\n    }\n}\n\nuse proptest::prelude::*;\n\nconst MAX_PERIOD: usize = 10;\nconst MAX_USERS: usize = 6;\nconst MAX_TOKENS: usize = 10;\nconst MAX_EVENTS: usize = 100;\n\nfn events_strategy() -\u003e impl Strategy\u003cValue = Event\u003e {\n    prop_oneof![\n        (\n            1u16..=100u16,\n            1..MAX_PERIOD,\n            prop::collection::vec(\"[a-z]{4,32}\", 1..MAX_USERS),\n            prop::collection::vec(\"[t-z]{6,32}\", 1..MAX_TOKENS)\n        )\n            .prop_map(|(a, b, c, d)| {\n                Event::CreateDelegation(\n                    a,\n                    WEEK * b as u64,\n                    c.iter().next().unwrap().to_string(),\n                    d.iter().next().unwrap().to_string(),\n                )\n            }),\n        (\n            1u16..=100u16,\n            1..MAX_PERIOD,\n            prop::collection::vec(\"[t-z]{2,32}\", 1..MAX_TOKENS)\n        )\n            .prop_map(|(a, b, c)| {\n                Event::ExtendDelegation(a, WEEK * b as u64, c.iter().next().unwrap().to_string())\n            }),\n    ]\n}\n\nfn generate_cases() -\u003e impl Strategy\u003cValue = (Vec\u003cString\u003e, Vec\u003c(usize, String, String, Event)\u003e)\u003e {\n    let users_strategy = prop::collection::vec(\"[a-z]{4,32}\", 1..MAX_USERS);\n\n    users_strategy.prop_flat_map(|users| {\n        (\n            Just(users.clone()),\n            prop::collection::vec(\n                (\n                    1..=MAX_PERIOD,\n                    prop::sample::select(users.clone()),\n                    prop::sample::select(users.clone()),\n                    events_strategy(),\n                ),\n                0..MAX_EVENTS,\n            ),\n        )\n    })\n}\n\nproptest! {\n    #[test]\n    fn run_simulations\n    (\n        case in generate_cases()\n    ) {\n        let mut events: Vec\u003cVec\u003c(String, String, Event)\u003e\u003e = vec![vec![]; MAX_PERIOD + 1];\n        let (users, events_tuples) = case;\n        for (period, user, recipient, event) in events_tuples {\n            events[period].push((user.to_string(), recipient.to_string(), event));\n        }\n\n        let mut simulator = Simulator::new();\n        for user in users {\n            simulator.mint(user.as_str(), 10000);\n            simulator.create_lock(user.as_str(), 500 as f64, WEEK * 11).unwrap();\n        }\n\n        for period in 1..=MAX_PERIOD {\n            if let Some(period_events) = events.get(period) {\n                if !period_events.is_empty() {\n                    println!(\"Period {}:\", period);\n                }\n                for (user, recipient, event) in period_events {\n                    // check user's balance before the delegation\n                    let user_balance_before = simulator\n                        .helper\n                        .adjusted_balance(\u0026mut simulator.router, user, None)\n                        .unwrap();\n\n                    // check user's delegated balance before the delegation\n                    let user_delegated_balance_before = simulator\n                        .helper\n                        .delegated_balance(\u0026mut simulator.router, user, None)\n                        .unwrap();\n\n                    // check recipient's balance before the delegation\n                    let recipient_balance_before = simulator\n                        .helper\n                        .adjusted_balance(\u0026mut simulator.router, recipient, None)\n                        .unwrap();\n\n                    // check recipient's delegated balance before the delegation\n                    let recipient_delegated_balance_before = simulator\n                        .helper\n                        .delegated_balance(\u0026mut simulator.router, recipient, None)\n                        .unwrap();\n\n                    // try to execute user's event\n                    simulator.event_router(user, event.clone());\n\n                    // check user's balance after the delegation\n                    let user_balance_after = simulator\n                        .helper\n                        .adjusted_balance(\u0026mut simulator.router, user, None)\n                        .unwrap();\n\n                    // check user's delegated balance\n                    let user_delegated_balance_after = simulator\n                        .helper\n                        .delegated_balance(\u0026mut simulator.router, user, None)\n                        .unwrap();\n\n                    // check recipient's balance after the delegation\n                    let recipient_balance_after = simulator\n                        .helper\n                        .adjusted_balance(\u0026mut simulator.router, recipient, None)\n                        .unwrap();\n\n                     // check recipient's delegated balance after the delegation\n                    let recipient_delegated_balance_after = simulator\n                        .helper\n                        .delegated_balance(\u0026mut simulator.router, recipient, None)\n                        .unwrap();\n\n                    // check user's balance\n                    assert_eq!(\n                        user_balance_after,\n                        user_balance_before\n                            - (user_delegated_balance_after - user_delegated_balance_before)\n                    );\n\n                    // check recipient's balance\n                    assert_eq!(\n                        recipient_balance_after,\n                        recipient_balance_before\n                            - (recipient_delegated_balance_after - recipient_delegated_balance_before)\n                    );\n                }\n            }\n\n            simulator.app_next_period()\n        }\n    }\n}\n\n#[test]\nfn exact_simulation() {\n    let case = (\n        [\"user1\", \"user2\"],\n        [\n            (\n                1,\n                \"user1\",\n                \"user2\",\n                CreateDelegation(10000, WEEK * 2, \"token_1\".to_string(), \"user2\".to_string()),\n            ),\n            (\n                1,\n                \"user2\",\n                \"user1\",\n                CreateDelegation(5000, WEEK * 2, \"token_2\".to_string(), \"user1\".to_string()),\n            ),\n            (\n                2,\n                \"user2\",\n                \"user1\",\n                CreateDelegation(3000, WEEK * 2, \"token_3\".to_string(), \"user1\".to_string()),\n            ),\n            (\n                3,\n                \"user2\",\n                \"user1\",\n                ExtendDelegation(7000, WEEK * 5, \"token_2\".to_string()),\n            ),\n            (\n                4,\n                \"user1\",\n                \"user2\",\n                ExtendDelegation(6000, WEEK * 4, \"token_1\".to_string()),\n            ),\n            (\n                5,\n                \"user1\",\n                \"user3\",\n                CreateDelegation(10000, WEEK * 4, \"token_4\".to_string(), \"user3\".to_string()),\n            ),\n            (\n                6,\n                \"user2\",\n                \"user1\",\n                CreateDelegation(10000, WEEK * 4, \"token_5\".to_string(), \"user1\".to_string()),\n            ),\n        ],\n    );\n\n    let mut events: Vec\u003cVec\u003c(String, String, Event)\u003e\u003e = vec![vec![]; MAX_PERIOD + 1];\n    let (users, events_tuples) = case;\n    for (period, user, recipient, event) in events_tuples {\n        events[period].push((user.to_string(), recipient.to_string(), event));\n    }\n\n    let mut simulator = Simulator::new();\n    for user in users {\n        simulator.mint(user, 10000);\n        simulator.create_lock(user, 500 as f64, WEEK * 10).unwrap();\n    }\n\n    for period in 1..=MAX_PERIOD {\n        if let Some(period_events) = events.get(period) {\n            if !period_events.is_empty() {\n                println!(\"Period {}:\", period);\n            }\n            for (user, recipient, event) in period_events {\n                // check user's balance before the delegation\n                let user_balance_before = simulator\n                    .helper\n                    .adjusted_balance(\u0026mut simulator.router, user, None)\n                    .unwrap();\n\n                let user_delegated_balance_before = simulator\n                    .helper\n                    .delegated_balance(\u0026mut simulator.router, user, None)\n                    .unwrap();\n\n                // check recipient's balance before the delegation\n                let recipient_balance_before = simulator\n                    .helper\n                    .adjusted_balance(\u0026mut simulator.router, recipient, None)\n                    .unwrap();\n\n                // try to execute user's event\n                simulator.event_router(user, event.clone());\n\n                // check user's balance after the delegation\n                let user_balance_after = simulator\n                    .helper\n                    .adjusted_balance(\u0026mut simulator.router, user, None)\n                    .unwrap();\n\n                // check user's delegated balance\n                let user_delegated_balance_after = simulator\n                    .helper\n                    .delegated_balance(\u0026mut simulator.router, user, None)\n                    .unwrap();\n\n                // check recipient's balance after the delegation\n                let recipient_balance_after = simulator\n                    .helper\n                    .adjusted_balance(\u0026mut simulator.router, recipient, None)\n                    .unwrap();\n\n                // check user's balance\n                assert_eq!(\n                    user_balance_after,\n                    user_balance_before\n                        - (user_delegated_balance_after - user_delegated_balance_before)\n                );\n\n                // check recipient's balance\n                assert_eq!(\n                    recipient_balance_after,\n                    recipient_balance_before\n                        + (user_delegated_balance_after - user_delegated_balance_before)\n                );\n            }\n        }\n\n        simulator.app_next_period()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","tests","test_helper.rs"],"content":"use anyhow::Result;\nuse astroport_governance::utils::EPOCH_START;\nuse astroport_governance::voting_escrow_delegation::Config;\nuse astroport_governance::voting_escrow_delegation::{InstantiateMsg, QueryMsg};\nuse astroport_tests::escrow_helper::EscrowHelper;\nuse cosmwasm_std::{to_binary, Addr, Empty, QueryRequest, StdResult, Uint128, WasmQuery};\nuse cw_multi_test::{App, AppResponse, Contract, ContractWrapper, Executor};\n\nuse astroport_governance::voting_escrow_delegation::ExecuteMsg;\nuse cw721_base::helpers::Cw721Contract;\n\npub struct Helper {\n    pub escrow_helper: EscrowHelper,\n    pub delegation_instance: Addr,\n    pub nft_instance: Addr,\n    pub nft_helper: Cw721Contract\u003cEmpty, Empty\u003e,\n}\n\nimpl Helper {\n    pub fn contract_escrow_delegation_template() -\u003e Box\u003cdyn Contract\u003cEmpty\u003e\u003e {\n        let contract = ContractWrapper::new_with_empty(\n            voting_escrow_delegation::contract::execute,\n            voting_escrow_delegation::contract::instantiate,\n            voting_escrow_delegation::contract::query,\n        )\n        .with_reply_empty(voting_escrow_delegation::contract::reply);\n        Box::new(contract)\n    }\n\n    pub fn contract_nft_template() -\u003e Box\u003cdyn Contract\u003cEmpty\u003e\u003e {\n        let contract = ContractWrapper::new(\n            astroport_nft::contract::execute,\n            astroport_nft::contract::instantiate,\n            astroport_nft::contract::query,\n        );\n        Box::new(contract)\n    }\n\n    fn instantiate_delegation(\n        router: \u0026mut App,\n        owner: Addr,\n        escrow_addr: Addr,\n        delegation_id: u64,\n        nft_id: u64,\n    ) -\u003e (Addr, Addr) {\n        let delegation_addr = router\n            .instantiate_contract(\n                delegation_id,\n                owner.clone(),\n                \u0026InstantiateMsg {\n                    owner: owner.to_string(),\n                    nft_code_id: nft_id,\n                    voting_escrow_addr: escrow_addr.to_string(),\n                },\n                \u0026[],\n                String::from(\"Astroport Escrow Delegation\"),\n                None,\n            )\n            .unwrap();\n\n        let res = router\n            .wrap()\n            .query::\u003cConfig\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                contract_addr: delegation_addr.to_string(),\n                msg: to_binary(\u0026QueryMsg::Config {}).unwrap(),\n            }))\n            .unwrap();\n\n        (delegation_addr, res.nft_addr)\n    }\n\n    pub fn init(router: \u0026mut App, owner: Addr) -\u003e Self {\n        let escrow_helper = EscrowHelper::init(router, owner.clone());\n\n        let delegation_id = router.store_code(Helper::contract_escrow_delegation_template());\n        let nft_id = router.store_code(Helper::contract_nft_template());\n\n        let (delegation_addr, nft_addr) = Helper::instantiate_delegation(\n            router,\n            owner,\n            escrow_helper.escrow_instance.clone(),\n            delegation_id,\n            nft_id,\n        );\n\n        let nft_helper = cw721_base::helpers::Cw721Contract(\n            nft_addr.clone(),\n            Default::default(),\n            Default::default(),\n        );\n\n        escrow_helper.mint_xastro(router, \"owner\", 1001);\n\n        Helper {\n            escrow_helper,\n            delegation_instance: delegation_addr,\n            nft_instance: nft_addr,\n            nft_helper,\n        }\n    }\n\n    pub fn create_delegation(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        bps: u16,\n        expire_time: u64,\n        token_id: String,\n        recipient: String,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.delegation_instance.clone(),\n            \u0026ExecuteMsg::CreateDelegation {\n                bps,\n                expire_time,\n                token_id,\n                recipient,\n            },\n            \u0026[],\n        )\n    }\n\n    pub fn extend_delegation(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        bps: u16,\n        expire_time: u64,\n        token_id: String,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.delegation_instance.clone(),\n            \u0026ExecuteMsg::ExtendDelegation {\n                bps,\n                expire_time,\n                token_id,\n            },\n            \u0026[],\n        )\n    }\n\n    pub fn adjusted_balance(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        timestamp: Option\u003cu64\u003e,\n    ) -\u003e StdResult\u003cUint128\u003e {\n        router\n            .wrap()\n            .query::\u003cUint128\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                contract_addr: self.delegation_instance.to_string(),\n                msg: to_binary(\u0026QueryMsg::AdjustedBalance {\n                    account: user.to_string(),\n                    timestamp,\n                })\n                .unwrap(),\n            }))\n    }\n\n    pub fn delegated_balance(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        timestamp: Option\u003cu64\u003e,\n    ) -\u003e StdResult\u003cUint128\u003e {\n        router\n            .wrap()\n            .query::\u003cUint128\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                contract_addr: self.delegation_instance.to_string(),\n                msg: to_binary(\u0026QueryMsg::DelegatedVotingPower {\n                    account: user.to_string(),\n                    timestamp,\n                })\n                .unwrap(),\n            }))\n    }\n}\n\npub fn mock_app() -\u003e App {\n    let mut app = App::default();\n\n    app.update_block(|bi| {\n        bi.time = bi.time.plus_seconds(EPOCH_START);\n        bi.height += 1;\n    });\n\n    app\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","assembly.rs"],"content":"// TODO: DO NOT COMMIT\nuse crate::assembly::helpers::is_safe_link;\nuse cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::{Addr, CosmosMsg, Decimal, StdError, StdResult, Uint128, Uint64};\nuse cw20::Cw20ReceiveMsg;\nuse std::fmt::{Display, Formatter, Result};\nuse std::str::FromStr;\n\n#[cfg(not(feature = \"testnet\"))]\nmod proposal_constants {\n    use std::ops::RangeInclusive;\n\n    pub const MINIMUM_PROPOSAL_REQUIRED_THRESHOLD_PERCENTAGE: u64 = 33;\n    pub const MAX_PROPOSAL_REQUIRED_THRESHOLD_PERCENTAGE: u64 = 100;\n    pub const MAX_PROPOSAL_REQUIRED_QUORUM_PERCENTAGE: \u0026str = \"1\";\n    pub const MINIMUM_PROPOSAL_REQUIRED_QUORUM_PERCENTAGE: \u0026str = \"0.01\";\n    pub const VOTING_PERIOD_INTERVAL: RangeInclusive\u003cu64\u003e = 12342..=7 * 12342;\n    // from 0.5 to 1 day in blocks (7 seconds per block)\n    pub const DELAY_INTERVAL: RangeInclusive\u003cu64\u003e = 6171..=14400;\n    pub const EXPIRATION_PERIOD_INTERVAL: RangeInclusive\u003cu64\u003e = 12342..=100_800;\n    // from 10k to 60k $xASTRO\n    pub const DEPOSIT_INTERVAL: RangeInclusive\u003cu128\u003e = 10000000000..=60000000000;\n}\n\n#[cfg(feature = \"testnet\")]\nmod proposal_constants {\n    use std::ops::RangeInclusive;\n\n    pub const MINIMUM_PROPOSAL_REQUIRED_THRESHOLD_PERCENTAGE: u64 = 33;\n    pub const MAX_PROPOSAL_REQUIRED_THRESHOLD_PERCENTAGE: u64 = 100;\n    pub const MAX_PROPOSAL_REQUIRED_QUORUM_PERCENTAGE: \u0026str = \"1\";\n    pub const MINIMUM_PROPOSAL_REQUIRED_QUORUM_PERCENTAGE: \u0026str = \"0.001\";\n    pub const VOTING_PERIOD_INTERVAL: RangeInclusive\u003cu64\u003e = 200..=7 * 12342;\n    // from ~350 sec to 1 day in blocks (7 seconds per block)\n    pub const DELAY_INTERVAL: RangeInclusive\u003cu64\u003e = 50..=14400;\n    pub const EXPIRATION_PERIOD_INTERVAL: RangeInclusive\u003cu64\u003e = 400..=100_800;\n    // from 0.001 to 60k $xASTRO\n    pub const DEPOSIT_INTERVAL: RangeInclusive\u003cu128\u003e = 1000..=60000000000;\n}\n\npub use proposal_constants::*;\n\n/// Proposal validation attributes\nconst MIN_TITLE_LENGTH: usize = 4;\nconst MAX_TITLE_LENGTH: usize = 64;\nconst MIN_DESC_LENGTH: usize = 4;\nconst MAX_DESC_LENGTH: usize = 1024;\nconst MIN_LINK_LENGTH: usize = 12;\nconst MAX_LINK_LENGTH: usize = 128;\n\n/// Special characters that are allowed in proposal text\nconst SAFE_TEXT_CHARS: \u0026str = \"!\u0026?#()*+'-./\\\"\";\n\n/// This structure holds the parameters used for creating an Assembly contract.\n#[cw_serde]\npub struct InstantiateMsg {\n    /// Address of xASTRO token\n    pub xastro_token_addr: String,\n    /// Address of vxASTRO token\n    pub vxastro_token_addr: Option\u003cString\u003e,\n    /// Voting Escrow delegator address\n    pub voting_escrow_delegator_addr: Option\u003cString\u003e,\n    /// Astroport IBC controller contract\n    pub ibc_controller: Option\u003cString\u003e,\n    /// Generator controller contract capable of immediate proposals\n    pub generator_controller_addr: Option\u003cString\u003e,\n    /// Hub contract that handles voting from Outposts\n    pub hub_addr: Option\u003cString\u003e,\n    /// Address of the builder unlock contract\n    pub builder_unlock_addr: String,\n    /// Proposal voting period\n    pub proposal_voting_period: u64,\n    /// Proposal effective delay\n    pub proposal_effective_delay: u64,\n    /// Proposal expiration period\n    pub proposal_expiration_period: u64,\n    /// Proposal required deposit\n    pub proposal_required_deposit: Uint128,\n    /// Proposal required quorum\n    pub proposal_required_quorum: String,\n    /// Proposal required threshold\n    pub proposal_required_threshold: String,\n    /// Whitelisted links\n    pub whitelisted_links: Vec\u003cString\u003e,\n}\n\n/// This enum describes all execute functions available in the contract.\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Receive a message of type [`Cw20ReceiveMsg`]\n    Receive(Cw20ReceiveMsg),\n    /// Cast a vote for an active proposal\n    CastVote {\n        /// Proposal identifier\n        proposal_id: u64,\n        /// Vote option\n        vote: ProposalVoteOption,\n    },\n    /// Cast a vote on an Assembly proposal from an Outpost via the Hub\n    CastOutpostVote {\n        /// Proposal identifier\n        proposal_id: u64,\n        /// The voter from an Outpost\n        voter: Addr,\n        /// The vote option\n        vote: ProposalVoteOption,\n        /// The voting power applied to this vote\n        voting_power: Uint128,\n    },\n    /// Set the status of a proposal that expired\n    EndProposal {\n        /// Proposal identifier\n        proposal_id: u64,\n    },\n    /// Checks that proposal messages are correct.\n    CheckMessages {\n        /// messages\n        messages: Vec\u003cCosmosMsg\u003e,\n    },\n    /// The last endpoint which is executed only if all proposal messages have been passed\n    CheckMessagesPassed {},\n    /// Execute a successful proposal\n    ExecuteProposal {\n        /// Proposal identifier\n        proposal_id: u64,\n    },\n    /// Load and execute a special emissions proposal. This proposal is passed\n    /// immediately and is not subject to voting as it is coming from the\n    /// generator controller based on emission votes.\n    ExecuteEmissionsProposal {\n        title: String,\n        description: String,\n        messages: Vec\u003cCosmosMsg\u003e,\n        /// If proposal should be executed on a remote chain this field should specify governance channel\n        ibc_channel: Option\u003cString\u003e,\n    },\n    /// Remove a proposal that was already executed (or failed/expired)\n    RemoveCompletedProposal {\n        /// Proposal identifier\n        proposal_id: u64,\n    },\n    /// Update parameters in the Assembly contract\n    /// ## Executor\n    /// Only the Assembly contract is allowed to update its own parameters\n    UpdateConfig(Box\u003cUpdateConfig\u003e),\n    /// Update proposal status InProgress -\u003e Executed or Failed.\n    /// ## Executor\n    /// Only the IBC controller contract is allowed to call this method.\n    IBCProposalCompleted {\n        proposal_id: u64,\n        status: ProposalStatus,\n    },\n}\n\n/// Thie enum describes all the queries available in the contract.\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// Return the contract's configuration\n    #[returns(Config)]\n    Config {},\n    /// Return the current list of proposals\n    #[returns(ProposalListResponse)]\n    Proposals {\n        /// Id from which to start querying\n        start: Option\u003cu64\u003e,\n        /// The amount of proposals to return\n        limit: Option\u003cu32\u003e,\n    },\n    /// Return proposal voters of specified proposal\n    #[returns(Vec\u003cAddr\u003e)]\n    ProposalVoters {\n        /// Proposal unique id\n        proposal_id: u64,\n        /// Proposal vote option\n        vote_option: ProposalVoteOption,\n        /// Id from which to start querying\n        start: Option\u003cu64\u003e,\n        /// The amount of proposals to return\n        limit: Option\u003cu32\u003e,\n    },\n    /// Return information about a specific proposal\n    #[returns(Proposal)]\n    Proposal { proposal_id: u64 },\n    /// Return information about the votes cast on a specific proposal\n    #[returns(ProposalVotesResponse)]\n    ProposalVotes { proposal_id: u64 },\n    /// Return user voting power for a specific proposal\n    #[returns(Uint128)]\n    UserVotingPower { user: String, proposal_id: u64 },\n    /// Return total voting power for a specific proposal\n    #[returns(Uint128)]\n    TotalVotingPower { proposal_id: u64 },\n}\n\n/// This structure stores data for a CW20 hook message.\n#[cw_serde]\npub enum Cw20HookMsg {\n    /// Submit a new proposal in the Assembly\n    SubmitProposal {\n        title: String,\n        description: String,\n        link: Option\u003cString\u003e,\n        messages: Option\u003cVec\u003cCosmosMsg\u003e\u003e,\n        /// If proposal should be executed on a remote chain this field should specify governance channel\n        ibc_channel: Option\u003cString\u003e,\n    },\n}\n\n/// This structure stores general parameters for the Assembly contract.\n#[cw_serde]\npub struct Config {\n    /// xASTRO token address\n    pub xastro_token_addr: Addr,\n    /// vxASTRO token address\n    pub vxastro_token_addr: Option\u003cAddr\u003e,\n    /// Voting Escrow delegator address\n    pub voting_escrow_delegator_addr: Option\u003cAddr\u003e,\n    /// Astroport IBC controller contract\n    pub ibc_controller: Option\u003cAddr\u003e,\n    /// Generator controller contract capable of immediate proposals\n    pub generator_controller: Option\u003cAddr\u003e,\n    /// Hub contract that handles voting from Outposts\n    pub hub: Option\u003cAddr\u003e,\n    /// Builder unlock contract address\n    pub builder_unlock_addr: Addr,\n    /// Proposal voting period\n    pub proposal_voting_period: u64,\n    /// Proposal effective delay\n    pub proposal_effective_delay: u64,\n    /// Proposal expiration period\n    pub proposal_expiration_period: u64,\n    /// Proposal required deposit\n    pub proposal_required_deposit: Uint128,\n    /// Proposal required quorum\n    pub proposal_required_quorum: Decimal,\n    /// Proposal required threshold\n    pub proposal_required_threshold: Decimal,\n    /// Whitelisted links\n    pub whitelisted_links: Vec\u003cString\u003e,\n}\n\nimpl Config {\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        if self.proposal_required_threshold\n            \u003e Decimal::percent(MAX_PROPOSAL_REQUIRED_THRESHOLD_PERCENTAGE)\n            || self.proposal_required_threshold\n                \u003c Decimal::percent(MINIMUM_PROPOSAL_REQUIRED_THRESHOLD_PERCENTAGE)\n        {\n            return Err(StdError::generic_err(format!(\n                \"The required threshold for a proposal cannot be lower than {MINIMUM_PROPOSAL_REQUIRED_THRESHOLD_PERCENTAGE}% or higher than {MAX_PROPOSAL_REQUIRED_THRESHOLD_PERCENTAGE}%\"\n            )));\n        }\n\n        let max_quorum = Decimal::from_str(MAX_PROPOSAL_REQUIRED_QUORUM_PERCENTAGE)?;\n        let min_quorum = Decimal::from_str(MINIMUM_PROPOSAL_REQUIRED_QUORUM_PERCENTAGE)?;\n        if self.proposal_required_quorum \u003e max_quorum || self.proposal_required_quorum \u003c min_quorum\n        {\n            return Err(StdError::generic_err(format!(\n                \"The required quorum for a proposal cannot be lower than {}% or higher than {}%\",\n                min_quorum * Decimal::from_ratio(100u8, 1u8),\n                max_quorum * Decimal::from_ratio(100u8, 1u8)\n            )));\n        }\n\n        if !DELAY_INTERVAL.contains(\u0026self.proposal_effective_delay) {\n            return Err(StdError::generic_err(format!(\n                \"The effective delay for a proposal cannot be lower than {} or higher than {}\",\n                DELAY_INTERVAL.start(),\n                DELAY_INTERVAL.end()\n            )));\n        }\n\n        if !EXPIRATION_PERIOD_INTERVAL.contains(\u0026self.proposal_expiration_period) {\n            return Err(StdError::generic_err(format!(\n                \"The expiration period for a proposal cannot be lower than {} or higher than {}\",\n                EXPIRATION_PERIOD_INTERVAL.start(),\n                EXPIRATION_PERIOD_INTERVAL.end()\n            )));\n        }\n\n        if !VOTING_PERIOD_INTERVAL.contains(\u0026self.proposal_voting_period) {\n            return Err(StdError::generic_err(format!(\n                \"The voting period for a proposal should be more than {} or less than {} blocks.\",\n                VOTING_PERIOD_INTERVAL.start(),\n                VOTING_PERIOD_INTERVAL.end()\n            )));\n        }\n\n        if !DEPOSIT_INTERVAL.contains(\u0026self.proposal_required_deposit.u128()) {\n            return Err(StdError::generic_err(format!(\n                \"The required deposit for a proposal cannot be lower than {} or higher than {}\",\n                DEPOSIT_INTERVAL.start(),\n                DEPOSIT_INTERVAL.end()\n            )));\n        }\n\n        if self.voting_escrow_delegator_addr.is_some() \u0026\u0026 self.vxastro_token_addr.is_none() {\n            return Err(StdError::generic_err(\n                \"The Voting Escrow contract should be specified to use the Voting Escrow Delegator contract.\"\n            ));\n        }\n\n        Ok(())\n    }\n}\n\n/// This structure stores the params used when updating the main Assembly contract params.\n#[cw_serde]\npub struct UpdateConfig {\n    /// xASTRO token address\n    pub xastro_token_addr: Option\u003cString\u003e,\n    /// vxASTRO token address\n    pub vxastro_token_addr: Option\u003cString\u003e,\n    /// Voting Escrow delegator address\n    pub voting_escrow_delegator_addr: Option\u003cString\u003e,\n    /// Astroport IBC controller contract\n    pub ibc_controller: Option\u003cString\u003e,\n    /// Generator controller contract capable of immediate proposals\n    pub generator_controller: Option\u003cString\u003e,\n    /// Hub contract that handles voting from Outposts\n    pub hub: Option\u003cString\u003e,\n    /// Builder unlock contract address\n    pub builder_unlock_addr: Option\u003cString\u003e,\n    /// Proposal voting period\n    pub proposal_voting_period: Option\u003cu64\u003e,\n    /// Proposal effective delay\n    pub proposal_effective_delay: Option\u003cu64\u003e,\n    /// Proposal expiration period\n    pub proposal_expiration_period: Option\u003cu64\u003e,\n    /// Proposal required deposit\n    pub proposal_required_deposit: Option\u003cu128\u003e,\n    /// Proposal required quorum\n    pub proposal_required_quorum: Option\u003cString\u003e,\n    /// Proposal required threshold\n    pub proposal_required_threshold: Option\u003cString\u003e,\n    /// Links to remove from whitelist\n    pub whitelist_remove: Option\u003cVec\u003cString\u003e\u003e,\n    /// Links to add to whitelist\n    pub whitelist_add: Option\u003cVec\u003cString\u003e\u003e,\n}\n\n/// This structure stores data for a proposal.\n#[cw_serde]\npub struct Proposal {\n    /// Unique proposal ID\n    pub proposal_id: Uint64,\n    /// The address of the proposal submitter\n    pub submitter: Addr,\n    /// Status of the proposal\n    pub status: ProposalStatus,\n    /// `For` power of proposal\n    pub for_power: Uint128,\n    /// `Against` power of proposal\n    pub against_power: Uint128,\n    /// `For` votes for the proposal\n    pub for_voters: Vec\u003cAddr\u003e,\n    /// `Against` votes for the proposal\n    pub against_voters: Vec\u003cAddr\u003e,\n    /// Start block of proposal\n    pub start_block: u64,\n    /// Start time of proposal\n    pub start_time: u64,\n    /// End block of proposal\n    pub end_block: u64,\n    /// Delayed end block of proposal\n    pub delayed_end_block: u64,\n    /// Expiration block of proposal\n    pub expiration_block: u64,\n    /// Proposal title\n    pub title: String,\n    /// Proposal description\n    pub description: String,\n    /// Proposal link\n    pub link: Option\u003cString\u003e,\n    /// Proposal messages\n    pub messages: Option\u003cVec\u003cCosmosMsg\u003e\u003e,\n    /// Amount of xASTRO deposited in order to post the proposal\n    pub deposit_amount: Uint128,\n    /// IBC channel\n    pub ibc_channel: Option\u003cString\u003e,\n}\n\nimpl Proposal {\n    pub fn validate(\u0026self, whitelisted_links: Vec\u003cString\u003e) -\u003e StdResult\u003c()\u003e {\n        // Title validation\n        if self.title.len() \u003c MIN_TITLE_LENGTH {\n            return Err(StdError::generic_err(\"Title too short!\"));\n        }\n        if self.title.len() \u003e MAX_TITLE_LENGTH {\n            return Err(StdError::generic_err(\"Title too long!\"));\n        }\n        if !self.title.chars().all(|c| {\n            c.is_ascii_alphanumeric() || c.is_ascii_whitespace() || SAFE_TEXT_CHARS.contains(c)\n        }) {\n            return Err(StdError::generic_err(\n                \"Title is not in alphanumeric format!\",\n            ));\n        }\n\n        // Description validation\n        if self.description.len() \u003c MIN_DESC_LENGTH {\n            return Err(StdError::generic_err(\"Description too short!\"));\n        }\n        if self.description.len() \u003e MAX_DESC_LENGTH {\n            return Err(StdError::generic_err(\"Description too long!\"));\n        }\n        if !self.description.chars().all(|c| {\n            c.is_ascii_alphanumeric() || c.is_ascii_whitespace() || SAFE_TEXT_CHARS.contains(c)\n        }) {\n            return Err(StdError::generic_err(\n                \"Description is not in alphanumeric format\",\n            ));\n        }\n\n        // Link validation\n        if let Some(link) = \u0026self.link {\n            if link.len() \u003c MIN_LINK_LENGTH {\n                return Err(StdError::generic_err(\"Link too short!\"));\n            }\n            if link.len() \u003e MAX_LINK_LENGTH {\n                return Err(StdError::generic_err(\"Link too long!\"));\n            }\n            if !whitelisted_links.iter().any(|wl| link.starts_with(wl)) {\n                return Err(StdError::generic_err(\"Link is not whitelisted!\"));\n            }\n            if !is_safe_link(link) {\n                return Err(StdError::generic_err(\n                    \"Link is not properly formatted or contains unsafe characters!\",\n                ));\n            }\n        }\n\n        Ok(())\n    }\n}\n\n/// This enum describes available statuses/states for a Proposal.\n#[cw_serde]\npub enum ProposalStatus {\n    Active,\n    Passed,\n    Rejected,\n    InProgress,\n    Failed,\n    Executed,\n    Expired,\n}\n\nimpl Display for ProposalStatus {\n    fn fmt(\u0026self, fmt: \u0026mut Formatter) -\u003e Result {\n        match self {\n            ProposalStatus::Active {} =\u003e fmt.write_str(\"active\"),\n            ProposalStatus::Passed {} =\u003e fmt.write_str(\"passed\"),\n            ProposalStatus::Rejected {} =\u003e fmt.write_str(\"rejected\"),\n            ProposalStatus::InProgress =\u003e fmt.write_str(\"in_progress\"),\n            ProposalStatus::Failed =\u003e fmt.write_str(\"failed\"),\n            ProposalStatus::Executed {} =\u003e fmt.write_str(\"executed\"),\n            ProposalStatus::Expired {} =\u003e fmt.write_str(\"expired\"),\n        }\n    }\n}\n\n/// This structure describes a proposal vote.\n#[cw_serde]\npub struct ProposalVote {\n    /// Voted option for the proposal\n    pub option: ProposalVoteOption,\n    /// Vote power\n    pub power: Uint128,\n}\n\n/// This enum describes available options for voting on a proposal.\n#[cw_serde]\npub enum ProposalVoteOption {\n    For,\n    Against,\n}\n\nimpl Display for ProposalVoteOption {\n    fn fmt(\u0026self, fmt: \u0026mut Formatter) -\u003e Result {\n        match self {\n            ProposalVoteOption::For {} =\u003e fmt.write_str(\"for\"),\n            ProposalVoteOption::Against {} =\u003e fmt.write_str(\"against\"),\n        }\n    }\n}\n\n/// This structure describes a proposal vote response.\n#[cw_serde]\npub struct ProposalVotesResponse {\n    /// Proposal identifier\n    pub proposal_id: u64,\n    /// Total amount of `for` votes for a proposal\n    pub for_power: Uint128,\n    /// Total amount of `against` votes for a proposal.\n    pub against_power: Uint128,\n}\n\n/// This structure describes a proposal list response.\n#[cw_serde]\npub struct ProposalListResponse {\n    /// The amount of proposals returned\n    pub proposal_count: Uint64,\n    /// The list of proposals that are returned\n    pub proposal_list: Vec\u003cProposal\u003e,\n}\n\npub mod helpers {\n    use cosmwasm_std::{StdError, StdResult};\n\n    const SAFE_LINK_CHARS: \u0026str = \"-_:/?#@!$\u0026()*+,;=.~[]'%\";\n\n    /// Checks if the link is valid. Returns a boolean value.\n    pub fn is_safe_link(link: \u0026str) -\u003e bool {\n        link.chars()\n            .all(|c| c.is_ascii_alphanumeric() || SAFE_LINK_CHARS.contains(c))\n    }\n\n    /// Validating the list of links. Returns an error if a list has an invalid link.\n    pub fn validate_links(links: \u0026[String]) -\u003e StdResult\u003c()\u003e {\n        for link in links {\n            if !(is_safe_link(link) \u0026\u0026 link.contains('.') \u0026\u0026 link.ends_with('/')) {\n                return Err(StdError::generic_err(format!(\n                    \"Link is not properly formatted or contains unsafe characters: {link}.\"\n                )));\n            }\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":244,"address":[6554112],"length":1,"stats":{"Line":0},"fn_name":"validate"},{"line":245,"address":[6554151,6554291,6554201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[6554163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[6554277,6554227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[6554239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[6554402],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[6554664,6554320,6554806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[6554874,6554962,6554728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[6554938,6555030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[6555311,6555211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[6555120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[6555254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[6555085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[6555637,6555592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[6555571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[6555616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[6555536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[6555916,6555961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[6555895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[6555940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[6555860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[6556311,6556266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[6556245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[6556290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[6556184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[6556580,6556625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[6556559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[6556604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[6556536,6556840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[6556906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[6556895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[6556976,6558502],"length":1,"stats":{"Line":0},"fn_name":"validate"},{"line":387,"address":[6557034,6557108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[6557144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[6557228,6557122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[6557272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[6557242,6557350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[6923405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[6557474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[6557452,6557544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[6557580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[6557558,6557650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[6557693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[6557666,6557768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[6923517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[6557891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[6557852,6557958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[6558016,6557966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[6558039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[6558106,6558027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[6558143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[6558122,6558215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[6558338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[6558321,6558410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[6558440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[6557994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[6558544],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":452,"address":[6558562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[6558597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[6558630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[6558663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[6558693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[6558723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[6558753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[6558783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[6558832],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":482,"address":[6558851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[6558869],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[6558900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[6942256],"length":1,"stats":{"Line":0},"fn_name":"is_safe_link"},{"line":516,"address":[6942270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[7440653,7440640],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":521,"address":[6942320],"length":1,"stats":{"Line":0},"fn_name":"validate_links"},{"line":522,"address":[6942451,6942377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[6942461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[6942589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[6942440],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":77},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","builder_unlock.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, StdError, Uint128};\n\n/// This structure stores general parameters for the builder unlock contract.\n#[cw_serde]\npub struct Config {\n    /// Account that can create new unlock schedules\n    pub owner: Addr,\n    /// Address of ASTRO token\n    pub astro_token: Addr,\n    /// Max ASTRO tokens to allocate\n    pub max_allocations_amount: Uint128,\n}\n\n/// This structure stores the total and the remaining amount of ASTRO to be unlocked by all accounts.\n#[cw_serde]\n#[derive(Default)]\npub struct State {\n    /// Amount of ASTRO tokens deposited into the contract\n    pub total_astro_deposited: Uint128,\n    /// Currently available ASTRO tokens that still need to be unlocked and/or withdrawn\n    pub remaining_astro_tokens: Uint128,\n    /// Amount of ASTRO tokens deposited into the contract but not assigned to an allocation\n    pub unallocated_tokens: Uint128,\n}\n\n/// This structure stores the parameters describing a typical unlock schedule.\n#[cw_serde]\n#[derive(Default)]\npub struct Schedule {\n    /// Timestamp for the start of the unlock schedule (in seconds)\n    pub start_time: u64,\n    /// Cliff period during which no tokens can be withdrawn out of the contract\n    pub cliff: u64,\n    /// Time after the cliff during which the remaining tokens linearly unlock\n    pub duration: u64,\n}\n\n/// This structure stores the parameters used to describe an ASTRO allocation.\n#[cw_serde]\n#[derive(Default)]\npub struct AllocationParams {\n    /// Total amount of ASTRO tokens allocated to a specific account\n    pub amount: Uint128,\n    /// Parameters controlling the unlocking process\n    pub unlock_schedule: Schedule,\n    /// Proposed new receiver who will get the ASTRO allocation\n    pub proposed_receiver: Option\u003cAddr\u003e,\n}\n\nimpl AllocationParams {\n    pub fn validate(\u0026self, account: \u0026str) -\u003e Result\u003c(), StdError\u003e {\n        if self.unlock_schedule.cliff \u003e= self.unlock_schedule.duration {\n            return Err(StdError::generic_err(format!(\n                \"The new cliff value must be less than the duration: {} \u003c {}. Account: {}\",\n                self.unlock_schedule.cliff, self.unlock_schedule.duration, account\n            )));\n        };\n\n        if self.amount.is_zero() {\n            return Err(StdError::generic_err(format!(\n                \"Amount must not be zero. Account: {account}\"\n            )));\n        }\n\n        if self.proposed_receiver.is_some() {\n            return Err(StdError::generic_err(format!(\n                \"Proposed receiver must be unset. Account: {account}\"\n            )));\n        }\n\n        Ok(())\n    }\n\n    pub fn update_schedule(\n        \u0026mut self,\n        new_schedule: Schedule,\n        account: \u0026String,\n    ) -\u003e Result\u003c(), StdError\u003e {\n        if new_schedule.cliff \u003c self.unlock_schedule.cliff {\n            return Err(StdError::generic_err(format!(\n                \"The new cliff value should be greater than or equal to the old one: {} \u003e= {}. Account error: {}\",\n                new_schedule.cliff, self.unlock_schedule.cliff, account\n            )));\n        }\n\n        if new_schedule.start_time \u003c self.unlock_schedule.start_time {\n            return Err(StdError::generic_err(format!(\n                \"The new start time should be later than or equal to the old one: {} \u003e= {}. Account error: {}\",\n                new_schedule.start_time, self.unlock_schedule.start_time, account\n            )));\n        }\n\n        if new_schedule.duration \u003c self.unlock_schedule.duration {\n            return Err(StdError::generic_err(format!(\n                \"The new duration value should be greater than or equal to the old one: {} \u003e= {}. Account error: {}\",\n                new_schedule.duration, self.unlock_schedule.duration, account\n            )));\n        }\n\n        self.unlock_schedule = new_schedule;\n        Ok(())\n    }\n}\n\n/// This structure stores the parameters used to describe the status of an allocation.\n#[cw_serde]\n#[derive(Default)]\npub struct AllocationStatus {\n    /// Amount of ASTRO already withdrawn\n    pub astro_withdrawn: Uint128,\n    /// Already unlocked amount after decreasing\n    pub unlocked_amount_checkpoint: Uint128,\n}\n\nimpl AllocationStatus {\n    pub const fn new() -\u003e Self {\n        Self {\n            astro_withdrawn: Uint128::zero(),\n            unlocked_amount_checkpoint: Uint128::zero(),\n        }\n    }\n}\n\npub mod msg {\n    use crate::builder_unlock::Schedule;\n    use cosmwasm_schema::{cw_serde, QueryResponses};\n    use cosmwasm_std::Uint128;\n    use cw20::Cw20ReceiveMsg;\n\n    use super::{AllocationParams, AllocationStatus, Config};\n\n    /// This structure holds the initial parameters used to instantiate the contract.\n    #[cw_serde]\n    pub struct InstantiateMsg {\n        /// Account that can create new allocations\n        pub owner: String,\n        /// ASTRO token address\n        pub astro_token: String,\n        /// Max ASTRO tokens to allocate\n        pub max_allocations_amount: Uint128,\n    }\n\n    /// This enum describes all the execute functions available in the contract.\n    #[cw_serde]\n    pub enum ExecuteMsg {\n        /// Receive is an implementation for the CW20 receive msg\n        Receive(Cw20ReceiveMsg),\n        /// Withdraw claims withdrawable ASTRO\n        Withdraw {},\n        /// ProposeNewReceiver allows a user to change the receiver address for their ASTRO allocation\n        ProposeNewReceiver { new_receiver: String },\n        /// DropNewReceiver allows a user to remove the previously proposed new receiver for their ASTRO allocation\n        DropNewReceiver {},\n        /// ClaimReceiver allows newly proposed receivers to claim ASTRO allocations ownership\n        ClaimReceiver { prev_receiver: String },\n        /// Increase the ASTRO allocation of a receiver\n        IncreaseAllocation { receiver: String, amount: Uint128 },\n        /// Decrease the ASTRO allocation of a receiver\n        DecreaseAllocation { receiver: String, amount: Uint128 },\n        /// Transfer unallocated tokens (only accessible to the owner)\n        TransferUnallocated {\n            amount: Uint128,\n            recipient: Option\u003cString\u003e,\n        },\n        /// Propose a new owner for the contract\n        ProposeNewOwner { new_owner: String, expires_in: u64 },\n        /// Remove the ownership transfer proposal\n        DropOwnershipProposal {},\n        /// Claim contract ownership\n        ClaimOwnership {},\n        /// Update parameters in the contract configuration\n        UpdateConfig { new_max_allocations_amount: Uint128 },\n        /// Update a schedule of allocation for specified accounts\n        UpdateUnlockSchedules {\n            new_unlock_schedules: Vec\u003c(String, Schedule)\u003e,\n        },\n    }\n\n    /// This enum describes receive msg templates.\n    #[cw_serde]\n    pub enum ReceiveMsg {\n        /// CreateAllocations creates new ASTRO allocations\n        CreateAllocations {\n            allocations: Vec\u003c(String, AllocationParams)\u003e,\n        },\n        /// Increase the ASTRO allocation for a receiver\n        IncreaseAllocation { user: String, amount: Uint128 },\n    }\n\n    /// Thie enum describes all the queries available in the contract.\n    #[cw_serde]\n    #[derive(QueryResponses)]\n    pub enum QueryMsg {\n        /// Config returns the configuration for this contract\n        #[returns(Config)]\n        Config {},\n        /// State returns the state of this contract\n        #[returns(StateResponse)]\n        State {},\n        /// Allocation returns the parameters and current status of an allocation\n        #[returns(AllocationResponse)]\n        Allocation {\n            /// Account whose allocation status we query\n            account: String,\n        },\n        /// Allocations returns a vector that contains builder unlock allocations by specified\n        /// parameters\n        #[returns(Vec\u003c(String, AllocationParams)\u003e)]\n        Allocations {\n            start_after: Option\u003cString\u003e,\n            limit: Option\u003cu32\u003e,\n        },\n        #[returns(Uint128)]\n        /// UnlockedTokens returns the unlocked tokens from an allocation\n        UnlockedTokens {\n            /// Account whose amount of unlocked ASTRO we query for\n            account: String,\n        },\n        /// SimulateWithdraw simulates how many ASTRO will be released if a withdrawal is attempted\n        #[returns(SimulateWithdrawResponse)]\n        SimulateWithdraw {\n            /// Account for which we simulate a withdrawal\n            account: String,\n            /// Timestamp used to simulate how much ASTRO the account can withdraw\n            timestamp: Option\u003cu64\u003e,\n        },\n    }\n\n    pub type ConfigResponse = Config;\n\n    /// This structure stores the parameters used to return the response when querying for an allocation data.\n    #[cw_serde]\n    pub struct AllocationResponse {\n        /// The allocation parameters\n        pub params: AllocationParams,\n        /// The allocation status\n        pub status: AllocationStatus,\n    }\n\n    /// This structure stores the parameters used to return a response when simulating a withdrawal.\n    #[cw_serde]\n    pub struct SimulateWithdrawResponse {\n        /// Amount of ASTRO to receive\n        pub astro_to_withdraw: Uint128,\n    }\n\n    /// This structure stores parameters used to return the response when querying for the contract state.\n    #[cw_serde]\n    pub struct StateResponse {\n        /// ASTRO tokens deposited into the contract and that are meant to unlock\n        pub total_astro_deposited: Uint128,\n        /// Currently available ASTRO tokens that weren't yet withdrawn from the contract\n        pub remaining_astro_tokens: Uint128,\n        /// Currently available ASTRO tokens to withdraw or increase allocations by the owner\n        pub unallocated_astro_tokens: Uint128,\n    }\n}\n","traces":[{"line":52,"address":[6887600],"length":1,"stats":{"Line":0},"fn_name":"validate"},{"line":53,"address":[16533688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[16533727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[16533703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[16534045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[16534022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[6888196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[6888185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[6888384],"length":1,"stats":{"Line":0},"fn_name":"update_schedule"},{"line":80,"address":[6888430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[6888473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[6888450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[6888805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[6888781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[6889138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[6889099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[6889122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[6889440],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":119,"address":[6889457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[6889472],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":20},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","escrow_fee_distributor.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::{Addr, Uint128};\nuse cw20::Cw20ReceiveMsg;\n\n/// This structure describes the basic settings for creating a contract.\n#[cw_serde]\npub struct InstantiateMsg {\n    /// Admin address\n    pub owner: String,\n    /// Fee token address\n    pub astro_token: String,\n    /// Voting escrow contract address\n    pub voting_escrow_addr: String,\n    /// Max limit of addresses to claim rewards for in a single call\n    pub claim_many_limit: Option\u003cu64\u003e,\n    /// Whether reward claiming is disabled\n    pub is_claim_disabled: Option\u003cbool\u003e,\n}\n\n/// This structure describes the execute messages available in the contract.\n#[cw_serde]\npub enum ExecuteMsg {\n    /// ProposeNewOwner creates a request to change contract ownership\n    ProposeNewOwner {\n        /// The newly proposed owner\n        owner: String,\n        /// The validity period of the offer to change the contract owner\n        expires_in: u64,\n    },\n    /// DropOwnershipProposal removes the request to change contract ownership\n    DropOwnershipProposal {},\n    /// ClaimOwnership claims contract ownership\n    ClaimOwnership {},\n    /// Claim claims staking rewards for a single staker and sends them to the specified recipient\n    Claim {\n        recipient: Option\u003cString\u003e,\n        max_periods: Option\u003cu64\u003e,\n    },\n    /// ClaimMany claims staking rewards for multiple addresses in a single call\n    ClaimMany { receivers: Vec\u003cString\u003e },\n    /// UpdateConfig updates the contract configuration\n    UpdateConfig {\n        /// Max limit of addresses to claim rewards for in a single call\n        claim_many_limit: Option\u003cu64\u003e,\n        /// Whether reward claiming is disabled\n        is_claim_disabled: Option\u003cbool\u003e,\n    },\n    /// Receive receives a message of type [`Cw20ReceiveMsg`] and processes it depending on the received template\n    Receive(Cw20ReceiveMsg),\n}\n\n/// This structure describes query messages available in the contract.\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// Config returns control settings using a custom [`ConfigResponse`] structure\n    #[returns(ConfigResponse)]\n    Config {},\n    /// UserReward returns the reward amount that can be claimed by a staker in the form of ASTRO at a specified timestamp\n    #[returns(Uint128)]\n    UserReward { user: String, timestamp: u64 },\n    /// AvailableRewardPerWeek returns a vector that contains the total reward amount per week distributed to vxASTRO stakers\n    #[returns(Vec\u003cUint128\u003e)]\n    AvailableRewardPerWeek {\n        start_after: Option\u003cu64\u003e,\n        limit: Option\u003cu64\u003e,\n    },\n}\n\n/// This structure describes the parameters returned when querying for the contract configuration.\n#[cw_serde]\npub struct ConfigResponse {\n    /// Address that's allowed to change contract parameters\n    pub owner: Addr,\n    /// Fee token address (ASTRO token)\n    pub astro_token: Addr,\n    /// Voting escrow contract address\n    pub voting_escrow_addr: Addr,\n    /// Max limit of addresses to claim rewards for in a single call\n    pub claim_many_limit: u64,\n    /// Wthether reward claiming is disabled\n    pub is_claim_disabled: bool,\n}\n\n/// This structure describes a migration message.\n#[cw_serde]\npub struct MigrateMsg {}\n\n/// This structure describes custom hooks for a CW20.\n#[cw_serde]\npub enum Cw20HookMsg {\n    /// ReceiveTokens receives tokens into the contract and triggers a vxASTRO checkpoint.\n    ReceiveTokens {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","generator_controller.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::{Addr, Decimal, Uint128};\n\n/// The maximum amount of voters that can be kicked at once from\npub const VOTERS_MAX_LIMIT: u32 = 30;\n\n/// This structure describes the basic settings for creating a contract.\n#[cw_serde]\npub struct InstantiateMsg {\n    /// Contract owner\n    pub owner: String,\n    /// The vxASTRO token contract address\n    pub escrow_addr: String,\n    /// Generator contract address\n    pub generator_addr: String,\n    /// Factory contract address\n    pub factory_addr: String,\n    /// Max number of pools that can receive ASTRO emissions at the same time\n    pub pools_limit: u64,\n    /// The list of pools which are eligible to receive votes\n    pub whitelisted_pools: Vec\u003cString\u003e,\n}\n\n/// This structure describes the execute messages available in the contract.\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Removes all votes applied by blacklisted voters\n    KickBlacklistedVoters { blacklisted_voters: Vec\u003cString\u003e },\n    /// Vote allows a vxASTRO holder to cast votes on which generators should get ASTRO emissions in the next epoch\n    Vote { votes: Vec\u003c(String, u16)\u003e },\n    /// TunePools transforms the latest vote distribution into alloc_points which are then applied to ASTRO generators\n    TunePools {},\n    UpdateConfig {\n        /// The number of voters that can be kicked at once from the pool..\n        blacklisted_voters_limit: Option\u003cu32\u003e,\n        /// Main pool that will receive a minimum amount of ASTRO emissions\n        main_pool: Option\u003cString\u003e,\n        /// The minimum percentage of ASTRO emissions that main pool should get every block\n        main_pool_min_alloc: Option\u003cDecimal\u003e,\n        /// Should the main pool be removed or not? If the variable is omitted then the pool will be kept.\n        remove_main_pool: Option\u003cbool\u003e,\n    },\n    /// ChangePoolsLimit changes the max amount of pools that can be voted at once to receive ASTRO emissions\n    ChangePoolsLimit { limit: u64 },\n    /// ProposeNewOwner proposes a new owner for the contract\n    ProposeNewOwner {\n        /// Newly proposed contract owner\n        new_owner: String,\n        /// The timestamp when the contract ownership change expires\n        expires_in: u64,\n    },\n    /// DropOwnershipProposal removes the latest contract ownership transfer proposal\n    DropOwnershipProposal {},\n    /// ClaimOwnership allows the newly proposed owner to claim contract ownership\n    ClaimOwnership {},\n    /// Adds or removes the pools which are eligible to receive votes\n    UpdateWhitelist {\n        add: Option\u003cVec\u003cString\u003e\u003e,\n        remove: Option\u003cVec\u003cString\u003e\u003e,\n    },\n}\n\n/// This structure describes the query messages available in the contract.\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// UserInfo returns information about a voter and the generators they voted for\n    #[returns(UserInfoResponse)]\n    UserInfo { user: String },\n    /// TuneInfo returns information about the latest generators that were voted to receive ASTRO emissions\n    #[returns(GaugeInfoResponse)]\n    TuneInfo {},\n    /// Config returns the contract configuration\n    #[returns(ConfigResponse)]\n    Config {},\n    /// PoolInfo returns the latest voting power allocated to a specific pool (generator)\n    #[returns(VotedPoolInfoResponse)]\n    PoolInfo { pool_addr: String },\n    /// PoolInfo returns the voting power allocated to a specific pool (generator) at a specific period\n    #[returns(VotedPoolInfoResponse)]\n    PoolInfoAtPeriod { pool_addr: String, period: u64 },\n}\n\n/// This structure describes a migration message.\n/// We currently take no arguments for migrations.\n#[cw_serde]\npub struct MigrateMsg {}\n\n/// This structure describes the parameters returned when querying for the contract configuration.\n#[cw_serde]\npub struct ConfigResponse {\n    /// Address that's allowed to change contract parameters\n    pub owner: Addr,\n    /// The vxASTRO token contract address\n    pub escrow_addr: Addr,\n    /// Generator contract address\n    pub generator_addr: Addr,\n    /// Factory contract address\n    pub factory_addr: Addr,\n    /// Max number of pools that can receive ASTRO emissions at the same time\n    pub pools_limit: u64,\n    /// Max number of blacklisted voters which can be removed\n    pub blacklisted_voters_limit: Option\u003cu32\u003e,\n    /// Main pool that will receive a minimum amount of ASTRO emissions\n    pub main_pool: Option\u003cAddr\u003e,\n    /// The minimum percentage of ASTRO emissions that main pool should get every block\n    pub main_pool_min_alloc: Decimal,\n    /// The list of pools which are eligible to receive votes\n    pub whitelisted_pools: Vec\u003cAddr\u003e,\n}\n\n/// This structure describes the response used to return voting information for a specific pool (generator).\n#[cw_serde]\n#[derive(Default)]\npub struct VotedPoolInfoResponse {\n    /// vxASTRO amount that voted for this pool/generator\n    pub vxastro_amount: Uint128,\n    /// The slope at which the amount of vxASTRO that voted for this pool/generator will decay\n    pub slope: Uint128,\n}\n\n/// This structure describes the response used to return tuning parameters for all pools/generators.\n#[cw_serde]\n#[derive(Default)]\npub struct GaugeInfoResponse {\n    /// Last timestamp when a tuning vote happened\n    pub tune_ts: u64,\n    /// Distribution of alloc_points to apply in the Generator contract\n    pub pool_alloc_points: Vec\u003c(String, Uint128)\u003e,\n}\n\n/// The struct describes a response used to return a staker's vxASTRO lock position.\n#[cw_serde]\n#[derive(Default)]\npub struct UserInfoResponse {\n    /// Last timestamp when the user voted\n    pub vote_ts: u64,\n    /// The user's vxASTRO voting power\n    pub voting_power: Uint128,\n    /// The slope at which the user's voting power decays\n    pub slope: Uint128,\n    /// Timestamp when the user's lock expires\n    pub lock_end: u64,\n    /// The vote distribution for all the generators/pools the staker picked\n    pub votes: Vec\u003c(Addr, u16)\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","generator_controller_lite.rs"],"content":"// TODO: DO NOT COMMIT - THIS IS INCLUDED IN ANOTHER PR\nuse cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::{Addr, Decimal, Uint128};\n\n/// The maximum amount of voters that can be kicked at once from\npub const VOTERS_MAX_LIMIT: u32 = 30;\n\n/// This structure describes the basic settings for creating a contract.\n#[cw_serde]\npub struct InstantiateMsg {\n    /// Contract owner\n    pub owner: String,\n    /// The vxASTRO token contract address\n    pub escrow_addr: String,\n    /// Generator contract address\n    pub generator_addr: String,\n    /// Factory contract address\n    pub factory_addr: String,\n    /// Assembly contract address\n    pub assembly_addr: String,\n    /// Hub contract address\n    pub hub_addr: Option\u003cString\u003e,\n    /// Max number of pools that can receive ASTRO emissions at the same time\n    pub pools_limit: u64,\n    /// The list of pools which are eligible to receive votes\n    pub whitelisted_pools: Vec\u003cString\u003e,\n    /// Prefix for addresses on this network\n    pub address_prefix: String,\n}\n\n/// This structure describes the execute messages available in the contract.\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Removes all votes applied by blacklisted voters\n    KickBlacklistedVoters { blacklisted_voters: Vec\u003cString\u003e },\n    /// Removes all votes applied by voters that have unlocked\n    KickUnlockedVoters { unlocked_voters: Vec\u003cString\u003e },\n    /// Removes all votes applied by a voter that have unlocked on an Outpost\n    KickUnlockedOutpostVoter { unlocked_voter: Addr },\n    /// Vote allows a vxASTRO holder to cast votes on which generators should get ASTRO emissions in the next epoch\n    Vote { votes: Vec\u003c(String, u16)\u003e },\n    /// OutpostVote allows a vxASTRO holder on an Outpost to cast votes on which generators should get ASTRO emissions in the next epoch\n    OutpostVote {\n        voter: Addr,\n        voting_power: Uint128,\n        votes: Vec\u003c(String, u16)\u003e,\n    },\n    /// TunePools transforms the latest vote distribution into alloc_points which are then applied to ASTRO generators\n    TunePools {},\n    UpdateConfig {\n        // Assembly contract address\n        assembly_addr: Option\u003cString\u003e,\n        /// The number of voters that can be kicked at once from the pool..\n        kick_voters_limit: Option\u003cu32\u003e,\n        /// Main pool that will receive a minimum amount of ASTRO emissions\n        main_pool: Option\u003cString\u003e,\n        /// The minimum percentage of ASTRO emissions that main pool should get every block\n        main_pool_min_alloc: Option\u003cDecimal\u003e,\n        /// Should the main pool be removed or not? If the variable is omitted then the pool will be kept.\n        remove_main_pool: Option\u003cbool\u003e,\n        // Hub contract address\n        hub_addr: Option\u003cString\u003e,\n    },\n    /// ChangePoolsLimit changes the max amount of pools that can be voted at once to receive ASTRO emissions\n    ChangePoolsLimit { limit: u64 },\n    /// ProposeNewOwner proposes a new owner for the contract\n    ProposeNewOwner {\n        /// Newly proposed contract owner\n        new_owner: String,\n        /// The timestamp when the contract ownership change expires\n        expires_in: u64,\n    },\n    /// DropOwnershipProposal removes the latest contract ownership transfer proposal\n    DropOwnershipProposal {},\n    /// ClaimOwnership allows the newly proposed owner to claim contract ownership\n    ClaimOwnership {},\n    /// Adds or removes the pools which are eligible to receive votes\n    UpdateWhitelist {\n        add: Option\u003cVec\u003cString\u003e\u003e,\n        remove: Option\u003cVec\u003cString\u003e\u003e,\n    },\n    // Update network config for IBC\n    UpdateNetworks {\n        // Adding requires a list of (network, address prefix, IBC governance channel)\n        add: Option\u003cVec\u003cNetworkInfo\u003e\u003e,\n        remove: Option\u003cVec\u003cString\u003e\u003e,\n    },\n}\n\n/// This structure describes the query messages available in the contract.\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// UserInfo returns information about a voter and the generators they voted for\n    #[returns(UserInfoResponse)]\n    UserInfo { user: String },\n    /// TuneInfo returns information about the latest generators that were voted to receive ASTRO emissions\n    #[returns(GaugeInfoResponse)]\n    TuneInfo {},\n    /// Config returns the contract configuration\n    #[returns(ConfigResponse)]\n    Config {},\n    /// PoolInfo returns the latest voting power allocated to a specific pool (generator)\n    #[returns(VotedPoolInfoResponse)]\n    PoolInfo { pool_addr: String },\n    /// PoolInfo returns the voting power allocated to a specific pool (generator) at a specific period\n    #[returns(VotedPoolInfoResponse)]\n    PoolInfoAtPeriod { pool_addr: String, period: u64 },\n}\n\n/// This structure describes a migration message.\n/// We currently take no arguments for migrations.\n#[cw_serde]\npub struct MigrateMsg {}\n\n/// This structure describes the parameters returned when querying for the contract configuration.\n#[cw_serde]\npub struct ConfigResponse {\n    /// Address that's allowed to change contract parameters\n    pub owner: Addr,\n    /// The vxASTRO token contract address\n    pub escrow_addr: Addr,\n    /// Generator contract address\n    pub generator_addr: Addr,\n    /// Factory contract address\n    pub factory_addr: Addr,\n    /// Assembly contract address\n    pub assembly_addr: Addr,\n    /// Hub contract address\n    pub hub_addr: Option\u003cAddr\u003e,\n    /// Max number of pools that can receive ASTRO emissions at the same time\n    pub pools_limit: u64,\n    /// Max number of voters which can be kicked at a time\n    pub kick_voters_limit: Option\u003cu32\u003e,\n    /// Main pool that will receive a minimum amount of ASTRO emissions\n    pub main_pool: Option\u003cAddr\u003e,\n    /// The minimum percentage of ASTRO emissions that main pool should get every block\n    pub main_pool_min_alloc: Decimal,\n    /// The list of pools which are eligible to receive votes\n    pub whitelisted_pools: Vec\u003cAddr\u003e,\n    /// The list of pools which are eligible to receive votes\n    pub whitelisted_networks: Vec\u003cNetworkInfo\u003e,\n}\n\n/// This structure describes the response used to return voting information for a specific pool (generator).\n#[cw_serde]\n#[derive(Default)]\npub struct VotedPoolInfoResponse {\n    /// vxASTRO amount that voted for this pool/generator\n    pub vxastro_amount: Uint128,\n    /// The slope at which the amount of vxASTRO that voted for this pool/generator will decay\n    pub slope: Uint128,\n}\n\n/// This structure describes the response used to return tuning parameters for all pools/generators.\n#[cw_serde]\n#[derive(Default)]\npub struct GaugeInfoResponse {\n    /// Last period when a tuning was applied\n    pub tune_period: u64,\n    /// Distribution of alloc_points to apply in the Generator contract\n    pub pool_alloc_points: Vec\u003c(String, Uint128)\u003e,\n}\n\n/// The struct describes a response used to return a staker's vxASTRO lock position.\n#[cw_serde]\n#[derive(Default)]\npub struct UserInfoResponse {\n    /// The period when the user voted last time, None if they've never voted\n    pub vote_period: Option\u003cu64\u003e,\n    /// The user's vxASTRO voting power\n    pub voting_power: Uint128,\n    /// The vote distribution for all the generators/pools the staker picked\n    pub votes: Vec\u003c(Addr, u16)\u003e,\n}\n\n#[cw_serde]\n#[derive(Eq, Hash)]\npub struct NetworkInfo {\n    /// The address prefix for the network, e.g. \"terra\"\n    pub address_prefix: String,\n    /// The address of the generator contract on the Outpost\n    pub generator_address: Addr,\n    /// The IBC channel used for governance\n    pub ibc_channel: Option\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","hub.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::Addr;\nuse cw20::Cw20ReceiveMsg;\n\n/// Holds the parameters used for creating a Hub contract\n#[cw_serde]\npub struct InstantiateMsg {\n    /// The contract owner\n    pub owner: String,\n    /// The address of the Assembly contract on the Hub\n    pub assembly_addr: String,\n    /// The address of the CW20-ICS20 contract on the Hub that supports\n    /// memo handling\n    pub cw20_ics20_addr: String,\n    /// The address of the xASTRO staking contract on the Hub\n    pub staking_addr: String,\n    /// The address of the generator controller contract on the Hub\n    pub generator_controller_addr: String,\n    /// The timeout in seconds for IBC packets\n    pub ibc_timeout_seconds: u64,\n}\n\n/// The contract migration message\n/// We currently take no arguments for migrations\n#[cw_serde]\npub struct MigrateMsg {}\n\n/// Describes the execute messages available in the contract\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Receive a message of type [`Cw20ReceiveMsg`]\n    Receive(Cw20ReceiveMsg),\n    /// Update parameters in the Hub contract. Only the owner is allowed to\n    /// update the config\n    UpdateConfig {\n        /// The new address of the Assembly on the Hub, ignored if None\n        assembly_addr: Option\u003cString\u003e,\n        /// The new address of the CW20-ICS20 contract on the Hub that\n        /// supports memo handling, ignored if None\n        cw20_ics20_addr: Option\u003cString\u003e,\n    },\n    /// Add a new Outpost to the Hub. Only allowed Outposts can send IBC messages\n    AddOutpost {\n        /// The remote contract address of the Outpost to add\n        outpost_addr: String,\n        /// The channel to use for CW20-ICS20 IBC transfers\n        cw20_ics20_channel: String,\n    },\n    /// Remove an Outpost from the Hub\n    RemoveOutpost {\n        /// The remote contract address of the Outpost to remove\n        outpost_addr: String,\n    },\n    /// Propose a new owner for the contract\n    ProposeNewOwner { new_owner: String, expires_in: u64 },\n    /// Remove the ownership transfer proposal\n    DropOwnershipProposal {},\n    /// Claim contract ownership\n    ClaimOwnership {},\n}\n\n/// Messages handled via CW20 transfers\n#[cw_serde]\npub enum Cw20HookMsg {\n    /// Handles instructions received via an IBC transfer memo in the\n    /// CW20-ICS20 contract\n    OutpostMemo {\n        /// The channel the memo was received on\n        channel: String,\n        /// The original sender of the packet on the outpost\n        sender: String,\n        /// The original intended receiver of the packet on the Hub\n        receiver: String,\n        /// The memo containing the JSON to handle\n        memo: String,\n    },\n    /// Handle failed CW20 IBC transfers\n    TransferFailure {\n        // The original sender where the funds should be returned to\n        receiver: String,\n    },\n}\n\n/// Describes the query messages available in the contract\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// Returns the config of the Hub\n    #[returns(Config)]\n    Config {},\n    /// Returns the list of the current Outposts on the Hub\n    #[returns(Vec\u003cOutpostConfig\u003e)]\n    Outposts {},\n}\n\n/// The config of the Hub\n#[cw_serde]\npub struct Config {\n    /// The owner of the contract\n    pub owner: Addr,\n    /// The address of the Assembly contract on the Hub\n    pub assembly_addr: Addr,\n    /// The address of the CW20-ICS20 contract on the Hub that supports memo\n    /// handling\n    pub cw20_ics20_addr: Addr,\n    /// The address of the ASTRO token contract on the Hub\n    pub token_addr: Addr,\n    /// The address of the xASTRO token contract on the Hub\n    pub xtoken_addr: Addr,\n    /// The address of the staking contract on the Hub\n    pub staking_addr: Addr,\n    /// The address of the generator controller contract on the Hub\n    pub generator_controller_addr: Addr,\n    /// The timeout in seconds for IBC packets\n    pub ibc_timeout_seconds: u64,\n}\n\n/// A response containing the Outpost address and channels\n#[cw_serde]\npub struct OutpostConfig {\n    /// The address of the Outpost contract on another chain\n    pub address: String,\n    /// The channel connecting the Hub contract with that Outpost contract\n    pub channel: String,\n    /// The CS20-ICS20 channel ASTRO is transferred through\n    pub cw20_ics20_channel: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","interchain.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Uint128};\nuse std::fmt::{Display, Formatter, Result};\n\nuse crate::assembly::{Proposal, ProposalVoteOption};\n\n// TODO: This will come from the new CW20-ICS20 contract once it is merged\n// IGNORE\n#[cw_serde]\npub struct TransferMsg {\n    /// The local channel to send the packets on\n    pub channel: String,\n    /// The remote address to send to.\n    /// Don't use HumanAddress as this will likely have a different Bech32 prefix than we use\n    /// and cannot be validated locally\n    pub remote_address: String,\n    /// How long the packet lives in seconds. If not specified, use default_timeout\n    pub timeout: Option\u003cu64\u003e,\n    /// An optional memo to add to the IBC transfer\n    pub memo: Option\u003cString\u003e,\n}\n// END IGNORE\n\n/// Hub defines the messages that can be sent from an Outpost to the Hub\n#[cw_serde]\npub enum Hub {\n    /// Queries the Assembly for a proposal by ID via the Hub\n    QueryProposal {\n        /// The ID of the proposal to query\n        id: u64,\n    },\n    /// Cast a vote on an Assembly proposal\n    CastAssemblyVote {\n        /// The ID of the proposal to vote on\n        proposal_id: u64,\n        /// The address of the voter\n        voter: Addr,\n        /// The vote choice\n        vote_option: ProposalVoteOption,\n        /// The voting power held by the voter, in this case xASTRO holdings\n        voting_power: Uint128,\n    },\n    /// Cast a vote during an emissions voting period\n    CastEmissionsVote {\n        /// The address of the voter\n        voter: Addr,\n        /// The voting power held by the voter, in this case vxASTRO  lite holdings\n        voting_power: Uint128,\n        /// The votes in the format (pool address, percent of voting power)\n        votes: Vec\u003c(String, u16)\u003e,\n    },\n    /// Stake ASTRO tokens for xASTRO\n    Stake {},\n    /// Unstake xASTRO tokens for ASTRO\n    Unstake {\n        // The user requesting the unstake and that should receive it\n        receiver: String,\n        /// The amount of xASTRO to unstake\n        amount: Uint128,\n    },\n    /// Kick an unlocked voter's voting power from the Generator Controller lite\n    KickUnlockedVoter {\n        /// The address of the voter to kick\n        voter: Addr,\n    },\n    /// Withdraw stuck funds from the Hub in case of specific IBC failures\n    WithdrawFunds {\n        /// The address of the user to withdraw funds for\n        user: Addr,\n    },\n}\n\n/// Defines the messages that can be sent from the Hub to an Outpost\n#[cw_serde]\npub enum Outpost {\n    /// Mint xASTRO tokens for the user\n    MintXAstro { receiver: String, amount: Uint128 },\n}\n\n/// Defines the messages that can be returned in response to an IBC Hub or\n/// Outpost message\n#[cw_serde]\npub enum Response {\n    /// The response to a QueryProposal message that includes a minimal Proposal\n    QueryProposal(Box\u003cProposal\u003e),\n    /// A generic response to a Hub/Outpost message, mostly used for indicating success\n    /// or error handling\n    Result {\n        /// The action that was performed, None if no specific action was taken\n        action: Option\u003cString\u003e,\n        /// The address of the user that took the action, None if the result\n        /// isn't specific to an address\n        address: Option\u003cString\u003e,\n        /// The error message, if None, the action was successful\n        error: Option\u003cString\u003e,\n    },\n}\n\n/// Utility functions for InterchainResponse to ease creation of responses\nimpl Response {\n    /// Create a new success response that sets address and action but leaves\n    /// error as None\n    pub fn new_success(action: String, address: String) -\u003e Self {\n        Response::Result {\n            action: Some(action),\n            address: Some(address),\n            error: None,\n        }\n    }\n    /// Create a new error response that sets address and action to None\n    /// while adding the error message\n    pub fn new_error(error: String) -\u003e Self {\n        Response::Result {\n            action: None,\n            address: None,\n            error: Some(error),\n        }\n    }\n}\n\n// TODO: Is this needed? Can we use #[derive(Debug)] instead\n/// Implements Display for Hub\nimpl Display for Hub {\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e Result {\n        write!(\n            f,\n            \"{}\",\n            match self {\n                Hub::Stake { .. } =\u003e \"stake\",\n                Hub::CastAssemblyVote { .. } =\u003e \"cast_assembly_vote\",\n                Hub::CastEmissionsVote { .. } =\u003e \"cast_emissions_vote\",\n                Hub::QueryProposal { .. } =\u003e \"query_proposal\",\n                Hub::Unstake { .. } =\u003e \"unstake\",\n                Hub::KickUnlockedVoter { .. } =\u003e \"kick_unlocked_voter\",\n                Hub::WithdrawFunds { .. } =\u003e \"withdraw_funds\",\n            }\n        )\n    }\n}\n\n// TODO: Is this needed? Can we use #[derive(Debug)] instead\n/// Implements Display for Outpost\nimpl Display for Outpost {\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e Result {\n        write!(\n            f,\n            \"{}\",\n            match self {\n                Outpost::MintXAstro { .. } =\u003e \"MintXAstro\",\n            }\n        )\n    }\n}\n\n/// Get the address from an IBC port. If the port is prefixed with `wasm.`,\n/// strip it out, if not, return the port as is.\npub fn get_contract_from_ibc_port(ibc_port: \u0026str) -\u003e \u0026str {\n    match ibc_port.strip_prefix(\"wasm.\") {\n        Some(suffix) =\u003e suffix, // prints: inj1234\n        None =\u003e ibc_port,\n    }\n}\n","traces":[{"line":103,"address":[15880704],"length":1,"stats":{"Line":1},"fn_name":"new_success"},{"line":105,"address":[15880711],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[15880736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[15880864],"length":1,"stats":{"Line":1},"fn_name":"new_error"},{"line":116,"address":[15880889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[15881008],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":125,"address":[15881220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[6234979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[6235082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[6235036],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[6235059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[6235010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[6235105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[6235128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[6235151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[6235264],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":145,"address":[6235282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[6235376],"length":1,"stats":{"Line":4},"fn_name":"get_contract_from_ibc_port"},{"line":158,"address":[6235400],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[6235479],"length":1,"stats":{"Line":4},"fn_name":null},{"line":160,"address":[6235467],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":8,"coverable":21},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","lib.rs"],"content":"pub mod assembly;\npub mod builder_unlock;\npub mod escrow_fee_distributor;\npub mod generator_controller;\npub mod generator_controller_lite;\npub mod hub;\npub mod interchain;\npub mod nft;\npub mod outpost;\npub mod utils;\npub mod voting_escrow;\npub mod voting_escrow_delegation;\npub mod voting_escrow_lite;\n\npub use astroport;\n\n// Default pagination constants\npub const DEFAULT_LIMIT: u32 = 10;\npub const MAX_LIMIT: u32 = 30;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","nft.rs"],"content":"use cosmwasm_schema::cw_serde;\n\n/// This structure describes a migration message.\n#[cw_serde]\npub struct MigrateMsg {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","outpost.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::Addr;\nuse cw20::Cw20ReceiveMsg;\n\nuse crate::assembly::ProposalVoteOption;\n\n/// Holds the parameters used for creating an Outpost contract\n#[cw_serde]\npub struct InstantiateMsg {\n    /// The contract owner\n    pub owner: String,\n    /// The address of the xASTRO token contract on the Outpost\n    pub xastro_token_addr: String,\n    /// The address of the vxASTRO lite contract on the Outpost\n    pub vxastro_token_addr: String,\n    /// The address of the Hub contract on the Hub chain\n    pub hub_addr: String,\n    /// The timeout in seconds for IBC packets\n    pub ibc_timeout_seconds: u64,\n}\n\n/// The contract migration message\n/// We currently take no arguments for migrations\n#[cw_serde]\npub struct MigrateMsg {}\n\n/// Describes the execute messages available in the contract\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Receive a message of type [`Cw20ReceiveMsg`]\n    Receive(Cw20ReceiveMsg),\n    /// Update parameters in the Outpost contract. Only the owner is allowed to\n    /// update the config\n    UpdateConfig {\n        /// The new Hub address\n        hub_addr: Option\u003cString\u003e,\n    },\n    /// Cast a vote on an Assembly proposal from an Outpost\n    CastAssemblyVote {\n        /// The ID of the proposal to vote on\n        proposal_id: u64,\n        /// The vote choice\n        vote: ProposalVoteOption,\n    },\n    /// Cast a vote during an emissions voting period\n    CastEmissionsVote {\n        /// The votes in the format (pool address, percent of voting power)\n        votes: Vec\u003c(String, u16)\u003e,\n    },\n    /// Kick an unlocked voter's voting power from the Generator Controller lite\n    KickUnlocked {\n        /// The address of the user to kick\n        user: Addr,\n    },\n    /// Withdraw stuck funds from the Hub in case of specific IBC failures\n    WithdrawHubFunds {},\n    /// Propose a new owner for the contract\n    ProposeNewOwner { new_owner: String, expires_in: u64 },\n    /// Remove the ownership transfer proposal\n    DropOwnershipProposal {},\n    /// Claim contract ownership\n    ClaimOwnership {},\n}\n\n/// Messages handled via CW20 transfers\n#[cw_serde]\npub enum Cw20HookMsg {\n    /// Unstake xASTRO from the Hub and return the ASTRO to the sender\n    Unstake {},\n}\n\n/// Describes the query messages available in the contract\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// Returns the config of the Outpost\n    #[returns(Config)]\n    Config {},\n}\n\n/// The config of the Outpost\n#[cw_serde]\npub struct Config {\n    /// The owner of the contract\n    pub owner: Addr,\n    /// The address of the Hub contract on the Hub chain    \n    pub hub_addr: Addr,\n    /// The channel used to communicate with the Hub\n    pub hub_channel: Option\u003cString\u003e,\n    /// The address of the xASTRO token contract on the Outpost\n    pub xastro_token_addr: Addr,\n    /// The address of the vxASTRO lite contract on the Outpost\n    pub vxastro_token_addr: Addr,\n    /// The timeout in seconds for IBC packets\n    pub ibc_timeout_seconds: u64,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","utils.rs"],"content":"use std::convert::TryInto;\n\nuse cosmwasm_std::{Decimal, Fraction, OverflowError, StdError, StdResult, Uint128, Uint256};\n\n/// Seconds in one week. It is intended for period number calculation.\npub const WEEK: u64 = 7 * 86400; // lock period is rounded down by week\n\n/// Seconds in 2 years which is the maximum lock period.\npub const MAX_LOCK_TIME: u64 = 2 * 365 * 86400; // 2 years (104 weeks)\n\n/// The constant describes the maximum number of accounts for which to claim accrued staking rewards in a single transaction.\npub const CLAIM_LIMIT: u64 = 10;\n\n/// The constant describes the minimum number of accounts for claim.\npub const MIN_CLAIM_LIMIT: u64 = 2;\n\n/// Feb 28 2022 00:00 UTC, Monday\npub const EPOCH_START: u64 = 1646006400;\n\n/// Calculates the period number. Time should be formatted as a timestamp.\npub fn get_period(time: u64) -\u003e StdResult\u003cu64\u003e {\n    if time \u003c EPOCH_START {\n        Err(StdError::generic_err(\"Invalid time\"))\n    } else {\n        Ok((time - EPOCH_START) / WEEK)\n    }\n}\n\n/// Calculates how many periods are in the specified time interval. The time should be in seconds.\npub fn get_periods_count(interval: u64) -\u003e u64 {\n    interval / WEEK\n}\n\n/// This trait was implemented to eliminate Decimal rounding problems.\ntrait DecimalRoundedCheckedMul {\n    fn checked_mul(self, other: Uint128) -\u003e Result\u003cUint128, OverflowError\u003e;\n}\n\npub trait DecimalCheckedOps {\n    fn checked_add(self, other: Decimal) -\u003e Result\u003cDecimal, OverflowError\u003e;\n    fn checked_mul_uint128(self, other: Uint128) -\u003e Result\u003cUint128, OverflowError\u003e;\n}\n\nimpl DecimalRoundedCheckedMul for Decimal {\n    fn checked_mul(self, other: Uint128) -\u003e Result\u003cUint128, OverflowError\u003e {\n        if self.is_zero() || other.is_zero() {\n            return Ok(Uint128::zero());\n        }\n        let numerator = other.full_mul(self.numerator());\n        let multiply_ratio = numerator / Uint256::from(self.denominator());\n        if multiply_ratio \u003e Uint256::from(Uint128::MAX) {\n            Err(OverflowError::new(\n                cosmwasm_std::OverflowOperation::Mul,\n                self,\n                other,\n            ))\n        } else {\n            let mut result: Uint128 = multiply_ratio.try_into().unwrap();\n            let rem: Uint128 = numerator\n                .checked_rem(Uint256::from(self.denominator()))\n                .unwrap()\n                .try_into()\n                .unwrap();\n            // 0.5 in Decimal\n            if rem.u128() \u003e= 500000000000000000_u128 {\n                result += Uint128::from(1_u128);\n            }\n            Ok(result)\n        }\n    }\n}\n\nimpl DecimalCheckedOps for Decimal {\n    fn checked_add(self, other: Decimal) -\u003e Result\u003cDecimal, OverflowError\u003e {\n        self.numerator()\n            .checked_add(other.numerator())\n            .map(|_| self + other)\n    }\n    fn checked_mul_uint128(self, other: Uint128) -\u003e Result\u003cUint128, OverflowError\u003e {\n        if self.is_zero() || other.is_zero() {\n            return Ok(Uint128::zero());\n        }\n        let multiply_ratio = other.full_mul(self.numerator()) / Uint256::from(self.denominator());\n        if multiply_ratio \u003e Uint256::from(Uint128::MAX) {\n            Err(OverflowError::new(\n                cosmwasm_std::OverflowOperation::Mul,\n                self,\n                other,\n            ))\n        } else {\n            Ok(multiply_ratio.try_into().unwrap())\n        }\n    }\n}\n\n/// Main function used to calculate a user's voting power at a specific period as: previous_power - slope*(x - previous_x).\npub fn calc_voting_power(\n    slope: Uint128,\n    old_vp: Uint128,\n    start_period: u64,\n    end_period: u64,\n) -\u003e Uint128 {\n    let shift = slope\n        .checked_mul(Uint128::from(end_period - start_period))\n        .unwrap_or_else(|_| Uint128::zero());\n    old_vp.saturating_sub(shift)\n}\n","traces":[{"line":45,"address":[6465472],"length":1,"stats":{"Line":0},"fn_name":"checked_mul"},{"line":46,"address":[16111557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[16111824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[16111612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[16111647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[16112268,16112305,16111765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[16112203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[16111861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[6465989,6465920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[6465954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[6466113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[6466262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[6466230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[6466304],"length":1,"stats":{"Line":0},"fn_name":"checked_add"},{"line":75,"address":[6466427,6466385,6466341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[6466360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[7330144,7330168],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":79,"address":[16112512],"length":1,"stats":{"Line":0},"fn_name":"checked_mul_uint128"},{"line":80,"address":[6466501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[6466701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[6466556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[6466832,6466899,6466645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[6466834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[6466738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[7330217,7330208],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"}],"covered":0,"coverable":25},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","voting_escrow.rs"],"content":"use crate::voting_escrow::QueryMsg::{\n    LockInfo, TotalVotingPower, TotalVotingPowerAt, UserVotingPower, UserVotingPowerAt,\n};\nuse cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::{Addr, Binary, Decimal, QuerierWrapper, StdResult, Uint128};\nuse cw20::{\n    BalanceResponse, Cw20ReceiveMsg, DownloadLogoResponse, Logo, MarketingInfoResponse,\n    TokenInfoResponse,\n};\nuse std::fmt;\n\n/// ## Pagination settings\n/// The maximum amount of items that can be read at once from\npub const MAX_LIMIT: u32 = 30;\n\n/// The default amount of items to read from\npub const DEFAULT_LIMIT: u32 = 10;\n\npub const DEFAULT_PERIODS_LIMIT: u64 = 20;\n\n/// This structure stores marketing information for vxASTRO.\n#[cw_serde]\npub struct UpdateMarketingInfo {\n    /// Project URL\n    pub project: Option\u003cString\u003e,\n    /// Token description\n    pub description: Option\u003cString\u003e,\n    /// Token marketing information\n    pub marketing: Option\u003cString\u003e,\n    /// Token logo\n    pub logo: Option\u003cLogo\u003e,\n}\n\n/// This structure stores general parameters for the vxASTRO contract.\n#[cw_serde]\npub struct InstantiateMsg {\n    /// The vxASTRO contract owner\n    pub owner: String,\n    /// Address that's allowed to black or whitelist contracts\n    pub guardian_addr: Option\u003cString\u003e,\n    /// xASTRO token address\n    pub deposit_token_addr: String,\n    /// Marketing info for vxASTRO\n    pub marketing: Option\u003cUpdateMarketingInfo\u003e,\n    /// The list of whitelisted logo urls prefixes\n    pub logo_urls_whitelist: Vec\u003cString\u003e,\n}\n\n/// This structure describes the execute functions in the contract.\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Extend the lockup time for your staked xASTRO\n    ExtendLockTime { time: u64 },\n    /// Receives a message of type [`Cw20ReceiveMsg`] and processes it depending on the received\n    /// template.\n    Receive(Cw20ReceiveMsg),\n    /// Withdraw xASTRO from the vxASTRO contract\n    Withdraw {},\n    /// Propose a new owner for the contract\n    ProposeNewOwner { new_owner: String, expires_in: u64 },\n    /// Remove the ownership transfer proposal\n    DropOwnershipProposal {},\n    /// Claim contract ownership\n    ClaimOwnership {},\n    /// Add or remove accounts from the blacklist\n    UpdateBlacklist {\n        append_addrs: Option\u003cVec\u003cString\u003e\u003e,\n        remove_addrs: Option\u003cVec\u003cString\u003e\u003e,\n    },\n    /// Update the marketing info for the vxASTRO contract\n    UpdateMarketing {\n        /// A URL pointing to the project behind this token\n        project: Option\u003cString\u003e,\n        /// A longer description of the token and its utility. Designed for tooltips or such\n        description: Option\u003cString\u003e,\n        /// The address (if any) that can update this data structure\n        marketing: Option\u003cString\u003e,\n    },\n    /// Upload a logo for vxASTRO\n    UploadLogo(Logo),\n    /// Update config\n    UpdateConfig { new_guardian: Option\u003cString\u003e },\n    /// Set whitelisted logo urls\n    SetLogoUrlsWhitelist { whitelist: Vec\u003cString\u003e },\n}\n\n/// This structure describes a CW20 hook message.\n#[cw_serde]\npub enum Cw20HookMsg {\n    /// Create a vxASTRO position and lock xASTRO for `time` amount of time\n    CreateLock { time: u64 },\n    /// Deposit xASTRO in another user's vxASTRO position\n    DepositFor { user: String },\n    /// Add more xASTRO to your vxASTRO position\n    ExtendLockAmount {},\n}\n\n/// This enum describes voters status.\n#[cw_serde]\npub enum BlacklistedVotersResponse {\n    /// Voters are blacklisted\n    VotersBlacklisted {},\n    /// Returns a voter that is not blacklisted.\n    VotersNotBlacklisted { voter: String },\n}\n\nimpl fmt::Display for BlacklistedVotersResponse {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            BlacklistedVotersResponse::VotersBlacklisted {} =\u003e write!(f, \"Voters are blacklisted!\"),\n            BlacklistedVotersResponse::VotersNotBlacklisted { voter } =\u003e {\n                write!(f, \"Voter is not blacklisted: {voter}\")\n            }\n        }\n    }\n}\n\n/// This structure describes the query messages available in the contract.\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// Checks if specified addresses are blacklisted\n    #[returns(BlacklistedVotersResponse)]\n    CheckVotersAreBlacklisted { voters: Vec\u003cString\u003e },\n    /// Return the blacklisted voters\n    #[returns(Vec\u003cAddr\u003e)]\n    BlacklistedVoters {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    /// Return the user's vxASTRO balance\n    #[returns(BalanceResponse)]\n    Balance { address: String },\n    /// Fetch the vxASTRO token information\n    #[returns(TokenInfoResponse)]\n    TokenInfo {},\n    /// Fetch vxASTRO's marketing information\n    #[returns(MarketingInfoResponse)]\n    MarketingInfo {},\n    /// Download the vxASTRO logo\n    #[returns(DownloadLogoResponse)]\n    DownloadLogo {},\n    /// Return the current total amount of vxASTRO\n    #[returns(VotingPowerResponse)]\n    TotalVotingPower {},\n    /// Return the total amount of vxASTRO at some point in the past\n    #[returns(VotingPowerResponse)]\n    TotalVotingPowerAt { time: u64 },\n    /// Return the total voting power at a specific period\n    #[returns(VotingPowerResponse)]\n    TotalVotingPowerAtPeriod { period: u64 },\n    /// Return the user's current voting power (vxASTRO balance)\n    #[returns(VotingPowerResponse)]\n    UserVotingPower { user: String },\n    /// Return the user's vxASTRO balance at some point in the past\n    #[returns(VotingPowerResponse)]\n    UserVotingPowerAt { user: String, time: u64 },\n    /// Return the user's voting power at a specific period\n    #[returns(VotingPowerResponse)]\n    UserVotingPowerAtPeriod { user: String, period: u64 },\n    /// Return information about a user's lock position\n    #[returns(LockInfoResponse)]\n    LockInfo { user: String },\n    /// Return user's locked xASTRO balance at the given block height\n    #[returns(Uint128)]\n    UserDepositAtHeight { user: String, height: u64 },\n    /// Return the  vxASTRO contract configuration\n    #[returns(ConfigResponse)]\n    Config {},\n}\n\n/// This structure is used to return a user's amount of vxASTRO.\n#[cw_serde]\npub struct VotingPowerResponse {\n    /// The vxASTRO balance\n    pub voting_power: Uint128,\n}\n\n/// This structure is used to return the lock information for a vxASTRO position.\n#[cw_serde]\npub struct LockInfoResponse {\n    /// The amount of xASTRO locked in the position\n    pub amount: Uint128,\n    /// This is the initial boost for the lock position\n    pub coefficient: Decimal,\n    /// Start time for the vxASTRO position decay\n    pub start: u64,\n    /// End time for the vxASTRO position decay\n    pub end: u64,\n    /// Slope at which a staker's vxASTRO balance decreases over time\n    pub slope: Uint128,\n}\n\n/// This structure stores the parameters returned when querying for a contract's configuration.\n#[cw_serde]\npub struct ConfigResponse {\n    /// Address that's allowed to change contract parameters\n    pub owner: String,\n    /// Address that can only blacklist vxASTRO stakers and remove their governance power\n    pub guardian_addr: Option\u003cAddr\u003e,\n    /// The xASTRO token contract address\n    pub deposit_token_addr: String,\n    /// The address of $ASTRO\n    pub astro_addr: String,\n    /// The address of $xASTRO staking contract\n    pub xastro_staking_addr: String,\n    /// The list of whitelisted logo urls prefixes\n    pub logo_urls_whitelist: Vec\u003cString\u003e,\n}\n\n/// This structure describes a Migration message.\n#[cw_serde]\npub struct MigrateMsg {\n    pub params: Binary,\n}\n\n/// Queries current user's voting power from the voting escrow contract.\n///\n/// * **user** staker for which we calculate the latest vxASTRO voting power.\npub fn get_voting_power(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    user: impl Into\u003cString\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse =\n        querier.query_wasm_smart(escrow_addr, \u0026UserVotingPower { user: user.into() })?;\n    Ok(vp.voting_power)\n}\n\n/// Queries current user's voting power from the voting escrow contract by timestamp.\n///\n/// * **user** staker for which we calculate the voting power at a specific time.\n///\n/// * **timestamp** timestamp at which we calculate the staker's voting power.\npub fn get_voting_power_at(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    user: impl Into\u003cString\u003e,\n    timestamp: u64,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse = querier.query_wasm_smart(\n        escrow_addr,\n        \u0026UserVotingPowerAt {\n            user: user.into(),\n            time: timestamp,\n        },\n    )?;\n\n    Ok(vp.voting_power)\n}\n\n/// Queries current total voting power from the voting escrow contract.\npub fn get_total_voting_power(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse = querier.query_wasm_smart(escrow_addr, \u0026TotalVotingPower {})?;\n\n    Ok(vp.voting_power)\n}\n\n/// Queries total voting power from the voting escrow contract by timestamp.\n///\n/// * **timestamp** time at which we fetch the total voting power.\npub fn get_total_voting_power_at(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    timestamp: u64,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse =\n        querier.query_wasm_smart(escrow_addr, \u0026TotalVotingPowerAt { time: timestamp })?;\n\n    Ok(vp.voting_power)\n}\n\n/// Queries user's lockup information from the voting escrow contract.\n///\n/// * **user** staker for which we return lock position information.\npub fn get_lock_info(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    user: impl Into\u003cString\u003e,\n) -\u003e StdResult\u003cLockInfoResponse\u003e {\n    let lock_info: LockInfoResponse =\n        querier.query_wasm_smart(escrow_addr, \u0026LockInfo { user: user.into() })?;\n    Ok(lock_info)\n}\n","traces":[{"line":108,"address":[7149312],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":109,"address":[7149345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[7149370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[7149433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[7149438],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","voting_escrow_delegation.rs"],"content":"use crate::voting_escrow_delegation::QueryMsg::AdjustedBalance;\nuse cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::{Addr, QuerierWrapper, StdResult, Uint128};\n\n/// This structure stores the main parameters for the voting escrow delegation contract.\n#[cw_serde]\npub struct Config {\n    /// Address that's allowed to change contract parameters\n    pub owner: Addr,\n    /// Astroport NFT contract address\n    pub nft_addr: Addr,\n    /// vxASTRO contract address\n    pub voting_escrow_addr: Addr,\n}\n\n#[cw_serde]\npub struct Token {\n    /// The amount of voting power to be delegated\n    pub power: Uint128,\n    /// Weekly voting power decay\n    pub slope: Uint128,\n    /// The start period when the delegated voting power start to decrease\n    pub start: u64,\n    /// The period when the delegated voting power should expire\n    pub expire_period: u64,\n}\n\n#[cw_serde]\npub struct InstantiateMsg {\n    /// The contract owner address\n    pub owner: String,\n    /// Astroport NFT code identifier\n    pub nft_code_id: u64,\n    /// vxASTRO contract address\n    pub voting_escrow_addr: String,\n}\n\n#[cw_serde]\npub enum ExecuteMsg {\n    CreateDelegation {\n        /// The share of voting power (in bps) that will be delegated to the recipient\n        bps: u16,\n        expire_time: u64,\n        token_id: String,\n        recipient: String,\n    },\n    ExtendDelegation {\n        /// The share of voting power (in bps) that will be delegated to the recipient\n        bps: u16,\n        expire_time: u64,\n        token_id: String,\n    },\n    UpdateConfig {\n        /// vxASTRO contract address\n        new_voting_escrow: Option\u003cString\u003e,\n    },\n    /// Propose a new owner for the contract\n    ProposeNewOwner { new_owner: String, expires_in: u64 },\n    /// Remove the ownership transfer proposal\n    DropOwnershipProposal {},\n    /// Claim contract ownership\n    ClaimOwnership {},\n}\n\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    #[returns(Config)]\n    Config {},\n    #[returns(Uint128)]\n    AdjustedBalance {\n        account: String,\n        timestamp: Option\u003cu64\u003e,\n    },\n    #[returns(Uint128)]\n    DelegatedVotingPower {\n        account: String,\n        timestamp: Option\u003cu64\u003e,\n    },\n}\n\n/// Queries current user's adjusted voting power from the voting escrow delegation contract.\npub fn get_adjusted_balance(\n    querier: \u0026QuerierWrapper,\n    escrow_delegation_addr: String,\n    account: String,\n    timestamp: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    querier.query_wasm_smart(\n        escrow_delegation_addr,\n        \u0026AdjustedBalance { account, timestamp },\n    )\n}\n","traces":[{"line":83,"address":[6750996,6750864],"length":1,"stats":{"Line":0},"fn_name":"get_adjusted_balance"},{"line":89,"address":[6750927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[6750891],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","voting_escrow_lite.rs"],"content":"use crate::voting_escrow_lite::QueryMsg::{\n    LockInfo, TotalVotingPower, TotalVotingPowerAt, UserDepositAtTime, UserEmissionsVotingPower,\n    UserVotingPower, UserVotingPowerAt,\n};\nuse cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::{Addr, Binary, QuerierWrapper, StdResult, Uint128, Uint64};\nuse cw20::{\n    BalanceResponse, Cw20ReceiveMsg, DownloadLogoResponse, Logo, MarketingInfoResponse,\n    TokenInfoResponse,\n};\nuse std::fmt;\n\n/// ## Pagination settings\n/// The maximum amount of items that can be read at once from\npub const MAX_LIMIT: u32 = 30;\n\n/// The default amount of items to read from\npub const DEFAULT_LIMIT: u32 = 10;\n\npub const DEFAULT_PERIODS_LIMIT: u64 = 20;\n\n/// This structure stores marketing information for vxASTRO.\n#[cw_serde]\npub struct UpdateMarketingInfo {\n    /// Project URL\n    pub project: Option\u003cString\u003e,\n    /// Token description\n    pub description: Option\u003cString\u003e,\n    /// Token marketing information\n    pub marketing: Option\u003cString\u003e,\n    /// Token logo\n    pub logo: Option\u003cLogo\u003e,\n}\n\n/// This structure stores general parameters for the vxASTRO contract.\n#[cw_serde]\npub struct InstantiateMsg {\n    /// The vxASTRO contract owner\n    pub owner: String,\n    /// Address that's allowed to black or whitelist contracts\n    pub guardian_addr: Option\u003cString\u003e,\n    /// xASTRO token address\n    pub deposit_token_addr: String,\n    /// Marketing info for vxASTRO\n    pub marketing: Option\u003cUpdateMarketingInfo\u003e,\n    /// The list of whitelisted logo urls prefixes\n    pub logo_urls_whitelist: Vec\u003cString\u003e,\n    /// Minimum unlock wait time in seconds,\n    /// if not provided, defaults to 2 weeks\n    pub unlock_period: Option\u003cu64\u003e,\n    /// Address of the Generator controller to kick unlocked users\n    pub generator_controller_addr: Option\u003cString\u003e,\n}\n\n/// This structure describes the execute functions in the contract.\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Receives a message of type [`Cw20ReceiveMsg`] and processes it depending on the received\n    /// template.\n    Receive(Cw20ReceiveMsg),\n    /// Unlock xASTRO from the vxASTRO contract\n    Unlock {},\n    /// Withdraw xASTRO from the vxASTRO contract\n    Withdraw {},\n    /// Propose a new owner for the contract\n    ProposeNewOwner { new_owner: String, expires_in: u64 },\n    /// Remove the ownership transfer proposal\n    DropOwnershipProposal {},\n    /// Claim contract ownership\n    ClaimOwnership {},\n    /// Add or remove accounts from the blacklist\n    UpdateBlacklist {\n        append_addrs: Option\u003cVec\u003cString\u003e\u003e,\n        remove_addrs: Option\u003cVec\u003cString\u003e\u003e,\n    },\n    /// Update the marketing info for the vxASTRO contract\n    UpdateMarketing {\n        /// A URL pointing to the project behind this token\n        project: Option\u003cString\u003e,\n        /// A longer description of the token and its utility. Designed for tooltips or such\n        description: Option\u003cString\u003e,\n        /// The address (if any) that can update this data structure\n        marketing: Option\u003cString\u003e,\n    },\n    /// Upload a logo for vxASTRO\n    UploadLogo(Logo),\n    /// Update config\n    UpdateConfig {\n        new_guardian: Option\u003cString\u003e,\n        generator_controller: Option\u003cString\u003e,\n    },\n    /// Set whitelisted logo urls\n    SetLogoUrlsWhitelist { whitelist: Vec\u003cString\u003e },\n}\n\n/// This structure describes a CW20 hook message.\n#[cw_serde]\npub enum Cw20HookMsg {\n    /// Create a vxASTRO position and lock xASTRO for `time` amount of time\n    CreateLock { time: u64 },\n    /// Deposit xASTRO in another user's vxASTRO position\n    DepositFor { user: String },\n    /// Add more xASTRO to your vxASTRO position\n    ExtendLockAmount {},\n}\n\n/// This enum describes voters status.\n#[cw_serde]\npub enum BlacklistedVotersResponse {\n    /// Voters are blacklisted\n    VotersBlacklisted {},\n    /// Returns a voter that is not blacklisted.\n    VotersNotBlacklisted { voter: String },\n}\n\nimpl fmt::Display for BlacklistedVotersResponse {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            BlacklistedVotersResponse::VotersBlacklisted {} =\u003e write!(f, \"Voters are blacklisted!\"),\n            BlacklistedVotersResponse::VotersNotBlacklisted { voter } =\u003e {\n                write!(f, \"Voter is not blacklisted: {voter}\")\n            }\n        }\n    }\n}\n\n/// This structure describes the query messages available in the contract.\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// Checks if specified addresses are blacklisted\n    #[returns(BlacklistedVotersResponse)]\n    CheckVotersAreBlacklisted { voters: Vec\u003cString\u003e },\n    /// Return the blacklisted voters\n    #[returns(Vec\u003cAddr\u003e)]\n    BlacklistedVoters {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    /// Return the user's vxASTRO balance\n    #[returns(BalanceResponse)]\n    Balance { address: String },\n    /// Fetch the vxASTRO token information\n    #[returns(TokenInfoResponse)]\n    TokenInfo {},\n    /// Fetch vxASTRO's marketing information\n    #[returns(MarketingInfoResponse)]\n    MarketingInfo {},\n    /// Download the vxASTRO logo\n    #[returns(DownloadLogoResponse)]\n    DownloadLogo {},\n    /// Return the current total amount of vxASTRO\n    #[returns(VotingPowerResponse)]\n    TotalVotingPower {},\n    /// Return the total amount of vxASTRO at some point in the past\n    #[returns(VotingPowerResponse)]\n    TotalVotingPowerAt { time: u64 },\n    /// Return the total voting power at a specific period\n    #[returns(VotingPowerResponse)]\n    TotalVotingPowerAtPeriod { period: u64 },\n    /// Return the user's current voting power (vxASTRO balance)\n    #[returns(VotingPowerResponse)]\n    UserVotingPower { user: String },\n    /// Return the user's vxASTRO balance at some point in the past\n    #[returns(VotingPowerResponse)]\n    UserVotingPowerAt { user: String, time: u64 },\n    /// Return the user's voting power at a specific period\n    #[returns(VotingPowerResponse)]\n    UserVotingPowerAtPeriod { user: String, period: u64 },\n\n    #[returns(VotingPowerResponse)]\n    TotalEmissionsVotingPower {},\n    /// Return the total amount of vxASTRO at some point in the past\n    #[returns(VotingPowerResponse)]\n    TotalEmissionsVotingPowerAt { time: u64 },\n    /// Return the total voting power at a specific period\n    #[returns(VotingPowerResponse)]\n    TotalEmissionsVotingPowerAtPeriod { period: u64 },\n    /// Return the user's current emission voting power\n    #[returns(VotingPowerResponse)]\n    UserEmissionsVotingPower { user: String },\n    /// Return the user's emission voting power  at some point in the past\n    #[returns(VotingPowerResponse)]\n    UserEmissionsVotingPowerAt { user: String, time: u64 },\n    /// Return the user's emission voting power at a specific period\n    #[returns(VotingPowerResponse)]\n    UserEmissionsVotingPowerAtPeriod { user: String, period: u64 },\n\n    #[returns(LockInfoResponse)]\n    LockInfo { user: String },\n    /// Return user's locked xASTRO balance at the given block height\n    #[returns(Uint128)]\n    UserDepositAtHeight { user: String, height: u64 },\n    /// Return user's locked xASTRO balance at the given timestamp\n    #[returns(Uint128)]\n    UserDepositAtTime { user: String, timestamp: Uint64 },\n    /// Return the  vxASTRO contract configuration\n    #[returns(ConfigResponse)]\n    Config {},\n}\n\n/// This structure is used to return a user's amount of vxASTRO.\n#[cw_serde]\npub struct VotingPowerResponse {\n    /// The vxASTRO balance\n    pub voting_power: Uint128,\n}\n\n/// This structure is used to return the lock information for a vxASTRO position.\n#[cw_serde]\npub struct LockInfoResponse {\n    /// The amount of xASTRO locked in the position\n    pub amount: Uint128,\n    /// Indicates the end of a lock period, if None the position is locked\n    pub end: Option\u003cu64\u003e,\n}\n\n/// This structure stores the parameters returned when querying for a contract's configuration.\n#[cw_serde]\npub struct ConfigResponse {\n    /// Address that's allowed to change contract parameters\n    pub owner: String,\n    /// Address that can only blacklist vxASTRO stakers and remove their governance power\n    pub guardian_addr: Option\u003cAddr\u003e,\n    /// The xASTRO token contract address\n    pub deposit_token_addr: String,\n    /// The address of $ASTRO\n    pub astro_addr: String,\n    /// The address of $xASTRO staking contract\n    pub xastro_staking_addr: String,\n    /// The list of whitelisted logo urls prefixes\n    pub logo_urls_whitelist: Vec\u003cString\u003e,\n}\n\n/// This structure describes a Migration message.\n#[cw_serde]\npub struct MigrateMsg {\n    pub params: Binary,\n}\n\n/// Queries current user's deposit from the voting escrow contract.\n///\n/// * **user** staker for which we fetch the latest xASTRO deposits.\n///\n/// * **timestamp** timestamp to fetch deposits at.\npub fn get_user_deposit_at_time(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    user: impl Into\u003cString\u003e,\n    timestamp: u64,\n) -\u003e StdResult\u003cUint128\u003e {\n    let balance = querier.query_wasm_smart(\n        escrow_addr,\n        \u0026UserDepositAtTime {\n            user: user.into(),\n            timestamp: Uint64::from(timestamp),\n        },\n    )?;\n    Ok(balance)\n}\n\n/// Queries current user's voting power from the voting escrow contract.\n///\n/// * **user** staker for which we calculate the latest vxASTRO voting power.\npub fn get_voting_power(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    user: impl Into\u003cString\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse =\n        querier.query_wasm_smart(escrow_addr, \u0026UserVotingPower { user: user.into() })?;\n    Ok(vp.voting_power)\n}\n\n/// Queries current user's emissions voting power from the voting escrow contract.\n///\n/// * **user** staker for which we calculate the latest vxASTRO voting power.\npub fn get_emissions_voting_power(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    user: impl Into\u003cString\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse =\n        querier.query_wasm_smart(escrow_addr, \u0026UserEmissionsVotingPower { user: user.into() })?;\n    Ok(vp.voting_power)\n}\n\n/// Queries current user's voting power from the voting escrow contract by timestamp.\n///\n/// * **user** staker for which we calculate the voting power at a specific time.\n///\n/// * **timestamp** timestamp at which we calculate the staker's voting power.\npub fn get_voting_power_at(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    user: impl Into\u003cString\u003e,\n    timestamp: u64,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse = querier.query_wasm_smart(\n        escrow_addr,\n        \u0026UserVotingPowerAt {\n            user: user.into(),\n            time: timestamp,\n        },\n    )?;\n\n    Ok(vp.voting_power)\n}\n\n/// Queries current total voting power from the voting escrow contract.\npub fn get_total_voting_power(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse = querier.query_wasm_smart(escrow_addr, \u0026TotalVotingPower {})?;\n\n    Ok(vp.voting_power)\n}\n\n/// Queries total voting power from the voting escrow contract by timestamp.\n///\n/// * **timestamp** time at which we fetch the total voting power.\npub fn get_total_voting_power_at(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    timestamp: u64,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse =\n        querier.query_wasm_smart(escrow_addr, \u0026TotalVotingPowerAt { time: timestamp })?;\n\n    Ok(vp.voting_power)\n}\n\n/// Queries user's lockup information from the voting escrow contract.\n///\n/// * **user** staker for which we return lock position information.\npub fn get_lock_info(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    user: impl Into\u003cString\u003e,\n) -\u003e StdResult\u003cLockInfoResponse\u003e {\n    let lock_info: LockInfoResponse =\n        querier.query_wasm_smart(escrow_addr, \u0026LockInfo { user: user.into() })?;\n    Ok(lock_info)\n}\n","traces":[{"line":117,"address":[7565040],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":118,"address":[7565073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[7565098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[7565161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[7565166],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-tests","src","base.rs"],"content":"use cosmwasm_schema::cw_serde;\n\nuse astroport::staking;\nuse astroport::token::InstantiateMsg as AstroTokenInstantiateMsg;\nuse astroport_governance::escrow_fee_distributor::InstantiateMsg as EscrowFeeDistributorInstantiateMsg;\nuse astroport_governance::voting_escrow::{\n    Cw20HookMsg, ExecuteMsg, InstantiateMsg as AstroVotingEscrowInstantiateMsg, QueryMsg,\n    VotingPowerResponse,\n};\nuse cosmwasm_std::{attr, to_binary, Addr, QueryRequest, StdResult, Uint128, WasmQuery};\nuse cw20::{BalanceResponse, Cw20ExecuteMsg, Cw20QueryMsg, MinterResponse};\n\nuse anyhow::Result;\nuse cw_multi_test::{App, AppResponse, ContractWrapper, Executor};\n\npub const MULTIPLIER: u64 = 1_000_000;\n\n#[cw_serde]\npub struct ContractInfo {\n    pub address: Addr,\n    pub code_id: u64,\n}\n\n#[cw_serde]\npub struct BaseAstroportTestPackage {\n    pub owner: Addr,\n    pub astro_token: Option\u003cContractInfo\u003e,\n    pub escrow_fee_distributor: Option\u003cContractInfo\u003e,\n    pub staking: Option\u003cContractInfo\u003e,\n    pub voting_escrow: Option\u003cContractInfo\u003e,\n}\n\n#[cw_serde]\npub struct BaseAstroportTestInitMessage {\n    pub owner: Addr,\n}\n\nimpl BaseAstroportTestPackage {\n    pub fn init_all(router: \u0026mut App, msg: BaseAstroportTestInitMessage) -\u003e Self {\n        let mut base_pack = BaseAstroportTestPackage {\n            owner: msg.owner.clone(),\n            astro_token: None,\n            escrow_fee_distributor: None,\n            staking: None,\n            voting_escrow: None,\n        };\n\n        base_pack.init_astro_token(router, msg.owner.clone());\n        base_pack.init_staking(router, msg.owner.clone());\n        base_pack.init_voting_escrow(router, msg.owner.clone());\n        base_pack.init_escrow_fee_distributor(router, msg.owner);\n        base_pack\n    }\n\n    fn init_astro_token(\u0026mut self, router: \u0026mut App, owner: Addr) {\n        let astro_token_contract = Box::new(ContractWrapper::new_with_empty(\n            astroport_token::contract::execute,\n            astroport_token::contract::instantiate,\n            astroport_token::contract::query,\n        ));\n\n        let astro_token_code_id = router.store_code(astro_token_contract);\n\n        let init_msg = AstroTokenInstantiateMsg {\n            name: String::from(\"Astro token\"),\n            symbol: String::from(\"ASTRO\"),\n            decimals: 6,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                minter: owner.to_string(),\n                cap: None,\n            }),\n            marketing: None,\n        };\n\n        let astro_token_instance = router\n            .instantiate_contract(\n                astro_token_code_id,\n                owner,\n                \u0026init_msg,\n                \u0026[],\n                \"Astro token\",\n                None,\n            )\n            .unwrap();\n\n        self.astro_token = Some(ContractInfo {\n            address: astro_token_instance,\n            code_id: astro_token_code_id,\n        })\n    }\n\n    fn init_staking(\u0026mut self, router: \u0026mut App, owner: Addr) {\n        let staking_contract = Box::new(\n            ContractWrapper::new_with_empty(\n                astroport_staking::contract::execute,\n                astroport_staking::contract::instantiate,\n                astroport_staking::contract::query,\n            )\n            .with_reply_empty(astroport_staking::contract::reply),\n        );\n\n        let staking_code_id = router.store_code(staking_contract);\n\n        let msg = staking::InstantiateMsg {\n            owner: owner.to_string(),\n            token_code_id: self.astro_token.clone().unwrap().code_id,\n            deposit_token_addr: self.astro_token.clone().unwrap().address.to_string(),\n            marketing: None,\n        };\n\n        let staking_instance = router\n            .instantiate_contract(\n                staking_code_id,\n                owner,\n                \u0026msg,\n                \u0026[],\n                String::from(\"xASTRO\"),\n                None,\n            )\n            .unwrap();\n\n        self.staking = Some(ContractInfo {\n            address: staking_instance,\n            code_id: staking_code_id,\n        })\n    }\n\n    pub fn get_staking_xastro(\u0026self, router: \u0026App) -\u003e Addr {\n        let res = router\n            .wrap()\n            .query::\u003cstaking::ConfigResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                contract_addr: self.staking.clone().unwrap().address.to_string(),\n                msg: to_binary(\u0026staking::QueryMsg::Config {}).unwrap(),\n            }))\n            .unwrap();\n\n        res.share_token_addr\n    }\n\n    fn init_voting_escrow(\u0026mut self, router: \u0026mut App, owner: Addr) {\n        let voting_contract = Box::new(ContractWrapper::new_with_empty(\n            voting_escrow::contract::execute,\n            voting_escrow::contract::instantiate,\n            voting_escrow::contract::query,\n        ));\n\n        let voting_code_id = router.store_code(voting_contract);\n\n        let msg = AstroVotingEscrowInstantiateMsg {\n            guardian_addr: Some(\"guardian\".to_string()),\n            marketing: None,\n            owner: owner.to_string(),\n            deposit_token_addr: self.get_staking_xastro(router).to_string(),\n            logo_urls_whitelist: vec![],\n        };\n\n        let voting_instance = router\n            .instantiate_contract(\n                voting_code_id,\n                owner,\n                \u0026msg,\n                \u0026[],\n                String::from(\"vxASTRO\"),\n                None,\n            )\n            .unwrap();\n\n        self.voting_escrow = Some(ContractInfo {\n            address: voting_instance,\n            code_id: voting_code_id,\n        })\n    }\n\n    pub fn init_escrow_fee_distributor(\u0026mut self, router: \u0026mut App, owner: Addr) {\n        let escrow_fee_distributor_contract = Box::new(ContractWrapper::new_with_empty(\n            astroport_escrow_fee_distributor::contract::execute,\n            astroport_escrow_fee_distributor::contract::instantiate,\n            astroport_escrow_fee_distributor::contract::query,\n        ));\n\n        let escrow_fee_distributor_code_id = router.store_code(escrow_fee_distributor_contract);\n\n        let init_msg = EscrowFeeDistributorInstantiateMsg {\n            owner: owner.to_string(),\n            astro_token: self.astro_token.clone().unwrap().address.to_string(),\n            voting_escrow_addr: self.voting_escrow.clone().unwrap().address.to_string(),\n            claim_many_limit: None,\n            is_claim_disabled: None,\n        };\n\n        let escrow_fee_distributor_instance = router\n            .instantiate_contract(\n                escrow_fee_distributor_code_id,\n                owner,\n                \u0026init_msg,\n                \u0026[],\n                \"Astroport escrow fee distributor\",\n                None,\n            )\n            .unwrap();\n\n        self.escrow_fee_distributor = Some(ContractInfo {\n            address: escrow_fee_distributor_instance,\n            code_id: escrow_fee_distributor_code_id,\n        })\n    }\n\n    pub fn create_lock(\n        \u0026self,\n        router: \u0026mut App,\n        user: Addr,\n        time: u64,\n        amount: u64,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let amount = amount * MULTIPLIER;\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.voting_escrow.clone().unwrap().address.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::CreateLock { time }).unwrap(),\n        };\n\n        router.execute_contract(user, self.get_staking_xastro(router), \u0026cw20msg, \u0026[])\n    }\n\n    pub fn extend_lock_amount(\n        \u0026mut self,\n        router: \u0026mut App,\n        user: \u0026str,\n        amount: u64,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let amount = amount * MULTIPLIER;\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.voting_escrow.clone().unwrap().address.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::ExtendLockAmount {}).unwrap(),\n        };\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.get_staking_xastro(router),\n            \u0026cw20msg,\n            \u0026[],\n        )\n    }\n\n    pub fn extend_lock_time(\n        \u0026mut self,\n        router: \u0026mut App,\n        user: \u0026str,\n        time: u64,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.voting_escrow.clone().unwrap().address,\n            \u0026ExecuteMsg::ExtendLockTime { time },\n            \u0026[],\n        )\n    }\n\n    pub fn withdraw(\u0026self, router: \u0026mut App, user: \u0026str) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.voting_escrow.clone().unwrap().address,\n            \u0026ExecuteMsg::Withdraw {},\n            \u0026[],\n        )\n    }\n\n    pub fn query_user_vp(\u0026self, router: \u0026mut App, user: Addr) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_escrow.clone().unwrap().address,\n                \u0026QueryMsg::UserVotingPower {\n                    user: user.to_string(),\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_user_vp_at(\u0026self, router: \u0026mut App, user: Addr, time: u64) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_escrow.clone().unwrap().address,\n                \u0026QueryMsg::UserVotingPowerAt {\n                    user: user.to_string(),\n                    time,\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_total_vp(\u0026self, router: \u0026mut App) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_escrow.clone().unwrap().address,\n                \u0026QueryMsg::TotalVotingPower {},\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_total_vp_at(\u0026self, router: \u0026mut App, time: u64) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_escrow.clone().unwrap().address,\n                \u0026QueryMsg::TotalVotingPowerAt { time },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n}\n\npub fn mint(router: \u0026mut App, owner: Addr, token_instance: Addr, to: \u0026Addr, amount: u128) {\n    let amount = amount * MULTIPLIER as u128;\n    let msg = cw20::Cw20ExecuteMsg::Mint {\n        recipient: to.to_string(),\n        amount: Uint128::from(amount),\n    };\n\n    let res = router\n        .execute_contract(owner, token_instance, \u0026msg, \u0026[])\n        .unwrap();\n    assert_eq!(res.events[1].attributes[1], attr(\"action\", \"mint\"));\n    assert_eq!(res.events[1].attributes[2], attr(\"to\", String::from(to)));\n    assert_eq!(\n        res.events[1].attributes[3],\n        attr(\"amount\", Uint128::from(amount))\n    );\n}\n\npub fn check_balance(app: \u0026mut App, token_addr: \u0026Addr, contract_addr: \u0026Addr, expected: u128) {\n    let msg = Cw20QueryMsg::Balance {\n        address: contract_addr.to_string(),\n    };\n    let res: StdResult\u003cBalanceResponse\u003e = app.wrap().query_wasm_smart(token_addr, \u0026msg);\n    assert_eq!(res.unwrap().balance, Uint128::from(expected));\n}\n\npub fn increase_allowance(\n    router: \u0026mut App,\n    owner: Addr,\n    spender: Addr,\n    token: Addr,\n    amount: Uint128,\n) {\n    let msg = cw20::Cw20ExecuteMsg::IncreaseAllowance {\n        spender: spender.to_string(),\n        amount,\n        expires: None,\n    };\n\n    let res = router\n        .execute_contract(owner.clone(), token, \u0026msg, \u0026[])\n        .unwrap();\n\n    assert_eq!(\n        res.events[1].attributes[1],\n        attr(\"action\", \"increase_allowance\")\n    );\n    assert_eq!(\n        res.events[1].attributes[2],\n        attr(\"owner\", owner.to_string())\n    );\n    assert_eq!(\n        res.events[1].attributes[3],\n        attr(\"spender\", spender.to_string())\n    );\n    assert_eq!(res.events[1].attributes[4], attr(\"amount\", amount));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-tests","src","controller_helper.rs"],"content":"use crate::escrow_helper::EscrowHelper;\nuse anyhow::Result as AnyResult;\nuse astroport::asset::{AssetInfo, PairInfo};\nuse astroport::factory::{PairConfig, PairType};\n\nuse astroport_governance::generator_controller::{ConfigResponse, ExecuteMsg, QueryMsg};\nuse cosmwasm_std::{Addr, Decimal, StdResult};\nuse cw_multi_test::{App, AppResponse, ContractWrapper, Executor};\nuse generator_controller::state::{UserInfo, VotedPoolInfo};\n\npub struct ControllerHelper {\n    pub owner: String,\n    pub generator: Addr,\n    pub controller: Addr,\n    pub factory: Addr,\n    pub escrow_helper: EscrowHelper,\n}\n\nimpl ControllerHelper {\n    pub fn init(router: \u0026mut App, owner: \u0026Addr) -\u003e Self {\n        let escrow_helper = EscrowHelper::init(router, owner.clone());\n\n        let pair_contract = Box::new(\n            ContractWrapper::new_with_empty(\n                astroport_pair::contract::execute,\n                astroport_pair::contract::instantiate,\n                astroport_pair::contract::query,\n            )\n            .with_reply_empty(astroport_pair::contract::reply),\n        );\n\n        let pair_code_id = router.store_code(pair_contract);\n\n        let factory_contract = Box::new(\n            ContractWrapper::new_with_empty(\n                astroport_factory::contract::execute,\n                astroport_factory::contract::instantiate,\n                astroport_factory::contract::query,\n            )\n            .with_reply_empty(astroport_factory::contract::reply),\n        );\n\n        let factory_code_id = router.store_code(factory_contract);\n\n        let whitelist_code_id = store_whitelist_code(router);\n\n        let msg = astroport::factory::InstantiateMsg {\n            pair_configs: vec![PairConfig {\n                code_id: pair_code_id,\n                pair_type: PairType::Xyk {},\n                total_fee_bps: 100,\n                maker_fee_bps: 10,\n                is_disabled: false,\n                is_generator_disabled: false,\n            }],\n            token_code_id: escrow_helper.astro_token_code_id,\n            fee_address: None,\n            generator_address: None,\n            owner: owner.to_string(),\n            whitelist_code_id,\n            coin_registry_address: Addr::unchecked(\"coin_registry\").to_string(),\n        };\n\n        let factory = router\n            .instantiate_contract(factory_code_id, owner.clone(), \u0026msg, \u0026[], \"Factory\", None)\n            .unwrap();\n\n        let generator_contract = Box::new(\n            ContractWrapper::new_with_empty(\n                astroport_generator::contract::execute,\n                astroport_generator::contract::instantiate,\n                astroport_generator::contract::query,\n            )\n            .with_reply_empty(astroport_generator::contract::reply),\n        );\n\n        let generator_code_id = router.store_code(generator_contract);\n        let init_msg = astroport::generator::InstantiateMsg {\n            owner: owner.to_string(),\n            factory: factory.to_string(),\n            generator_controller: None,\n            guardian: None,\n            astro_token: AssetInfo::NativeToken {\n                denom: escrow_helper.astro_token.to_string(),\n            },\n            tokens_per_block: Default::default(),\n            start_block: Default::default(),\n            vesting_contract: \"vesting_placeholder\".to_string(),\n            whitelist_code_id,\n            voting_escrow: None,\n            voting_escrow_delegation: None,\n        };\n\n        let generator = router\n            .instantiate_contract(\n                generator_code_id,\n                owner.clone(),\n                \u0026init_msg,\n                \u0026[],\n                String::from(\"Generator\"),\n                None,\n            )\n            .unwrap();\n\n        let controller_contract = Box::new(ContractWrapper::new_with_empty(\n            generator_controller::contract::execute,\n            generator_controller::contract::instantiate,\n            generator_controller::contract::query,\n        ));\n\n        let controller_code_id = router.store_code(controller_contract);\n        let init_msg = astroport_governance::generator_controller::InstantiateMsg {\n            owner: owner.to_string(),\n            escrow_addr: escrow_helper.escrow_instance.to_string(),\n            generator_addr: generator.to_string(),\n            factory_addr: factory.to_string(),\n            pools_limit: 5,\n            whitelisted_pools: vec![],\n        };\n\n        let controller = router\n            .instantiate_contract(\n                controller_code_id,\n                owner.clone(),\n                \u0026init_msg,\n                \u0026[],\n                String::from(\"Controller\"),\n                None,\n            )\n            .unwrap();\n\n        // Setup controller in generator contract\n        router\n            .execute_contract(\n                owner.clone(),\n                generator.clone(),\n                \u0026astroport::generator::ExecuteMsg::UpdateConfig {\n                    vesting_contract: None,\n                    generator_controller: Some(controller.to_string()),\n                    guardian: None,\n                    checkpoint_generator_limit: None,\n                    voting_escrow: None,\n                    voting_escrow_delegation: None,\n                },\n                \u0026[],\n            )\n            .unwrap();\n\n        Self {\n            owner: owner.to_string(),\n            generator,\n            controller,\n            factory,\n            escrow_helper,\n        }\n    }\n\n    pub fn init_cw20_token(\u0026self, router: \u0026mut App, name: \u0026str) -\u003e AnyResult\u003cAddr\u003e {\n        let msg = astroport::token::InstantiateMsg {\n            name: name.to_string(),\n            symbol: name.to_string(),\n            decimals: 6,\n            initial_balances: vec![],\n            mint: None,\n            marketing: None,\n        };\n\n        router.instantiate_contract(\n            self.escrow_helper.astro_token_code_id,\n            Addr::unchecked(self.owner.clone()),\n            \u0026msg,\n            \u0026[],\n            name.to_string(),\n            None,\n        )\n    }\n\n    pub fn create_pool(\u0026self, router: \u0026mut App, token1: \u0026Addr, token2: \u0026Addr) -\u003e AnyResult\u003cAddr\u003e {\n        let asset_infos = vec![\n            AssetInfo::Token {\n                contract_addr: token1.clone(),\n            },\n            AssetInfo::Token {\n                contract_addr: token2.clone(),\n            },\n        ];\n\n        router.execute_contract(\n            Addr::unchecked(self.owner.clone()),\n            self.factory.clone(),\n            \u0026astroport::factory::ExecuteMsg::CreatePair {\n                pair_type: PairType::Xyk {},\n                asset_infos: asset_infos.to_vec(),\n                init_params: None,\n            },\n            \u0026[],\n        )?;\n\n        let res: PairInfo = router.wrap().query_wasm_smart(\n            self.factory.clone(),\n            \u0026astroport::factory::QueryMsg::Pair {\n                asset_infos: asset_infos.to_vec(),\n            },\n        )?;\n\n        Ok(res.liquidity_token)\n    }\n\n    pub fn create_pool_with_tokens(\n        \u0026self,\n        router: \u0026mut App,\n        name1: \u0026str,\n        name2: \u0026str,\n    ) -\u003e AnyResult\u003cAddr\u003e {\n        let token1 = self.init_cw20_token(router, name1).unwrap();\n        let token2 = self.init_cw20_token(router, name2).unwrap();\n\n        self.create_pool(router, \u0026token1, \u0026token2)\n    }\n\n    pub fn vote(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        votes: Vec\u003c(impl Into\u003cString\u003e, u16)\u003e,\n    ) -\u003e AnyResult\u003cAppResponse\u003e {\n        let msg = ExecuteMsg::Vote {\n            votes: votes\n                .into_iter()\n                .map(|(pool, apoints)| (pool.into(), apoints))\n                .collect(),\n        };\n\n        router.execute_contract(Addr::unchecked(user), self.controller.clone(), \u0026msg, \u0026[])\n    }\n\n    pub fn tune(\u0026self, router: \u0026mut App) -\u003e AnyResult\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(\"anyone\"),\n            self.controller.clone(),\n            \u0026ExecuteMsg::TunePools {},\n            \u0026[],\n        )\n    }\n\n    pub fn kick_holders(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        blacklisted_voters: Vec\u003cString\u003e,\n    ) -\u003e AnyResult\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.controller.clone(),\n            \u0026ExecuteMsg::KickBlacklistedVoters { blacklisted_voters },\n            \u0026[],\n        )\n    }\n\n    pub fn update_blacklisted_limit(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        blacklisted_voters_limit: Option\u003cu32\u003e,\n    ) -\u003e AnyResult\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.controller.clone(),\n            \u0026ExecuteMsg::UpdateConfig {\n                blacklisted_voters_limit,\n                main_pool: None,\n                main_pool_min_alloc: None,\n                remove_main_pool: None,\n            },\n            \u0026[],\n        )\n    }\n\n    pub fn update_main_pool(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        main_pool: Option\u003c\u0026Addr\u003e,\n        main_pool_min_alloc: Option\u003cDecimal\u003e,\n        remove_main_pool: bool,\n    ) -\u003e AnyResult\u003cAppResponse\u003e {\n        let remove_main_pool = if remove_main_pool { Some(true) } else { None };\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.controller.clone(),\n            \u0026ExecuteMsg::UpdateConfig {\n                blacklisted_voters_limit: None,\n                main_pool: main_pool.map(|p| p.to_string()),\n                main_pool_min_alloc,\n                remove_main_pool,\n            },\n            \u0026[],\n        )\n    }\n\n    pub fn update_whitelist(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        add_pools: Option\u003cVec\u003cString\u003e\u003e,\n        remove_pools: Option\u003cVec\u003cString\u003e\u003e,\n    ) -\u003e AnyResult\u003cAppResponse\u003e {\n        let msg = ExecuteMsg::UpdateWhitelist {\n            add: add_pools,\n            remove: remove_pools,\n        };\n\n        router.execute_contract(Addr::unchecked(user), self.controller.clone(), \u0026msg, \u0026[])\n    }\n\n    pub fn query_user_info(\u0026self, router: \u0026mut App, user: \u0026str) -\u003e StdResult\u003cUserInfo\u003e {\n        router.wrap().query_wasm_smart(\n            self.controller.clone(),\n            \u0026QueryMsg::UserInfo {\n                user: user.to_string(),\n            },\n        )\n    }\n\n    pub fn query_voted_pool_info(\u0026self, router: \u0026mut App, pool: \u0026str) -\u003e StdResult\u003cVotedPoolInfo\u003e {\n        router.wrap().query_wasm_smart(\n            self.controller.clone(),\n            \u0026QueryMsg::PoolInfo {\n                pool_addr: pool.to_string(),\n            },\n        )\n    }\n\n    pub fn query_voted_pool_info_at_period(\n        \u0026self,\n        router: \u0026mut App,\n        pool: \u0026str,\n        period: u64,\n    ) -\u003e StdResult\u003cVotedPoolInfo\u003e {\n        router.wrap().query_wasm_smart(\n            self.controller.clone(),\n            \u0026QueryMsg::PoolInfoAtPeriod {\n                pool_addr: pool.to_string(),\n                period,\n            },\n        )\n    }\n\n    pub fn query_config(\u0026self, router: \u0026mut App) -\u003e StdResult\u003cConfigResponse\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(self.controller.clone(), \u0026QueryMsg::Config {})\n    }\n}\n\nfn store_whitelist_code(app: \u0026mut App) -\u003e u64 {\n    let whitelist_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_whitelist::contract::execute,\n        astroport_whitelist::contract::instantiate,\n        astroport_whitelist::contract::query,\n    ));\n\n    app.store_code(whitelist_contract)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-tests","src","escrow_helper.rs"],"content":"use anyhow::Result;\nuse astroport::{staking as xastro, token as astro};\nuse astroport_governance::voting_escrow::{\n    Cw20HookMsg, ExecuteMsg, InstantiateMsg, LockInfoResponse, QueryMsg, VotingPowerResponse,\n};\nuse cosmwasm_std::{attr, to_binary, Addr, QueryRequest, StdResult, Uint128, WasmQuery};\nuse cw20::{BalanceResponse, Cw20ExecuteMsg, Cw20QueryMsg, MinterResponse};\nuse cw_multi_test::{App, AppResponse, ContractWrapper, Executor};\n\npub const MULTIPLIER: u64 = 1000000;\n\npub struct EscrowHelper {\n    pub owner: Addr,\n    pub astro_token: Addr,\n    pub staking_instance: Addr,\n    pub xastro_token: Addr,\n    pub escrow_instance: Addr,\n    pub astro_token_code_id: u64,\n}\n\nimpl EscrowHelper {\n    pub fn init(router: \u0026mut App, owner: Addr) -\u003e Self {\n        let astro_token_contract = Box::new(ContractWrapper::new_with_empty(\n            astroport_token::contract::execute,\n            astroport_token::contract::instantiate,\n            astroport_token::contract::query,\n        ));\n\n        let astro_token_code_id = router.store_code(astro_token_contract);\n\n        let msg = astro::InstantiateMsg {\n            name: String::from(\"Astro token\"),\n            symbol: String::from(\"ASTRO\"),\n            decimals: 6,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                minter: owner.to_string(),\n                cap: None,\n            }),\n            marketing: None,\n        };\n\n        let astro_token = router\n            .instantiate_contract(\n                astro_token_code_id,\n                owner.clone(),\n                \u0026msg,\n                \u0026[],\n                String::from(\"ASTRO\"),\n                None,\n            )\n            .unwrap();\n\n        let staking_contract = Box::new(\n            ContractWrapper::new_with_empty(\n                astroport_staking::contract::execute,\n                astroport_staking::contract::instantiate,\n                astroport_staking::contract::query,\n            )\n            .with_reply_empty(astroport_staking::contract::reply),\n        );\n\n        let staking_code_id = router.store_code(staking_contract);\n\n        let msg = xastro::InstantiateMsg {\n            owner: owner.to_string(),\n            token_code_id: astro_token_code_id,\n            deposit_token_addr: astro_token.to_string(),\n            marketing: None,\n        };\n        let staking_instance = router\n            .instantiate_contract(\n                staking_code_id,\n                owner.clone(),\n                \u0026msg,\n                \u0026[],\n                String::from(\"xASTRO\"),\n                None,\n            )\n            .unwrap();\n\n        let res = router\n            .wrap()\n            .query::\u003cxastro::ConfigResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                contract_addr: staking_instance.to_string(),\n                msg: to_binary(\u0026xastro::QueryMsg::Config {}).unwrap(),\n            }))\n            .unwrap();\n\n        let voting_contract = Box::new(ContractWrapper::new_with_empty(\n            voting_escrow::contract::execute,\n            voting_escrow::contract::instantiate,\n            voting_escrow::contract::query,\n        ));\n\n        let voting_code_id = router.store_code(voting_contract);\n\n        let msg = InstantiateMsg {\n            owner: owner.to_string(),\n            guardian_addr: Some(\"guardian\".to_string()),\n            deposit_token_addr: res.share_token_addr.to_string(),\n            marketing: None,\n            logo_urls_whitelist: vec![],\n        };\n        let voting_instance = router\n            .instantiate_contract(\n                voting_code_id,\n                owner.clone(),\n                \u0026msg,\n                \u0026[],\n                String::from(\"vxASTRO\"),\n                None,\n            )\n            .unwrap();\n\n        Self {\n            owner,\n            xastro_token: res.share_token_addr,\n            astro_token,\n            staking_instance,\n            escrow_instance: voting_instance,\n            astro_token_code_id,\n        }\n    }\n\n    pub fn mint_xastro(\u0026self, router: \u0026mut App, to: \u0026str, amount: u64) {\n        let amount = amount * MULTIPLIER;\n        let msg = Cw20ExecuteMsg::Mint {\n            recipient: String::from(to),\n            amount: Uint128::from(amount),\n        };\n        let res = router\n            .execute_contract(self.owner.clone(), self.astro_token.clone(), \u0026msg, \u0026[])\n            .unwrap();\n        assert_eq!(res.events[1].attributes[1], attr(\"action\", \"mint\"));\n        assert_eq!(res.events[1].attributes[2], attr(\"to\", String::from(to)));\n        assert_eq!(\n            res.events[1].attributes[3],\n            attr(\"amount\", Uint128::from(amount))\n        );\n\n        let to_addr = Addr::unchecked(to);\n        let msg = Cw20ExecuteMsg::Send {\n            contract: self.staking_instance.to_string(),\n            msg: to_binary(\u0026xastro::Cw20HookMsg::Enter {}).unwrap(),\n            amount: Uint128::from(amount),\n        };\n        router\n            .execute_contract(to_addr, self.astro_token.clone(), \u0026msg, \u0026[])\n            .unwrap();\n    }\n\n    pub fn check_xastro_balance(\u0026self, router: \u0026mut App, user: \u0026str, amount: u64) {\n        let amount = amount * MULTIPLIER;\n        let res: BalanceResponse = router\n            .wrap()\n            .query_wasm_smart(\n                self.xastro_token.clone(),\n                \u0026Cw20QueryMsg::Balance {\n                    address: user.to_string(),\n                },\n            )\n            .unwrap();\n        assert_eq!(res.balance.u128(), amount as u128);\n    }\n\n    pub fn create_lock(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        time: u64,\n        amount: f32,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let amount = (amount * MULTIPLIER as f32) as u64;\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.escrow_instance.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::CreateLock { time }).unwrap(),\n        };\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.xastro_token.clone(),\n            \u0026cw20msg,\n            \u0026[],\n        )\n    }\n\n    pub fn extend_lock_amount(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        amount: f32,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let amount = (amount * MULTIPLIER as f32) as u64;\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.escrow_instance.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::ExtendLockAmount {}).unwrap(),\n        };\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.xastro_token.clone(),\n            \u0026cw20msg,\n            \u0026[],\n        )\n    }\n\n    pub fn deposit_for(\n        \u0026self,\n        router: \u0026mut App,\n        from: \u0026str,\n        to: \u0026str,\n        amount: f32,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let amount = (amount * MULTIPLIER as f32) as u64;\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.escrow_instance.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::DepositFor {\n                user: to.to_string(),\n            })\n            .unwrap(),\n        };\n        router.execute_contract(\n            Addr::unchecked(from),\n            self.xastro_token.clone(),\n            \u0026cw20msg,\n            \u0026[],\n        )\n    }\n\n    pub fn extend_lock_time(\u0026self, router: \u0026mut App, user: \u0026str, time: u64) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.escrow_instance.clone(),\n            \u0026ExecuteMsg::ExtendLockTime { time },\n            \u0026[],\n        )\n    }\n\n    pub fn withdraw(\u0026self, router: \u0026mut App, user: \u0026str) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.escrow_instance.clone(),\n            \u0026ExecuteMsg::Withdraw {},\n            \u0026[],\n        )\n    }\n\n    pub fn update_blacklist(\n        \u0026self,\n        router: \u0026mut App,\n        append_addrs: Option\u003cVec\u003cString\u003e\u003e,\n        remove_addrs: Option\u003cVec\u003cString\u003e\u003e,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(\"owner\"),\n            self.escrow_instance.clone(),\n            \u0026ExecuteMsg::UpdateBlacklist {\n                append_addrs,\n                remove_addrs,\n            },\n            \u0026[],\n        )\n    }\n\n    pub fn query_user_vp(\u0026self, router: \u0026mut App, user: \u0026str) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.escrow_instance.clone(),\n                \u0026QueryMsg::UserVotingPower {\n                    user: user.to_string(),\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_user_vp_at(\u0026self, router: \u0026mut App, user: \u0026str, time: u64) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.escrow_instance.clone(),\n                \u0026QueryMsg::UserVotingPowerAt {\n                    user: user.to_string(),\n                    time,\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_user_vp_at_period(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        period: u64,\n    ) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.escrow_instance.clone(),\n                \u0026QueryMsg::UserVotingPowerAtPeriod {\n                    user: user.to_string(),\n                    period,\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_total_vp(\u0026self, router: \u0026mut App) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(self.escrow_instance.clone(), \u0026QueryMsg::TotalVotingPower {})\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_total_vp_at(\u0026self, router: \u0026mut App, time: u64) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.escrow_instance.clone(),\n                \u0026QueryMsg::TotalVotingPowerAt { time },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_total_vp_at_period(\u0026self, router: \u0026mut App, period: u64) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.escrow_instance.clone(),\n                \u0026QueryMsg::TotalVotingPowerAtPeriod { period },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_lock_info(\u0026self, router: \u0026mut App, user: \u0026str) -\u003e StdResult\u003cLockInfoResponse\u003e {\n        router.wrap().query_wasm_smart(\n            self.escrow_instance.clone(),\n            \u0026QueryMsg::LockInfo {\n                user: user.to_string(),\n            },\n        )\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-tests","src","lib.rs"],"content":"pub mod base;\nuse astroport_governance::utils::{get_period, EPOCH_START};\nuse cosmwasm_std::testing::{mock_env, MockApi, MockStorage};\nuse cosmwasm_std::Timestamp;\nuse cw_multi_test::{App, BankKeeper, BasicAppBuilder};\n\n#[allow(clippy::all)]\n#[allow(dead_code)]\npub mod controller_helper;\n\n#[allow(clippy::all)]\n#[allow(dead_code)]\npub mod escrow_helper;\n\npub fn mock_app() -\u003e App {\n    let mut env = mock_env();\n    env.block.time = Timestamp::from_seconds(EPOCH_START);\n    let api = MockApi::default();\n    let bank = BankKeeper::new();\n    let storage = MockStorage::new();\n\n    BasicAppBuilder::new()\n        .with_api(api)\n        .with_block(env.block)\n        .with_bank(bank)\n        .with_storage(storage)\n        .build(|_, _, _| {})\n}\n\npub trait TerraAppExtension {\n    fn next_block(\u0026mut self, time: u64);\n    fn block_period(\u0026self) -\u003e u64;\n}\n\nimpl TerraAppExtension for App {\n    fn next_block(\u0026mut self, time: u64) {\n        self.update_block(|block| {\n            block.time = block.time.plus_seconds(time);\n            block.height += 1\n        });\n    }\n\n    fn block_period(\u0026self) -\u003e u64 {\n        get_period(self.block_info().time.seconds()).unwrap()\n    }\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","assembly","examples","assembly_schema.rs"],"content":"use astroport_governance::assembly::{ExecuteMsg, InstantiateMsg, QueryMsg};\nuse cosmwasm_schema::write_api;\n\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        query: QueryMsg,\n        execute: ExecuteMsg,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","assembly","src","contract.rs"],"content":"use cosmwasm_std::{\n    attr, entry_point, from_binary, to_binary, wasm_execute, Addr, Binary, CosmosMsg, Decimal,\n    Deps, DepsMut, Env, IbcQuery, ListChannelsResponse, MessageInfo, Order, QuerierWrapper,\n    QueryRequest, Response, StdResult, Uint128, Uint64, WasmMsg,\n};\nuse cw2::{get_contract_version, set_contract_version};\nuse cw20::{BalanceResponse, Cw20ExecuteMsg, Cw20ReceiveMsg};\nuse cw_storage_plus::Bound;\nuse std::str::FromStr;\n\nuse crate::astroport;\nuse astroport_governance::assembly::{\n    helpers::validate_links, Config, Cw20HookMsg, ExecuteMsg, InstantiateMsg, Proposal,\n    ProposalListResponse, ProposalStatus, ProposalVoteOption, ProposalVotesResponse, QueryMsg,\n    UpdateConfig,\n};\n\nuse crate::astroport::asset::addr_opt_validate;\nuse astroport::xastro_token::QueryMsg as XAstroTokenQueryMsg;\nuse astroport_governance::builder_unlock::msg::{\n    AllocationResponse, QueryMsg as BuilderUnlockQueryMsg, StateResponse,\n};\nuse astroport_governance::utils::WEEK;\nuse astroport_governance::voting_escrow::{QueryMsg as VotingEscrowQueryMsg, VotingPowerResponse};\nuse astroport_governance::voting_escrow_delegation::QueryMsg::AdjustedBalance;\n\nuse crate::error::ContractError;\nuse crate::migration::{migrate_config_to_140, migrate_proposals_to_v140, MigrateMsg};\nuse crate::state::{CONFIG, PROPOSALS, PROPOSAL_COUNT};\n\nuse ibc_controller_package::ExecuteMsg as ControllerExecuteMsg;\n\n// Contract name and version used for migration.\nconst CONTRACT_NAME: \u0026str = \"astro-assembly\";\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n// Default pagination constants\nconst DEFAULT_LIMIT: u32 = 10;\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_VOTERS_LIMIT: u32 = 100;\nconst MAX_VOTERS_LIMIT: u32 = 250;\n\n/// Creates a new contract with the specified parameters in the `msg` variable.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    if msg.whitelisted_links.is_empty() {\n        return Err(ContractError::WhitelistEmpty {});\n    }\n\n    validate_links(\u0026msg.whitelisted_links)?;\n\n    let config = Config {\n        xastro_token_addr: deps.api.addr_validate(\u0026msg.xastro_token_addr)?,\n        vxastro_token_addr: addr_opt_validate(deps.api, \u0026msg.vxastro_token_addr)?,\n        voting_escrow_delegator_addr: addr_opt_validate(\n            deps.api,\n            \u0026msg.voting_escrow_delegator_addr,\n        )?,\n        ibc_controller: addr_opt_validate(deps.api, \u0026msg.ibc_controller)?,\n        builder_unlock_addr: deps.api.addr_validate(\u0026msg.builder_unlock_addr)?,\n        proposal_voting_period: msg.proposal_voting_period,\n        proposal_effective_delay: msg.proposal_effective_delay,\n        proposal_expiration_period: msg.proposal_expiration_period,\n        proposal_required_deposit: msg.proposal_required_deposit,\n        proposal_required_quorum: Decimal::from_str(\u0026msg.proposal_required_quorum)?,\n        proposal_required_threshold: Decimal::from_str(\u0026msg.proposal_required_threshold)?,\n        whitelisted_links: msg.whitelisted_links,\n    };\n\n    config.validate()?;\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    PROPOSAL_COUNT.save(deps.storage, \u0026Uint64::zero())?;\n\n    Ok(Response::default())\n}\n\n/// Exposes all the execute functions available in the contract.\n///\n/// ## Execute messages\n/// * **ExecuteMsg::Receive(cw20_msg)** Receives a message of type [`Cw20ReceiveMsg`] and processes\n/// it depending on the received template.\n///\n/// * **ExecuteMsg::CastVote { proposal_id, vote }** Cast a vote on a specific proposal.\n///\n/// * **ExecuteMsg::EndProposal { proposal_id }** Sets the status of an expired/finalized proposal.\n///\n/// * **ExecuteMsg::ExecuteProposal { proposal_id }** Executes a successful proposal.\n///\n/// * **ExecuteMsg::RemoveCompletedProposal { proposal_id }** Removes a finalized proposal from the proposal list.\n///\n/// * **ExecuteMsg::UpdateConfig(config)** Updates the contract configuration.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::Receive(cw20_msg) =\u003e receive_cw20(deps, env, info, cw20_msg),\n        ExecuteMsg::CastVote { proposal_id, vote } =\u003e cast_vote(deps, env, info, proposal_id, vote),\n        ExecuteMsg::EndProposal { proposal_id } =\u003e end_proposal(deps, env, proposal_id),\n        ExecuteMsg::ExecuteProposal { proposal_id } =\u003e execute_proposal(deps, env, proposal_id),\n        ExecuteMsg::CheckMessages { messages } =\u003e check_messages(env, messages),\n        ExecuteMsg::CheckMessagesPassed {} =\u003e Err(ContractError::MessagesCheckPassed {}),\n        ExecuteMsg::RemoveCompletedProposal { proposal_id } =\u003e {\n            remove_completed_proposal(deps, env, proposal_id)\n        }\n        ExecuteMsg::UpdateConfig(config) =\u003e update_config(deps, env, info, config),\n        ExecuteMsg::IBCProposalCompleted {\n            proposal_id,\n            status,\n        } =\u003e update_ibc_proposal_status(deps, info, proposal_id, status),\n    }\n}\n\n/// Receives a message of type [`Cw20ReceiveMsg`] and processes it depending on the received template.\n///\n/// * **cw20_msg** CW20 message to process.\npub fn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match from_binary(\u0026cw20_msg.msg)? {\n        Cw20HookMsg::SubmitProposal {\n            title,\n            description,\n            link,\n            messages,\n            ibc_channel,\n        } =\u003e submit_proposal(\n            deps,\n            env,\n            info,\n            Addr::unchecked(cw20_msg.sender),\n            cw20_msg.amount,\n            title,\n            description,\n            link,\n            messages,\n            ibc_channel,\n        ),\n    }\n}\n\n/// Submit a brand new proposal and locks some xASTRO as an anti-spam mechanism.\n///\n/// * **sender** proposal submitter.\n///\n/// * **deposit_amount**  amount of xASTRO to deposit in order to submit the proposal.\n///\n/// * **title** proposal title.\n///\n/// * **description** proposal description.\n///\n/// * **link** proposal link.\n///\n/// * **messages** executable messages (actions to perform if the proposal passes).\n#[allow(clippy::too_many_arguments)]\npub fn submit_proposal(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    sender: Addr,\n    deposit_amount: Uint128,\n    title: String,\n    description: String,\n    link: Option\u003cString\u003e,\n    messages: Option\u003cVec\u003cCosmosMsg\u003e\u003e,\n    ibc_channel: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    if info.sender != config.xastro_token_addr {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if deposit_amount \u003c config.proposal_required_deposit {\n        return Err(ContractError::InsufficientDeposit {});\n    }\n\n    // Update the proposal count\n    let count = PROPOSAL_COUNT.update(deps.storage, |c| -\u003e StdResult\u003c_\u003e {\n        Ok(c.checked_add(Uint64::new(1))?)\n    })?;\n\n    // Check that controller exists and it supports this channel\n    if let Some(ibc_channel) = \u0026ibc_channel {\n        if let Some(ibc_controller) = \u0026config.ibc_controller {\n            check_controller_supports_channel(deps.querier, ibc_controller, ibc_channel)?;\n        } else {\n            return Err(ContractError::MissingIBCController {});\n        }\n    }\n\n    let proposal = Proposal {\n        proposal_id: count,\n        submitter: sender.clone(),\n        status: ProposalStatus::Active,\n        for_power: Uint128::zero(),\n        against_power: Uint128::zero(),\n        for_voters: Vec::new(),\n        against_voters: Vec::new(),\n        start_block: env.block.height,\n        start_time: env.block.time.seconds(),\n        end_block: env.block.height + config.proposal_voting_period,\n        delayed_end_block: env.block.height\n            + config.proposal_voting_period\n            + config.proposal_effective_delay,\n        expiration_block: env.block.height\n            + config.proposal_voting_period\n            + config.proposal_effective_delay\n            + config.proposal_expiration_period,\n        title,\n        description,\n        link,\n        messages,\n        deposit_amount,\n        ibc_channel,\n    };\n\n    proposal.validate(config.whitelisted_links)?;\n\n    PROPOSALS.save(deps.storage, count.u64(), \u0026proposal)?;\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"submit_proposal\"),\n        attr(\"submitter\", sender),\n        attr(\"proposal_id\", count),\n        attr(\n            \"proposal_end_height\",\n            (env.block.height + config.proposal_voting_period).to_string(),\n        ),\n    ]))\n}\n\n/// Cast a vote on a proposal.\n///\n/// * **proposal_id** is the identifier of the proposal.\n///\n/// * **vote_option** contains the vote option.\npub fn cast_vote(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    proposal_id: u64,\n    vote_option: ProposalVoteOption,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut proposal = PROPOSALS.load(deps.storage, proposal_id)?;\n\n    if proposal.status != ProposalStatus::Active {\n        return Err(ContractError::ProposalNotActive {});\n    }\n\n    if proposal.submitter == info.sender {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if env.block.height \u003e proposal.end_block {\n        return Err(ContractError::VotingPeriodEnded {});\n    }\n\n    if proposal.for_voters.contains(\u0026info.sender) || proposal.against_voters.contains(\u0026info.sender)\n    {\n        return Err(ContractError::UserAlreadyVoted {});\n    }\n\n    let voting_power = calc_voting_power(deps.as_ref(), info.sender.to_string(), \u0026proposal)?;\n\n    if voting_power.is_zero() {\n        return Err(ContractError::NoVotingPower {});\n    }\n\n    match vote_option {\n        ProposalVoteOption::For =\u003e {\n            proposal.for_power = proposal.for_power.checked_add(voting_power)?;\n            proposal.for_voters.push(info.sender.clone());\n        }\n        ProposalVoteOption::Against =\u003e {\n            proposal.against_power = proposal.against_power.checked_add(voting_power)?;\n            proposal.against_voters.push(info.sender.clone());\n        }\n    };\n\n    PROPOSALS.save(deps.storage, proposal_id, \u0026proposal)?;\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"cast_vote\"),\n        attr(\"proposal_id\", proposal_id.to_string()),\n        attr(\"voter\", \u0026info.sender),\n        attr(\"vote\", vote_option.to_string()),\n        attr(\"voting_power\", voting_power),\n    ]))\n}\n\n/// Ends proposal voting period and sets the proposal status by id.\npub fn end_proposal(deps: DepsMut, env: Env, proposal_id: u64) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut proposal = PROPOSALS.load(deps.storage, proposal_id)?;\n\n    if proposal.status != ProposalStatus::Active {\n        return Err(ContractError::ProposalNotActive {});\n    }\n\n    if env.block.height \u003c= proposal.end_block {\n        return Err(ContractError::VotingPeriodNotEnded {});\n    }\n\n    let config = CONFIG.load(deps.storage)?;\n\n    let for_votes = proposal.for_power;\n    let against_votes = proposal.against_power;\n    let total_votes = for_votes + against_votes;\n\n    let total_voting_power = calc_total_voting_power_at(deps.as_ref(), \u0026proposal)?;\n\n    let mut proposal_quorum: Decimal = Decimal::zero();\n    let mut proposal_threshold: Decimal = Decimal::zero();\n\n    if !total_voting_power.is_zero() {\n        proposal_quorum = Decimal::from_ratio(total_votes, total_voting_power);\n    }\n\n    if !total_votes.is_zero() {\n        proposal_threshold = Decimal::from_ratio(for_votes, total_votes);\n    }\n\n    // Determine the proposal result\n    proposal.status = if proposal_quorum \u003e= config.proposal_required_quorum\n        \u0026\u0026 proposal_threshold \u003e config.proposal_required_threshold\n    {\n        ProposalStatus::Passed\n    } else {\n        ProposalStatus::Rejected\n    };\n\n    PROPOSALS.save(deps.storage, proposal_id, \u0026proposal)?;\n\n    let response = Response::new()\n        .add_attributes(vec![\n            attr(\"action\", \"end_proposal\"),\n            attr(\"proposal_id\", proposal_id.to_string()),\n            attr(\"proposal_result\", proposal.status.to_string()),\n        ])\n        .add_message(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: config.xastro_token_addr.to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                recipient: proposal.submitter.to_string(),\n                amount: proposal.deposit_amount,\n            })?,\n            funds: vec![],\n        }));\n\n    Ok(response)\n}\n\n/// Executes a successful proposal by id.\npub fn execute_proposal(\n    deps: DepsMut,\n    env: Env,\n    proposal_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut proposal = PROPOSALS.load(deps.storage, proposal_id)?;\n\n    if proposal.status != ProposalStatus::Passed {\n        return Err(ContractError::ProposalNotPassed {});\n    }\n\n    if env.block.height \u003c proposal.delayed_end_block {\n        return Err(ContractError::ProposalDelayNotEnded {});\n    }\n\n    if env.block.height \u003e proposal.expiration_block {\n        return Err(ContractError::ExecuteProposalExpired {});\n    }\n\n    let messages;\n    if let Some(channel) = \u0026proposal.ibc_channel {\n        let config = CONFIG.load(deps.storage)?;\n\n        messages = match \u0026proposal.messages {\n            Some(messages) =\u003e {\n                if !messages.is_empty() {\n                    proposal.status = ProposalStatus::InProgress;\n                    vec![CosmosMsg::Wasm(wasm_execute(\n                        config\n                            .ibc_controller\n                            .ok_or(ContractError::MissingIBCController {})?,\n                        \u0026ControllerExecuteMsg::IbcExecuteProposal {\n                            channel_id: channel.to_string(),\n                            proposal_id,\n                            messages: messages.to_vec(),\n                        },\n                        vec![],\n                    )?)]\n                } else {\n                    proposal.status = ProposalStatus::Executed;\n                    vec![]\n                }\n            }\n            None =\u003e {\n                proposal.status = ProposalStatus::Executed;\n                vec![]\n            }\n        };\n\n        PROPOSALS.save(deps.storage, proposal_id, \u0026proposal)?;\n    } else {\n        proposal.status = ProposalStatus::Executed;\n        PROPOSALS.save(deps.storage, proposal_id, \u0026proposal)?;\n\n        messages = proposal.messages.unwrap_or_default()\n    }\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"execute_proposal\")\n        .add_attribute(\"proposal_id\", proposal_id.to_string())\n        .add_messages(messages))\n}\n\n/// Checks that proposal messages are correct.\npub fn check_messages(env: Env, mut messages: Vec\u003cCosmosMsg\u003e) -\u003e Result\u003cResponse, ContractError\u003e {\n    messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: env.contract.address.to_string(),\n        msg: to_binary(\u0026ExecuteMsg::CheckMessagesPassed {})?,\n        funds: vec![],\n    }));\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"check_messages\")\n        .add_messages(messages))\n}\n\n/// Removes an expired or rejected proposal from the general proposal list.\npub fn remove_completed_proposal(\n    deps: DepsMut,\n    env: Env,\n    proposal_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    let mut proposal = PROPOSALS.load(deps.storage, proposal_id)?;\n\n    if env.block.height\n        \u003e (proposal.end_block + config.proposal_effective_delay + config.proposal_expiration_period)\n    {\n        proposal.status = ProposalStatus::Expired;\n    }\n\n    if proposal.status != ProposalStatus::Expired \u0026\u0026 proposal.status != ProposalStatus::Rejected {\n        return Err(ContractError::ProposalNotCompleted {});\n    }\n\n    PROPOSALS.remove(deps.storage, proposal_id);\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"remove_completed_proposal\")\n        .add_attribute(\"proposal_id\", proposal_id.to_string()))\n}\n\n/// Updates Assembly contract parameters.\n///\n/// * **updated_config** new contract configuration.\npub fn update_config(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    updated_config: Box\u003cUpdateConfig\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    // Only the Assembly is allowed to update its own parameters (through a successful proposal)\n    if info.sender != env.contract.address {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(xastro_token_addr) = updated_config.xastro_token_addr {\n        config.xastro_token_addr = deps.api.addr_validate(\u0026xastro_token_addr)?;\n    }\n\n    if let Some(vxastro_token_addr) = updated_config.vxastro_token_addr {\n        config.vxastro_token_addr = Some(deps.api.addr_validate(\u0026vxastro_token_addr)?);\n    }\n\n    if let Some(voting_escrow_delegator_addr) = updated_config.voting_escrow_delegator_addr {\n        config.voting_escrow_delegator_addr = Some(\n            deps.api\n                .addr_validate(voting_escrow_delegator_addr.as_str())?,\n        )\n    }\n\n    if let Some(ibc_controller) = updated_config.ibc_controller {\n        config.ibc_controller = Some(deps.api.addr_validate(\u0026ibc_controller)?)\n    }\n\n    if let Some(builder_unlock_addr) = updated_config.builder_unlock_addr {\n        config.builder_unlock_addr = deps.api.addr_validate(\u0026builder_unlock_addr)?;\n    }\n\n    if let Some(proposal_voting_period) = updated_config.proposal_voting_period {\n        config.proposal_voting_period = proposal_voting_period;\n    }\n\n    if let Some(proposal_effective_delay) = updated_config.proposal_effective_delay {\n        config.proposal_effective_delay = proposal_effective_delay;\n    }\n\n    if let Some(proposal_expiration_period) = updated_config.proposal_expiration_period {\n        config.proposal_expiration_period = proposal_expiration_period;\n    }\n\n    if let Some(proposal_required_deposit) = updated_config.proposal_required_deposit {\n        config.proposal_required_deposit = Uint128::from(proposal_required_deposit);\n    }\n\n    if let Some(proposal_required_quorum) = updated_config.proposal_required_quorum {\n        config.proposal_required_quorum = Decimal::from_str(\u0026proposal_required_quorum)?;\n    }\n\n    if let Some(proposal_required_threshold) = updated_config.proposal_required_threshold {\n        config.proposal_required_threshold = Decimal::from_str(\u0026proposal_required_threshold)?;\n    }\n\n    if let Some(whitelist_add) = updated_config.whitelist_add {\n        validate_links(\u0026whitelist_add)?;\n\n        config.whitelisted_links.append(\n            \u0026mut whitelist_add\n                .into_iter()\n                .filter(|link| !config.whitelisted_links.contains(link))\n                .collect(),\n        );\n    }\n\n    if let Some(whitelist_remove) = updated_config.whitelist_remove {\n        config\n            .whitelisted_links\n            .retain(|link| !whitelist_remove.contains(link));\n\n        if config.whitelisted_links.is_empty() {\n            return Err(ContractError::WhitelistEmpty {});\n        }\n    }\n\n    config.validate()?;\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::new().add_attribute(\"action\", \"update_config\"))\n}\n\n/// Updates proposal status InProgress -\u003e Executed or Failed. Intended to be called in the end of\n/// the ibc execution cycle via ibc-controller. Only ibc controller is able to call this function.\n///\n/// * **id** proposal's id,\n///\n/// * **status** a new proposal status reported by ibc controller.\nfn update_ibc_proposal_status(\n    deps: DepsMut,\n    info: MessageInfo,\n    id: u64,\n    new_status: ProposalStatus,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n    if Some(info.sender) == config.ibc_controller {\n        let mut proposal = PROPOSALS.load(deps.storage, id)?;\n\n        if proposal.status != ProposalStatus::InProgress {\n            return Err(ContractError::WrongIbcProposalStatus(\n                proposal.status.to_string(),\n            ));\n        }\n\n        match new_status {\n            ProposalStatus::Executed {} | ProposalStatus::Failed {} =\u003e {\n                proposal.status = new_status;\n                PROPOSALS.save(deps.storage, id, \u0026proposal)?;\n                Ok(Response::new().add_attribute(\"action\", \"ibc_proposal_completed\"))\n            }\n            _ =\u003e Err(ContractError::InvalidRemoteIbcProposalStatus(\n                new_status.to_string(),\n            )),\n        }\n    } else {\n        Err(ContractError::InvalidIBCController {})\n    }\n}\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::Config {}** Returns core contract settings stored in the [`Config`] structure.\n///\n/// * **QueryMsg::Proposals { start, limit }** Returns a [`ProposalListResponse`] according to the specified input parameters.\n///\n/// * **QueryMsg::Proposal { proposal_id }** Returns a [`Proposal`] according to the specified `proposal_id`.\n///\n/// * **QueryMsg::ProposalVotes { proposal_id }** Returns proposal vote counts that are stored in the [`ProposalVotesResponse`] structure.\n///\n/// * **QueryMsg::UserVotingPower { user, proposal_id }** Returns user voting power for a specific proposal.\n///\n/// * **QueryMsg::TotalVotingPower { proposal_id }** Returns total voting power for a specific proposal.\n///\n/// * **QueryMsg::ProposalVoters {\n///             proposal_id,\n///             vote_option,\n///             start,\n///             limit,\n///         }** Returns a vector of proposal voters according to the specified input parameters.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Config {} =\u003e to_binary(\u0026CONFIG.load(deps.storage)?),\n        QueryMsg::Proposals { start, limit } =\u003e to_binary(\u0026query_proposals(deps, start, limit)?),\n        QueryMsg::Proposal { proposal_id } =\u003e {\n            to_binary(\u0026PROPOSALS.load(deps.storage, proposal_id)?)\n        }\n        QueryMsg::ProposalVotes { proposal_id } =\u003e {\n            to_binary(\u0026query_proposal_votes(deps, proposal_id)?)\n        }\n        QueryMsg::UserVotingPower { user, proposal_id } =\u003e {\n            let proposal = PROPOSALS.load(deps.storage, proposal_id)?;\n\n            deps.api.addr_validate(\u0026user)?;\n\n            to_binary(\u0026calc_voting_power(deps, user, \u0026proposal)?)\n        }\n        QueryMsg::TotalVotingPower { proposal_id } =\u003e {\n            let proposal = PROPOSALS.load(deps.storage, proposal_id)?;\n            to_binary(\u0026calc_total_voting_power_at(deps, \u0026proposal)?)\n        }\n        QueryMsg::ProposalVoters {\n            proposal_id,\n            vote_option,\n            start,\n            limit,\n        } =\u003e to_binary(\u0026query_proposal_voters(\n            deps,\n            proposal_id,\n            vote_option,\n            start,\n            limit,\n        )?),\n    }\n}\n\n/// Returns the current proposal list.\npub fn query_proposals(\n    deps: Deps,\n    start: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cProposalListResponse\u003e {\n    let proposal_count = PROPOSAL_COUNT.load(deps.storage)?;\n\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start.map(Bound::inclusive);\n\n    let proposal_list = PROPOSALS\n        .range(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|item| {\n            let (_, v) = item?;\n            Ok(v)\n        })\n        .collect::\u003cStdResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n    Ok(ProposalListResponse {\n        proposal_count,\n        proposal_list,\n    })\n}\n\n/// Returns proposal's voters.\npub fn query_proposal_voters(\n    deps: Deps,\n    proposal_id: u64,\n    vote_option: ProposalVoteOption,\n    start: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cVec\u003cAddr\u003e\u003e {\n    let limit = limit.unwrap_or(DEFAULT_VOTERS_LIMIT).min(MAX_VOTERS_LIMIT);\n    let start = start.unwrap_or_default();\n\n    let proposal = PROPOSALS.load(deps.storage, proposal_id)?;\n\n    let voters = match vote_option {\n        ProposalVoteOption::For =\u003e proposal.for_voters,\n        ProposalVoteOption::Against =\u003e proposal.against_voters,\n    };\n\n    Ok(voters\n        .iter()\n        .skip(start as usize)\n        .take(limit as usize)\n        .cloned()\n        .collect())\n}\n\n/// Returns proposal votes stored in the [`ProposalVotesResponse`] structure.\npub fn query_proposal_votes(deps: Deps, proposal_id: u64) -\u003e StdResult\u003cProposalVotesResponse\u003e {\n    let proposal = PROPOSALS.load(deps.storage, proposal_id)?;\n\n    Ok(ProposalVotesResponse {\n        proposal_id,\n        for_power: proposal.for_power,\n        against_power: proposal.against_power,\n    })\n}\n\n/// Calculates an address' voting power at the specified block.\n///\n/// * **sender** address whose voting power we calculate.\n///\n/// * **proposal** proposal for which we want to compute the `sender` (voter) voting power.\npub fn calc_voting_power(deps: Deps, sender: String, proposal: \u0026Proposal) -\u003e StdResult\u003cUint128\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // This is the address' xASTRO balance at the previous block (proposal.start_block - 1).\n    // We use the previous block because it always has an up-to-date checkpoint.\n    // BalanceAt will always return the balance information in the previous block,\n    // so we don't subtract one block from proposal.start_block.\n    let xastro_amount: BalanceResponse = deps.querier.query_wasm_smart(\n        config.xastro_token_addr,\n        \u0026XAstroTokenQueryMsg::BalanceAt {\n            address: sender.clone(),\n            block: proposal.start_block,\n        },\n    )?;\n\n    let mut total = xastro_amount.balance;\n\n    let locked_amount: AllocationResponse = deps.querier.query_wasm_smart(\n        config.builder_unlock_addr,\n        \u0026BuilderUnlockQueryMsg::Allocation {\n            account: sender.clone(),\n        },\n    )?;\n\n    if !locked_amount.params.amount.is_zero() {\n        total = total\n            .checked_add(locked_amount.params.amount)?\n            .checked_sub(locked_amount.status.astro_withdrawn)?;\n    }\n\n    if let Some(vxastro_token_addr) = config.vxastro_token_addr {\n        let vxastro_amount: Uint128 =\n            if let Some(voting_escrow_delegator_addr) = config.voting_escrow_delegator_addr {\n                deps.querier.query_wasm_smart(\n                    voting_escrow_delegator_addr,\n                    \u0026AdjustedBalance {\n                        account: sender.clone(),\n                        timestamp: Some(proposal.start_time - WEEK),\n                    },\n                )?\n            } else {\n                let res: VotingPowerResponse = deps.querier.query_wasm_smart(\n                    \u0026vxastro_token_addr,\n                    \u0026VotingEscrowQueryMsg::UserVotingPowerAt {\n                        user: sender.clone(),\n                        time: proposal.start_time - WEEK,\n                    },\n                )?;\n\n                res.voting_power\n            };\n\n        if !vxastro_amount.is_zero() {\n            total = total.checked_add(vxastro_amount)?;\n        }\n\n        let locked_xastro: Uint128 = deps.querier.query_wasm_smart(\n            vxastro_token_addr,\n            \u0026VotingEscrowQueryMsg::UserDepositAtHeight {\n                user: sender,\n                height: proposal.start_block,\n            },\n        )?;\n\n        total = total.checked_add(locked_xastro)?;\n    }\n\n    Ok(total)\n}\n\n/// Calculates the total voting power at a specified block (that is relevant for a specific proposal).\n///\n/// * **proposal** proposal for which we calculate the total voting power.\npub fn calc_total_voting_power_at(deps: Deps, proposal: \u0026Proposal) -\u003e StdResult\u003cUint128\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // This is the address' xASTRO balance at the previous block (proposal.start_block - 1).\n    // We use the previous block because it always has an up-to-date checkpoint.\n    let mut total: Uint128 = deps.querier.query_wasm_smart(\n        \u0026config.xastro_token_addr,\n        \u0026XAstroTokenQueryMsg::TotalSupplyAt {\n            block: proposal.start_block - 1,\n        },\n    )?;\n\n    // Total amount of ASTRO locked in the initial builder's unlock schedule\n    let builder_state: StateResponse = deps\n        .querier\n        .query_wasm_smart(config.builder_unlock_addr, \u0026BuilderUnlockQueryMsg::State {})?;\n\n    if !builder_state.remaining_astro_tokens.is_zero() {\n        total = total.checked_add(builder_state.remaining_astro_tokens)?;\n    }\n\n    if let Some(vxastro_token_addr) = config.vxastro_token_addr {\n        // Total vxASTRO voting power\n        let vxastro: VotingPowerResponse = deps.querier.query_wasm_smart(\n            vxastro_token_addr,\n            \u0026VotingEscrowQueryMsg::TotalVotingPowerAt {\n                time: proposal.start_time - WEEK,\n            },\n        )?;\n        if !vxastro.voting_power.is_zero() {\n            total = total.checked_add(vxastro.voting_power)?;\n        }\n    }\n\n    Ok(total)\n}\n\n/// Checks that controller supports given IBC-channel.\n/// ## Params\n/// * **querier** is an object of type [`QuerierWrapper`].\n///\n/// * **ibc_controller** is an ibc controller contract address.\n///\n/// * **given_channel** is an IBC channel id the function needs to check.\npub fn check_controller_supports_channel(\n    querier: QuerierWrapper,\n    ibc_controller: \u0026Addr,\n    given_channel: \u0026String,\n) -\u003e Result\u003c(), ContractError\u003e {\n    let port_id = Some(format!(\"wasm.{ibc_controller}\"));\n    let ListChannelsResponse { channels } =\n        querier.query(\u0026QueryRequest::Ibc(IbcQuery::ListChannels { port_id }))?;\n    channels\n        .iter()\n        .find(|channel| \u0026channel.endpoint.channel_id == given_channel)\n        .map(|_| ())\n        .ok_or_else(|| ContractError::InvalidChannel(given_channel.to_string()))\n}\n\n/// Manages contract migration.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(mut deps: DepsMut, _env: Env, msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    let contract_version = get_contract_version(deps.storage)?;\n\n    match contract_version.contract.as_ref() {\n        \"astro-assembly\" =\u003e match contract_version.version.as_ref() {\n            \"1.3.0\" =\u003e {\n                let cfg = migrate_config_to_140(deps.branch(), msg)?;\n                migrate_proposals_to_v140(deps.branch(), \u0026cfg)?;\n            }\n            _ =\u003e return Err(ContractError::MigrationError {}),\n        },\n        _ =\u003e return Err(ContractError::MigrationError {}),\n    };\n\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    Ok(Response::new()\n        .add_attribute(\"previous_contract_name\", \u0026contract_version.contract)\n        .add_attribute(\"previous_contract_version\", \u0026contract_version.version)\n        .add_attribute(\"new_contract_name\", CONTRACT_NAME)\n        .add_attribute(\"new_contract_version\", CONTRACT_VERSION))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","assembly","src","error.rs"],"content":"use astroport_governance::assembly::ProposalStatus;\nuse cosmwasm_std::{OverflowError, StdError};\nuse thiserror::Error;\n\n/// This enum describes Assembly contract errors\n#[derive(Error, Debug)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Proposal not active!\")]\n    ProposalNotActive {},\n\n    #[error(\"Voting period ended!\")]\n    VotingPeriodEnded {},\n\n    #[error(\"User already voted!\")]\n    UserAlreadyVoted {},\n\n    #[error(\"You don't have any voting power!\")]\n    NoVotingPower {},\n\n    #[error(\"Voting period not ended yet!\")]\n    VotingPeriodNotEnded {},\n\n    #[error(\"Proposal expired!\")]\n    ExecuteProposalExpired {},\n\n    #[error(\"Insufficient token deposit!\")]\n    InsufficientDeposit {},\n\n    #[error(\"Proposal not passed!\")]\n    ProposalNotPassed {},\n\n    #[error(\"Proposal not completed!\")]\n    ProposalNotCompleted {},\n\n    #[error(\"Proposal delay not ended!\")]\n    ProposalDelayNotEnded {},\n\n    #[error(\"Contract can't be migrated!\")]\n    MigrationError {},\n\n    #[error(\"Whitelist cannot be empty!\")]\n    WhitelistEmpty {},\n\n    #[error(\"Messages check passed. Nothing was committed to the blockchain\")]\n    MessagesCheckPassed {},\n\n    #[error(\"IBC controller does not have channel {0}\")]\n    InvalidChannel(String),\n\n    #[error(\"IBC controller is not set\")]\n    MissingIBCController {},\n\n    #[error(\n        \"Failed to process callback from IBC controller as proposal {0} is not in \\\"{}\\\" state\",\n        ProposalStatus::InProgress\n    )]\n    WrongIbcProposalStatus(String),\n\n    #[error(\"The IBC controller reports an invalid proposal status: {0}. Valid statuses: failed or executed \")]\n    InvalidRemoteIbcProposalStatus(String),\n\n    #[error(\"Sender is not an IBC controller installed in the assembly\")]\n    InvalidIBCController {},\n}\n\nimpl From\u003cOverflowError\u003e for ContractError {\n    fn from(o: OverflowError) -\u003e Self {\n        StdError::from(o).into()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","assembly","src","lib.rs"],"content":"pub mod contract;\npub mod error;\npub mod state;\n\nmod migration;\n\n// During development this import could be replaced with another astroport version.\n// However, in production, the astroport version should be the same for all contracts.\npub use astroport_governance::astroport;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","assembly","src","migration.rs"],"content":"use crate::state::{CONFIG, PROPOSALS};\nuse astroport_governance::{\n    assembly::{Config, Proposal, ProposalStatus},\n    astroport::asset::addr_opt_validate,\n};\n\nuse cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, CosmosMsg, Decimal, DepsMut, StdResult, Uint128, Uint64};\nuse cw_storage_plus::{Item, Map};\n\n/// This structure describes a migration message.\n#[cw_serde]\npub struct MigrateMsg {\n    voting_escrow_delegator_addr: Option\u003cString\u003e,\n    vxastro_token_addr: Option\u003cString\u003e,\n    ibc_controller: Option\u003cString\u003e,\n}\n\n#[cw_serde]\npub struct ProposalV130 {\n    /// Unique proposal ID\n    pub proposal_id: Uint64,\n    /// The address of the proposal submitter\n    pub submitter: Addr,\n    /// Status of the proposal\n    pub status: ProposalStatus,\n    /// `For` power of proposal\n    pub for_power: Uint128,\n    /// `Against` power of proposal\n    pub against_power: Uint128,\n    /// `For` votes for the proposal\n    pub for_voters: Vec\u003cAddr\u003e,\n    /// `Against` votes for the proposal\n    pub against_voters: Vec\u003cAddr\u003e,\n    /// Start block of proposal\n    pub start_block: u64,\n    /// Start time of proposal\n    pub start_time: u64,\n    /// End block of proposal\n    pub end_block: u64,\n    /// Delayed end block of proposal\n    pub delayed_end_block: u64,\n    /// Expiration block of proposal\n    pub expiration_block: u64,\n    /// Proposal title\n    pub title: String,\n    /// Proposal description\n    pub description: String,\n    /// Proposal link\n    pub link: Option\u003cString\u003e,\n    /// Proposal messages\n    pub messages: Option\u003cVec\u003cCosmosMsg\u003e\u003e,\n    /// Amount of xASTRO deposited in order to post the proposal\n    pub deposit_amount: Uint128,\n    /// IBC channel\n    pub ibc_channel: Option\u003cString\u003e,\n}\n\n#[cw_serde]\npub struct ConfigV130 {\n    /// xASTRO token address\n    pub xastro_token_addr: Addr,\n    /// vxASTRO token address\n    pub vxastro_token_addr: Option\u003cAddr\u003e,\n    /// Astroport IBC controller contract\n    pub ibc_controller: Option\u003cAddr\u003e,\n    /// Builder unlock contract address\n    pub builder_unlock_addr: Addr,\n    /// Proposal voting period\n    pub proposal_voting_period: u64,\n    /// Proposal effective delay\n    pub proposal_effective_delay: u64,\n    /// Proposal expiration period\n    pub proposal_expiration_period: u64,\n    /// Proposal required deposit\n    pub proposal_required_deposit: Uint128,\n    /// Proposal required quorum\n    pub proposal_required_quorum: Decimal,\n    /// Proposal required threshold\n    pub proposal_required_threshold: Decimal,\n    /// Whitelisted links\n    pub whitelisted_links: Vec\u003cString\u003e,\n}\n\npub const CONFIG_V130: Item\u003cConfigV130\u003e = Item::new(\"config\");\n\n/// Migrate proposals to V1.4.0\npub(crate) fn migrate_proposals_to_v140(deps: DepsMut, cfg: \u0026Config) -\u003e StdResult\u003c()\u003e {\n    let v130_proposals_interface: Map\u003cu64, ProposalV130\u003e = Map::new(\"proposals\");\n    let proposals_v130 = v130_proposals_interface\n        .range(deps.storage, None, None, cosmwasm_std::Order::Ascending {})\n        .collect::\u003cStdResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n    for (key, proposal) in proposals_v130 {\n        PROPOSALS.save(\n            deps.storage,\n            key,\n            \u0026Proposal {\n                proposal_id: proposal.proposal_id,\n                submitter: proposal.submitter,\n                status: proposal.status,\n                for_power: proposal.for_power,\n                against_power: proposal.against_power,\n                for_voters: proposal.for_voters,\n                against_voters: proposal.against_voters,\n                start_block: proposal.start_block,\n                start_time: proposal.start_time,\n                end_block: proposal.end_block,\n                delayed_end_block: proposal.end_block + cfg.proposal_effective_delay,\n                expiration_block: proposal.end_block\n                    + cfg.proposal_effective_delay\n                    + cfg.proposal_expiration_period,\n                title: proposal.title,\n                description: proposal.description,\n                link: proposal.link,\n                messages: proposal.messages,\n                deposit_amount: proposal.deposit_amount,\n                ibc_channel: proposal.ibc_channel,\n            },\n        )?;\n    }\n\n    Ok(())\n}\n\n/// Migrate contract config to V1.4.0\npub(crate) fn migrate_config_to_140(deps: DepsMut, msg: MigrateMsg) -\u003e StdResult\u003cConfig\u003e {\n    let cfg_v130 = CONFIG_V130.load(deps.storage)?;\n\n    let cfg = Config {\n        xastro_token_addr: cfg_v130.xastro_token_addr,\n        vxastro_token_addr: cfg_v130.vxastro_token_addr,\n        voting_escrow_delegator_addr: addr_opt_validate(\n            deps.api,\n            \u0026msg.voting_escrow_delegator_addr,\n        )?,\n        ibc_controller: cfg_v130.ibc_controller,\n        builder_unlock_addr: cfg_v130.builder_unlock_addr,\n        proposal_voting_period: cfg_v130.proposal_voting_period,\n        proposal_effective_delay: cfg_v130.proposal_effective_delay,\n        proposal_expiration_period: cfg_v130.proposal_expiration_period,\n        proposal_required_deposit: cfg_v130.proposal_required_deposit,\n        proposal_required_quorum: cfg_v130.proposal_required_quorum,\n        proposal_required_threshold: cfg_v130.proposal_required_threshold,\n        whitelisted_links: cfg_v130.whitelisted_links,\n    };\n\n    CONFIG.save(deps.storage, \u0026cfg)?;\n\n    Ok(cfg)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","assembly","src","state.rs"],"content":"use astroport_governance::assembly::{Config, Proposal};\nuse cosmwasm_std::Uint64;\nuse cw_storage_plus::{Item, Map};\n\n/// Stores the config for the Assembly contract\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n\n/// Stores the global state for the Assembly contract\npub const PROPOSAL_COUNT: Item\u003cUint64\u003e = Item::new(\"proposal_count\");\n\n/// This is a map that contains information about all proposals\npub const PROPOSALS: Map\u003cu64, Proposal\u003e = Map::new(\"proposals\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","assembly","tests","integration.rs"],"content":"use astro_assembly::astroport;\nuse astroport::{\n    token::InstantiateMsg as TokenInstantiateMsg, xastro_token::QueryMsg as XAstroQueryMsg,\n};\nuse astroport_governance::assembly::{\n    Config, Cw20HookMsg, ExecuteMsg, InstantiateMsg, Proposal, ProposalListResponse,\n    ProposalStatus, ProposalVoteOption, ProposalVotesResponse, QueryMsg, UpdateConfig,\n    DEPOSIT_INTERVAL, VOTING_PERIOD_INTERVAL,\n};\n\nuse std::str::FromStr;\n\nuse astroport_governance::voting_escrow::{\n    Cw20HookMsg as VXAstroCw20HookMsg, InstantiateMsg as VXAstroInstantiateMsg,\n};\n\nuse astroport_governance::builder_unlock::msg::{\n    InstantiateMsg as BuilderUnlockInstantiateMsg, ReceiveMsg as BuilderUnlockReceiveMsg,\n};\nuse astroport_governance::builder_unlock::{AllocationParams, Schedule};\nuse astroport_governance::utils::{EPOCH_START, WEEK};\nuse astroport_governance::voting_escrow_delegation::{\n    ExecuteMsg as DelegatorExecuteMsg, InstantiateMsg as DelegatorInstantiateMsg,\n    QueryMsg as DelegatorQueryMsg,\n};\nuse cosmwasm_std::{\n    testing::{mock_env, MockApi, MockStorage},\n    to_binary, Addr, Binary, CosmosMsg, Decimal, QueryRequest, StdResult, Timestamp, Uint128,\n    Uint64, WasmMsg, WasmQuery,\n};\nuse cw20::{BalanceResponse, Cw20ExecuteMsg, MinterResponse};\nuse cw_multi_test::{\n    next_block, App, AppBuilder, AppResponse, BankKeeper, ContractWrapper, Executor,\n};\n\nconst PROPOSAL_VOTING_PERIOD: u64 = *VOTING_PERIOD_INTERVAL.start();\nconst PROPOSAL_EFFECTIVE_DELAY: u64 = 12_342;\nconst PROPOSAL_EXPIRATION_PERIOD: u64 = 86_399;\nconst PROPOSAL_REQUIRED_DEPOSIT: u128 = *DEPOSIT_INTERVAL.start();\nconst PROPOSAL_REQUIRED_QUORUM: \u0026str = \"0.50\";\nconst PROPOSAL_REQUIRED_THRESHOLD: \u0026str = \"0.60\";\n\n#[cfg(not(feature = \"testnet\"))]\n#[test]\nfn test_contract_instantiation() {\n    let mut app = mock_app();\n\n    let owner = Addr::unchecked(\"owner\");\n\n    // Instantiate needed contracts\n    let token_addr = instantiate_astro_token(\u0026mut app, \u0026owner);\n    let (_, xastro_token_addr) = instantiate_xastro_token(\u0026mut app, \u0026owner, \u0026token_addr);\n    let vxastro_token_addr = instantiate_vxastro_token(\u0026mut app, \u0026owner, \u0026xastro_token_addr);\n    let builder_unlock_addr = instantiate_builder_unlock_contract(\u0026mut app, \u0026owner, \u0026token_addr);\n\n    let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n        astro_assembly::contract::execute,\n        astro_assembly::contract::instantiate,\n        astro_assembly::contract::query,\n    ));\n\n    let assembly_code = app.store_code(assembly_contract);\n\n    let assembly_default_instantiate_msg = InstantiateMsg {\n        xastro_token_addr: xastro_token_addr.to_string(),\n        vxastro_token_addr: Some(vxastro_token_addr.to_string()),\n        voting_escrow_delegator_addr: None,\n        ibc_controller: None,\n        builder_unlock_addr: builder_unlock_addr.to_string(),\n        proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n        proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n        proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n        proposal_required_deposit: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n        proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n        proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n        whitelisted_links: vec![\"https://some.link/\".to_string()],\n    };\n\n    // Try to instantiate assembly with wrong threshold\n    let err = app\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                proposal_required_threshold: \"0.3\".to_string(),\n                ..assembly_default_instantiate_msg.clone()\n            },\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: The required threshold for a proposal cannot be lower than 33% or higher than 100%\"\n    );\n\n    let err = app\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                proposal_required_threshold: \"1.1\".to_string(),\n                ..assembly_default_instantiate_msg.clone()\n            },\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: The required threshold for a proposal cannot be lower than 33% or higher than 100%\"\n    );\n\n    let err = app\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                proposal_required_quorum: \"1.1\".to_string(),\n                ..assembly_default_instantiate_msg.clone()\n            },\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: The required quorum for a proposal cannot be lower than 1% or higher than 100%\"\n    );\n\n    let err = app\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                proposal_expiration_period: 500,\n                ..assembly_default_instantiate_msg.clone()\n            },\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: The expiration period for a proposal cannot be lower than 12342 or higher than 100800\"\n    );\n\n    let err = app\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026InstantiateMsg {\n                proposal_effective_delay: 400,\n                ..assembly_default_instantiate_msg.clone()\n            },\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: The effective delay for a proposal cannot be lower than 6171 or higher than 14400\"\n    );\n\n    let assembly_instance = app\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026assembly_default_instantiate_msg,\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let res: Config = app\n        .wrap()\n        .query_wasm_smart(assembly_instance, \u0026QueryMsg::Config {})\n        .unwrap();\n\n    assert_eq!(res.xastro_token_addr, xastro_token_addr);\n    assert_eq!(res.builder_unlock_addr, builder_unlock_addr);\n    assert_eq!(res.proposal_voting_period, PROPOSAL_VOTING_PERIOD);\n    assert_eq!(res.proposal_effective_delay, PROPOSAL_EFFECTIVE_DELAY);\n    assert_eq!(res.proposal_expiration_period, PROPOSAL_EXPIRATION_PERIOD);\n    assert_eq!(\n        res.proposal_required_deposit,\n        Uint128::from(PROPOSAL_REQUIRED_DEPOSIT)\n    );\n    assert_eq!(\n        res.proposal_required_quorum,\n        Decimal::from_str(PROPOSAL_REQUIRED_QUORUM).unwrap()\n    );\n    assert_eq!(\n        res.proposal_required_threshold,\n        Decimal::from_str(PROPOSAL_REQUIRED_THRESHOLD).unwrap()\n    );\n    assert_eq!(\n        res.whitelisted_links,\n        vec![\"https://some.link/\".to_string(),]\n    );\n}\n\n#[test]\nfn test_proposal_submitting() {\n    let mut app = mock_app();\n\n    let owner = Addr::unchecked(\"owner\");\n    let user = Addr::unchecked(\"user1\");\n\n    let (_, staking_instance, xastro_addr, _, _, assembly_addr, _) =\n        instantiate_contracts(\u0026mut app, owner, false);\n\n    let proposals: ProposalListResponse = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposals {\n                start: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(proposals.proposal_count, Uint64::from(0u32));\n    assert_eq!(proposals.proposal_list, vec![]);\n\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026user,\n        PROPOSAL_REQUIRED_DEPOSIT,\n    );\n\n    check_token_balance(\u0026mut app, \u0026xastro_addr, \u0026user, PROPOSAL_REQUIRED_DEPOSIT);\n\n    // Try to create proposal with insufficient token deposit\n    let submit_proposal_msg = Cw20ExecuteMsg::Send {\n        contract: assembly_addr.to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n            title: String::from(\"Title\"),\n            description: String::from(\"Description\"),\n            link: Some(String::from(\"https://some.link\")),\n            messages: None,\n            ibc_channel: None,\n        })\n        .unwrap(),\n        amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT - 1),\n    };\n\n    let err = app\n        .execute_contract(user.clone(), xastro_addr.clone(), \u0026submit_proposal_msg, \u0026[])\n        .unwrap_err();\n\n    assert_eq!(err.root_cause().to_string(), \"Insufficient token deposit!\");\n\n    // Try to create a proposal with wrong title\n    let err = app\n        .execute_contract(\n            user.clone(),\n            xastro_addr.clone(),\n            \u0026Cw20ExecuteMsg::Send {\n                contract: assembly_addr.to_string(),\n                msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                    title: String::from(\"X\"),\n                    description: String::from(\"Description\"),\n                    link: Some(String::from(\"https://some.link/\")),\n                    messages: None,\n                    ibc_channel: None,\n                })\n                .unwrap(),\n                amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Title too short!\"\n    );\n\n    let err = app\n        .execute_contract(\n            user.clone(),\n            xastro_addr.clone(),\n            \u0026Cw20ExecuteMsg::Send {\n                contract: assembly_addr.to_string(),\n                msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                    title: String::from_utf8(vec![b'X'; 65]).unwrap(),\n                    description: String::from(\"Description\"),\n                    link: Some(String::from(\"https://some.link/\")),\n                    messages: None,\n                    ibc_channel: None,\n                })\n                .unwrap(),\n                amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Title too long!\"\n    );\n\n    // Try to create a proposal with wrong description\n    let err = app\n        .execute_contract(\n            user.clone(),\n            xastro_addr.clone(),\n            \u0026Cw20ExecuteMsg::Send {\n                contract: assembly_addr.to_string(),\n                msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                    title: String::from(\"Title\"),\n                    description: String::from(\"X\"),\n                    link: Some(String::from(\"https://some.link/\")),\n                    messages: None,\n                    ibc_channel: None,\n                })\n                .unwrap(),\n                amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Description too short!\"\n    );\n\n    let err = app\n        .execute_contract(\n            user.clone(),\n            xastro_addr.clone(),\n            \u0026Cw20ExecuteMsg::Send {\n                contract: assembly_addr.to_string(),\n                msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                    title: String::from(\"Title\"),\n                    description: String::from_utf8(vec![b'X'; 1025]).unwrap(),\n                    link: Some(String::from(\"https://some.link/\")),\n                    messages: None,\n                    ibc_channel: None,\n                })\n                .unwrap(),\n                amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Description too long!\"\n    );\n\n    // Try to create a proposal with wrong link\n    let err = app\n        .execute_contract(\n            user.clone(),\n            xastro_addr.clone(),\n            \u0026Cw20ExecuteMsg::Send {\n                contract: assembly_addr.to_string(),\n                msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                    title: String::from(\"Title\"),\n                    description: String::from(\"Description\"),\n                    link: Some(String::from(\"X\")),\n                    messages: None,\n                    ibc_channel: None,\n                })\n                .unwrap(),\n                amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Link too short!\"\n    );\n\n    let err = app\n        .execute_contract(\n            user.clone(),\n            xastro_addr.clone(),\n            \u0026Cw20ExecuteMsg::Send {\n                contract: assembly_addr.to_string(),\n                msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                    title: String::from(\"Title\"),\n                    description: String::from(\"Description\"),\n                    link: Some(String::from_utf8(vec![b'X'; 129]).unwrap()),\n                    messages: None,\n                    ibc_channel: None,\n                })\n                .unwrap(),\n                amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Link too long!\"\n    );\n\n    let err = app\n        .execute_contract(\n            user.clone(),\n            xastro_addr.clone(),\n            \u0026Cw20ExecuteMsg::Send {\n                contract: assembly_addr.to_string(),\n                msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                    title: String::from(\"Title\"),\n                    description: String::from(\"Description\"),\n                    link: Some(String::from(\"https://some1.link\")),\n                    messages: None,\n                    ibc_channel: None,\n                })\n                .unwrap(),\n                amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Link is not whitelisted!\"\n    );\n\n    let err = app\n        .execute_contract(\n            user.clone(),\n            xastro_addr.clone(),\n            \u0026Cw20ExecuteMsg::Send {\n                contract: assembly_addr.to_string(),\n                msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                    title: String::from(\"Title\"),\n                    description: String::from(\"Description\"),\n                    link: Some(String::from(\n                        \"https://some.link/\u003cscript\u003ealert('test');\u003c/script\u003e\",\n                    )),\n                    messages: None,\n                    ibc_channel: None,\n                })\n                .unwrap(),\n                amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Link is not properly formatted or contains unsafe characters!\"\n    );\n\n    // Valid proposal submission\n    app.execute_contract(\n        user.clone(),\n        xastro_addr.clone(),\n        \u0026Cw20ExecuteMsg::Send {\n            contract: assembly_addr.to_string(),\n            msg: to_binary(\u0026Cw20HookMsg::SubmitProposal {\n                title: String::from(\"Title\"),\n                description: String::from(\"Description\"),\n                link: Some(String::from(\"https://some.link/q/\")),\n                messages: Some(vec![CosmosMsg::Wasm(WasmMsg::Execute {\n                    contract_addr: assembly_addr.to_string(),\n                    msg: to_binary(\u0026ExecuteMsg::UpdateConfig(Box::new(UpdateConfig {\n                        xastro_token_addr: None,\n                        vxastro_token_addr: None,\n                        voting_escrow_delegator_addr: None,\n                        ibc_controller: None,\n                        builder_unlock_addr: None,\n                        proposal_voting_period: Some(750),\n                        proposal_effective_delay: None,\n                        proposal_expiration_period: None,\n                        proposal_required_deposit: None,\n                        proposal_required_quorum: None,\n                        proposal_required_threshold: None,\n                        whitelist_add: None,\n                        whitelist_remove: None,\n                    })))\n                    .unwrap(),\n                    funds: vec![],\n                })]),\n                ibc_channel: None,\n            })\n            .unwrap(),\n            amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    assert_eq!(proposal.proposal_id, Uint64::from(1u64));\n    assert_eq!(proposal.submitter, user);\n    assert_eq!(proposal.status, ProposalStatus::Active);\n    assert_eq!(proposal.for_power, Uint128::zero());\n    assert_eq!(proposal.against_power, Uint128::zero());\n    assert_eq!(proposal.start_block, 12_345);\n    assert_eq!(proposal.end_block, 12_345 + PROPOSAL_VOTING_PERIOD);\n    assert_eq!(proposal.title, String::from(\"Title\"));\n    assert_eq!(proposal.description, String::from(\"Description\"));\n    assert_eq!(proposal.link, Some(String::from(\"https://some.link/q/\")));\n    assert_eq!(\n        proposal.messages,\n        Some(vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: assembly_addr.to_string(),\n            msg: to_binary(\u0026ExecuteMsg::UpdateConfig(Box::new(UpdateConfig {\n                xastro_token_addr: None,\n                vxastro_token_addr: None,\n                voting_escrow_delegator_addr: None,\n                ibc_controller: None,\n                builder_unlock_addr: None,\n                proposal_voting_period: Some(750),\n                proposal_effective_delay: None,\n                proposal_expiration_period: None,\n                proposal_required_deposit: None,\n                proposal_required_quorum: None,\n                proposal_required_threshold: None,\n                whitelist_add: None,\n                whitelist_remove: None,\n            })))\n            .unwrap(),\n            funds: vec![],\n        })])\n    );\n    assert_eq!(\n        proposal.deposit_amount,\n        Uint128::from(PROPOSAL_REQUIRED_DEPOSIT)\n    )\n}\n\n#[cfg(not(feature = \"testnet\"))]\n#[test]\nfn test_successful_proposal() {\n    let mut app = mock_app();\n\n    let owner = Addr::unchecked(\"owner\");\n\n    let (\n        token_addr,\n        staking_instance,\n        xastro_addr,\n        vxastro_addr,\n        builder_unlock_addr,\n        assembly_addr,\n        _,\n    ) = instantiate_contracts(\u0026mut app, owner, false);\n\n    // Init voting power for users\n    let balances: Vec\u003c(\u0026str, u128, u128)\u003e = vec![\n        (\"user0\", PROPOSAL_REQUIRED_DEPOSIT, 0), // proposal submitter\n        (\"user1\", 20, 80),\n        (\"user2\", 100, 100),\n        (\"user3\", 300, 100),\n        (\"user4\", 200, 50),\n        (\"user5\", 0, 90),\n        (\"user6\", 100, 200),\n        (\"user7\", 30, 0),\n        (\"user8\", 80, 100),\n        (\"user9\", 50, 0),\n        (\"user10\", 0, 90),\n        (\"user11\", 500, 0),\n        (\"user12\", 10000_000000, 0),\n    ];\n\n    let default_allocation_params = AllocationParams {\n        amount: Uint128::zero(),\n        unlock_schedule: Schedule {\n            start_time: 12_345,\n            cliff: 5,\n            duration: 500,\n        },\n        proposed_receiver: None,\n    };\n\n    let locked_balances = vec![\n        (\n            \"user1\".to_string(),\n            AllocationParams {\n                amount: Uint128::from(80u32),\n                ..default_allocation_params.clone()\n            },\n        ),\n        (\n            \"user4\".to_string(),\n            AllocationParams {\n                amount: Uint128::from(50u32),\n                ..default_allocation_params.clone()\n            },\n        ),\n        (\n            \"user7\".to_string(),\n            AllocationParams {\n                amount: Uint128::from(100u32),\n                ..default_allocation_params.clone()\n            },\n        ),\n        (\n            \"user10\".to_string(),\n            AllocationParams {\n                amount: Uint128::from(30u32),\n                ..default_allocation_params.clone()\n            },\n        ),\n    ];\n\n    for (addr, xastro, vxastro) in balances {\n        if xastro \u003e 0 {\n            mint_tokens(\n                \u0026mut app,\n                \u0026staking_instance,\n                \u0026xastro_addr,\n                \u0026Addr::unchecked(addr),\n                xastro,\n            );\n        }\n\n        if vxastro \u003e 0 {\n            mint_vxastro(\n                \u0026mut app,\n                \u0026staking_instance,\n                xastro_addr.clone(),\n                \u0026vxastro_addr,\n                Addr::unchecked(addr),\n                vxastro,\n            );\n        }\n    }\n\n    create_allocations(\u0026mut app, token_addr, builder_unlock_addr, locked_balances);\n\n    // Skip period\n    app.update_block(|mut block| {\n        block.time = block.time.plus_seconds(WEEK);\n        block.height += WEEK / 5;\n    });\n\n    // Create default proposal\n    create_proposal(\n        \u0026mut app,\n        \u0026xastro_addr,\n        \u0026assembly_addr,\n        Addr::unchecked(\"user0\"),\n        Some(vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: assembly_addr.to_string(),\n            msg: to_binary(\u0026ExecuteMsg::UpdateConfig(Box::new(UpdateConfig {\n                xastro_token_addr: None,\n                vxastro_token_addr: None,\n                voting_escrow_delegator_addr: None,\n                ibc_controller: None,\n                builder_unlock_addr: None,\n                proposal_voting_period: Some(PROPOSAL_VOTING_PERIOD + 1000),\n                proposal_effective_delay: None,\n                proposal_expiration_period: None,\n                proposal_required_deposit: None,\n                proposal_required_quorum: None,\n                proposal_required_threshold: None,\n                whitelist_add: Some(vec![\n                    \"https://some1.link/\".to_string(),\n                    \"https://some2.link/\".to_string(),\n                ]),\n                whitelist_remove: Some(vec![\"https://some.link/\".to_string()]),\n            })))\n            .unwrap(),\n            funds: vec![],\n        })]),\n    );\n\n    let votes: Vec\u003c(\u0026str, ProposalVoteOption, u128)\u003e = vec![\n        (\"user1\", ProposalVoteOption::For, 280u128),\n        (\"user2\", ProposalVoteOption::For, 350u128),\n        (\"user3\", ProposalVoteOption::For, 550u128),\n        (\"user4\", ProposalVoteOption::For, 350u128),\n        (\"user5\", ProposalVoteOption::For, 240u128),\n        (\"user6\", ProposalVoteOption::For, 600u128),\n        (\"user7\", ProposalVoteOption::For, 130u128),\n        (\"user8\", ProposalVoteOption::Against, 330u128),\n        (\"user9\", ProposalVoteOption::Against, 50u128),\n        (\"user10\", ProposalVoteOption::Against, 270u128),\n        (\"user11\", ProposalVoteOption::Against, 500u128),\n        (\"user12\", ProposalVoteOption::For, 10000_000000u128),\n    ];\n\n    check_total_vp(\u0026mut app, \u0026assembly_addr, 1, 20000003650);\n\n    for (addr, option, expected_vp) in votes {\n        let sender = Addr::unchecked(addr);\n\n        check_user_vp(\u0026mut app, \u0026assembly_addr, \u0026sender, 1, expected_vp);\n\n        cast_vote(\u0026mut app, assembly_addr.clone(), 1, sender, option).unwrap();\n    }\n\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    let proposal_votes: ProposalVotesResponse = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::ProposalVotes { proposal_id: 1 },\n        )\n        .unwrap();\n\n    let proposal_for_voters: Vec\u003cAddr\u003e = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::ProposalVoters {\n                proposal_id: 1,\n                vote_option: ProposalVoteOption::For,\n                start: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    let proposal_against_voters: Vec\u003cAddr\u003e = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::ProposalVoters {\n                proposal_id: 1,\n                vote_option: ProposalVoteOption::Against,\n                start: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    // Check proposal votes\n    assert_eq!(proposal.for_power, Uint128::from(10000002500u128));\n    assert_eq!(proposal.against_power, Uint128::from(1150u32));\n\n    assert_eq!(proposal_votes.for_power, Uint128::from(10000002500u128));\n    assert_eq!(proposal_votes.against_power, Uint128::from(1150u32));\n\n    assert_eq!(\n        proposal_for_voters,\n        vec![\n            Addr::unchecked(\"user1\"),\n            Addr::unchecked(\"user2\"),\n            Addr::unchecked(\"user3\"),\n            Addr::unchecked(\"user4\"),\n            Addr::unchecked(\"user5\"),\n            Addr::unchecked(\"user6\"),\n            Addr::unchecked(\"user7\"),\n            Addr::unchecked(\"user12\"),\n        ]\n    );\n    assert_eq!(\n        proposal_against_voters,\n        vec![\n            Addr::unchecked(\"user8\"),\n            Addr::unchecked(\"user9\"),\n            Addr::unchecked(\"user10\"),\n            Addr::unchecked(\"user11\")\n        ]\n    );\n\n    // Skip voting period\n    app.update_block(|bi| {\n        bi.height += PROPOSAL_VOTING_PERIOD + 1;\n        bi.time = bi.time.plus_seconds(5 * (PROPOSAL_VOTING_PERIOD + 1));\n    });\n\n    // Try to vote after voting period\n    let err = cast_vote(\n        \u0026mut app,\n        assembly_addr.clone(),\n        1,\n        Addr::unchecked(\"user11\"),\n        ProposalVoteOption::Against,\n    )\n    .unwrap_err();\n\n    assert_eq!(err.root_cause().to_string(), \"Voting period ended!\");\n\n    // Try to execute the proposal before end_proposal\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"user0\"),\n            assembly_addr.clone(),\n            \u0026ExecuteMsg::ExecuteProposal { proposal_id: 1 },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(err.root_cause().to_string(), \"Proposal not passed!\");\n\n    // Check the successful completion of the proposal\n    check_token_balance(\u0026mut app, \u0026xastro_addr, \u0026Addr::unchecked(\"user0\"), 0);\n\n    app.execute_contract(\n        Addr::unchecked(\"user0\"),\n        assembly_addr.clone(),\n        \u0026ExecuteMsg::EndProposal { proposal_id: 1 },\n        \u0026[],\n    )\n    .unwrap();\n\n    check_token_balance(\n        \u0026mut app,\n        \u0026xastro_addr,\n        \u0026Addr::unchecked(\"user0\"),\n        PROPOSAL_REQUIRED_DEPOSIT,\n    );\n\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    assert_eq!(proposal.status, ProposalStatus::Passed);\n\n    // Try to end proposal again\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"user0\"),\n            assembly_addr.clone(),\n            \u0026ExecuteMsg::EndProposal { proposal_id: 1 },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(err.root_cause().to_string(), \"Proposal not active!\");\n\n    // Try to execute the proposal before the delay\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"user0\"),\n            assembly_addr.clone(),\n            \u0026ExecuteMsg::ExecuteProposal { proposal_id: 1 },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(err.root_cause().to_string(), \"Proposal delay not ended!\");\n\n    // Skip blocks\n    app.update_block(|bi| {\n        bi.height += PROPOSAL_EFFECTIVE_DELAY + 1;\n        bi.time = bi.time.plus_seconds(5 * (PROPOSAL_EFFECTIVE_DELAY + 1));\n    });\n\n    // Try to execute the proposal after the delay\n    app.execute_contract(\n        Addr::unchecked(\"user0\"),\n        assembly_addr.clone(),\n        \u0026ExecuteMsg::ExecuteProposal { proposal_id: 1 },\n        \u0026[],\n    )\n    .unwrap();\n\n    let config: Config = app\n        .wrap()\n        .query_wasm_smart(assembly_addr.to_string(), \u0026QueryMsg::Config {})\n        .unwrap();\n\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.to_string(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    // Check execution result\n    assert_eq!(config.proposal_voting_period, PROPOSAL_VOTING_PERIOD + 1000);\n    assert_eq!(\n        config.whitelisted_links,\n        vec![\n            \"https://some1.link/\".to_string(),\n            \"https://some2.link/\".to_string(),\n        ]\n    );\n    assert_eq!(proposal.status, ProposalStatus::Executed);\n\n    // Try to remove proposal before expiration period\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"user0\"),\n            assembly_addr.clone(),\n            \u0026ExecuteMsg::RemoveCompletedProposal { proposal_id: 1 },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(err.root_cause().to_string(), \"Proposal not completed!\");\n\n    // Remove expired proposal\n    app.update_block(|bi| {\n        bi.height += PROPOSAL_EXPIRATION_PERIOD + 1;\n        bi.time = bi.time.plus_seconds(5 * (PROPOSAL_EXPIRATION_PERIOD + 1));\n    });\n\n    app.execute_contract(\n        Addr::unchecked(\"user0\"),\n        assembly_addr.clone(),\n        \u0026ExecuteMsg::RemoveCompletedProposal { proposal_id: 1 },\n        \u0026[],\n    )\n    .unwrap();\n\n    let res: ProposalListResponse = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.to_string(),\n            \u0026QueryMsg::Proposals {\n                start: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(res.proposal_list, vec![]);\n    // proposal_count should not be changed after removing a proposal\n    assert_eq!(res.proposal_count, Uint64::from(1u32));\n}\n\n#[test]\nfn test_voting_power_changes() {\n    let mut app = mock_app();\n\n    let owner = Addr::unchecked(\"owner\");\n\n    let (_, staking_instance, xastro_addr, _, _, assembly_addr, _) =\n        instantiate_contracts(\u0026mut app, owner, false);\n\n    // Mint tokens for submitting proposal\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026Addr::unchecked(\"user0\"),\n        PROPOSAL_REQUIRED_DEPOSIT,\n    );\n\n    // Mint tokens for casting votes at start block\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026Addr::unchecked(\"user1\"),\n        40000_000000,\n    );\n\n    app.update_block(|mut block| {\n        block.time = block.time.plus_seconds(WEEK);\n        block.height += WEEK / 5;\n    });\n\n    // Create proposal\n    create_proposal(\n        \u0026mut app,\n        \u0026xastro_addr,\n        \u0026assembly_addr,\n        Addr::unchecked(\"user0\"),\n        Some(vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: assembly_addr.to_string(),\n            msg: to_binary(\u0026ExecuteMsg::UpdateConfig(Box::new(UpdateConfig {\n                xastro_token_addr: None,\n                vxastro_token_addr: None,\n                voting_escrow_delegator_addr: None,\n                ibc_controller: None,\n                builder_unlock_addr: None,\n                proposal_voting_period: Some(750),\n                proposal_effective_delay: None,\n                proposal_expiration_period: None,\n                proposal_required_deposit: None,\n                proposal_required_quorum: None,\n                proposal_required_threshold: None,\n                whitelist_add: None,\n                whitelist_remove: None,\n            })))\n            .unwrap(),\n            funds: vec![],\n        })]),\n    );\n    // Mint user2's tokens at the same block to increase total supply and add voting power to try to cast vote.\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026Addr::unchecked(\"user2\"),\n        5000_000000,\n    );\n\n    app.update_block(next_block);\n\n    // user1 can vote as he had voting power before the proposal submitting.\n    cast_vote(\n        \u0026mut app,\n        assembly_addr.clone(),\n        1,\n        Addr::unchecked(\"user1\"),\n        ProposalVoteOption::For,\n    )\n    .unwrap();\n    // Should panic, because user2 doesn't have any voting power.\n    let err = cast_vote(\n        \u0026mut app,\n        assembly_addr.clone(),\n        1,\n        Addr::unchecked(\"user2\"),\n        ProposalVoteOption::Against,\n    )\n    .unwrap_err();\n\n    // user2 doesn't have voting power and doesn't affect on total voting power(total supply at)\n    // total supply = 5000\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"You don't have any voting power!\"\n    );\n\n    app.update_block(next_block);\n\n    // Skip voting period and delay\n    app.update_block(|bi| {\n        bi.height += PROPOSAL_VOTING_PERIOD + PROPOSAL_EFFECTIVE_DELAY + 1;\n        bi.time = bi\n            .time\n            .plus_seconds(5 * (PROPOSAL_VOTING_PERIOD + PROPOSAL_EFFECTIVE_DELAY + 1));\n    });\n\n    // End proposal\n    app.execute_contract(\n        Addr::unchecked(\"user0\"),\n        assembly_addr.clone(),\n        \u0026ExecuteMsg::EndProposal { proposal_id: 1 },\n        \u0026[],\n    )\n    .unwrap();\n\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    // Check proposal votes\n    assert_eq!(proposal.for_power, Uint128::from(40000_000000u128));\n    assert_eq!(proposal.against_power, Uint128::zero());\n    // Should be passed, as total_voting_power=5000, for_votes=40000.\n    // So user2 didn't affect the result. Because he had to have xASTRO before the vote was submitted.\n    assert_eq!(proposal.status, ProposalStatus::Passed);\n}\n\n#[cfg(not(feature = \"testnet\"))]\n#[test]\nfn test_block_height_selection() {\n    // Block height is 12345 after app initialization\n    let mut app = mock_app();\n\n    let owner = Addr::unchecked(\"owner\");\n    let user1 = Addr::unchecked(\"user1\");\n    let user2 = Addr::unchecked(\"user2\");\n    let user3 = Addr::unchecked(\"user3\");\n\n    let (_, staking_instance, xastro_addr, _, _, assembly_addr, _) =\n        instantiate_contracts(\u0026mut app, owner, false);\n\n    // Mint tokens for submitting proposal\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026Addr::unchecked(\"user0\"),\n        PROPOSAL_REQUIRED_DEPOSIT,\n    );\n\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026user1,\n        6000_000001,\n    );\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026user2,\n        4000_000000,\n    );\n\n    // Skip to the next period\n    app.update_block(|mut block| {\n        block.time = block.time.plus_seconds(WEEK);\n        block.height += WEEK / 5;\n    });\n\n    // Create proposal\n    create_proposal(\n        \u0026mut app,\n        \u0026xastro_addr,\n        \u0026assembly_addr,\n        Addr::unchecked(\"user0\"),\n        None,\n    );\n\n    cast_vote(\n        \u0026mut app,\n        assembly_addr.clone(),\n        1,\n        user1,\n        ProposalVoteOption::For,\n    )\n    .unwrap();\n\n    // Mint huge amount of xASTRO. These tokens cannot affect on total supply in proposal 1 because\n    // they were minted after proposal.start_block - 1\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026user3,\n        100000_000000,\n    );\n    // Mint more xASTRO to user2, who will vote against the proposal, what is enough to make proposal unsuccessful.\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026user2,\n        3000_000000,\n    );\n    // Total voting power should be 20k xASTRO (proposal minimum deposit 10k + 4k + 6k users VP)\n    check_total_vp(\u0026mut app, \u0026assembly_addr, 1, 20000_000001);\n\n    cast_vote(\n        \u0026mut app,\n        assembly_addr.clone(),\n        1,\n        user2,\n        ProposalVoteOption::Against,\n    )\n    .unwrap();\n\n    // Skip voting period\n    app.update_block(|bi| {\n        bi.height += PROPOSAL_VOTING_PERIOD + PROPOSAL_EFFECTIVE_DELAY + 1;\n        bi.time = bi\n            .time\n            .plus_seconds(5 * (PROPOSAL_VOTING_PERIOD + PROPOSAL_EFFECTIVE_DELAY + 1));\n    });\n\n    // End proposal\n    app.execute_contract(\n        Addr::unchecked(\"user0\"),\n        assembly_addr.clone(),\n        \u0026ExecuteMsg::EndProposal { proposal_id: 1 },\n        \u0026[],\n    )\n    .unwrap();\n\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    assert_eq!(proposal.for_power, Uint128::new(6000_000001));\n    // Against power is 4000, as user2's balance was increased after proposal.start_block - 1\n    // at which everyone's voting power are considered.\n    assert_eq!(proposal.against_power, Uint128::new(4000_000000));\n    // Proposal is passed, as the total supply was increased after proposal.start_block - 1.\n    assert_eq!(proposal.status, ProposalStatus::Passed);\n}\n\n#[cfg(not(feature = \"testnet\"))]\n#[test]\nfn test_unsuccessful_proposal() {\n    let mut app = mock_app();\n\n    let owner = Addr::unchecked(\"owner\");\n\n    let (_, staking_instance, xastro_addr, _, _, assembly_addr, _) =\n        instantiate_contracts(\u0026mut app, owner, false);\n\n    // Init voting power for users\n    let xastro_balances: Vec\u003c(\u0026str, u128)\u003e = vec![\n        (\"user0\", PROPOSAL_REQUIRED_DEPOSIT), // proposal submitter\n        (\"user1\", 100),\n        (\"user2\", 200),\n        (\"user3\", 400),\n        (\"user4\", 250),\n        (\"user5\", 90),\n        (\"user6\", 300),\n        (\"user7\", 30),\n        (\"user8\", 180),\n        (\"user9\", 50),\n        (\"user10\", 90),\n        (\"user11\", 500),\n    ];\n\n    for (addr, xastro) in xastro_balances {\n        mint_tokens(\n            \u0026mut app,\n            \u0026staking_instance,\n            \u0026xastro_addr,\n            \u0026Addr::unchecked(addr),\n            xastro,\n        );\n    }\n\n    // Skip period\n    app.update_block(|mut block| {\n        block.time = block.time.plus_seconds(WEEK);\n        block.height += WEEK / 5;\n    });\n\n    // Create proposal\n    create_proposal(\n        \u0026mut app,\n        \u0026xastro_addr,\n        \u0026assembly_addr,\n        Addr::unchecked(\"user0\"),\n        None,\n    );\n\n    let expected_voting_power: Vec\u003c(\u0026str, ProposalVoteOption)\u003e = vec![\n        (\"user1\", ProposalVoteOption::For),\n        (\"user2\", ProposalVoteOption::For),\n        (\"user3\", ProposalVoteOption::For),\n        (\"user4\", ProposalVoteOption::Against),\n        (\"user5\", ProposalVoteOption::Against),\n        (\"user6\", ProposalVoteOption::Against),\n        (\"user7\", ProposalVoteOption::Against),\n        (\"user8\", ProposalVoteOption::Against),\n        (\"user9\", ProposalVoteOption::Against),\n        (\"user10\", ProposalVoteOption::Against),\n    ];\n\n    for (addr, option) in expected_voting_power {\n        cast_vote(\n            \u0026mut app,\n            assembly_addr.clone(),\n            1,\n            Addr::unchecked(addr),\n            option,\n        )\n        .unwrap();\n    }\n\n    // Skip voting period\n    app.update_block(|bi| {\n        bi.height += PROPOSAL_VOTING_PERIOD + 1;\n        bi.time = bi.time.plus_seconds(5 * (PROPOSAL_VOTING_PERIOD + 1));\n    });\n\n    // Check balance of submitter before and after proposal completion\n    check_token_balance(\u0026mut app, \u0026xastro_addr, \u0026Addr::unchecked(\"user0\"), 0);\n\n    app.execute_contract(\n        Addr::unchecked(\"user0\"),\n        assembly_addr.clone(),\n        \u0026ExecuteMsg::EndProposal { proposal_id: 1 },\n        \u0026[],\n    )\n    .unwrap();\n\n    check_token_balance(\n        \u0026mut app,\n        \u0026xastro_addr,\n        \u0026Addr::unchecked(\"user0\"),\n        10000_000000,\n    );\n\n    // Check proposal status\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    assert_eq!(proposal.status, ProposalStatus::Rejected);\n\n    // Remove expired proposal\n    app.update_block(|bi| {\n        bi.height += PROPOSAL_EXPIRATION_PERIOD + PROPOSAL_EFFECTIVE_DELAY + 1;\n        bi.time = bi\n            .time\n            .plus_seconds(5 * (PROPOSAL_EXPIRATION_PERIOD + PROPOSAL_EFFECTIVE_DELAY + 1));\n    });\n\n    app.execute_contract(\n        Addr::unchecked(\"user0\"),\n        assembly_addr.clone(),\n        \u0026ExecuteMsg::RemoveCompletedProposal { proposal_id: 1 },\n        \u0026[],\n    )\n    .unwrap();\n\n    let res: ProposalListResponse = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.to_string(),\n            \u0026QueryMsg::Proposals {\n                start: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(res.proposal_list, vec![]);\n    // proposal_count should not be changed after removing\n    assert_eq!(res.proposal_count, Uint64::from(1u32));\n}\n\n#[test]\nfn test_check_messages() {\n    let mut app = mock_app();\n    let owner = Addr::unchecked(\"owner\");\n    let (_, _, _, vxastro_addr, _, assembly_addr, _) =\n        instantiate_contracts(\u0026mut app, owner, false);\n\n    change_owner(\u0026mut app, \u0026vxastro_addr, \u0026assembly_addr);\n    let user = Addr::unchecked(\"user\");\n    let into_check_msg = |msgs: Vec\u003c(String, Binary)\u003e| {\n        let messages = msgs\n            .into_iter()\n            .map(|(contract_addr, msg)| {\n                CosmosMsg::Wasm(WasmMsg::Execute {\n                    contract_addr,\n                    msg,\n                    funds: vec![],\n                })\n            })\n            .collect();\n        ExecuteMsg::CheckMessages { messages }\n    };\n\n    let config_before: astroport_governance::voting_escrow::ConfigResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026vxastro_addr,\n            \u0026astroport_governance::voting_escrow::QueryMsg::Config {},\n        )\n        .unwrap();\n\n    let vxastro_blacklist_msg = vec![(\n        vxastro_addr.to_string(),\n        to_binary(\n            \u0026astroport_governance::voting_escrow::ExecuteMsg::UpdateConfig { new_guardian: None },\n        )\n        .unwrap(),\n    )];\n    let err = app\n        .execute_contract(\n            user.clone(),\n            assembly_addr.clone(),\n            \u0026into_check_msg(vxastro_blacklist_msg),\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"Messages check passed. Nothing was committed to the blockchain\"\n    );\n\n    let config_after: astroport_governance::voting_escrow::ConfigResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026vxastro_addr,\n            \u0026astroport_governance::voting_escrow::QueryMsg::Config {},\n        )\n        .unwrap();\n    assert_eq!(config_before, config_after);\n}\n\n#[test]\nfn test_delegated_vp() {\n    let mut app = mock_app();\n\n    let owner = Addr::unchecked(\"owner\");\n\n    let (_, staking_instance, xastro_addr, vxastro_addr, _, assembly_addr, delegator) =\n        instantiate_contracts(\u0026mut app, owner, true);\n    let delegator = delegator.unwrap();\n\n    let users = vec![\n        (\n            \"user1\",\n            103_000_000_000u128,\n            1000u16,\n            \"user4\",\n            177_278_846_150u128,\n        ),\n        (\n            \"user2\",\n            612_000_000_000u128,\n            2000u16,\n            \"user5\",\n            1_053_346_153_800u128,\n        ),\n        (\n            \"user3\",\n            205_000_000_000u128,\n            3000u16,\n            \"user6\",\n            352_836_538_450u128,\n        ),\n    ];\n\n    // Mint tokens for submitting proposal\n    mint_tokens(\n        \u0026mut app,\n        \u0026staking_instance,\n        \u0026xastro_addr,\n        \u0026Addr::unchecked(\"user0\"),\n        PROPOSAL_REQUIRED_DEPOSIT,\n    );\n\n    // Mint vxASTRO and delegate it to the other users\n    for (from, amount, bps, to, exp_vp) in users {\n        mint_vxastro(\n            \u0026mut app,\n            \u0026staking_instance,\n            xastro_addr.clone(),\n            \u0026vxastro_addr,\n            Addr::unchecked(from),\n            amount,\n        );\n        delegate_vxastro(\n            \u0026mut app,\n            delegator.clone(),\n            Addr::unchecked(from),\n            Addr::unchecked(to),\n            bps,\n        );\n\n        let from_amount: Uint128 = app\n            .wrap()\n            .query_wasm_smart(\n                \u0026delegator,\n                \u0026DelegatorQueryMsg::AdjustedBalance {\n                    account: from.to_string(),\n                    timestamp: None,\n                },\n            )\n            .unwrap();\n\n        let to_amount: Uint128 = app\n            .wrap()\n            .query_wasm_smart(\n                \u0026delegator,\n                \u0026DelegatorQueryMsg::AdjustedBalance {\n                    account: to.to_string(),\n                    timestamp: None,\n                },\n            )\n            .unwrap();\n\n        assert_eq!(from_amount + to_amount, Uint128::from(exp_vp));\n    }\n\n    app.update_block(|mut block| {\n        block.time = block.time.plus_seconds(WEEK);\n        block.height += WEEK / 5;\n    });\n\n    // Create proposal\n    create_proposal(\n        \u0026mut app,\n        \u0026xastro_addr,\n        \u0026assembly_addr,\n        Addr::unchecked(\"user0\"),\n        Some(vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: assembly_addr.to_string(),\n            msg: to_binary(\u0026ExecuteMsg::UpdateConfig(Box::new(UpdateConfig {\n                xastro_token_addr: None,\n                vxastro_token_addr: None,\n                voting_escrow_delegator_addr: None,\n                ibc_controller: None,\n                builder_unlock_addr: None,\n                proposal_voting_period: Some(750),\n                proposal_effective_delay: None,\n                proposal_expiration_period: None,\n                proposal_required_deposit: None,\n                proposal_required_quorum: None,\n                proposal_required_threshold: None,\n                whitelist_add: None,\n                whitelist_remove: None,\n            })))\n            .unwrap(),\n            funds: vec![],\n        })]),\n    );\n\n    let votes: Vec\u003c(\u0026str, ProposalVoteOption)\u003e = vec![\n        (\"user1\", ProposalVoteOption::Against),\n        (\"user2\", ProposalVoteOption::For),\n        (\"user3\", ProposalVoteOption::Against),\n        (\"user4\", ProposalVoteOption::For),\n        (\"user5\", ProposalVoteOption::Against),\n        (\"user6\", ProposalVoteOption::For),\n    ];\n\n    for (user, vote) in votes {\n        cast_vote(\n            \u0026mut app,\n            assembly_addr.clone(),\n            1u64,\n            Addr::unchecked(user),\n            vote,\n        )\n        .unwrap();\n    }\n\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    assert_eq!(proposal.for_power, Uint128::from(1_578_255_769_188u128));\n    assert_eq!(proposal.against_power, Uint128::from(925_205_769_212u128));\n\n    // Skip voting period\n    app.update_block(|bi| {\n        bi.height += PROPOSAL_VOTING_PERIOD + 1;\n        bi.time = bi.time.plus_seconds(5 * (PROPOSAL_VOTING_PERIOD + 1));\n    });\n\n    app.execute_contract(\n        Addr::unchecked(\"user0\"),\n        assembly_addr.clone(),\n        \u0026ExecuteMsg::EndProposal { proposal_id: 1 },\n        \u0026[],\n    )\n    .unwrap();\n\n    let proposal: Proposal = app\n        .wrap()\n        .query_wasm_smart(\n            assembly_addr.clone(),\n            \u0026QueryMsg::Proposal { proposal_id: 1 },\n        )\n        .unwrap();\n\n    assert_eq!(proposal.status, ProposalStatus::Passed);\n}\n\nfn mock_app() -\u003e App {\n    let mut env = mock_env();\n    env.block.time = Timestamp::from_seconds(EPOCH_START);\n    let api = MockApi::default();\n    let bank = BankKeeper::new();\n    let storage = MockStorage::new();\n\n    AppBuilder::new()\n        .with_api(api)\n        .with_block(env.block)\n        .with_bank(bank)\n        .with_storage(storage)\n        .build(|_, _, _| {})\n}\n\nfn instantiate_contracts(\n    router: \u0026mut App,\n    owner: Addr,\n    with_delegator: bool,\n) -\u003e (Addr, Addr, Addr, Addr, Addr, Addr, Option\u003cAddr\u003e) {\n    let token_addr = instantiate_astro_token(router, \u0026owner);\n    let (staking_addr, xastro_token_addr) = instantiate_xastro_token(router, \u0026owner, \u0026token_addr);\n    let vxastro_token_addr = instantiate_vxastro_token(router, \u0026owner, \u0026xastro_token_addr);\n    let builder_unlock_addr = instantiate_builder_unlock_contract(router, \u0026owner, \u0026token_addr);\n\n    let mut delegator_addr = None;\n\n    if with_delegator {\n        delegator_addr = Some(instantiate_delegator_contract(\n            router,\n            \u0026owner,\n            \u0026vxastro_token_addr,\n        ));\n    }\n\n    let assembly_addr = instantiate_assembly_contract(\n        router,\n        \u0026owner,\n        \u0026xastro_token_addr,\n        \u0026vxastro_token_addr,\n        \u0026builder_unlock_addr,\n        delegator_addr.clone().map(String::from),\n    );\n\n    (\n        token_addr,\n        staking_addr,\n        xastro_token_addr,\n        vxastro_token_addr,\n        builder_unlock_addr,\n        assembly_addr,\n        delegator_addr,\n    )\n}\n\nfn instantiate_astro_token(router: \u0026mut App, owner: \u0026Addr) -\u003e Addr {\n    let astro_token_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_token::contract::execute,\n        astroport_token::contract::instantiate,\n        astroport_token::contract::query,\n    ));\n\n    let astro_token_code_id = router.store_code(astro_token_contract);\n\n    let msg = TokenInstantiateMsg {\n        name: String::from(\"Astro token\"),\n        symbol: String::from(\"ASTRO\"),\n        decimals: 6,\n        initial_balances: vec![],\n        mint: Some(MinterResponse {\n            minter: owner.to_string(),\n            cap: None,\n        }),\n        marketing: None,\n    };\n\n    router\n        .instantiate_contract(\n            astro_token_code_id,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            String::from(\"ASTRO\"),\n            None,\n        )\n        .unwrap()\n}\n\nfn instantiate_xastro_token(router: \u0026mut App, owner: \u0026Addr, astro_token: \u0026Addr) -\u003e (Addr, Addr) {\n    let xastro_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_xastro_token::contract::execute,\n        astroport_xastro_token::contract::instantiate,\n        astroport_xastro_token::contract::query,\n    ));\n\n    let xastro_code_id = router.store_code(xastro_contract);\n\n    let staking_contract = Box::new(\n        ContractWrapper::new_with_empty(\n            astroport_staking::contract::execute,\n            astroport_staking::contract::instantiate,\n            astroport_staking::contract::query,\n        )\n        .with_reply_empty(astroport_staking::contract::reply),\n    );\n\n    let staking_code_id = router.store_code(staking_contract);\n\n    let msg = astroport::staking::InstantiateMsg {\n        owner: owner.to_string(),\n        token_code_id: xastro_code_id,\n        deposit_token_addr: astro_token.to_string(),\n        marketing: None,\n    };\n    let staking_instance = router\n        .instantiate_contract(\n            staking_code_id,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            String::from(\"xASTRO\"),\n            None,\n        )\n        .unwrap();\n\n    let res = router\n        .wrap()\n        .query::\u003castroport::staking::ConfigResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: staking_instance.to_string(),\n            msg: to_binary(\u0026astroport::staking::QueryMsg::Config {}).unwrap(),\n        }))\n        .unwrap();\n\n    (staking_instance, res.share_token_addr)\n}\n\nfn instantiate_vxastro_token(router: \u0026mut App, owner: \u0026Addr, xastro: \u0026Addr) -\u003e Addr {\n    let vxastro_token_contract = Box::new(ContractWrapper::new_with_empty(\n        voting_escrow::contract::execute,\n        voting_escrow::contract::instantiate,\n        voting_escrow::contract::query,\n    ));\n\n    let vxastro_token_code_id = router.store_code(vxastro_token_contract);\n\n    let msg = VXAstroInstantiateMsg {\n        owner: owner.to_string(),\n        guardian_addr: Some(owner.to_string()),\n        deposit_token_addr: xastro.to_string(),\n        marketing: None,\n        logo_urls_whitelist: vec![],\n    };\n\n    router\n        .instantiate_contract(\n            vxastro_token_code_id,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            String::from(\"vxASTRO\"),\n            None,\n        )\n        .unwrap()\n}\n\nfn instantiate_builder_unlock_contract(router: \u0026mut App, owner: \u0026Addr, astro_token: \u0026Addr) -\u003e Addr {\n    let builder_unlock_contract = Box::new(ContractWrapper::new_with_empty(\n        builder_unlock::contract::execute,\n        builder_unlock::contract::instantiate,\n        builder_unlock::contract::query,\n    ));\n\n    let builder_unlock_code_id = router.store_code(builder_unlock_contract);\n\n    let msg = BuilderUnlockInstantiateMsg {\n        owner: owner.to_string(),\n        astro_token: astro_token.to_string(),\n        max_allocations_amount: Uint128::new(300_000_000_000_000u128),\n    };\n\n    router\n        .instantiate_contract(\n            builder_unlock_code_id,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            \"Builder Unlock contract\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap()\n}\n\nfn instantiate_assembly_contract(\n    router: \u0026mut App,\n    owner: \u0026Addr,\n    xastro: \u0026Addr,\n    vxastro: \u0026Addr,\n    builder: \u0026Addr,\n    delegator: Option\u003cString\u003e,\n) -\u003e Addr {\n    let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n        astro_assembly::contract::execute,\n        astro_assembly::contract::instantiate,\n        astro_assembly::contract::query,\n    ));\n\n    let assembly_code = router.store_code(assembly_contract);\n\n    let msg = InstantiateMsg {\n        xastro_token_addr: xastro.to_string(),\n        vxastro_token_addr: Some(vxastro.to_string()),\n        voting_escrow_delegator_addr: delegator,\n        ibc_controller: None,\n        builder_unlock_addr: builder.to_string(),\n        proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n        proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n        proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n        proposal_required_deposit: Uint128::new(PROPOSAL_REQUIRED_DEPOSIT),\n        proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n        proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n        whitelisted_links: vec![\"https://some.link/\".to_string()],\n    };\n\n    router\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap()\n}\n\nfn instantiate_delegator_contract(router: \u0026mut App, owner: \u0026Addr, vxastro: \u0026Addr) -\u003e Addr {\n    let nft_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_nft::contract::execute,\n        astroport_nft::contract::instantiate,\n        astroport_nft::contract::query,\n    ));\n\n    let nft_code_id = router.store_code(nft_contract);\n\n    let delegator_contract = Box::new(\n        ContractWrapper::new_with_empty(\n            voting_escrow_delegation::contract::execute,\n            voting_escrow_delegation::contract::instantiate,\n            voting_escrow_delegation::contract::query,\n        )\n        .with_reply_empty(voting_escrow_delegation::contract::reply),\n    );\n\n    let delegator_code_id = router.store_code(delegator_contract);\n\n    let msg = DelegatorInstantiateMsg {\n        owner: owner.to_string(),\n        nft_code_id,\n        voting_escrow_addr: vxastro.to_string(),\n    };\n\n    router\n        .instantiate_contract(\n            delegator_code_id,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            \"Voting Escrow Delegator\",\n            Some(owner.to_string()),\n        )\n        .unwrap()\n}\n\nfn mint_tokens(app: \u0026mut App, minter: \u0026Addr, token: \u0026Addr, recipient: \u0026Addr, amount: u128) {\n    let msg = Cw20ExecuteMsg::Mint {\n        recipient: recipient.to_string(),\n        amount: Uint128::from(amount),\n    };\n\n    app.execute_contract(minter.clone(), token.to_owned(), \u0026msg, \u0026[])\n        .unwrap();\n}\n\nfn mint_vxastro(\n    app: \u0026mut App,\n    staking_instance: \u0026Addr,\n    xastro: Addr,\n    vxastro: \u0026Addr,\n    recipient: Addr,\n    amount: u128,\n) {\n    mint_tokens(\n        app,\n        staking_instance,\n        \u0026xastro.clone(),\n        \u0026recipient.clone(),\n        amount,\n    );\n\n    let msg = Cw20ExecuteMsg::Send {\n        contract: vxastro.to_string(),\n        amount: Uint128::from(amount),\n        msg: to_binary(\u0026VXAstroCw20HookMsg::CreateLock { time: WEEK * 50 }).unwrap(),\n    };\n\n    app.execute_contract(recipient, xastro, \u0026msg, \u0026[]).unwrap();\n}\n\nfn delegate_vxastro(app: \u0026mut App, delegator_addr: Addr, from: Addr, to: Addr, bps: u16) {\n    let msg = DelegatorExecuteMsg::CreateDelegation {\n        bps,\n        expire_time: 2 * 7 * 86400,\n        token_id: format!(\"{}-{}-{}\", from, to, bps),\n        recipient: to.to_string(),\n    };\n\n    app.execute_contract(from.clone(), delegator_addr, \u0026msg, \u0026[])\n        .unwrap();\n}\n\nfn create_allocations(\n    app: \u0026mut App,\n    token: Addr,\n    builder_unlock_contract_addr: Addr,\n    allocations: Vec\u003c(String, AllocationParams)\u003e,\n) {\n    let amount = allocations\n        .iter()\n        .map(|params| params.1.amount.u128())\n        .sum();\n\n    mint_tokens(\n        app,\n        \u0026Addr::unchecked(\"owner\"),\n        \u0026token,\n        \u0026Addr::unchecked(\"owner\"),\n        amount,\n    );\n\n    app.execute_contract(\n        Addr::unchecked(\"owner\"),\n        Addr::unchecked(token.to_string()),\n        \u0026Cw20ExecuteMsg::Send {\n            contract: builder_unlock_contract_addr.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026BuilderUnlockReceiveMsg::CreateAllocations { allocations }).unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n}\n\nfn create_proposal(\n    app: \u0026mut App,\n    token: \u0026Addr,\n    assembly: \u0026Addr,\n    submitter: Addr,\n    msgs: Option\u003cVec\u003cCosmosMsg\u003e\u003e,\n) {\n    let submit_proposal_msg = Cw20HookMsg::SubmitProposal {\n        title: \"Test title!\".to_string(),\n        description: \"Test description!\".to_string(),\n        link: None,\n        messages: msgs,\n        ibc_channel: None,\n    };\n\n    app.execute_contract(\n        submitter,\n        token.clone(),\n        \u0026Cw20ExecuteMsg::Send {\n            contract: assembly.to_string(),\n            amount: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n            msg: to_binary(\u0026submit_proposal_msg).unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n}\n\nfn check_token_balance(app: \u0026mut App, token: \u0026Addr, address: \u0026Addr, expected: u128) {\n    let msg = XAstroQueryMsg::Balance {\n        address: address.to_string(),\n    };\n    let res: StdResult\u003cBalanceResponse\u003e = app.wrap().query_wasm_smart(token, \u0026msg);\n    assert_eq!(res.unwrap().balance, Uint128::from(expected));\n}\n\nfn check_user_vp(app: \u0026mut App, assembly: \u0026Addr, address: \u0026Addr, proposal_id: u64, expected: u128) {\n    let res: Uint128 = app\n        .wrap()\n        .query_wasm_smart(\n            assembly.to_string(),\n            \u0026QueryMsg::UserVotingPower {\n                user: address.to_string(),\n                proposal_id,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(res.u128(), expected);\n}\n\nfn check_total_vp(app: \u0026mut App, assembly: \u0026Addr, proposal_id: u64, expected: u128) {\n    let res: Uint128 = app\n        .wrap()\n        .query_wasm_smart(\n            assembly.to_string(),\n            \u0026QueryMsg::TotalVotingPower { proposal_id },\n        )\n        .unwrap();\n\n    assert_eq!(res.u128(), expected);\n}\n\nfn cast_vote(\n    app: \u0026mut App,\n    assembly: Addr,\n    proposal_id: u64,\n    sender: Addr,\n    option: ProposalVoteOption,\n) -\u003e anyhow::Result\u003cAppResponse\u003e {\n    app.execute_contract(\n        sender,\n        assembly,\n        \u0026ExecuteMsg::CastVote {\n            proposal_id,\n            vote: option,\n        },\n        \u0026[],\n    )\n}\n\nfn change_owner(app: \u0026mut App, contract: \u0026Addr, assembly: \u0026Addr) {\n    let msg = astroport_governance::voting_escrow::ExecuteMsg::ProposeNewOwner {\n        new_owner: assembly.to_string(),\n        expires_in: 100,\n    };\n    app.execute_contract(Addr::unchecked(\"owner\"), contract.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    app.execute_contract(\n        assembly.clone(),\n        contract.clone(),\n        \u0026astroport_governance::voting_escrow::ExecuteMsg::ClaimOwnership {},\n        \u0026[],\n    )\n    .unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","builder_unlock","examples","unlock_schema.rs"],"content":"use astroport_governance::builder_unlock::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\nuse cosmwasm_schema::write_api;\n\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        query: QueryMsg,\n        execute: ExecuteMsg\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","builder_unlock","src","contract.rs"],"content":"use crate::astroport::common::{claim_ownership, drop_ownership_proposal, propose_new_owner};\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\n\nuse cosmwasm_std::{\n    attr, from_binary, to_binary, Addr, Binary, Deps, DepsMut, Env, MessageInfo, Order, Response,\n    StdError, StdResult, Uint128, WasmMsg,\n};\nuse cw2::{get_contract_version, set_contract_version};\nuse cw20::{Cw20ExecuteMsg, Cw20ReceiveMsg};\nuse cw_storage_plus::Bound;\n\nuse crate::astroport::asset::addr_opt_validate;\nuse crate::contract::helpers::{compute_unlocked_amount, compute_withdraw_amount};\nuse crate::migration::MigrateMsg;\nuse astroport_governance::builder_unlock::msg::{\n    AllocationResponse, ExecuteMsg, InstantiateMsg, QueryMsg, ReceiveMsg, SimulateWithdrawResponse,\n    StateResponse,\n};\nuse astroport_governance::builder_unlock::{AllocationParams, AllocationStatus, Config, Schedule};\n\nuse astroport_governance::{DEFAULT_LIMIT, MAX_LIMIT};\n\nuse crate::state::{CONFIG, OWNERSHIP_PROPOSAL, PARAMS, STATE, STATUS};\n\n// Version and name used for contract migration.\nconst CONTRACT_NAME: \u0026str = \"builder-unlock\";\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Creates a new contract with the specified parameters in the `msg` variable.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    STATE.save(deps.storage, \u0026Default::default())?;\n\n    CONFIG.save(\n        deps.storage,\n        \u0026Config {\n            owner: deps.api.addr_validate(\u0026msg.owner)?,\n            astro_token: deps.api.addr_validate(\u0026msg.astro_token)?,\n            max_allocations_amount: msg.max_allocations_amount,\n        },\n    )?;\n    Ok(Response::default())\n}\n\n/// Exposes all the execute functions available in the contract.\n///\n/// ## Execute messages\n/// * **ExecuteMsg::Receive(cw20_msg)** Parse incoming messages coming from the ASTRO token contract.\n///\n/// * **ExecuteMsg::Withdraw** Withdraw unlocked ASTRO.\n///\n/// * **ExecuteMsg::TransferOwnership** Transfer contract ownership.\n///\n/// * **ExecuteMsg::ProposeNewReceiver** Propose a new receiver for a specific ASTRO unlock schedule.\n///\n/// * **ExecuteMsg::DropNewReceiver** Drop the proposal to change the receiver for an unlock schedule.\n///\n/// * **ExecuteMsg::ClaimReceiver**  Claim the position as a receiver for a specific unlock schedule.\n///\n/// * **ExecuteMsg::IncreaseAllocation** Increase ASTRO allocation for receiver.\n///\n/// * **ExecuteMsg::DecreaseAllocation** Decrease ASTRO allocation for receiver.\n///\n/// * **ExecuteMsg::TransferUnallocated** Transfer unallocated tokens.\n///\n/// * **ExecuteMsg::ProposeNewOwner** Creates a new request to change contract ownership.\n///\n/// * **ExecuteMsg::DropOwnershipProposal** Removes a request to change contract ownership.\n///\n/// * **ExecuteMsg::ClaimOwnership** Claims contract ownership.\n///\n/// * **ExecuteMsg::UpdateConfig** Update contract configuration.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -\u003e StdResult\u003cResponse\u003e {\n    match msg {\n        ExecuteMsg::Receive(cw20_msg) =\u003e execute_receive_cw20(deps, info, cw20_msg),\n        ExecuteMsg::Withdraw {} =\u003e execute_withdraw(deps, env, info),\n        ExecuteMsg::ProposeNewReceiver { new_receiver } =\u003e {\n            execute_propose_new_receiver(deps, info, new_receiver)\n        }\n        ExecuteMsg::DropNewReceiver {} =\u003e execute_drop_new_receiver(deps, info),\n        ExecuteMsg::ClaimReceiver { prev_receiver } =\u003e {\n            execute_claim_receiver(deps, info, prev_receiver)\n        }\n        ExecuteMsg::IncreaseAllocation { receiver, amount } =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n            if info.sender != config.owner {\n                return Err(StdError::generic_err(\n                    \"Only the contract owner can increase allocations\",\n                ));\n            }\n            execute_increase_allocation(deps, \u0026config, receiver, amount, None)\n        }\n        ExecuteMsg::DecreaseAllocation { receiver, amount } =\u003e {\n            execute_decrease_allocation(deps, env, info, receiver, amount)\n        }\n        ExecuteMsg::TransferUnallocated { amount, recipient } =\u003e {\n            execute_transfer_unallocated(deps, info, amount, recipient)\n        }\n        ExecuteMsg::ProposeNewOwner {\n            new_owner,\n            expires_in,\n        } =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n\n            propose_new_owner(\n                deps,\n                info,\n                env,\n                new_owner,\n                expires_in,\n                config.owner,\n                OWNERSHIP_PROPOSAL,\n            )\n        }\n        ExecuteMsg::DropOwnershipProposal {} =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n\n            drop_ownership_proposal(deps, info, config.owner, OWNERSHIP_PROPOSAL)\n        }\n        ExecuteMsg::ClaimOwnership {} =\u003e {\n            claim_ownership(deps, info, env, OWNERSHIP_PROPOSAL, |deps, new_owner| {\n                CONFIG.update::\u003c_, StdError\u003e(deps.storage, |mut v| {\n                    v.owner = new_owner;\n                    Ok(v)\n                })?;\n\n                Ok(())\n            })\n        }\n        ExecuteMsg::UpdateConfig {\n            new_max_allocations_amount,\n        } =\u003e update_config(deps, info, new_max_allocations_amount),\n        ExecuteMsg::UpdateUnlockSchedules {\n            new_unlock_schedules,\n        } =\u003e update_unlock_schedules(deps, env, info, new_unlock_schedules),\n    }\n}\n\n/// Receives a message of type [`Cw20ReceiveMsg`] and processes it depending on the received template.\n///\n/// * **cw20_msg** CW20 message to process.\nfn execute_receive_cw20(\n    deps: DepsMut,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    match from_binary(\u0026cw20_msg.msg)? {\n        ReceiveMsg::CreateAllocations { allocations } =\u003e execute_create_allocations(\n            deps,\n            cw20_msg.sender,\n            info.sender,\n            cw20_msg.amount,\n            allocations,\n        ),\n        ReceiveMsg::IncreaseAllocation { user, amount } =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n\n            if config.astro_token != info.sender {\n                return Err(StdError::generic_err(\"Only ASTRO can be deposited\"));\n            }\n            if deps.api.addr_validate(\u0026cw20_msg.sender)? != config.owner {\n                return Err(StdError::generic_err(\n                    \"Only the contract owner can increase allocations\",\n                ));\n            }\n\n            execute_increase_allocation(deps, \u0026config, user, amount, Some(cw20_msg.amount))\n        }\n    }\n}\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::Config {}** Return the contract configuration.\n///\n/// * **QueryMsg::State {}** Return the contract state (number of ASTRO that still need to be withdrawn).\n///\n/// * **QueryMsg::Allocation {}** Return the allocation details for a specific account.\n///\n/// * **QueryMsg::UnlockedTokens {}** Return the amount of unlocked ASTRO for a specific account.\n///\n/// * **QueryMsg::SimulateWithdraw {}** Return the result of a withdrawal simulation.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Config {} =\u003e to_binary(\u0026CONFIG.load(deps.storage)?),\n        QueryMsg::State {} =\u003e to_binary(\u0026query_state(deps)?),\n        QueryMsg::Allocation { account } =\u003e to_binary(\u0026query_allocation(deps, account)?),\n        QueryMsg::UnlockedTokens { account } =\u003e {\n            to_binary(\u0026query_tokens_unlocked(deps, env, account)?)\n        }\n        QueryMsg::SimulateWithdraw { account, timestamp } =\u003e {\n            to_binary(\u0026query_simulate_withdraw(deps, env, account, timestamp)?)\n        }\n        QueryMsg::Allocations { start_after, limit } =\u003e {\n            to_binary(\u0026query_allocations(deps, start_after, limit)?)\n        }\n    }\n}\n\n/// Admin function facilitating the creation of new allocations.\n///\n/// * **creator** allocations creator (the contract admin).\n///\n/// * **deposit_token** token being deposited (should be ASTRO).\n///\n/// * **deposit_amount** tokens sent along with the call (should equal the sum of allocation amounts)\n///\n/// * **deposit_amount** new allocations being created.\nfn execute_create_allocations(\n    deps: DepsMut,\n    creator: String,\n    deposit_token: Addr,\n    deposit_amount: Uint128,\n    allocations: Vec\u003c(String, AllocationParams)\u003e,\n) -\u003e StdResult\u003cResponse\u003e {\n    let config = CONFIG.load(deps.storage)?;\n    let mut state = STATE.load(deps.storage)?;\n\n    if deps.api.addr_validate(\u0026creator)? != config.owner {\n        return Err(StdError::generic_err(\n            \"Only the contract owner can create allocations\",\n        ));\n    }\n\n    if deposit_token != config.astro_token {\n        return Err(StdError::generic_err(\"Only ASTRO can be deposited\"));\n    }\n\n    if deposit_amount\n        != allocations\n            .iter()\n            .map(|params| params.1.amount)\n            .sum::\u003cUint128\u003e()\n    {\n        return Err(StdError::generic_err(\"ASTRO deposit amount mismatch\"));\n    }\n\n    state.total_astro_deposited += deposit_amount;\n    state.remaining_astro_tokens += deposit_amount;\n\n    if state.total_astro_deposited \u003e config.max_allocations_amount {\n        return Err(StdError::generic_err(format!(\n            \"The total allocation for all recipients cannot exceed total ASTRO amount allocated to unlock (currently {} ASTRO)\",\n            config.max_allocations_amount,\n        )));\n    }\n\n    for (user_unchecked, params) in allocations {\n        params.validate(\u0026user_unchecked)?;\n        let user = deps.api.addr_validate(\u0026user_unchecked)?;\n\n        if PARAMS.has(deps.storage, \u0026user) {\n            return Err(StdError::generic_err(format!(\n                \"Allocation (params) already exists for {user}\"\n            )));\n        }\n        PARAMS.save(deps.storage, \u0026user, \u0026params)?;\n        STATUS.save(deps.storage, \u0026user, \u0026AllocationStatus::new())?;\n    }\n\n    STATE.save(deps.storage, \u0026state)?;\n    Ok(Response::default())\n}\n\n/// Allow allocation recipients to withdraw unlocked ASTRO.\nfn execute_withdraw(deps: DepsMut, env: Env, info: MessageInfo) -\u003e StdResult\u003cResponse\u003e {\n    let config = CONFIG.load(deps.storage)?;\n    let mut state = STATE.load(deps.storage)?;\n\n    let params = PARAMS.load(deps.storage, \u0026info.sender)?;\n\n    if params.proposed_receiver.is_some() {\n        return Err(StdError::generic_err(\n            \"You may not withdraw once you proposed new receiver!\",\n        ));\n    }\n\n    let mut status = STATUS.load(deps.storage, \u0026info.sender)?;\n\n    let SimulateWithdrawResponse { astro_to_withdraw } =\n        compute_withdraw_amount(env.block.time.seconds(), \u0026params, \u0026status);\n\n    if astro_to_withdraw.is_zero() {\n        return Err(StdError::generic_err(\"No unlocked ASTRO to be withdrawn\"));\n    }\n\n    status.astro_withdrawn += astro_to_withdraw;\n    state.remaining_astro_tokens -= astro_to_withdraw;\n\n    // SAVE :: state \u0026 allocation\n    STATE.save(deps.storage, \u0026state)?;\n\n    // Update status\n    STATUS.save(deps.storage, \u0026info.sender, \u0026status)?;\n\n    Ok(Response::new()\n        .add_message(WasmMsg::Execute {\n            contract_addr: config.astro_token.to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                recipient: info.sender.to_string(),\n                amount: astro_to_withdraw,\n            })?,\n            funds: vec![],\n        })\n        .add_attribute(\"astro_withdrawn\", astro_to_withdraw))\n}\n\n/// Allows the current allocation receiver to propose a new receiver.\n///\n/// * **new_receiver** new proposed receiver for the allocation.\nfn execute_propose_new_receiver(\n    deps: DepsMut,\n    info: MessageInfo,\n    new_receiver: String,\n) -\u003e StdResult\u003cResponse\u003e {\n    let mut alloc_params = PARAMS.load(deps.storage, \u0026info.sender)?;\n    let new_receiver = deps.api.addr_validate(\u0026new_receiver)?;\n\n    match alloc_params.proposed_receiver {\n        Some(proposed_receiver) =\u003e {\n            return Err(StdError::generic_err(format!(\n                \"Proposed receiver already set to {proposed_receiver}\"\n            )));\n        }\n        None =\u003e {\n            if PARAMS.has(deps.storage, \u0026new_receiver) {\n                return Err(StdError::generic_err(\n                    \"Invalid new_receiver. Proposed receiver already has an ASTRO allocation\",\n                ));\n            }\n\n            alloc_params.proposed_receiver = Some(new_receiver.clone());\n            PARAMS.save(deps.storage, \u0026info.sender, \u0026alloc_params)?;\n        }\n    }\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"ProposeNewReceiver\")\n        .add_attribute(\"proposed_receiver\", new_receiver))\n}\n\n/// Drop the new proposed receiver for a specific allocation.\nfn execute_drop_new_receiver(deps: DepsMut, info: MessageInfo) -\u003e StdResult\u003cResponse\u003e {\n    let mut alloc_params = PARAMS.load(deps.storage, \u0026info.sender)?;\n\n    match alloc_params.proposed_receiver {\n        Some(proposed_receiver) =\u003e {\n            alloc_params.proposed_receiver = None;\n            PARAMS.save(deps.storage, \u0026info.sender, \u0026alloc_params)?;\n\n            Ok(Response::new()\n                .add_attribute(\"action\", \"DropNewReceiver\")\n                .add_attribute(\"dropped_proposed_receiver\", proposed_receiver))\n        }\n        None =\u003e Err(StdError::generic_err(\"Proposed receiver not set\")),\n    }\n}\n\n/// Decrease an address' ASTRO allocation.\n///\n/// * **receiver** address that will have its allocation decreased.\n///\n/// * **amount** ASTRO amount to decrease the allocation by.\nfn execute_decrease_allocation(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    receiver: String,\n    amount: Uint128,\n) -\u003e StdResult\u003cResponse\u003e {\n    let config = CONFIG.load(deps.storage)?;\n    if info.sender != config.owner {\n        return Err(StdError::generic_err(\n            \"Only the contract owner can decrease allocations\",\n        ));\n    }\n\n    let receiver = deps.api.addr_validate(\u0026receiver)?;\n\n    let mut state = STATE.load(deps.storage)?;\n    let mut params = PARAMS.load(deps.storage, \u0026receiver)?;\n    let mut status = STATUS.load(deps.storage, \u0026receiver)?;\n\n    let unlocked_amount = compute_unlocked_amount(\n        env.block.time.seconds(),\n        params.amount,\n        \u0026params.unlock_schedule,\n        status.unlocked_amount_checkpoint,\n    );\n    let locked_amount = params.amount - unlocked_amount;\n\n    if locked_amount \u003c amount {\n        return Err(StdError::generic_err(format!(\n            \"Insufficient amount of lock to decrease allocation, user has locked {locked_amount} ASTRO.\"\n        )));\n    }\n\n    params.amount = params.amount.checked_sub(amount)?;\n    status.unlocked_amount_checkpoint = unlocked_amount;\n    state.unallocated_tokens = state.unallocated_tokens.checked_add(amount)?;\n    state.remaining_astro_tokens = state.remaining_astro_tokens.checked_sub(amount)?;\n\n    STATUS.save(deps.storage, \u0026receiver, \u0026status)?;\n    PARAMS.save(deps.storage, \u0026receiver, \u0026params)?;\n    STATE.save(deps.storage, \u0026state)?;\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"execute_decrease_allocation\"),\n        attr(\"receiver\", receiver),\n        attr(\"amount\", amount),\n    ]))\n}\n\n/// Increase an address' ASTRO allocation.\n///\n/// * **receiver** address that will have its allocation incrased.\n///\n/// * **amount** ASTRO amount to increase the allocation by.\n///\n/// * **deposit_amount** is amount of ASTRO to increase the allocation by using CW20 Receive.\nfn execute_increase_allocation(\n    deps: DepsMut,\n    config: \u0026Config,\n    receiver: String,\n    amount: Uint128,\n    deposit_amount: Option\u003cUint128\u003e,\n) -\u003e StdResult\u003cResponse\u003e {\n    let receiver = deps.api.addr_validate(\u0026receiver)?;\n\n    match PARAMS.may_load(deps.storage, \u0026receiver)? {\n        Some(mut params) =\u003e {\n            let mut state = STATE.load(deps.storage)?;\n\n            if let Some(deposit_amount) = deposit_amount {\n                state.total_astro_deposited =\n                    state.total_astro_deposited.checked_add(deposit_amount)?;\n                state.unallocated_tokens = state.unallocated_tokens.checked_add(deposit_amount)?;\n\n                if state.total_astro_deposited \u003e config.max_allocations_amount {\n                    return Err(StdError::generic_err(format!(\n                        \"The total allocation for all recipients cannot exceed total ASTRO amount allocated to unlock (currently {} ASTRO)\",\n                        config.max_allocations_amount,\n                    )));\n                }\n            }\n\n            if state.unallocated_tokens \u003c amount {\n                return Err(StdError::generic_err(format!(\n                    \"Insufficient unallocated ASTRO to increase allocation. Contract has: {} unallocated ASTRO.\",\n                    state.unallocated_tokens\n                )));\n            }\n\n            params.amount = params.amount.checked_add(amount)?;\n            state.unallocated_tokens = state.unallocated_tokens.checked_sub(amount)?;\n            state.remaining_astro_tokens = state.remaining_astro_tokens.checked_add(amount)?;\n\n            PARAMS.save(deps.storage, \u0026receiver, \u0026params)?;\n            STATE.save(deps.storage, \u0026state)?;\n        }\n        None =\u003e {\n            return Err(StdError::generic_err(\"Proposed receiver not set\"));\n        }\n    }\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"execute_increase_allocation\")\n        .add_attribute(\"amount\", amount)\n        .add_attribute(\"receiver\", receiver))\n}\n\n/// Transfer unallocated ASTRO tokens to a recipient.\n///\n/// * **amount** amount ASTRO to transfer.\n///\n/// * **recipient** transfer recipient.\nfn execute_transfer_unallocated(\n    deps: DepsMut,\n    info: MessageInfo,\n    amount: Uint128,\n    recipient: Option\u003cString\u003e,\n) -\u003e StdResult\u003cResponse\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    if config.owner != info.sender {\n        return Err(StdError::generic_err(\n            \"Only contract owner can transfer unallocated ASTRO.\",\n        ));\n    }\n\n    let mut state = STATE.load(deps.storage)?;\n\n    if state.unallocated_tokens \u003c amount {\n        return Err(StdError::generic_err(format!(\n            \"Insufficient unallocated ASTRO to transfer. Contract has: {} unallocated ASTRO.\",\n            state.unallocated_tokens\n        )));\n    }\n\n    state.unallocated_tokens = state.unallocated_tokens.checked_sub(amount)?;\n    state.total_astro_deposited = state.total_astro_deposited.checked_sub(amount)?;\n\n    let recipient = addr_opt_validate(deps.api, \u0026recipient)?.unwrap_or_else(|| info.sender.clone());\n    let msg = WasmMsg::Execute {\n        contract_addr: config.astro_token.to_string(),\n        msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n            recipient: recipient.to_string(),\n            amount,\n        })?,\n        funds: vec![],\n    };\n\n    STATE.save(deps.storage, \u0026state)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"execute_transfer_unallocated\")\n        .add_attribute(\"amount\", amount)\n        .add_message(msg))\n}\n\n/// Allows a newly proposed allocation receiver to claim the ownership of that allocation.\n///\n/// * **prev_receiver** this is the previous receiver for the allocation.\nfn execute_claim_receiver(\n    deps: DepsMut,\n    info: MessageInfo,\n    prev_receiver: String,\n) -\u003e StdResult\u003cResponse\u003e {\n    let prev_receiver_addr = deps.api.addr_validate(\u0026prev_receiver)?;\n    let mut alloc_params = PARAMS.load(deps.storage, \u0026prev_receiver_addr)?;\n\n    match alloc_params.proposed_receiver {\n        Some(proposed_receiver) =\u003e {\n            if proposed_receiver == info.sender {\n                if let Some(sender_params) = PARAMS.may_load(deps.storage, \u0026info.sender)? {\n                    return Err(StdError::generic_err(format!(\n                        \"The proposed receiver already has an ASTRO allocation of {} ASTRO, that ends at {}\",\n                        sender_params.amount,\n                        sender_params.unlock_schedule.start_time + sender_params.unlock_schedule.duration + sender_params.unlock_schedule.cliff,\n                    )));\n                }\n\n                // Transfers allocation parameters\n                // 1. Save the allocation for the new receiver\n                alloc_params.proposed_receiver = None;\n                PARAMS.save(deps.storage, \u0026info.sender, \u0026alloc_params)?;\n                // 2. Remove the allocation info from the previous owner\n                PARAMS.remove(deps.storage, \u0026prev_receiver_addr);\n                // Transfers Allocation Status\n                let status = STATUS.load(deps.storage, \u0026prev_receiver_addr)?;\n\n                STATUS.save(deps.storage, \u0026info.sender, \u0026status)?;\n                STATUS.remove(deps.storage, \u0026prev_receiver_addr)\n            } else {\n                return Err(StdError::generic_err(format!(\n                    \"Proposed receiver mismatch, actual proposed receiver : {proposed_receiver}\"\n                )));\n            }\n        }\n        None =\u003e {\n            return Err(StdError::generic_err(\"Proposed receiver not set\"));\n        }\n    }\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"ClaimReceiver\"),\n        attr(\"prev_receiver\", prev_receiver),\n        attr(\"receiver\", info.sender),\n    ]))\n}\n\n/// Updates builder unlock contract parameters.\nfn update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    new_max_allocations_amount: Uint128,\n) -\u003e StdResult\u003cResponse\u003e {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    if info.sender != config.owner {\n        return Err(StdError::generic_err(\n            \"Only the contract owner can change config\",\n        ));\n    }\n\n    let state = STATE.load(deps.storage)?;\n\n    if new_max_allocations_amount \u003c state.total_astro_deposited {\n        return Err(StdError::generic_err(format!(\n            \"The new max allocations amount {} can not be less than currently deposited {}\",\n            new_max_allocations_amount, state.total_astro_deposited,\n        )));\n    }\n\n    config.max_allocations_amount = new_max_allocations_amount;\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"update_config\")\n        .add_attribute(\"new_max_allocations_amount\", new_max_allocations_amount))\n}\n\n/// Updates builder unlock schedules for specified accounts.\nfn update_unlock_schedules(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    new_unlock_schedules: Vec\u003c(String, Schedule)\u003e,\n) -\u003e StdResult\u003cResponse\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    if info.sender != config.owner {\n        return Err(StdError::generic_err(\n            \"Only the contract owner can change config\",\n        ));\n    }\n\n    for (account, new_schedule) in new_unlock_schedules {\n        let account_addr = deps.api.addr_validate(\u0026account)?;\n        let mut params = PARAMS.load(deps.storage, \u0026account_addr)?;\n\n        let mut status = STATUS.load(deps.storage, \u0026account_addr)?;\n\n        let unlocked_amount_checkpoint = compute_unlocked_amount(\n            env.block.time.seconds(),\n            params.amount,\n            \u0026params.unlock_schedule,\n            status.unlocked_amount_checkpoint,\n        );\n\n        if unlocked_amount_checkpoint \u003e status.unlocked_amount_checkpoint {\n            status.unlocked_amount_checkpoint = unlocked_amount_checkpoint;\n            STATUS.save(deps.storage, \u0026account_addr, \u0026status)?;\n        }\n\n        params.update_schedule(new_schedule, \u0026account)?;\n        PARAMS.save(deps.storage, \u0026account_addr, \u0026params)?;\n    }\n\n    Ok(Response::new().add_attribute(\"action\", \"update_unlock_schedules\"))\n}\n\n/// Return the global distribution state.\npub fn query_state(deps: Deps) -\u003e StdResult\u003cStateResponse\u003e {\n    let state = STATE.load(deps.storage)?;\n    Ok(StateResponse {\n        total_astro_deposited: state.total_astro_deposited,\n        remaining_astro_tokens: state.remaining_astro_tokens,\n        unallocated_astro_tokens: state.unallocated_tokens,\n    })\n}\n\n/// Return information about a specific allocation.\n///\n/// * **account** account whose allocation we query.\nfn query_allocation(deps: Deps, account: String) -\u003e StdResult\u003cAllocationResponse\u003e {\n    let account_checked = deps.api.addr_validate(\u0026account)?;\n\n    Ok(AllocationResponse {\n        params: PARAMS\n            .may_load(deps.storage, \u0026account_checked)?\n            .unwrap_or_default(),\n        status: STATUS\n            .may_load(deps.storage, \u0026account_checked)?\n            .unwrap_or_default(),\n    })\n}\n\n/// Return information about a specific allocation.\n///\n/// * **start_after** account from which to start querying.\n///\n/// * **limit** max amount of entries to return.\nfn query_allocations(\n    deps: Deps,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cVec\u003c(Addr, AllocationParams)\u003e\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let default_start;\n\n    let start = if let Some(start_after) = start_after {\n        default_start = deps.api.addr_validate(\u0026start_after)?;\n        Some(Bound::exclusive(\u0026default_start))\n    } else {\n        None\n    };\n\n    PARAMS\n        .range(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .collect()\n}\n\n/// Return the total amount of unlocked tokens for a specific account.\n///\n/// * **account** account whose unlocked token amount we query.\nfn query_tokens_unlocked(deps: Deps, env: Env, account: String) -\u003e StdResult\u003cUint128\u003e {\n    let account_checked = deps.api.addr_validate(\u0026account)?;\n\n    let params = PARAMS.load(deps.storage, \u0026account_checked)?;\n    let status = STATUS.load(deps.storage, \u0026account_checked)?;\n\n    Ok(compute_unlocked_amount(\n        env.block.time.seconds(),\n        params.amount,\n        \u0026params.unlock_schedule,\n        status.unlocked_amount_checkpoint,\n    ))\n}\n\n/// Simulate a token withdrawal.\n///\n/// * **account** account for which we simulate a withdrawal.\n///\n/// * **timestamp** timestamp where we assume the account would withdraw.\nfn query_simulate_withdraw(\n    deps: Deps,\n    env: Env,\n    account: String,\n    timestamp: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cSimulateWithdrawResponse\u003e {\n    let account_checked = deps.api.addr_validate(\u0026account)?;\n\n    let params = PARAMS.load(deps.storage, \u0026account_checked)?;\n    let status = STATUS.load(deps.storage, \u0026account_checked)?;\n\n    Ok(compute_withdraw_amount(\n        timestamp.unwrap_or_else(|| env.block.time.seconds()),\n        \u0026params,\n        \u0026status,\n    ))\n}\n\n/// Manages contract migration\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e StdResult\u003cResponse\u003e {\n    let contract_version = get_contract_version(deps.storage)?;\n\n    match contract_version.contract.as_ref() {\n        \"builder-unlock\" =\u003e match contract_version.version.as_ref() {\n            \"1.2.0\" =\u003e {}\n            \"1.2.2\" =\u003e {}\n            _ =\u003e return Err(StdError::generic_err(\"Contract can't be migrated!\")),\n        },\n        _ =\u003e return Err(StdError::generic_err(\"Contract can't be migrated!\")),\n    };\n\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    Ok(Response::new()\n        .add_attribute(\"previous_contract_name\", \u0026contract_version.contract)\n        .add_attribute(\"previous_contract_version\", \u0026contract_version.version)\n        .add_attribute(\"new_contract_name\", CONTRACT_NAME)\n        .add_attribute(\"new_contract_version\", CONTRACT_VERSION))\n}\n\n//----------------------------------------------------------------------------------------\n// Helper Functions\n//----------------------------------------------------------------------------------------\n\nmod helpers {\n    use cosmwasm_std::Uint128;\n\n    use astroport_governance::builder_unlock::msg::SimulateWithdrawResponse;\n    use astroport_governance::builder_unlock::{AllocationParams, AllocationStatus, Schedule};\n\n    /// Computes number of tokens that are now unlocked for a given allocation\n    pub fn compute_unlocked_amount(\n        timestamp: u64,\n        amount: Uint128,\n        schedule: \u0026Schedule,\n        unlock_checkpoint: Uint128,\n    ) -\u003e Uint128 {\n        // Tokens haven't begun unlocking\n        if timestamp \u003c schedule.start_time + schedule.cliff {\n            unlock_checkpoint\n        }\n        // Tokens unlock linearly between start time and end time\n        else if (timestamp \u003c schedule.start_time + schedule.duration) \u0026\u0026 schedule.duration != 0 {\n            let unlocked_amount =\n                amount.multiply_ratio(timestamp - schedule.start_time, schedule.duration);\n\n            if unlocked_amount \u003e unlock_checkpoint {\n                unlocked_amount\n            } else {\n                unlock_checkpoint\n            }\n        }\n        // After end time, all tokens are fully unlocked\n        else {\n            amount\n        }\n    }\n\n    /// Computes number of tokens that are withdrawable for a given allocation\n    pub fn compute_withdraw_amount(\n        timestamp: u64,\n        params: \u0026AllocationParams,\n        status: \u0026AllocationStatus,\n    ) -\u003e SimulateWithdrawResponse {\n        // \"Unlocked\" amount\n        let astro_unlocked = compute_unlocked_amount(\n            timestamp,\n            params.amount,\n            \u0026params.unlock_schedule,\n            status.unlocked_amount_checkpoint,\n        );\n\n        // Withdrawal amount is unlocked amount minus the amount already withdrawn\n        let astro_withdrawable = astro_unlocked - status.astro_withdrawn;\n\n        SimulateWithdrawResponse {\n            astro_to_withdraw: astro_withdrawable,\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","builder_unlock","src","lib.rs"],"content":"pub mod contract;\nmod migration;\npub mod state;\n\n// During development this import could be replaced with another astroport version.\n// However, in production, the astroport version should be the same for all contracts.\npub use astroport_governance::astroport;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","builder_unlock","src","migration.rs"],"content":"use cosmwasm_schema::cw_serde;\n\n/// This structure describes a migration message.\n#[cw_serde]\npub struct MigrateMsg {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","builder_unlock","src","state.rs"],"content":"use crate::astroport::common::OwnershipProposal;\nuse cosmwasm_std::Addr;\nuse cw_storage_plus::{Item, Map};\n\nuse astroport_governance::builder_unlock::{AllocationParams, AllocationStatus, Config, State};\n\n/// Stores the contract configuration\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n/// Stores global unlcok state such as the total amount of ASTRO tokens still to be distributed\npub const STATE: Item\u003cState\u003e = Item::new(\"state\");\n/// Allocation parameters for each unlock recipient\npub const PARAMS: Map\u003c\u0026Addr, AllocationParams\u003e = Map::new(\"params\");\n/// The status of each unlock schedule\npub const STATUS: Map\u003c\u0026Addr, AllocationStatus\u003e = Map::new(\"status\");\n/// Contains a proposal to change contract ownership\npub const OWNERSHIP_PROPOSAL: Item\u003cOwnershipProposal\u003e = Item::new(\"ownership_proposal\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","builder_unlock","tests","integration.rs"],"content":"use astroport::token::InstantiateMsg as TokenInstantiateMsg;\nuse astroport_governance::builder_unlock::{AllocationParams, Schedule};\n\nuse astroport_governance::builder_unlock::msg::{\n    AllocationResponse, ConfigResponse, ExecuteMsg, InstantiateMsg, QueryMsg, ReceiveMsg,\n    SimulateWithdrawResponse, StateResponse,\n};\nuse cosmwasm_std::{attr, to_binary, Addr, StdResult, Timestamp, Uint128};\nuse cw20::BalanceResponse;\nuse cw_multi_test::{App, BasicApp, ContractWrapper, Executor};\n\nconst OWNER: \u0026str = \"owner\";\n\nfn mock_app() -\u003e App {\n    BasicApp::default()\n}\n\nfn init_contracts(app: \u0026mut App) -\u003e (Addr, Addr, InstantiateMsg) {\n    // Instantiate ASTRO token contract\n    let astro_token_contract = Box::new(ContractWrapper::new(\n        astroport_token::contract::execute,\n        astroport_token::contract::instantiate,\n        astroport_token::contract::query,\n    ));\n\n    let astro_token_code_id = app.store_code(astro_token_contract);\n\n    let msg = TokenInstantiateMsg {\n        name: String::from(\"Astro token\"),\n        symbol: String::from(\"ASTRO\"),\n        decimals: 6,\n        initial_balances: vec![],\n        mint: Some(cw20::MinterResponse {\n            minter: OWNER.clone().to_string(),\n            cap: None,\n        }),\n        marketing: None,\n    };\n\n    let astro_token_instance = app\n        .instantiate_contract(\n            astro_token_code_id,\n            Addr::unchecked(OWNER.clone().to_string()),\n            \u0026msg,\n            \u0026[],\n            String::from(\"ASTRO\"),\n            None,\n        )\n        .unwrap();\n\n    // Instantiate the contract\n    let unlock_contract = Box::new(ContractWrapper::new(\n        builder_unlock::contract::execute,\n        builder_unlock::contract::instantiate,\n        builder_unlock::contract::query,\n    ));\n\n    let unlock_code_id = app.store_code(unlock_contract);\n\n    let unlock_instantiate_msg = InstantiateMsg {\n        owner: OWNER.clone().to_string(),\n        astro_token: astro_token_instance.to_string(),\n        max_allocations_amount: Uint128::new(300_000_000_000_000u128),\n    };\n\n    // Init contract\n    let unlock_instance = app\n        .instantiate_contract(\n            unlock_code_id,\n            Addr::unchecked(OWNER.clone()),\n            \u0026unlock_instantiate_msg,\n            \u0026[],\n            \"unlock\",\n            None,\n        )\n        .unwrap();\n\n    (\n        unlock_instance,\n        astro_token_instance,\n        unlock_instantiate_msg,\n    )\n}\n\nfn mint_some_astro(\n    app: \u0026mut App,\n    owner: Addr,\n    astro_token_instance: Addr,\n    amount: Uint128,\n    to: String,\n) {\n    let msg = cw20::Cw20ExecuteMsg::Mint {\n        recipient: to.clone(),\n        amount: amount,\n    };\n    let res = app\n        .execute_contract(owner.clone(), astro_token_instance.clone(), \u0026msg, \u0026[])\n        .unwrap();\n    assert_eq!(res.events[1].attributes[1], attr(\"action\", \"mint\"));\n    assert_eq!(res.events[1].attributes[2], attr(\"to\", to));\n    assert_eq!(res.events[1].attributes[3], attr(\"amount\", amount));\n}\n\nfn check_alloc_amount(app: \u0026mut App, contract_addr: \u0026Addr, account: \u0026Addr, amount: Uint128) {\n    let res: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            contract_addr,\n            \u0026QueryMsg::Allocation {\n                account: account.to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(res.params.amount, amount);\n}\n\nfn check_unlock_amount(app: \u0026mut App, contract_addr: \u0026Addr, account: \u0026Addr, amount: Uint128) {\n    let resp: Uint128 = app\n        .wrap()\n        .query_wasm_smart(\n            contract_addr,\n            \u0026QueryMsg::UnlockedTokens {\n                account: account.to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(resp, amount);\n}\n\n#[test]\nfn proper_initialization() {\n    let mut app = mock_app();\n    let (unlock_instance, _astro_instance, init_msg) = init_contracts(\u0026mut app);\n\n    let resp: ConfigResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026unlock_instance, \u0026QueryMsg::Config {})\n        .unwrap();\n\n    // Check config\n    assert_eq!(init_msg.owner, resp.owner);\n    assert_eq!(init_msg.astro_token, resp.astro_token);\n\n    // Check state\n    let resp: StateResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026unlock_instance, \u0026QueryMsg::State {})\n        .unwrap();\n\n    assert_eq!(Uint128::zero(), resp.total_astro_deposited);\n    assert_eq!(Uint128::zero(), resp.remaining_astro_tokens);\n}\n\n#[test]\nfn test_transfer_ownership() {\n    let mut app = mock_app();\n    let (unlock_instance, _, init_msg) = init_contracts(\u0026mut app);\n\n    // ######    ERROR :: Unauthorized     ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"not_owner\".to_string()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::ProposeNewOwner {\n                new_owner: \"new_owner\".to_string(),\n                expires_in: 600,\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Generic error: Unauthorized\");\n\n    app.execute_contract(\n        Addr::unchecked(OWNER.to_string()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::ProposeNewOwner {\n            new_owner: \"new_owner\".to_string(),\n            expires_in: 100,\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    app.execute_contract(\n        Addr::unchecked(\"new_owner\".to_string()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::ClaimOwnership {},\n        \u0026[],\n    )\n    .unwrap();\n\n    let resp: ConfigResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026unlock_instance, \u0026QueryMsg::Config {})\n        .unwrap();\n\n    // Check config\n    assert_eq!(\"new_owner\".to_string(), resp.owner);\n    assert_eq!(init_msg.astro_token, resp.astro_token);\n}\n\n#[test]\nfn test_create_allocations() {\n    let mut app = mock_app();\n    let (unlock_instance, astro_instance, _) = init_contracts(\u0026mut app);\n\n    mint_some_astro(\n        \u0026mut app,\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        Uint128::new(1_000_000_000_000000),\n        OWNER.to_string(),\n    );\n\n    let mut allocations: Vec\u003c(String, AllocationParams)\u003e = vec![];\n    allocations.push((\n        \"investor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 0u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"advisor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"team_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n\n    // ######    ERROR :: Only owner can create allocations     ######\n    mint_some_astro(\n        \u0026mut app,\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        Uint128::new(1_000),\n        \"not_owner\".to_string(),\n    );\n\n    let mut err = app\n        .execute_contract(\n            Addr::unchecked(\"not_owner\".to_string()),\n            astro_instance.clone(),\n            \u0026cw20::Cw20ExecuteMsg::Send {\n                contract: unlock_instance.clone().to_string(),\n                amount: Uint128::from(1_000u64),\n                msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                    allocations: allocations.clone(),\n                })\n                .unwrap(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Only the contract owner can create allocations\"\n    );\n\n    // ######    ERROR :: Only ASTRO can be can be deposited     ######\n    // Instantiate the ASTRO token contract\n    let not_astro_token_contract = Box::new(ContractWrapper::new(\n        astroport_token::contract::execute,\n        astroport_token::contract::instantiate,\n        astroport_token::contract::query,\n    ));\n\n    let not_astro_token_code_id = app.store_code(not_astro_token_contract);\n\n    let msg = TokenInstantiateMsg {\n        name: String::from(\"Astro Token\"),\n        symbol: String::from(\"ASTRO\"),\n        decimals: 6,\n        initial_balances: vec![],\n        mint: Some(cw20::MinterResponse {\n            minter: OWNER.clone().to_string(),\n            cap: None,\n        }),\n        marketing: None,\n    };\n\n    let not_astro_token_instance = app\n        .instantiate_contract(\n            not_astro_token_code_id,\n            Addr::unchecked(OWNER.clone().to_string()),\n            \u0026msg,\n            \u0026[],\n            String::from(\"FAKE_ASTRO\"),\n            None,\n        )\n        .unwrap();\n\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        not_astro_token_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Mint {\n            recipient: OWNER.clone().to_string(),\n            amount: Uint128::from(15_000_000_000000u64),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            not_astro_token_instance.clone(),\n            \u0026cw20::Cw20ExecuteMsg::Send {\n                contract: unlock_instance.clone().to_string(),\n                amount: Uint128::from(15_000_000_000000u64),\n                msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                    allocations: allocations.clone(),\n                })\n                .unwrap(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Only ASTRO can be deposited\"\n    );\n\n    // ######    ERROR :: ASTRO deposit amount mismatch     ######\n    err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            astro_instance.clone(),\n            \u0026cw20::Cw20ExecuteMsg::Send {\n                contract: unlock_instance.clone().to_string(),\n                amount: Uint128::from(15_000_000_000001u64),\n                msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                    allocations: allocations.clone(),\n                })\n                .unwrap(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: ASTRO deposit amount mismatch\"\n    );\n\n    // ######    SUCCESSFULLY CREATES ALLOCATIONS    ######\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Send {\n            contract: unlock_instance.clone().to_string(),\n            amount: Uint128::from(15_000_000_000000u64),\n            msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                allocations: allocations.clone(),\n            })\n            .unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Check state\n    let resp: StateResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026unlock_instance, \u0026QueryMsg::State {})\n        .unwrap();\n    assert_eq!(\n        resp.total_astro_deposited,\n        Uint128::from(15_000_000_000000u64)\n    );\n    assert_eq!(\n        resp.remaining_astro_tokens,\n        Uint128::from(15_000_000_000000u64)\n    );\n\n    // Check allocation #1\n    let resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(resp.params.amount, Uint128::from(5_000_000_000000u64));\n    assert_eq!(resp.status.astro_withdrawn, Uint128::from(0u64));\n    assert_eq!(\n        resp.params.unlock_schedule,\n        Schedule {\n            start_time: 1642402274u64,\n            cliff: 0u64,\n            duration: 31536000u64\n        }\n    );\n\n    // Check allocation #2\n    let resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"advisor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(resp.params.amount, Uint128::from(5_000_000_000000u64));\n    assert_eq!(resp.status.astro_withdrawn, Uint128::from(0u64));\n    assert_eq!(\n        resp.params.unlock_schedule,\n        Schedule {\n            start_time: 1642402274u64,\n            cliff: 7776000u64,\n            duration: 31536000u64\n        }\n    );\n\n    // Check allocation #3\n    let resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"team_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(resp.params.amount, Uint128::from(5_000_000_000000u64));\n    assert_eq!(resp.status.astro_withdrawn, Uint128::from(0u64));\n    assert_eq!(\n        resp.params.unlock_schedule,\n        Schedule {\n            start_time: 1642402274u64,\n            cliff: 7776000u64,\n            duration: 31536000u64\n        }\n    );\n\n    // ######    ERROR :: Allocation already exists for user {}     ######\n    err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            astro_instance.clone(),\n            \u0026cw20::Cw20ExecuteMsg::Send {\n                contract: unlock_instance.clone().to_string(),\n                amount: Uint128::from(5_000_000_000000u64),\n                msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                    allocations: vec![allocations[0].clone()],\n                })\n                .unwrap(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Allocation (params) already exists for investor_1\"\n    );\n}\n\n#[test]\nfn test_withdraw() {\n    let mut app = mock_app();\n    let (unlock_instance, astro_instance, _) = init_contracts(\u0026mut app);\n\n    mint_some_astro(\n        \u0026mut app,\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        Uint128::new(1_000_000_000_000000),\n        OWNER.to_string(),\n    );\n\n    let mut allocations: Vec\u003c(String, AllocationParams)\u003e = vec![];\n    allocations.push((\n        \"investor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 0u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"advisor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"team_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n\n    // SUCCESSFULLY CREATES ALLOCATIONS\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Send {\n            contract: unlock_instance.clone().to_string(),\n            amount: Uint128::from(15_000_000_000000u64),\n            msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                allocations: allocations.clone(),\n            })\n            .unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // ######    ERROR :: Allocation doesn't exist    ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::Withdraw {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"astroport_governance::builder_unlock::AllocationParams not found\"\n    );\n\n    // ######   SUCCESSFULLY WITHDRAWS ASTRO #1   ######\n    app.update_block(|b| {\n        b.height += 17280;\n        b.time = Timestamp::from_seconds(1642402275)\n    });\n\n    let astro_bal_before: BalanceResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026astro_instance,\n            \u0026cw20::Cw20QueryMsg::Balance {\n                address: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n\n    app.execute_contract(\n        Addr::unchecked(\"investor_1\".clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::Withdraw {},\n        \u0026[],\n    )\n    .unwrap();\n\n    // Check state\n    let state_resp: StateResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026unlock_instance, \u0026QueryMsg::State {})\n        .unwrap();\n    assert_eq!(\n        state_resp.total_astro_deposited,\n        Uint128::from(15_000_000_000000u64)\n    );\n    assert_eq!(\n        state_resp.remaining_astro_tokens,\n        Uint128::from(14_999_999_841452u64)\n    );\n\n    // Check allocation #1\n    let alloc_resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(alloc_resp.params.amount, Uint128::from(5_000_000_000000u64));\n    assert_eq!(alloc_resp.status.astro_withdrawn, Uint128::from(158548u64));\n\n    let astro_bal_after: BalanceResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026astro_instance,\n            \u0026cw20::Cw20QueryMsg::Balance {\n                address: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n\n    assert_eq!(\n        astro_bal_after.balance - astro_bal_before.balance,\n        alloc_resp.status.astro_withdrawn\n    );\n\n    // Check the number of unlocked tokens\n    let mut unlock_resp: Uint128 = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::UnlockedTokens {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(unlock_resp, Uint128::from(158548u64));\n\n    // ######    ERROR :: No unlocked ASTRO to be withdrawn   ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"investor_1\".clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::Withdraw {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: No unlocked ASTRO to be withdrawn\"\n    );\n\n    // ######   SUCCESSFULLY WITHDRAWS ASTRO #2   ######\n    app.update_block(|b| {\n        b.height += 17280;\n        b.time = Timestamp::from_seconds(1642402285)\n    });\n\n    // Check the number of unlocked tokens\n    unlock_resp = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::UnlockedTokens {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(unlock_resp, Uint128::from(1744038u64));\n\n    // Check the number of tokens that can be withdrawn from the contract right now\n    let mut sim_withdraw_resp: SimulateWithdrawResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::SimulateWithdraw {\n                account: \"investor_1\".to_string(),\n                timestamp: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(\n        sim_withdraw_resp.astro_to_withdraw,\n        unlock_resp - alloc_resp.status.astro_withdrawn\n    );\n\n    app.execute_contract(\n        Addr::unchecked(\"investor_1\".clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::Withdraw {},\n        \u0026[],\n    )\n    .unwrap();\n\n    let resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(resp.params.amount, Uint128::from(5_000_000_000000u64));\n    assert_eq!(resp.status.astro_withdrawn, unlock_resp);\n\n    // ######    ERROR :: No unlocked ASTRO to be withdrawn   ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"investor_1\".clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::Withdraw {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: No unlocked ASTRO to be withdrawn\"\n    );\n\n    // ######   SUCCESSFULLY WITHDRAWS ASTRO #3   ######\n    // ***** Check that tokens that can be withdrawn before cliff is 0 *****\n    app.update_block(|b| {\n        b.height += 1572480;\n        b.time = Timestamp::from_seconds(1657954273)\n    });\n\n    // Check the number of unlocked tokens\n    unlock_resp = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::UnlockedTokens {\n                account: \"team_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(unlock_resp, Uint128::from(2465753266108u64));\n\n    // Check Number of tokens that can be withdrawn\n    sim_withdraw_resp = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::SimulateWithdraw {\n                account: \"team_1\".to_string(),\n                timestamp: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(\n        sim_withdraw_resp.astro_to_withdraw,\n        Uint128::from(2465753266108u64)\n    );\n\n    app.update_block(|b| {\n        b.height += 17280;\n        b.time = Timestamp::from_seconds(1657954279)\n    });\n\n    // Check the number of unlocked tokens\n    unlock_resp = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::UnlockedTokens {\n                account: \"team_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(unlock_resp, Uint128::from(2465754217402u64));\n\n    // Check Number of tokens that can be withdrawn\n    sim_withdraw_resp = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::SimulateWithdraw {\n                account: \"team_1\".to_string(),\n                timestamp: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(\n        sim_withdraw_resp.astro_to_withdraw,\n        Uint128::from(2465754217402u64)\n    );\n\n    app.execute_contract(\n        Addr::unchecked(\"team_1\".clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::Withdraw {},\n        \u0026[],\n    )\n    .unwrap();\n\n    let resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"team_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        resp.status.astro_withdrawn,\n        sim_withdraw_resp.astro_to_withdraw\n    );\n\n    // Check Number of tokens that can be withdrawn\n    sim_withdraw_resp = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::SimulateWithdraw {\n                account: \"team_1\".to_string(),\n                timestamp: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(sim_withdraw_resp.astro_to_withdraw, Uint128::zero());\n}\n\n#[test]\nfn test_propose_new_receiver() {\n    let mut app = mock_app();\n    let (unlock_instance, astro_instance, _) = init_contracts(\u0026mut app);\n\n    mint_some_astro(\n        \u0026mut app,\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        Uint128::new(1_000_000_000_000000),\n        OWNER.to_string(),\n    );\n\n    let mut allocations: Vec\u003c(String, AllocationParams)\u003e = vec![];\n    allocations.push((\n        \"investor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 0u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"advisor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"team_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n\n    // SUCCESSFULLY CREATES ALLOCATIONS\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Send {\n            contract: unlock_instance.clone().to_string(),\n            amount: Uint128::from(15_000_000_000000u64),\n            msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                allocations: allocations.clone(),\n            })\n            .unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // ######    ERROR :: Allocation doesn't exist    ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::ProposeNewReceiver {\n                new_receiver: \"investor_1_new\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"astroport_governance::builder_unlock::AllocationParams not found\"\n    );\n\n    // ######    ERROR :: Invalid new_receiver    ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"investor_1\".clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::ProposeNewReceiver {\n                new_receiver: \"team_1\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Invalid new_receiver. Proposed receiver already has an ASTRO allocation\"\n    );\n\n    // ######   SUCCESSFULLY PROPOSES NEW RECEIVER   ######\n    app.execute_contract(\n        Addr::unchecked(\"investor_1\".clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::ProposeNewReceiver {\n            new_receiver: \"investor_1_new\".to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    let resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        resp.params.proposed_receiver,\n        Some(Addr::unchecked(\"investor_1_new\".to_string()))\n    );\n\n    // ######    ERROR ::\"Proposed receiver already set\"   ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"investor_1\".clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::ProposeNewReceiver {\n                new_receiver: \"investor_1_new_\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Proposed receiver already set to investor_1_new\"\n    );\n}\n\n#[test]\nfn test_drop_new_receiver() {\n    let mut app = mock_app();\n    let (unlock_instance, astro_instance, _) = init_contracts(\u0026mut app);\n\n    mint_some_astro(\n        \u0026mut app,\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        Uint128::new(1_000_000_000_000000),\n        OWNER.to_string(),\n    );\n\n    let mut allocations: Vec\u003c(String, AllocationParams)\u003e = vec![];\n    allocations.push((\n        \"investor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 0u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"advisor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"team_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n\n    // SUCCESSFULLY CREATES ALLOCATIONS\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Send {\n            contract: unlock_instance.clone().to_string(),\n            amount: Uint128::from(15_000_000_000000u64),\n            msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                allocations: allocations.clone(),\n            })\n            .unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // ######    ERROR :: Allocation doesn't exist    ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::DropNewReceiver {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"astroport_governance::builder_unlock::AllocationParams not found\"\n    );\n\n    // ######    ERROR ::\"Proposed receiver not set\"   ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"investor_1\".clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::DropNewReceiver {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Proposed receiver not set\"\n    );\n\n    // ######   SUCCESSFULLY DROP NEW RECEIVER   ######\n    // SUCCESSFULLY PROPOSES NEW RECEIVER\n    app.execute_contract(\n        Addr::unchecked(\"investor_1\".clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::ProposeNewReceiver {\n            new_receiver: \"investor_1_new\".to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    let mut resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        resp.params.proposed_receiver,\n        Some(Addr::unchecked(\"investor_1_new\".to_string()))\n    );\n\n    app.execute_contract(\n        Addr::unchecked(\"investor_1\".clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::DropNewReceiver {},\n        \u0026[],\n    )\n    .unwrap();\n\n    resp = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(resp.params.proposed_receiver, None);\n}\n\n#[test]\nfn test_claim_receiver() {\n    let mut app = mock_app();\n    let (unlock_instance, astro_instance, _) = init_contracts(\u0026mut app);\n\n    mint_some_astro(\n        \u0026mut app,\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        Uint128::new(1_000_000_000_000000),\n        OWNER.to_string(),\n    );\n\n    let mut allocations: Vec\u003c(String, AllocationParams)\u003e = vec![];\n    allocations.push((\n        \"investor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 0u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"advisor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"team_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n\n    // SUCCESSFULLY CREATES ALLOCATIONS\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Send {\n            contract: unlock_instance.clone().to_string(),\n            amount: Uint128::from(15_000_000_000000u64),\n            msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                allocations: allocations.clone(),\n            })\n            .unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // ######    ERROR :: Allocation doesn't exist    ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::Withdraw {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"astroport_governance::builder_unlock::AllocationParams not found\"\n    );\n\n    // ######    ERROR ::\"Proposed receiver not set\"   ######\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"investor_1_new\".clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::ClaimReceiver {\n                prev_receiver: \"investor_1\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Proposed receiver not set\"\n    );\n\n    // ######   SUCCESSFULLY CLAIMED BY NEW RECEIVER   ######\n    // SUCCESSFULLY PROPOSES NEW RECEIVER\n    app.execute_contract(\n        Addr::unchecked(\"investor_1\".clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::ProposeNewReceiver {\n            new_receiver: \"investor_1_new\".to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    let alloc_resp_before: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n\n    // Check Number of tokens that can be withdrawn\n    let sim_withdraw_resp_before: SimulateWithdrawResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::SimulateWithdraw {\n                account: \"investor_1\".to_string(),\n                timestamp: None,\n            },\n        )\n        .unwrap();\n\n    // Claimed by new receiver\n    app.execute_contract(\n        Addr::unchecked(\"investor_1_new\".clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::ClaimReceiver {\n            prev_receiver: \"investor_1\".to_string(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Check allocation state of previous beneficiary\n    let alloc_resp_after: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        AllocationParams {\n            amount: Uint128::zero(),\n            unlock_schedule: Schedule {\n                start_time: 0u64,\n                cliff: 0u64,\n                duration: 0u64,\n            },\n            proposed_receiver: None,\n        },\n        alloc_resp_after.params\n    );\n    assert_eq!(alloc_resp_before.status, alloc_resp_after.status);\n\n    // Check allocation state of new beneficiary\n    let alloc_resp_after: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocation {\n                account: \"investor_1_new\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        AllocationParams {\n            amount: alloc_resp_before.params.amount,\n            unlock_schedule: Schedule {\n                start_time: alloc_resp_before.params.unlock_schedule.start_time,\n                cliff: alloc_resp_before.params.unlock_schedule.cliff,\n                duration: alloc_resp_before.params.unlock_schedule.duration,\n            },\n            proposed_receiver: None,\n        },\n        alloc_resp_after.params\n    );\n    assert_eq!(alloc_resp_before.status, alloc_resp_after.status);\n\n    // Check Number of tokens that can be withdrawn\n    let sim_withdraw_resp_after_prev_inv: SimulateWithdrawResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::SimulateWithdraw {\n                account: \"investor_1_new\".to_string(),\n                timestamp: None,\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        sim_withdraw_resp_after_prev_inv.astro_to_withdraw,\n        Uint128::zero()\n    );\n\n    // Check Number of tokens that can be withdrawn\n    let sim_withdraw_resp_after_new_inv: SimulateWithdrawResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::SimulateWithdraw {\n                account: \"investor_1_new\".to_string(),\n                timestamp: None,\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        sim_withdraw_resp_after_new_inv.astro_to_withdraw,\n        sim_withdraw_resp_before.astro_to_withdraw,\n    );\n}\n\n#[test]\nfn test_increase_and_decrease_allocation() {\n    let mut app = mock_app();\n    let (unlock_instance, astro_instance, _) = init_contracts(\u0026mut app);\n\n    mint_some_astro(\n        \u0026mut app,\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        Uint128::new(1_000_000_000_000_000),\n        OWNER.to_string(),\n    );\n\n    // Create allocations\n    let allocations: Vec\u003c(String, AllocationParams)\u003e = vec![(\n        \"investor\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1_571_797_419u64,\n                cliff: 300u64,\n                duration: 1_534_700u64,\n            },\n            proposed_receiver: None,\n        },\n    )];\n\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Send {\n            contract: unlock_instance.clone().to_string(),\n            amount: Uint128::from(5_000_000_000000u64),\n            msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                allocations: allocations.clone(),\n            })\n            .unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Check allocations before changes\n    check_alloc_amount(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \u0026Addr::unchecked(\"investor\"),\n        Uint128::new(5_000_000_000_000u128),\n    );\n\n    // Skip blocks\n    app.update_block(|bi| {\n        bi.height += 1000;\n        bi.time = bi.time.plus_seconds(5_000);\n    });\n\n    // Withdraw ASTRO\n    app.execute_contract(\n        Addr::unchecked(\"investor\".to_string()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::Withdraw {},\n        \u0026[],\n    )\n    .unwrap();\n\n    // Skip blocks\n    app.update_block(|bi| {\n        bi.height += 4000;\n        bi.time = bi.time.plus_seconds(20_000);\n    });\n\n    check_unlock_amount(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \u0026Addr::unchecked(\"investor\"),\n        Uint128::new(81_449_143_155u128),\n    );\n\n    // Try to decrease 4918550856846 ASTRO\n    let err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::DecreaseAllocation {\n                receiver: \"investor\".to_string(),\n                amount: Uint128::from(4_918_550_856_846u128),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Insufficient amount of lock to decrease allocation, user has locked 4918550856845 ASTRO.\"\n    );\n\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::DecreaseAllocation {\n            receiver: \"investor\".to_string(),\n            amount: Uint128::from(1_000_000_000_000u128),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Unlock amount didn't change after decreasing\n    check_unlock_amount(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \u0026Addr::unchecked(\"investor\"),\n        Uint128::new(81_449_143_155u128),\n    );\n    let res: StateResponse = app\n        .wrap()\n        .query_wasm_smart(unlock_instance.clone(), \u0026QueryMsg::State {})\n        .unwrap();\n\n    assert_eq!(\n        res,\n        StateResponse {\n            total_astro_deposited: Uint128::new(5_000_000_000_000u128),\n            remaining_astro_tokens: Uint128::new(3_983_710_171_369u128),\n            unallocated_astro_tokens: Uint128::new(1_000_000_000_000u128)\n        }\n    );\n\n    // Try to increase\n    let err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::IncreaseAllocation {\n                receiver: \"investor\".to_string(),\n                amount: Uint128::from(1_000_000_000_001u128),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Insufficient unallocated ASTRO to increase allocation. Contract has: 1000000000000 unallocated ASTRO.\"\n    );\n\n    // Transfer unallocated tokens to owner\n    app.execute_contract(\n        Addr::unchecked(\"owner\".to_string()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::TransferUnallocated {\n            amount: Uint128::from(500_000_000_000u128),\n            recipient: Some(OWNER.to_string()),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    let res: BalanceResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026astro_instance,\n            \u0026cw20::Cw20QueryMsg::Balance {\n                address: OWNER.to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(res.balance, Uint128::from(995_500_000_000_000u128));\n\n    // Increase allocations with sending cw20\n    app.execute_contract(\n        Addr::unchecked(OWNER),\n        astro_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Send {\n            contract: unlock_instance.clone().to_string(),\n            amount: Uint128::from(1_000u64),\n            msg: to_binary(\u0026ReceiveMsg::IncreaseAllocation {\n                amount: Uint128::from(500_000_001_000u128),\n                user: \"investor\".to_string(),\n            })\n            .unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Withdraw ASTRO\n    app.execute_contract(\n        Addr::unchecked(\"investor\".to_string()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::Withdraw {},\n        \u0026[],\n    )\n    .unwrap();\n\n    let res: BalanceResponse = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026astro_instance,\n            \u0026cw20::Cw20QueryMsg::Balance {\n                address: \"investor\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(res.balance, Uint128::from(81_449_143_155u128));\n\n    // Check allocation amount after decreasing and increasing\n    check_alloc_amount(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \u0026Addr::unchecked(\"investor\"),\n        Uint128::new(4_500_000_001_000u128),\n    );\n    // Check astro to withdraw after withdrawal\n    let res: SimulateWithdrawResponse = app\n        .wrap()\n        .query_wasm_smart(\n            unlock_instance.clone(),\n            \u0026QueryMsg::SimulateWithdraw {\n                account: \"investor\".to_string(),\n                timestamp: None,\n            },\n        )\n        .unwrap();\n    assert_eq!(res.astro_to_withdraw, Uint128::zero());\n    // Check state\n    let res: StateResponse = app\n        .wrap()\n        .query_wasm_smart(unlock_instance.clone(), \u0026QueryMsg::State {})\n        .unwrap();\n    assert_eq!(\n        res,\n        StateResponse {\n            total_astro_deposited: Uint128::new(4_500_000_001_000u128),\n            remaining_astro_tokens: Uint128::new(4_418_550_857_845u128),\n            unallocated_astro_tokens: Uint128::zero()\n        }\n    );\n}\n\n#[test]\nfn test_updates_schedules() {\n    let mut app = mock_app();\n    let (unlock_instance, astro_instance, _) = init_contracts(\u0026mut app);\n\n    mint_some_astro(\n        \u0026mut app,\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        Uint128::new(1_000_000_000_000000),\n        OWNER.to_string(),\n    );\n\n    let mut allocations: Vec\u003c(String, AllocationParams)\u003e = vec![];\n    allocations.push((\n        \"investor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 0u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"advisor_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n    allocations.push((\n        \"team_1\".to_string(),\n        AllocationParams {\n            amount: Uint128::from(5_000_000_000000u64),\n            unlock_schedule: Schedule {\n                start_time: 1642402274u64,\n                cliff: 7776000u64,\n                duration: 31536000u64,\n            },\n            proposed_receiver: None,\n        },\n    ));\n\n    // ######    SUCCESSFULLY CREATES ALLOCATIONS    ######\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        astro_instance.clone(),\n        \u0026cw20::Cw20ExecuteMsg::Send {\n            contract: unlock_instance.clone().to_string(),\n            amount: Uint128::from(15_000_000_000000u64),\n            msg: to_binary(\u0026ReceiveMsg::CreateAllocations {\n                allocations: allocations.clone(),\n            })\n            .unwrap(),\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Check state before update parameters\n    let resp: StateResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026unlock_instance, \u0026QueryMsg::State {})\n        .unwrap();\n    assert_eq!(\n        resp.total_astro_deposited,\n        Uint128::from(15_000_000_000000u64)\n    );\n    assert_eq!(\n        resp.remaining_astro_tokens,\n        Uint128::from(15_000_000_000000u64)\n    );\n\n    // Check allocation #1 before update\n    check_allocation(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \"investor_1\".to_string(),\n        Uint128::from(5_000_000_000000u64),\n        Uint128::from(0u64),\n        Schedule {\n            start_time: 1642402274u64,\n            cliff: 0u64,\n            duration: 31536000u64,\n        },\n    )\n    .unwrap();\n\n    // Check allocation #2 before update\n    check_allocation(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \"advisor_1\".to_string(),\n        Uint128::from(5_000_000_000000u64),\n        Uint128::from(0u64),\n        Schedule {\n            start_time: 1642402274u64,\n            cliff: 7776000u64,\n            duration: 31536000u64,\n        },\n    )\n    .unwrap();\n\n    // Check allocation #3 before update\n    check_allocation(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \"team_1\".to_string(),\n        Uint128::from(5_000_000_000000u64),\n        Uint128::from(0u64),\n        Schedule {\n            start_time: 1642402274u64,\n            cliff: 7776000u64,\n            duration: 31536000u64,\n        },\n    )\n    .unwrap();\n\n    // not owner try to update configs\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"not_owner\".clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::UpdateUnlockSchedules {\n                new_unlock_schedules: vec![(\n                    \"team_1\".to_string(),\n                    Schedule {\n                        start_time: 123u64,\n                        cliff: 123u64,\n                        duration: 123u64,\n                    },\n                )],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"Generic error: Only the contract owner can change config\",\n        err.root_cause().to_string()\n    );\n\n    let err = app\n        .execute_contract(\n            Addr::unchecked(OWNER.clone()),\n            unlock_instance.clone(),\n            \u0026ExecuteMsg::UpdateUnlockSchedules {\n                new_unlock_schedules: vec![\n                    (\n                        \"team_1\".to_string(),\n                        Schedule {\n                            start_time: 123u64,\n                            cliff: 123u64,\n                            duration: 123u64,\n                        },\n                    ),\n                    (\n                        \"advisor_1\".to_string(),\n                        Schedule {\n                            start_time: 123u64,\n                            cliff: 123u64,\n                            duration: 123u64,\n                        },\n                    ),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"Generic error: The new cliff value should be greater than or equal to the old one: 123 \u003e= 7776000. Account error: team_1\",\n        err.root_cause().to_string()\n    );\n\n    app.execute_contract(\n        Addr::unchecked(OWNER.clone()),\n        unlock_instance.clone(),\n        \u0026ExecuteMsg::UpdateUnlockSchedules {\n            new_unlock_schedules: vec![\n                (\n                    \"team_1\".to_string(),\n                    Schedule {\n                        start_time: 1642402284u64,\n                        cliff: 8776000u64,\n                        duration: 31536001u64,\n                    },\n                ),\n                (\n                    \"advisor_1\".to_string(),\n                    Schedule {\n                        start_time: 1642402284u64,\n                        cliff: 8776000u64,\n                        duration: 31536001u64,\n                    },\n                ),\n            ],\n        },\n        \u0026[],\n    )\n    .unwrap();\n\n    // Check allocation #2 before update\n    check_allocation(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \"advisor_1\".to_string(),\n        Uint128::from(5_000_000_000000u64),\n        Uint128::from(0u64),\n        Schedule {\n            start_time: 1642402284u64,\n            cliff: 8776000u64,\n            duration: 31536001u64,\n        },\n    )\n    .unwrap();\n\n    // Check allocation #3 before update\n    check_allocation(\n        \u0026mut app,\n        \u0026unlock_instance,\n        \"team_1\".to_string(),\n        Uint128::from(5_000_000_000000u64),\n        Uint128::from(0u64),\n        Schedule {\n            start_time: 1642402284u64,\n            cliff: 8776000u64,\n            duration: 31536001u64,\n        },\n    )\n    .unwrap();\n\n    // Query allocations\n    let resp: Vec\u003c(Addr, AllocationParams)\u003e = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocations {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    let comparing_values: Vec\u003c(Addr, AllocationParams)\u003e = vec![\n        (\n            Addr::unchecked(\"advisor_1\"),\n            AllocationParams {\n                amount: Uint128::new(5000000000000),\n                unlock_schedule: Schedule {\n                    start_time: 1642402284u64,\n                    cliff: 8776000u64,\n                    duration: 31536001u64,\n                },\n                proposed_receiver: None,\n            },\n        ),\n        (\n            Addr::unchecked(\"investor_1\"),\n            AllocationParams {\n                amount: Uint128::new(5000000000000),\n                unlock_schedule: Schedule {\n                    start_time: 1642402274,\n                    cliff: 0,\n                    duration: 31536000,\n                },\n                proposed_receiver: None,\n            },\n        ),\n        (\n            Addr::unchecked(\"team_1\"),\n            AllocationParams {\n                amount: Uint128::new(5000000000000),\n                unlock_schedule: Schedule {\n                    start_time: 1642402284u64,\n                    cliff: 8776000u64,\n                    duration: 31536001u64,\n                },\n                proposed_receiver: None,\n            },\n        ),\n    ];\n    assert_eq!(comparing_values, resp);\n\n    // Query allocations by specified parameters\n    let resp: Vec\u003c(Addr, AllocationParams)\u003e = app\n        .wrap()\n        .query_wasm_smart(\n            \u0026unlock_instance,\n            \u0026QueryMsg::Allocations {\n                start_after: Some(\"investor_1\".to_string()),\n                limit: None,\n            },\n        )\n        .unwrap();\n    let comparing_values: Vec\u003c(Addr, AllocationParams)\u003e = vec![(\n        Addr::unchecked(\"team_1\"),\n        AllocationParams {\n            amount: Uint128::new(5000000000000),\n            unlock_schedule: Schedule {\n                start_time: 1642402284u64,\n                cliff: 8776000u64,\n                duration: 31536001u64,\n            },\n            proposed_receiver: None,\n        },\n    )];\n    assert_eq!(comparing_values, resp);\n}\n\nfn check_allocation(\n    app: \u0026mut App,\n    unlock_instance: \u0026Addr,\n    account: String,\n    total_amount: Uint128,\n    astro_withdrawn: Uint128,\n    unlock_schedule: Schedule,\n) -\u003e StdResult\u003c()\u003e {\n    let resp: AllocationResponse = app\n        .wrap()\n        .query_wasm_smart(unlock_instance, \u0026QueryMsg::Allocation { account })\n        .unwrap();\n    assert_eq!(resp.params.amount, total_amount);\n    assert_eq!(resp.status.astro_withdrawn, astro_withdrawn);\n    assert_eq!(resp.params.unlock_schedule, unlock_schedule);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","escrow_fee_distributor","examples","escrow_fee_distributor_schema.rs"],"content":"use astroport_governance::escrow_fee_distributor::{\n    ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg,\n};\nuse cosmwasm_schema::write_api;\n\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        query: QueryMsg,\n        execute: ExecuteMsg,\n        migrate: MigrateMsg\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","escrow_fee_distributor","src","contract.rs"],"content":"use astroport::common::{claim_ownership, drop_ownership_proposal, propose_new_owner};\nuse cosmwasm_std::{\n    attr, entry_point, to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Order, Response,\n    StdError, StdResult, Uint128,\n};\nuse cw2::set_contract_version;\nuse cw20::Cw20ReceiveMsg;\nuse cw_storage_plus::Bound;\n\nuse astroport_governance::escrow_fee_distributor::{\n    ConfigResponse, ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg,\n};\nuse astroport_governance::utils::{get_period, CLAIM_LIMIT, MIN_CLAIM_LIMIT};\nuse astroport_governance::voting_escrow::{get_total_voting_power_at, get_voting_power_at};\n\nuse crate::astroport;\nuse crate::astroport::asset::addr_opt_validate;\nuse crate::error::ContractError;\nuse crate::state::{Config, CONFIG, OWNERSHIP_PROPOSAL, REWARDS_PER_WEEK};\nuse crate::utils::{calc_claim_amount, calculate_reward, transfer_token_amount};\n\n/// Contract name that is used for migration.\nconst CONTRACT_NAME: \u0026str = \"astroport-escrow-fee-distributor\";\n/// Contract version that is used for migration.\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Creates a new contract with the specified parameters in the [`InstantiateMsg`].\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    if let Some(claim_many_limit) = msg.claim_many_limit {\n        if claim_many_limit \u003c MIN_CLAIM_LIMIT {\n            return Err(StdError::generic_err(format!(\n                \"Accounts limit for claim operation cannot be less than {MIN_CLAIM_LIMIT} !\"\n            )));\n        }\n    }\n\n    CONFIG.save(\n        deps.storage,\n        \u0026Config {\n            owner: deps.api.addr_validate(\u0026msg.owner)?,\n            astro_token: deps.api.addr_validate(\u0026msg.astro_token)?,\n            voting_escrow_addr: deps.api.addr_validate(\u0026msg.voting_escrow_addr)?,\n            is_claim_disabled: msg.is_claim_disabled.unwrap_or(false),\n            claim_many_limit: msg.claim_many_limit.unwrap_or(CLAIM_LIMIT),\n        },\n    )?;\n\n    Ok(Response::new())\n}\n\n/// Exposes all the execute functions available in the contract.\n///\n/// ## Execute messages\n/// * **ExecuteMsg::ProposeNewOwner { owner, expires_in }** Creates a request to change contract ownership.\n///\n/// * **ExecuteMsg::DropOwnershipProposal {}** Removes a request to change contract ownership.\n///\n/// * **ExecuteMsg::ClaimOwnership {}** Claims contract ownership.\n///\n/// * **ExecuteMsg::Claim { recipient }** Claims ASTRO fees from the distributor and sends them to the recipient.\n///\n/// * **ExecuteMsg::ClaimMany { receivers }** Perform multiple fee claims in a single transaction.\n///\n/// * **ExecuteMsg::Receive(msg)** Parse incoming messages from the ASTRO token.\n///\n/// * **ExecuteMsg::UpdateConfig { claim_many_limit, is_claim_disabled}** Updates general settings.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config: Config = CONFIG.load(deps.storage)?;\n    match msg {\n        ExecuteMsg::ProposeNewOwner { owner, expires_in } =\u003e propose_new_owner(\n            deps,\n            info,\n            env,\n            owner,\n            expires_in,\n            config.owner,\n            OWNERSHIP_PROPOSAL,\n        )\n        .map_err(Into::into),\n        ExecuteMsg::DropOwnershipProposal {} =\u003e {\n            drop_ownership_proposal(deps, info, config.owner, OWNERSHIP_PROPOSAL)\n                .map_err(Into::into)\n        }\n        ExecuteMsg::ClaimOwnership {} =\u003e {\n            claim_ownership(deps, info, env, OWNERSHIP_PROPOSAL, |deps, new_owner| {\n                CONFIG\n                    .update::\u003c_, StdError\u003e(deps.storage, |mut v| {\n                        v.owner = new_owner;\n                        Ok(v)\n                    })\n                    .map(|_| ())\n            })\n            .map_err(Into::into)\n        }\n        ExecuteMsg::Claim {\n            recipient,\n            max_periods,\n        } =\u003e claim(deps, env, info, recipient, max_periods),\n        ExecuteMsg::ClaimMany { receivers } =\u003e claim_many(deps, env, receivers),\n        ExecuteMsg::UpdateConfig {\n            claim_many_limit,\n            is_claim_disabled,\n        } =\u003e update_config(deps, info, claim_many_limit, is_claim_disabled),\n        ExecuteMsg::Receive(msg) =\u003e receive_cw20(deps, env, info, msg),\n    }\n}\n\n/// Receives a message of type [`Cw20ReceiveMsg`] and processes it depending on the received template.\n///\n/// * **cw20_msg** CW20 message to process.\nfn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config: Config = CONFIG.load(deps.storage)?;\n    if info.sender != config.astro_token {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let curr_period = get_period(env.block.time.seconds())?;\n\n    REWARDS_PER_WEEK.update(deps.storage, curr_period, |period| -\u003e StdResult\u003c_\u003e {\n        if let Some(tokens_amount) = period {\n            Ok(tokens_amount.checked_add(cw20_msg.amount)?)\n        } else {\n            Ok(cw20_msg.amount)\n        }\n    })?;\n\n    Ok(Response::new())\n}\n\n/// Claims ASTRO staking rewards from this contract and sends them to the `recipient`.\n///\n/// * **recipient** address that will receive the ASTRO staking rewards.\npub fn claim(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    recipient: Option\u003cString\u003e,\n    max_periods: Option\u003cu64\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    if config.is_claim_disabled {\n        return Err(ContractError::ClaimDisabled {});\n    }\n\n    let recipient_addr =\n        addr_opt_validate(deps.api, \u0026recipient)?.unwrap_or_else(|| info.sender.clone());\n    let current_period = get_period(env.block.time.seconds())?;\n\n    let claim_amount = calc_claim_amount(\n        deps,\n        current_period,\n        \u0026info.sender,\n        \u0026config.voting_escrow_addr,\n        max_periods,\n    )?;\n\n    let transfer_msg = transfer_token_amount(\u0026config.astro_token, \u0026recipient_addr, claim_amount)?;\n\n    let response = Response::new()\n        .add_attributes(vec![\n            attr(\"action\", \"claim\"),\n            attr(\"address\", recipient_addr.to_string()),\n            attr(\"amount\", claim_amount.to_string()),\n        ])\n        .add_messages(transfer_msg);\n\n    Ok(response)\n}\n\n/// Make multiple ASTRO fee claims in a single call.\n///\n/// * **receivers** list of addresses that will receive the claimed ASTRO.\nfn claim_many(\n    mut deps: DepsMut,\n    env: Env,\n    receivers: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    if config.is_claim_disabled {\n        return Err(ContractError::ClaimDisabled {});\n    }\n\n    if receivers.len() \u003e config.claim_many_limit as usize {\n        return Err(ContractError::ClaimLimitExceeded {});\n    }\n\n    let mut claim_total_amount = Uint128::zero();\n    let mut transfer_msg = vec![];\n    let current_period = get_period(env.block.time.seconds())?;\n\n    for receiver in receivers {\n        let receiver_addr = deps.api.addr_validate(\u0026receiver)?;\n        let claim_amount = calc_claim_amount(\n            deps.branch(),\n            current_period,\n            \u0026receiver_addr,\n            \u0026config.voting_escrow_addr,\n            None,\n        )?;\n\n        if !claim_amount.is_zero() {\n            transfer_msg.extend(transfer_token_amount(\n                \u0026config.astro_token,\n                \u0026receiver_addr,\n                claim_amount,\n            )?);\n            claim_total_amount = claim_total_amount.checked_add(claim_amount)?;\n        };\n    }\n\n    let response = Response::new()\n        .add_attributes(vec![\n            attr(\"action\", \"claim_many\"),\n            attr(\"amount\", claim_total_amount.to_string()),\n        ])\n        .add_messages(transfer_msg);\n\n    Ok(response)\n}\n\n/// Updates general contract settings.\n///\n/// * **claim_many_limit** max amount of rewards slots to claim in one transaction.\n///\n/// * **is_claim_disabled** whether reward claims are disabled or not.\nfn update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    claim_many_limit: Option\u003cu64\u003e,\n    is_claim_disabled: Option\u003cbool\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let mut attributes = vec![attr(\"action\", \"update_config\")];\n\n    if let Some(is_claim_disabled) = is_claim_disabled {\n        if config.is_claim_disabled == is_claim_disabled {\n            return Err(ContractError::Std(StdError::generic_err(format!(\n                \"Parameter is_claim_disabled is already {}!\",\n                config.is_claim_disabled\n            ))));\n        }\n        config.is_claim_disabled = is_claim_disabled;\n        attributes.push(attr(\"is_claim_disabled\", is_claim_disabled.to_string()));\n    };\n\n    if let Some(claim_many_limit) = claim_many_limit {\n        if claim_many_limit \u003c MIN_CLAIM_LIMIT {\n            return Err(StdError::generic_err(format!(\n                \"Accounts limit for claim operation cannot be less than {MIN_CLAIM_LIMIT} !\"\n            ))\n            .into());\n        }\n\n        config.claim_many_limit = claim_many_limit;\n        attributes.push(attr(\"claim_many_limit\", claim_many_limit.to_string()));\n    };\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::new().add_attributes(attributes))\n}\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::UserReward { user, timestamp }** Returns the amount of ASTRO rewards a user can claim at a specific timestamp.\n///\n/// * **QueryMsg::Config {}** Returns the contract configuration.\n///\n/// * **QueryMsg::AvailableRewardPerWeek { start_after, limit }** Returns a vector with total amounts\n/// of ASTRO distributed as rewards every week to stakers.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::UserReward { user, timestamp } =\u003e {\n            to_binary(\u0026query_user_reward(deps, user, timestamp)?)\n        }\n        QueryMsg::Config {} =\u003e to_binary(\u0026query_config(deps)?),\n        QueryMsg::AvailableRewardPerWeek { start_after, limit } =\u003e {\n            to_binary(\u0026query_available_reward_per_week(deps, start_after, limit)?)\n        }\n    }\n}\n\n/// Pagination settings\n/// The maximum limit for reading pairs from [`PAIRS`].\nconst MAX_LIMIT: u64 = 30;\n\n/// The default limit for reading pairs from [`PAIRS`].\nconst DEFAULT_LIMIT: u64 = 10;\n\n/// Returns a vector of weekly rewards for current vxASTRO stakers.\n///\n/// * **start_after** timestamp from which to start querying.\n///\n/// * **limit** max amount of entries to return.\nfn query_available_reward_per_week(\n    deps: Deps,\n    start_after: Option\u003cu64\u003e,\n    limit: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cVec\u003cUint128\u003e\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = if let Some(timestamp) = start_after {\n        Some(Bound::exclusive(get_period(timestamp)?))\n    } else {\n        None\n    };\n\n    REWARDS_PER_WEEK\n        .range(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|week| Ok(week?.1))\n        .collect()\n}\n\n/// Returns the amount of rewards a user accrued at a specific timestamp.\n///\n/// * **user** user for which we return the amount of rewards.\n///\n/// * **timestamp** timestamp at which we fetch the user's reward amount.\nfn query_user_reward(deps: Deps, user: String, timestamp: u64) -\u003e StdResult\u003cUint128\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    let user_voting_power =\n        get_voting_power_at(\u0026deps.querier, \u0026config.voting_escrow_addr, user, timestamp)?;\n    let total_voting_power =\n        get_total_voting_power_at(\u0026deps.querier, \u0026config.voting_escrow_addr, timestamp)?;\n\n    if !total_voting_power.is_zero() {\n        let current_period = get_period(timestamp)?;\n        calculate_reward(\n            deps.storage,\n            current_period,\n            user_voting_power,\n            total_voting_power,\n        )\n    } else {\n        Ok(Uint128::zero())\n    }\n}\n\n/// Returns the contract configuration.\npub fn query_config(deps: Deps) -\u003e StdResult\u003cConfigResponse\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    let resp = ConfigResponse {\n        owner: config.owner,\n        astro_token: config.astro_token,\n        voting_escrow_addr: config.voting_escrow_addr,\n        is_claim_disabled: config.is_claim_disabled,\n        claim_many_limit: config.claim_many_limit,\n    };\n\n    Ok(resp)\n}\n\n/// Manages contract migration.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    Err(ContractError::MigrationError {})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","escrow_fee_distributor","src","error.rs"],"content":"use cosmwasm_std::{OverflowError, StdError};\nuse thiserror::Error;\n\n/// ## Description\n/// This enum describes fee distributor contract errors!\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Exceeded account limit for the claim operation!\")]\n    ClaimLimitExceeded {},\n\n    #[error(\"Claiming is disabled!\")]\n    ClaimDisabled {},\n\n    #[error(\"Contract can't be migrated!\")]\n    MigrationError {},\n}\n\nimpl From\u003cOverflowError\u003e for ContractError {\n    fn from(o: OverflowError) -\u003e Self {\n        StdError::from(o).into()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","escrow_fee_distributor","src","lib.rs"],"content":"pub mod contract;\nmod error;\npub mod state;\nmod utils;\n\n// During development this import could be replaced with another astroport version.\n// However, in production, the astroport version should be the same for all contracts.\nuse astroport_governance::astroport;\n\n#[cfg(test)]\nmod testing;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","escrow_fee_distributor","src","state.rs"],"content":"use cosmwasm_schema::cw_serde;\n\nuse crate::astroport::common::OwnershipProposal;\n\nuse cosmwasm_std::{Addr, Uint128};\nuse cw_storage_plus::{Item, Map};\n\n/// This structure stores the main parameters for the distributor contract.\n#[cw_serde]\npub struct Config {\n    /// Address that's allowed to change contract parameters\n    pub owner: Addr,\n    /// ASTRO token address\n    pub astro_token: Addr,\n    /// vxASTRO contract address\n    pub voting_escrow_addr: Addr,\n    /// Max limit of addresses that can claim rewards in a single call\n    pub claim_many_limit: u64,\n    /// Whether reward claiming is disabled\n    pub is_claim_disabled: bool,\n}\n\n/// Stores the contract config at the given key.\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n/// Contains information about weekly distributed rewards.\npub const REWARDS_PER_WEEK: Map\u003cu64, Uint128\u003e = Map::new(\"rewards_per_week\");\n/// Contains information about the last week of reward issuance.\npub const LAST_CLAIM_PERIOD: Map\u003c\u0026Addr, u64\u003e = Map::new(\"last_claim_period\");\n/// Contains the proposal to change contract ownership.\npub const OWNERSHIP_PROPOSAL: Item\u003cOwnershipProposal\u003e = Item::new(\"ownership_proposal\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","escrow_fee_distributor","src","testing.rs"],"content":"use crate::contract::{instantiate, query};\nuse astroport_governance::escrow_fee_distributor::{ConfigResponse, InstantiateMsg, QueryMsg};\n\nuse cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};\nuse cosmwasm_std::{from_binary, Addr};\n\n#[test]\nfn proper_initialization() {\n    let mut deps = mock_dependencies();\n\n    let msg = InstantiateMsg {\n        owner: \"owner\".to_string(),\n        astro_token: \"token\".to_string(),\n        voting_escrow_addr: \"voting_escrow\".to_string(),\n        claim_many_limit: None,\n        is_claim_disabled: None,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026vec![]);\n    let _res = instantiate(deps.as_mut(), env.clone(), info, msg).unwrap();\n\n    assert_eq!(\n        from_binary::\u003cConfigResponse\u003e(\u0026query(deps.as_ref(), env, QueryMsg::Config {}).unwrap())\n            .unwrap(),\n        ConfigResponse {\n            owner: Addr::unchecked(\"owner\"),\n            astro_token: Addr::unchecked(\"token\"),\n            voting_escrow_addr: Addr::unchecked(\"voting_escrow\"),\n            claim_many_limit: 10,\n            is_claim_disabled: false\n        }\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","escrow_fee_distributor","src","utils.rs"],"content":"use std::cmp::min;\n\nuse cosmwasm_std::{\n    to_binary, Addr, CosmosMsg, DepsMut, StdError, StdResult, Storage, Uint128, WasmMsg,\n};\nuse cw20::Cw20ExecuteMsg;\n\nuse astroport_governance::voting_escrow::{\n    get_lock_info, QueryMsg as VotingQueryMsg, VotingPowerResponse, DEFAULT_PERIODS_LIMIT,\n};\n\nuse crate::error::ContractError;\nuse crate::state::{LAST_CLAIM_PERIOD, REWARDS_PER_WEEK};\n\n/// Transfer tokens to another address.\n///\n/// * **contract_addr** address of the token contract.\n///\n/// * **recipient** address of the token recipient.\n///\n/// * **amount** token amount to transfer.\npub(crate) fn transfer_token_amount(\n    contract_addr: \u0026Addr,\n    recipient: \u0026Addr,\n    amount: Uint128,\n) -\u003e Result\u003cVec\u003cCosmosMsg\u003e, ContractError\u003e {\n    let messages = if !amount.is_zero() {\n        vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: contract_addr.to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                recipient: recipient.to_string(),\n                amount,\n            })?,\n            funds: vec![],\n        })]\n    } else {\n        vec![]\n    };\n\n    Ok(messages)\n}\n\n/// Returns the amount of rewards distributed to a user for a specific period.\n///\n/// * **period** period for which we calculate the user's reward.\n///\n/// * **user_vp** user's voting power for the specified period.\n///\n/// * **total_vp** total voting power for the specified period.\npub(crate) fn calculate_reward(\n    storage: \u0026dyn Storage,\n    period: u64,\n    user_vp: Uint128,\n    total_vp: Uint128,\n) -\u003e StdResult\u003cUint128\u003e {\n    let rewards_per_week = REWARDS_PER_WEEK\n        .may_load(storage, period)?\n        .unwrap_or_default();\n\n    user_vp\n        .checked_multiply_ratio(rewards_per_week, total_vp)\n        .map_err(|e| StdError::generic_err(format!(\"{e:?}\")))\n}\n\n/// Calculates the amount of ASTRO available to claim by a specific address.\n///\n/// * **current_period** current epoch number.\n///\n/// * **account** account for which we calculate the amount of ASTRO rewards available to claim.\n///\n/// * **voting_escrow_addr** vxASTRO contract address.\n///\n/// * **max_periods** maximum number of periods to claim.\npub(crate) fn calc_claim_amount(\n    deps: DepsMut,\n    current_period: u64,\n    account: \u0026Addr,\n    voting_escrow_addr: \u0026Addr,\n    max_periods: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let user_lock_info = get_lock_info(\u0026deps.querier, voting_escrow_addr, account)?;\n\n    let mut claim_period = LAST_CLAIM_PERIOD\n        .may_load(deps.storage, account)?\n        .unwrap_or(user_lock_info.start);\n\n    let lock_end_period = user_lock_info.end;\n    let mut claim_amount: Uint128 = Default::default();\n    let max_period = min(\n        max_periods.unwrap_or(DEFAULT_PERIODS_LIMIT) + claim_period,\n        current_period,\n    );\n\n    loop {\n        // User cannot claim for the current period/\n        if claim_period \u003e= max_period {\n            break;\n        }\n\n        // User cannot claim after their max lock period\n        if claim_period \u003e lock_end_period {\n            break;\n        }\n\n        let user_voting_power: VotingPowerResponse = deps.querier.query_wasm_smart(\n            voting_escrow_addr,\n            \u0026VotingQueryMsg::UserVotingPowerAtPeriod {\n                user: account.to_string(),\n                period: claim_period,\n            },\n        )?;\n\n        let total_voting_power: VotingPowerResponse = deps.querier.query_wasm_smart(\n            voting_escrow_addr,\n            \u0026VotingQueryMsg::TotalVotingPowerAtPeriod {\n                period: claim_period,\n            },\n        )?;\n\n        if !user_voting_power.voting_power.is_zero() \u0026\u0026 !total_voting_power.voting_power.is_zero() {\n            claim_amount = claim_amount.checked_add(calculate_reward(\n                deps.storage,\n                claim_period,\n                user_voting_power.voting_power,\n                total_voting_power.voting_power,\n            )?)?;\n        }\n\n        claim_period += 1;\n    }\n\n    LAST_CLAIM_PERIOD.save(deps.storage, account, \u0026claim_period)?;\n\n    Ok(claim_amount)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","escrow_fee_distributor","tests","integration.rs"],"content":"use cosmwasm_std::testing::{mock_env, MockApi, MockStorage};\nuse cosmwasm_std::{attr, to_binary, Addr, StdResult, Timestamp, Uint128};\n\nuse astroport_governance::utils::{get_period, EPOCH_START, WEEK};\n\nuse astroport_governance::escrow_fee_distributor::{\n    ConfigResponse, Cw20HookMsg, ExecuteMsg, QueryMsg,\n};\nuse astroport_governance::voting_escrow::{\n    LockInfoResponse, QueryMsg as VotingEscrowQueryMsg, VotingPowerResponse,\n};\n\nuse astroport_tests::base::{\n    check_balance, mint, BaseAstroportTestInitMessage, BaseAstroportTestPackage, MULTIPLIER,\n};\nuse cw20::Cw20ExecuteMsg;\nuse cw_multi_test::{next_block, App, AppBuilder, BankKeeper, Executor};\n\nconst OWNER: \u0026str = \"owner\";\nconst USER1: \u0026str = \"user1\";\nconst USER2: \u0026str = \"user2\";\nconst USER3: \u0026str = \"user3\";\nconst USER4: \u0026str = \"user4\";\nconst USER5: \u0026str = \"user5\";\nconst MAKER: \u0026str = \"maker\";\n\nfn mock_app() -\u003e App {\n    let mut env = mock_env();\n    env.block.time = Timestamp::from_seconds(EPOCH_START);\n    let api = MockApi::default();\n    let bank = BankKeeper::new();\n    let storage = MockStorage::new();\n\n    AppBuilder::new()\n        .with_api(api)\n        .with_block(env.block)\n        .with_bank(bank)\n        .with_storage(storage)\n        .build(|_, _, _| {})\n}\n\nfn init_astroport_test_package(router: \u0026mut App) -\u003e StdResult\u003cBaseAstroportTestPackage\u003e {\n    let base_msg = BaseAstroportTestInitMessage {\n        owner: Addr::unchecked(OWNER),\n    };\n\n    Ok(BaseAstroportTestPackage::init_all(router, base_msg))\n}\n\n#[test]\nfn instantiation() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(OWNER);\n\n    let base_pack = init_astroport_test_package(router_ref).unwrap();\n\n    let resp: ConfigResponse = router\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026QueryMsg::Config {},\n        )\n        .unwrap();\n\n    assert_eq!(owner, resp.owner);\n    assert_eq!(base_pack.astro_token.unwrap().address, resp.astro_token);\n    assert_eq!(\n        base_pack.voting_escrow.unwrap().address,\n        resp.voting_escrow_addr\n    );\n    assert_eq!(false, resp.is_claim_disabled);\n    assert_eq!(10u64, resp.claim_many_limit);\n}\n\n#[test]\nfn test_receive_tokens() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(OWNER.clone());\n    let maker = Addr::unchecked(MAKER.clone());\n\n    let base_pack = init_astroport_test_package(router_ref).unwrap();\n\n    // Mint 1000_000_000 ASTRO for the Maker\n    mint(\n        router_ref,\n        owner.clone(),\n        base_pack.astro_token.clone().unwrap().address,\n        \u0026maker,\n        1000,\n    );\n\n    // Check if Maker's ASTRO balance is 1000_000_000\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026maker,\n        1000 * MULTIPLIER as u128,\n    );\n\n    // Check if escrow_fee_distributor ASTRO balance is 0\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        0u128,\n    );\n\n    // Try to send 100_000_000 ASTRO from Maker to distributor\n    let msg = Cw20ExecuteMsg::Send {\n        contract: base_pack\n            .escrow_fee_distributor\n            .clone()\n            .unwrap()\n            .address\n            .to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::ReceiveTokens {}).unwrap(),\n        amount: Uint128::from(100 * MULTIPLIER as u128),\n    };\n\n    router_ref\n        .execute_contract(\n            maker.clone(),\n            base_pack.astro_token.clone().unwrap().address,\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Sends 100_000_000 ASTRO from Maker to distributor for the next 5 weeks\n    for _i in 0..5 {\n        router_ref\n            .execute_contract(\n                maker.clone(),\n                base_pack.astro_token.clone().unwrap().address,\n                \u0026msg,\n                \u0026[],\n            )\n            .unwrap();\n\n        // Going to the next week\n        router_ref.update_block(next_block);\n        router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n    }\n\n    // Check if escrow_fee_distributor's ASTRO balance is equal to 600_000_000\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        600 * MULTIPLIER as u128,\n    );\n\n    // Check if Maker's ASTRO balance is equal to 400_000_000\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026maker.clone(),\n        400 * MULTIPLIER as u128,\n    );\n\n    // Checks rewards per week\n    let resp: Vec\u003cUint128\u003e = router_ref\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026QueryMsg::AvailableRewardPerWeek {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        vec![\n            Uint128::new(200_000_000),\n            Uint128::new(100_000_000),\n            Uint128::new(100_000_000),\n            Uint128::new(100_000_000),\n            Uint128::new(100_000_000),\n        ],\n        resp\n    );\n}\n\n#[test]\nfn update_config() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(OWNER.clone());\n    let user1 = Addr::unchecked(USER1.clone());\n\n    let base_pack = init_astroport_test_package(router_ref).unwrap();\n    let escrow_fee_distributor = base_pack.escrow_fee_distributor.unwrap().address;\n\n    let resp: ConfigResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\u0026escrow_fee_distributor.clone(), \u0026QueryMsg::Config {})\n        .unwrap();\n\n    assert_eq!(10u64, resp.claim_many_limit);\n    assert_eq!(false, resp.is_claim_disabled);\n\n    // Check if a random address can update the config\n    let err = router_ref\n        .execute_contract(\n            user1.clone(),\n            escrow_fee_distributor.clone(),\n            \u0026ExecuteMsg::UpdateConfig {\n                claim_many_limit: Some(20u64),\n                is_claim_disabled: Some(true),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\"Unauthorized\", err.root_cause().to_string());\n\n    // Check that the owner can update the config\n    let resp = router_ref\n        .execute_contract(\n            owner.clone(),\n            escrow_fee_distributor.clone(),\n            \u0026ExecuteMsg::UpdateConfig {\n                claim_many_limit: Some(20u64),\n                is_claim_disabled: Some(true),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    let resp_config: ConfigResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\u0026escrow_fee_distributor.clone(), \u0026QueryMsg::Config {})\n        .unwrap();\n\n    assert_eq!(20u64, resp_config.claim_many_limit);\n    assert_eq!(true, resp_config.is_claim_disabled);\n\n    assert_eq!(\n        vec![\n            attr(\"action\", \"update_config\"),\n            attr(\"is_claim_disabled\", \"true\"),\n            attr(\"claim_many_limit\", \"20\"),\n        ],\n        vec![\n            resp.events[1].attributes[1].clone(),\n            resp.events[1].attributes[2].clone(),\n            resp.events[1].attributes[3].clone(),\n        ]\n    );\n}\n\n#[test]\nfn check_if_user_exists_after_withdraw() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let user1 = Addr::unchecked(USER1.clone());\n\n    let base_pack = init_astroport_test_package(router_ref).unwrap();\n    let xastro_token = base_pack.get_staking_xastro(router_ref);\n\n    // Send 200_000_000 xASTRO tokens to user1\n    mint(\n        router_ref,\n        base_pack.staking.clone().unwrap().address,\n        xastro_token.clone(),\n        \u0026user1,\n        200,\n    );\n\n    // Create lock for user1 for WEEK\n    base_pack\n        .create_lock(router_ref, user1.clone(), WEEK, 200)\n        .unwrap();\n\n    // Going to the last week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n\n    let resp: LockInfoResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.voting_escrow.clone().unwrap().address,\n            \u0026VotingEscrowQueryMsg::LockInfo {\n                user: user1.to_string(),\n            },\n        )\n        .unwrap();\n\n    assert_eq!(Uint128::new(200_000_000), resp.amount);\n    assert_eq!(\n        get_period(router_ref.block_info().time.seconds() - WEEK).unwrap(),\n        resp.start\n    );\n    assert_eq!(\n        get_period(router_ref.block_info().time.seconds()).unwrap(),\n        resp.end\n    );\n\n    base_pack.withdraw(router_ref, user1.as_str()).unwrap();\n\n    let resp: LockInfoResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.voting_escrow.clone().unwrap().address,\n            \u0026VotingEscrowQueryMsg::LockInfo {\n                user: user1.to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(resp.amount, Uint128::zero());\n    assert_eq!(\n        resp.start,\n        get_period(router_ref.block_info().time.minus_seconds(WEEK).seconds()).unwrap()\n    );\n    assert_eq!(\n        resp.end,\n        get_period(router_ref.block_info().time.seconds()).unwrap()\n    );\n}\n\n#[test]\nfn claim_without_fee_on_distributor() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let user1 = Addr::unchecked(USER1.clone());\n    let user2 = Addr::unchecked(USER2.clone());\n\n    let base_pack = init_astroport_test_package(router_ref).unwrap();\n\n    let xastro_token = base_pack.get_staking_xastro(router_ref);\n\n    // Sets 200_000_000 xASTRO tokens to user1\n    mint(\n        router_ref,\n        base_pack.staking.clone().unwrap().address,\n        xastro_token.clone(),\n        \u0026user1,\n        200,\n    );\n\n    // Send 200_000_000 xASTRO tokens to user2\n    mint(\n        router_ref,\n        base_pack.staking.clone().unwrap().address,\n        xastro_token.clone(),\n        \u0026user2,\n        200,\n    );\n\n    // Create lock for user1 for WEEK * 104\n    base_pack\n        .create_lock(router_ref, user1.clone(), WEEK * 104, 200)\n        .unwrap();\n\n    // Create lock for user2 for WEEK * 104\n    base_pack\n        .create_lock(router_ref, user2.clone(), WEEK * 104, 200)\n        .unwrap();\n\n    // Going to the last week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK * 103));\n\n    // Try to claim fees for user1\n    router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::Claim {\n                recipient: None,\n                max_periods: None,\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Try to claim fees for user2\n    router_ref\n        .execute_contract(\n            user2.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::Claim {\n                recipient: None,\n                max_periods: None,\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Check if user1's ASTRO balance is equal to 0\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026user1,\n        0,\n    );\n\n    // Check if user2's ASTRO balance is equal to 0\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026user2,\n        0,\n    );\n}\n\n#[test]\nfn claim_max_period() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(OWNER.clone());\n    let maker = Addr::unchecked(MAKER.clone());\n    let user1 = Addr::unchecked(USER1.clone());\n    let user2 = Addr::unchecked(USER2.clone());\n\n    let base_pack = init_astroport_test_package(router_ref).unwrap();\n\n    let xastro_token = base_pack.get_staking_xastro(router_ref);\n\n    // Send 200_000_000 xASTRO tokens to user1\n    mint(\n        router_ref,\n        base_pack.staking.clone().unwrap().address,\n        xastro_token.clone(),\n        \u0026user1,\n        200,\n    );\n\n    // Send 200_000_000 xASTRO tokens to user2\n    mint(\n        router_ref,\n        base_pack.staking.clone().unwrap().address,\n        xastro_token.clone(),\n        \u0026user2,\n        200,\n    );\n\n    // Create lock for user1 for WEEK * 104\n    base_pack\n        .create_lock(router_ref, user1.clone(), WEEK * 104, 200)\n        .unwrap();\n\n    // Create lock for user2 for WEEK * 104\n    base_pack\n        .create_lock(router_ref, user2.clone(), WEEK * 104, 200)\n        .unwrap();\n\n    // Mint 100_000_000 ASTRO for the Maker\n    mint(\n        router_ref,\n        owner.clone(),\n        base_pack.astro_token.clone().unwrap().address,\n        \u0026maker,\n        100,\n    );\n\n    // Try to send 100_000_000 ASTRO from Maker to distributor for the first period\n    let msg = Cw20ExecuteMsg::Send {\n        contract: base_pack\n            .escrow_fee_distributor\n            .clone()\n            .unwrap()\n            .address\n            .to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::ReceiveTokens {}).unwrap(),\n        amount: Uint128::from(100 * MULTIPLIER as u128),\n    };\n\n    router_ref\n        .execute_contract(\n            maker.clone(),\n            base_pack.astro_token.clone().unwrap().address,\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Going to the next week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n\n    // Mint 100_000_000 ASTRO for the Maker\n    mint(\n        router_ref,\n        owner.clone(),\n        base_pack.astro_token.clone().unwrap().address,\n        \u0026maker,\n        100,\n    );\n\n    // Try to send 100_000_000 ASTRO from Maker to distributor for the second period\n    let msg = Cw20ExecuteMsg::Send {\n        contract: base_pack\n            .escrow_fee_distributor\n            .clone()\n            .unwrap()\n            .address\n            .to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::ReceiveTokens {}).unwrap(),\n        amount: Uint128::from(100 * MULTIPLIER as u128),\n    };\n\n    router_ref\n        .execute_contract(\n            maker.clone(),\n            base_pack.astro_token.clone().unwrap().address,\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Warping to the week after user's lock period ends\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK * 105));\n\n    // Check if rewards for the first and the second weeks equal 100_000_000 ASTRO\n    let resp: Vec\u003cUint128\u003e = router_ref\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026QueryMsg::AvailableRewardPerWeek {\n                start_after: None,\n                limit: Some(2),\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        vec![Uint128::new(100_000_000), Uint128::new(100_000_000)],\n        resp\n    );\n\n    // Claim fees for max period for user1(firstly 1 period)\n    router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::Claim {\n                recipient: None,\n                max_periods: Some(1),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026user1,\n        50_000_000,\n    );\n\n    router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::Claim {\n                recipient: None,\n                max_periods: None,\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Claim fees for max period for user2\n    router_ref\n        .execute_contract(\n            user2.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::Claim {\n                recipient: None,\n                max_periods: None,\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Check if user1's ASTRO balance is equal to 100_000_000 ASTRO\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026user1,\n        100_000_000,\n    );\n\n    // Check if user2's ASTRO balance equal to 100_000_000 ASTRO\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026user2,\n        100_000_000,\n    );\n\n    // Check if distributor's ASTRO balance equal to 0\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        0,\n    );\n}\n\n#[test]\nfn claim_multiple_users() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(OWNER.clone());\n    let maker = Addr::unchecked(MAKER.clone());\n    let user1 = Addr::unchecked(USER1.clone());\n    let user2 = Addr::unchecked(USER2.clone());\n    let user3 = Addr::unchecked(USER3.clone());\n    let user4 = Addr::unchecked(USER4.clone());\n    let user5 = Addr::unchecked(USER5.clone());\n\n    let base_pack = init_astroport_test_package(router_ref).unwrap();\n\n    let xastro_token = base_pack.get_staking_xastro(router_ref);\n\n    for user in [user1.clone(), user2.clone(), user3.clone(), user4.clone()] {\n        // Sends 200_000_000 xASTRO tokens to users\n        mint(\n            router_ref,\n            base_pack.staking.clone().unwrap().address,\n            xastro_token.clone(),\n            \u0026user,\n            200,\n        );\n\n        // Checks if user's xASTRO balance is equal to 200 * 1000_000 ASTRO\n        check_balance(\n            router_ref,\n            \u0026xastro_token.clone(),\n            \u0026user,\n            200 * MULTIPLIER as u128,\n        );\n\n        // Create lock for user for WEEK * 2\n        base_pack\n            .create_lock(router_ref, user.clone(), WEEK * 2, 100)\n            .unwrap();\n    }\n\n    mint(\n        router_ref,\n        owner.clone(),\n        base_pack.astro_token.clone().unwrap().address,\n        \u0026maker,\n        1000,\n    );\n\n    // Sends 100_000_000 ASTRO from Maker to distributor for the first period\n    let msg = Cw20ExecuteMsg::Send {\n        contract: base_pack\n            .escrow_fee_distributor\n            .clone()\n            .unwrap()\n            .address\n            .to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::ReceiveTokens {}).unwrap(),\n        amount: Uint128::from(100 * MULTIPLIER as u128),\n    };\n\n    router_ref\n        .execute_contract(\n            maker.clone(),\n            base_pack.astro_token.clone().unwrap().address,\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Checks if distributor's ASTRO balance is equal to 100_000_000 ASTRO\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        100 * MULTIPLIER as u128,\n    );\n\n    // Check if rewards per week are set to 100_000_000 ASTRO\n    let resp: Vec\u003cUint128\u003e = router_ref\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026QueryMsg::AvailableRewardPerWeek {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n    assert_eq!(vec![Uint128::new(100_000_000)], resp);\n\n    // Check if weekly voting supply can be queried\n    let resp: VotingPowerResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.voting_escrow.clone().unwrap().address,\n            \u0026VotingEscrowQueryMsg::TotalVotingPowerAt {\n                time: router_ref.block_info().time.seconds(),\n            },\n        )\n        .unwrap();\n    assert_eq!(Uint128::new(411_538_456), resp.voting_power);\n\n    // Go to the next week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n\n    // Perform an operation for an unlimited number of users\n    let err = router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::ClaimMany {\n                receivers: vec![\n                    user1.to_string(),\n                    user2.to_string(),\n                    user3.to_string(),\n                    user4.to_string(),\n                    Addr::unchecked(\"user5\").to_string(),\n                    Addr::unchecked(\"user6\").to_string(),\n                    Addr::unchecked(\"user7\").to_string(),\n                    Addr::unchecked(\"user8\").to_string(),\n                    Addr::unchecked(\"user9\").to_string(),\n                    Addr::unchecked(\"user10\").to_string(),\n                    Addr::unchecked(\"user11\").to_string(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        \"Exceeded account limit for the claim operation!\",\n        err.root_cause().to_string()\n    );\n\n    mint(\n        router_ref,\n        base_pack.staking.clone().unwrap().address,\n        xastro_token.clone(),\n        \u0026user5,\n        200,\n    );\n\n    // Check if user5's xASTRO balance is equal to 200 * 1000_000\n    check_balance(\n        router_ref,\n        \u0026xastro_token.clone(),\n        \u0026user5,\n        200 * MULTIPLIER as u128,\n    );\n\n    // Create lock for user5 for WEEK * 2\n    base_pack\n        .create_lock(router_ref, user5.clone(), WEEK * 2, 100)\n        .unwrap();\n\n    // Claim for all users\n    router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::ClaimMany {\n                receivers: vec![\n                    user1.to_string(),\n                    user2.to_string(),\n                    user3.to_string(),\n                    user4.to_string(),\n                    user5.to_string(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Checks if user's ASTRO balance is equal to 100 / 4 = 25 * 1_000_000\n    for user in [user1.clone(), user2.clone(), user3.clone(), user4.clone()] {\n        check_balance(\n            router_ref,\n            \u0026base_pack.astro_token.clone().unwrap().address,\n            \u0026user,\n            25 * MULTIPLIER as u128,\n        );\n    }\n\n    // Checks if user5's ASTRO balance is equal to 0. Cannot claim for the current period\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026user5,\n        0,\n    );\n\n    // Check if distributor's ASTRO balance equal to 0\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        0,\n    );\n\n    // Going to next week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n\n    // Sends 900_000_000 ASTRO from the Maker to the distributor for the third period\n    let msg = Cw20ExecuteMsg::Send {\n        contract: base_pack\n            .escrow_fee_distributor\n            .clone()\n            .unwrap()\n            .address\n            .to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::ReceiveTokens {}).unwrap(),\n        amount: Uint128::from(900 * MULTIPLIER as u128),\n    };\n\n    router_ref\n        .execute_contract(\n            maker.clone(),\n            base_pack.astro_token.clone().unwrap().address,\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Check if rewards per week are set to 900_000_000 ASTRO\n    let resp: Vec\u003cUint128\u003e = router_ref\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026QueryMsg::AvailableRewardPerWeek {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n    assert_eq!(\n        vec![Uint128::new(100_000_000), Uint128::new(900_000_000),],\n        resp\n    );\n\n    // Try to claim for all users for the current period\n    router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::ClaimMany {\n                receivers: vec![\n                    user1.to_string(),\n                    user2.to_string(),\n                    user3.to_string(),\n                    user4.to_string(),\n                    user5.to_string(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Checks if the user's ASTRO token balance is still equal to 100 / 4 = 25 * 1_000_000\n    for user in [user1.clone(), user2.clone(), user3.clone(), user4.clone()] {\n        check_balance(\n            router_ref,\n            \u0026base_pack.astro_token.clone().unwrap().address,\n            \u0026user,\n            25 * MULTIPLIER as u128,\n        );\n    }\n\n    // Check if user5's ASTRO balance is 0 for the first lock week\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026user5,\n        0,\n    );\n\n    // Check if the distributor's ASTRO balance is still equal to 900_000_000\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        900_000_000,\n    );\n\n    // Going to next week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n\n    // Try to claim for all users\n    router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::ClaimMany {\n                receivers: vec![\n                    user1.to_string(),\n                    user2.to_string(),\n                    user3.to_string(),\n                    user4.to_string(),\n                    user5.to_string(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Checks if the user's ASTRO balance is still equal to 25 * 100_000_000.\n    for user in [user1.clone(), user2.clone(), user3.clone(), user4.clone()] {\n        check_balance(\n            router_ref,\n            \u0026base_pack.astro_token.clone().unwrap().address,\n            \u0026user,\n            25 * MULTIPLIER as u128,\n        );\n    }\n\n    // Checks if user5's ASTRO balance equal to 900_000_000 for the second week of lock\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026user5,\n        900_000_000,\n    );\n\n    // Check if distributor's ASTRO balance still equal to 0\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        0,\n    );\n}\n\n#[test]\nfn is_claim_enabled() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(OWNER.clone());\n    let maker = Addr::unchecked(MAKER.clone());\n    let user1 = Addr::unchecked(USER1.clone());\n    let user2 = Addr::unchecked(USER2.clone());\n\n    let base_pack = init_astroport_test_package(router_ref).unwrap();\n\n    let xastro_token = base_pack.get_staking_xastro(router_ref);\n\n    // Sends 200_000_000 xASTRO tokens to users\n    for user in [user1.clone(), user2.clone()] {\n        mint(\n            router_ref,\n            base_pack.staking.clone().unwrap().address,\n            xastro_token.clone(),\n            \u0026user,\n            200,\n        );\n\n        // Checks if user's xASTRO token balance is equal to 200 * 1000_000\n        check_balance(\n            router_ref,\n            \u0026xastro_token.clone(),\n            \u0026user,\n            200 * MULTIPLIER as u128,\n        );\n\n        // Create a lock for user for WEEK * 3\n        base_pack\n            .create_lock(router_ref, user.clone(), WEEK * 3, 100)\n            .unwrap();\n    }\n\n    // Send 1000_000_000 ASTRO tokens to the Maker\n    mint(\n        router_ref,\n        owner.clone(),\n        base_pack.astro_token.clone().unwrap().address,\n        \u0026maker,\n        1000,\n    );\n\n    // Send 100_000_000 ASTRO from the Maker to the distributor for the first period\n    let msg = Cw20ExecuteMsg::Send {\n        contract: base_pack\n            .escrow_fee_distributor\n            .clone()\n            .unwrap()\n            .address\n            .to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::ReceiveTokens {}).unwrap(),\n        amount: Uint128::from(100 * MULTIPLIER as u128),\n    };\n\n    router_ref\n        .execute_contract(\n            maker.clone(),\n            base_pack.astro_token.clone().unwrap().address,\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Check if distributor's ASTRO balance is equal to 100_000_000 ASTRO\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        100 * MULTIPLIER as u128,\n    );\n\n    // Checl if rewards are set to 100_000_000 ASTRO\n    let resp: Vec\u003cUint128\u003e = router_ref\n        .wrap()\n        .query_wasm_smart(\n            \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026QueryMsg::AvailableRewardPerWeek {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n    assert_eq!(vec![Uint128::new(100_000_000)], resp);\n\n    // Going to the next week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n\n    // Disable claiming\n    router_ref\n        .execute_contract(\n            owner.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::UpdateConfig {\n                claim_many_limit: None,\n                is_claim_disabled: Some(true),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Try to claim fees for all users for the first week\n    let err = router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::ClaimMany {\n                receivers: vec![user1.to_string(), user2.to_string()],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\"Claiming is disabled!\", err.root_cause().to_string());\n\n    // Send 100_000_000 ASTRO from the Maker to the distributor for the first period\n    let msg = Cw20ExecuteMsg::Send {\n        contract: base_pack\n            .escrow_fee_distributor\n            .clone()\n            .unwrap()\n            .address\n            .to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::ReceiveTokens {}).unwrap(),\n        amount: Uint128::from(100 * MULTIPLIER as u128),\n    };\n\n    router_ref\n        .execute_contract(\n            maker.clone(),\n            base_pack.astro_token.clone().unwrap().address,\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Going to the next week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n\n    // Try to claim fees for all users\n    let err = router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::ClaimMany {\n                receivers: vec![user1.to_string(), user2.to_string()],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\"Claiming is disabled!\", err.root_cause().to_string());\n\n    // Going to the next week\n    router_ref.update_block(next_block);\n    router_ref.update_block(|b| b.time = b.time.plus_seconds(WEEK));\n\n    // Enable claiming\n    router_ref\n        .execute_contract(\n            owner.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::UpdateConfig {\n                claim_many_limit: None,\n                is_claim_disabled: Some(false),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Try to claim fees for all users\n    router_ref\n        .execute_contract(\n            user1.clone(),\n            base_pack.escrow_fee_distributor.clone().unwrap().address,\n            \u0026ExecuteMsg::ClaimMany {\n                receivers: vec![user1.to_string(), user2.to_string()],\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Check if the user's ASTRO token balance is equal to 25 * 1_000_000\n    for user in [user1.clone(), user2.clone()] {\n        check_balance(\n            router_ref,\n            \u0026base_pack.astro_token.clone().unwrap().address,\n            \u0026user,\n            100 * MULTIPLIER as u128,\n        );\n    }\n\n    // Check if the distributor's ASTRO balance is 0\n    check_balance(\n        router_ref,\n        \u0026base_pack.astro_token.clone().unwrap().address,\n        \u0026base_pack.escrow_fee_distributor.clone().unwrap().address,\n        0,\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","generator_controller","src","bps.rs"],"content":"use crate::error::ContractError;\nuse cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Decimal, Fraction, StdError, Uint128};\nuse std::convert::{TryFrom, TryInto};\nuse std::ops::Mul;\n\n/// BasicPoints struct implementation. BasicPoints value is within [0, 10000] interval.\n/// Technically BasicPoints is wrapper over [`u16`] with additional limit checks and\n/// several implementations of math functions so BasicPoints object\n/// can be used in formulas along with [`Uint128`] and [`Decimal`].\n#[cw_serde]\n#[derive(Default, Copy)]\npub struct BasicPoints(u16);\n\nimpl BasicPoints {\n    pub const MAX: u16 = 10000;\n\n    pub fn checked_add(self, rhs: Self) -\u003e Result\u003cSelf, ContractError\u003e {\n        let next_value = self.0 + rhs.0;\n        if next_value \u003e Self::MAX {\n            Err(ContractError::BPSLimitError {})\n        } else {\n            Ok(Self(next_value))\n        }\n    }\n\n    pub fn from_ratio(numerator: Uint128, denominator: Uint128) -\u003e Result\u003cSelf, ContractError\u003e {\n        numerator\n            .checked_multiply_ratio(Self::MAX, denominator)\n            .map_err(|_| StdError::generic_err(\"Checked multiply ratio error!\"))?\n            .u128()\n            .try_into()\n    }\n}\n\nimpl TryFrom\u003cu16\u003e for BasicPoints {\n    type Error = ContractError;\n\n    fn try_from(value: u16) -\u003e Result\u003cSelf, Self::Error\u003e {\n        if value \u003c= Self::MAX {\n            Ok(Self(value))\n        } else {\n            Err(ContractError::BPSConverstionError(value as u128))\n        }\n    }\n}\n\nimpl TryFrom\u003cu128\u003e for BasicPoints {\n    type Error = ContractError;\n\n    fn try_from(value: u128) -\u003e Result\u003cSelf, Self::Error\u003e {\n        if value \u003c= Self::MAX as u128 {\n            Ok(Self(value as u16))\n        } else {\n            Err(ContractError::BPSConverstionError(value))\n        }\n    }\n}\n\nimpl From\u003cBasicPoints\u003e for u16 {\n    fn from(value: BasicPoints) -\u003e Self {\n        value.0\n    }\n}\n\nimpl From\u003cBasicPoints\u003e for Uint128 {\n    fn from(value: BasicPoints) -\u003e Self {\n        Uint128::from(u16::from(value))\n    }\n}\n\nimpl Mul\u003cUint128\u003e for BasicPoints {\n    type Output = Uint128;\n\n    fn mul(self, rhs: Uint128) -\u003e Self::Output {\n        rhs.multiply_ratio(self.0, Self::MAX)\n    }\n}\n\nimpl Mul\u003cDecimal\u003e for BasicPoints {\n    type Output = Decimal;\n\n    fn mul(self, rhs: Decimal) -\u003e Self::Output {\n        Decimal::from_ratio(\n            rhs.numerator() * Uint128::from(self.0),\n            rhs.denominator() * Uint128::from(Self::MAX),\n        )\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","generator_controller","src","contract.rs"],"content":"use std::collections::HashSet;\nuse std::convert::TryInto;\n\nuse crate::astroport;\nuse astroport::common::{claim_ownership, drop_ownership_proposal, propose_new_owner};\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    to_binary, Addr, Binary, CosmosMsg, Decimal, Deps, DepsMut, Env, Fraction, MessageInfo, Order,\n    Response, StdError, StdResult, Uint128, WasmMsg,\n};\nuse cw2::set_contract_version;\nuse itertools::Itertools;\n\nuse astroport_governance::generator_controller::{\n    ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg, UserInfoResponse, VOTERS_MAX_LIMIT,\n};\nuse astroport_governance::utils::{calc_voting_power, get_period, WEEK};\nuse astroport_governance::voting_escrow::QueryMsg::CheckVotersAreBlacklisted;\nuse astroport_governance::voting_escrow::{\n    get_lock_info, get_voting_power, BlacklistedVotersResponse,\n};\n\nuse crate::bps::BasicPoints;\nuse crate::error::ContractError;\nuse crate::state::{\n    Config, TuneInfo, UserInfo, VotedPoolInfo, CONFIG, OWNERSHIP_PROPOSAL, POOLS, TUNE_INFO,\n    USER_INFO,\n};\n\nuse crate::utils::{\n    cancel_user_changes, check_duplicated, filter_pools, get_pool_info, update_pool_info,\n    validate_pool, validate_pools_limit, vote_for_pool,\n};\n\n/// Contract name that is used for migration.\nconst CONTRACT_NAME: \u0026str = \"generator-controller\";\n/// Contract version that is used for migration.\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\nconst DAY: u64 = 86400;\n/// The user can only vote once every 10 days\nconst VOTE_COOLDOWN: u64 = DAY * 10;\n/// It is possible to tune pools once every 14 days\nconst TUNE_COOLDOWN: u64 = WEEK * 2;\n\ntype ExecuteResult = Result\u003cResponse, ContractError\u003e;\n\n/// Creates a new contract with the specified parameters in the [`InstantiateMsg`].\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e ExecuteResult {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    CONFIG.save(\n        deps.storage,\n        \u0026Config {\n            owner: deps.api.addr_validate(\u0026msg.owner)?,\n            escrow_addr: deps.api.addr_validate(\u0026msg.escrow_addr)?,\n            generator_addr: deps.api.addr_validate(\u0026msg.generator_addr)?,\n            factory_addr: deps.api.addr_validate(\u0026msg.factory_addr)?,\n            pools_limit: validate_pools_limit(msg.pools_limit)?,\n            blacklisted_voters_limit: None,\n            main_pool: None,\n            main_pool_min_alloc: Decimal::zero(),\n            whitelisted_pools: vec![],\n        },\n    )?;\n\n    // Set tune_ts just for safety so the first tuning could happen in 2 weeks\n    TUNE_INFO.save(\n        deps.storage,\n        \u0026TuneInfo {\n            tune_ts: env.block.time.seconds(),\n            pool_alloc_points: vec![],\n        },\n    )?;\n\n    Ok(Response::default())\n}\n\n/// Exposes all the execute functions available in the contract.\n///\n/// ## Execute messages\n/// * **ExecuteMsg::KickBlacklistedVoters { blacklisted_voters }** Removes all votes applied by\n/// blacklisted voters\n///\n/// * **ExecuteMsg::Vote { votes }** Casts votes for pools\n///\n/// * **ExecuteMsg::TunePools** Launches pool tuning\n///\n/// * **ExecuteMsg::ChangePoolsLimit { limit }** Changes the number of pools which are eligible\n/// to receive allocation points\n///\n/// * **ExecuteMsg::UpdateConfig { blacklisted_voters_limit }** Changes the number of blacklisted\n/// voters that can be kicked at once\n///\n/// * **ExecuteMsg::UpdateWhitelist { add, remove }** Adds or removes lp tokens which are eligible\n/// to receive votes.\n///\n/// * **ExecuteMsg::ProposeNewOwner { owner, expires_in }** Creates a new request to change\n/// contract ownership.\n///\n/// * **ExecuteMsg::DropOwnershipProposal {}** Removes a request to change contract ownership.\n///\n/// * **ExecuteMsg::ClaimOwnership {}** Claims contract ownership.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -\u003e ExecuteResult {\n    match msg {\n        ExecuteMsg::KickBlacklistedVoters { blacklisted_voters } =\u003e {\n            kick_blacklisted_voters(deps, env, blacklisted_voters)\n        }\n        ExecuteMsg::Vote { votes } =\u003e handle_vote(deps, env, info, votes),\n        ExecuteMsg::TunePools {} =\u003e tune_pools(deps, env),\n        ExecuteMsg::ChangePoolsLimit { limit } =\u003e change_pools_limit(deps, info, limit),\n        ExecuteMsg::UpdateConfig {\n            blacklisted_voters_limit,\n            main_pool,\n            main_pool_min_alloc,\n            remove_main_pool,\n        } =\u003e update_config(\n            deps,\n            info,\n            blacklisted_voters_limit,\n            main_pool,\n            main_pool_min_alloc,\n            remove_main_pool,\n        ),\n        ExecuteMsg::UpdateWhitelist { add, remove } =\u003e update_whitelist(deps, info, add, remove),\n        ExecuteMsg::ProposeNewOwner {\n            new_owner,\n            expires_in,\n        } =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n\n            propose_new_owner(\n                deps,\n                info,\n                env,\n                new_owner,\n                expires_in,\n                config.owner,\n                OWNERSHIP_PROPOSAL,\n            )\n            .map_err(Into::into)\n        }\n        ExecuteMsg::DropOwnershipProposal {} =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n\n            drop_ownership_proposal(deps, info, config.owner, OWNERSHIP_PROPOSAL)\n                .map_err(Into::into)\n        }\n        ExecuteMsg::ClaimOwnership {} =\u003e {\n            claim_ownership(deps, info, env, OWNERSHIP_PROPOSAL, |deps, new_owner| {\n                CONFIG\n                    .update::\u003c_, StdError\u003e(deps.storage, |mut v| {\n                        v.owner = new_owner;\n                        Ok(v)\n                    })\n                    .map(|_| ())\n            })\n            .map_err(Into::into)\n        }\n    }\n}\n\n/// Adds or removes lp tokens which are eligible to receive votes.\n/// Returns a [`ContractError`] on failure.\nfn update_whitelist(\n    deps: DepsMut,\n    info: MessageInfo,\n    add: Option\u003cVec\u003cString\u003e\u003e,\n    remove: Option\u003cVec\u003cString\u003e\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut cfg = CONFIG.load(deps.storage)?;\n\n    // Permission check\n    if info.sender != cfg.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    // Remove old LP tokens\n    if let Some(remove_lp_tokens) = remove {\n        cfg.whitelisted_pools\n            .retain(|pool| !remove_lp_tokens.contains(\u0026pool.to_string()));\n    }\n\n    // Add new lp tokens\n    if let Some(add_lp_tokens) = add {\n        cfg.whitelisted_pools.append(\n            \u0026mut add_lp_tokens\n                .into_iter()\n                .map(|lp_token| {\n                    let lp_token_addr = deps.api.addr_validate(lp_token.as_str())?;\n                    validate_pool(deps.as_ref(), \u0026cfg, \u0026lp_token_addr)?;\n                    Ok(lp_token_addr)\n                })\n                .collect::\u003cResult\u003cVec\u003c_\u003e, ContractError\u003e\u003e()?,\n        );\n        check_duplicated(\u0026cfg.whitelisted_pools).map_err(|_|\n            ContractError::Std(StdError::generic_err(\"The resulting whitelist contains duplicated pools. It's either provided 'add' list contains duplicated pools or some of the added pools are already whitelisted.\")))?;\n    }\n\n    CONFIG.save(deps.storage, \u0026cfg)?;\n    Ok(Response::default().add_attribute(\"action\", \"update_whitelist\"))\n}\n\n/// This function removes all votes applied by blacklisted voters.\n///\n/// * **holders** list with blacklisted holders whose votes will be removed.\nfn kick_blacklisted_voters(deps: DepsMut, env: Env, voters: Vec\u003cString\u003e) -\u003e ExecuteResult {\n    let block_period = get_period(env.block.time.seconds())?;\n    let config = CONFIG.load(deps.storage)?;\n\n    if voters.len() \u003e config.blacklisted_voters_limit.unwrap_or(VOTERS_MAX_LIMIT) as usize {\n        return Err(ContractError::KickVotersLimitExceeded {});\n    }\n\n    // Check duplicated voters\n    let addrs_set = voters.iter().collect::\u003cHashSet\u003c_\u003e\u003e();\n    if voters.len() != addrs_set.len() {\n        return Err(ContractError::DuplicatedVoters {});\n    }\n\n    // Check if voters are blacklisted\n    let res: BlacklistedVotersResponse = deps.querier.query_wasm_smart(\n        config.escrow_addr,\n        \u0026CheckVotersAreBlacklisted {\n            voters: voters.clone(),\n        },\n    )?;\n\n    if !res.eq(\u0026BlacklistedVotersResponse::VotersBlacklisted {}) {\n        return Err(ContractError::Std(StdError::generic_err(res.to_string())));\n    }\n\n    for voter in voters {\n        let voter_addr = deps.api.addr_validate(\u0026voter)?;\n        if let Some(user_info) = USER_INFO.may_load(deps.storage, \u0026voter_addr)? {\n            if user_info.lock_end \u003e block_period {\n                let user_last_vote_period = get_period(user_info.vote_ts)?;\n                // Calculate voting power before changes\n                let old_vp_at_period = calc_voting_power(\n                    user_info.slope,\n                    user_info.voting_power,\n                    user_last_vote_period,\n                    block_period,\n                );\n\n                // Cancel changes applied by previous votes\n                user_info.votes.iter().try_for_each(|(pool_addr, bps)| {\n                    cancel_user_changes(\n                        deps.storage,\n                        block_period + 1,\n                        pool_addr,\n                        *bps,\n                        old_vp_at_period,\n                        user_info.slope,\n                        user_info.lock_end,\n                    )\n                })?;\n\n                let user_info = UserInfo {\n                    vote_ts: env.block.time.seconds(),\n                    lock_end: block_period,\n                    ..Default::default()\n                };\n\n                USER_INFO.save(deps.storage, \u0026voter_addr, \u0026user_info)?;\n            }\n        }\n    }\n\n    Ok(Response::new().add_attribute(\"action\", \"kick_holders\"))\n}\n\n/// The function checks that:\n/// * the user voting power is \u003e 0,\n/// * user didn't vote for last 10 days,\n/// * all pool addresses are valid LP token addresses,\n/// * 'votes' vector doesn't contain duplicated pool addresses,\n/// * sum of all BPS values \u003c= 10000.\n///\n/// The function cancels changes applied by previous votes and apply new votes for the next period.\n/// New vote parameters are saved in [`USER_INFO`].\n///\n/// The function returns [`Response`] in case of success or [`ContractError`] in case of errors.\n///\n/// * **votes** is a vector of pairs ([`String`], [`u16`]).\n/// Tuple consists of pool address and percentage of user's voting power for a given pool.\n/// Percentage should be in BPS form.\nfn handle_vote(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    votes: Vec\u003c(String, u16)\u003e,\n) -\u003e ExecuteResult {\n    let user = info.sender;\n    let block_period = get_period(env.block.time.seconds())?;\n    let config = CONFIG.load(deps.storage)?;\n    let user_vp = get_voting_power(\u0026deps.querier, \u0026config.escrow_addr, \u0026user)?;\n\n    if user_vp.is_zero() {\n        return Err(ContractError::ZeroVotingPower {});\n    }\n\n    if config.whitelisted_pools.is_empty() {\n        return Err(ContractError::WhitelistEmpty {});\n    }\n\n    let user_info = USER_INFO.may_load(deps.storage, \u0026user)?.unwrap_or_default();\n    // Does the user eligible to vote again?\n    if env.block.time.seconds() - user_info.vote_ts \u003c VOTE_COOLDOWN {\n        return Err(ContractError::CooldownError(VOTE_COOLDOWN / DAY));\n    }\n\n    check_duplicated(\n        \u0026votes\n            .iter()\n            .map(|vote| {\n                let (lp_token, _) = vote;\n                Addr::unchecked(lp_token)\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e(),\n    )?;\n\n    // Validating addrs and bps\n    let votes = votes\n        .into_iter()\n        .map(|(addr, bps)| {\n            let pool = deps.api.addr_validate(\u0026addr)?;\n\n            // Voting for the main pool is prohibited\n            if let Some(main_pool) = \u0026config.main_pool {\n                if pool == main_pool {\n                    return Err(ContractError::MainPoolVoteOrWhitelistingProhibited(\n                        main_pool.to_string(),\n                    ));\n                }\n            }\n            if !config.whitelisted_pools.contains(\u0026pool) {\n                return Err(ContractError::PoolIsNotWhitelisted(pool.to_string()));\n            }\n\n            validate_pool(deps.as_ref(), \u0026config, \u0026pool)?;\n\n            let bps: BasicPoints = bps.try_into()?;\n            Ok((pool, bps))\n        })\n        .collect::\u003cResult\u003cVec\u003c_\u003e, ContractError\u003e\u003e()?;\n\n    // Check the bps sum is within the limit\n    votes\n        .iter()\n        .try_fold(BasicPoints::default(), |acc, (_, bps)| {\n            acc.checked_add(*bps)\n        })?;\n\n    if user_info.lock_end \u003e block_period {\n        let user_last_vote_period = get_period(user_info.vote_ts).unwrap_or(block_period);\n        // Calculate voting power before changes\n        let old_vp_at_period = calc_voting_power(\n            user_info.slope,\n            user_info.voting_power,\n            user_last_vote_period,\n            block_period,\n        );\n\n        // Cancel changes applied by previous votes\n        user_info.votes.iter().try_for_each(|(pool_addr, bps)| {\n            cancel_user_changes(\n                deps.storage,\n                block_period + 1,\n                pool_addr,\n                *bps,\n                old_vp_at_period,\n                user_info.slope,\n                user_info.lock_end,\n            )\n        })?;\n    }\n\n    let ve_lock_info = get_lock_info(\u0026deps.querier, \u0026config.escrow_addr, \u0026user)?;\n\n    // Votes are applied to the next period\n    votes.iter().try_for_each(|(pool_addr, bps)| {\n        vote_for_pool(\n            deps.storage,\n            block_period + 1,\n            pool_addr,\n            *bps,\n            user_vp,\n            ve_lock_info.slope,\n            ve_lock_info.end,\n        )\n    })?;\n\n    let user_info = UserInfo {\n        vote_ts: env.block.time.seconds(),\n        voting_power: user_vp,\n        slope: ve_lock_info.slope,\n        lock_end: ve_lock_info.end,\n        votes,\n    };\n\n    USER_INFO.save(deps.storage, \u0026user, \u0026user_info)?;\n\n    Ok(Response::new().add_attribute(\"action\", \"vote\"))\n}\n\n/// The function checks that the last pools tuning happened \u003e= 14 days ago.\n/// Then it calculates voting power for each pool at the current period, filters all pools which\n/// are not eligible to receive allocation points,\n/// takes top X pools by voting power, where X is 'config.pools_limit', calculates allocation points\n/// for these pools and applies allocation points in generator contract.\nfn tune_pools(deps: DepsMut, env: Env) -\u003e ExecuteResult {\n    let mut tune_info = TUNE_INFO.load(deps.storage)?;\n    let config = CONFIG.load(deps.storage)?;\n    let block_period = get_period(env.block.time.seconds())?;\n\n    if env.block.time.seconds() - tune_info.tune_ts \u003c TUNE_COOLDOWN {\n        return Err(ContractError::CooldownError(TUNE_COOLDOWN / DAY));\n    }\n\n    let pool_votes: Vec\u003c_\u003e = POOLS\n        .keys(deps.as_ref().storage, None, None, Order::Ascending)\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .into_iter()\n        .map(|pool_addr| {\n            let pool_addr = pool_addr?;\n\n            let pool_info = update_pool_info(deps.storage, block_period, \u0026pool_addr, None)?;\n            // Remove pools with zero voting power so we won't iterate over them in future\n            if pool_info.vxastro_amount.is_zero() {\n                POOLS.remove(deps.storage, \u0026pool_addr)\n            }\n            Ok((pool_addr, pool_info.vxastro_amount))\n        })\n        .collect::\u003cStdResult\u003cVec\u003c_\u003e\u003e\u003e()?\n        .into_iter()\n        .filter(|(_, vxastro_amount)| !vxastro_amount.is_zero())\n        .sorted_by(|(_, a), (_, b)| b.cmp(a)) // Sort in descending order\n        .collect();\n\n    tune_info.pool_alloc_points = filter_pools(\n        \u0026deps.querier,\n        \u0026config.generator_addr,\n        \u0026config.factory_addr,\n        pool_votes,\n        config.pools_limit + 1, // +1 additional pool if we will need to remove the main pool\n    )?;\n\n    // Set allocation points for the main pool\n    match config.main_pool {\n        Some(main_pool) if !config.main_pool_min_alloc.is_zero() =\u003e {\n            // Main pool may appear in the pool list thus we need to eliminate its contribution in the total VP.\n            tune_info\n                .pool_alloc_points\n                .retain(|(pool, _)| pool != \u0026main_pool.to_string());\n            // If there is no main pool in the filtered list then we need to remove additional pool\n            tune_info.pool_alloc_points = tune_info\n                .pool_alloc_points\n                .iter()\n                .take(config.pools_limit as usize)\n                .cloned()\n                .collect();\n\n            let total_vp: Uint128 = tune_info\n                .pool_alloc_points\n                .iter()\n                .fold(Uint128::zero(), |acc, (_, vp)| acc + vp);\n            // Calculate main pool contribution.\n            // Example (30% for the main pool): VP + x = y, x = 0.3y =\u003e y = VP/0.7  =\u003e x = 0.3 * VP / 0.7,\n            // where VP - total VP, x - main pool's contribution, y - new total VP.\n            // x = 0.3 * VP * (1-0.3)^(-1)\n            let main_pool_contribution = config.main_pool_min_alloc\n                * total_vp\n                * (Decimal::one() - config.main_pool_min_alloc).inv().unwrap();\n            tune_info\n                .pool_alloc_points\n                .push((main_pool.to_string(), main_pool_contribution))\n        }\n        _ =\u003e {\n            // there is no main pool or min alloc is 0%\n            tune_info.pool_alloc_points = tune_info\n                .pool_alloc_points\n                .iter()\n                .take(config.pools_limit as usize)\n                .cloned()\n                .collect();\n        }\n    }\n\n    if tune_info.pool_alloc_points.is_empty() {\n        return Err(ContractError::TuneNoPools {});\n    }\n\n    tune_info.tune_ts = env.block.time.seconds();\n    TUNE_INFO.save(deps.storage, \u0026tune_info)?;\n\n    // Set new alloc points\n    let setup_pools_msg = CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: config.generator_addr.to_string(),\n        msg: to_binary(\u0026astroport::generator::ExecuteMsg::SetupPools {\n            pools: tune_info.pool_alloc_points,\n        })?,\n        funds: vec![],\n    });\n\n    Ok(Response::new()\n        .add_message(setup_pools_msg)\n        .add_attribute(\"action\", \"tune_pools\"))\n}\n\n/// Only contract owner can call this function.  \n/// The function sets a new limit of blacklisted voters that can be kicked at once.\n///\n/// * **blacklisted_voters_limit** is a new limit of blacklisted voters which can be kicked at once\n///\n/// * **main_pool** is a main pool address\n///\n/// * **main_pool_min_alloc** is a minimum percentage of ASTRO emissions that this pool should get every block\n///\n/// * **remove_main_pool** should the main pool be removed or not\nfn update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    blacklisted_voters_limit: Option\u003cu32\u003e,\n    main_pool: Option\u003cString\u003e,\n    main_pool_min_alloc: Option\u003cDecimal\u003e,\n    remove_main_pool: Option\u003cbool\u003e,\n) -\u003e ExecuteResult {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(blacklisted_voters_limit) = blacklisted_voters_limit {\n        config.blacklisted_voters_limit = Some(blacklisted_voters_limit);\n    }\n\n    if let Some(main_pool_min_alloc) = main_pool_min_alloc {\n        if main_pool_min_alloc == Decimal::zero() || main_pool_min_alloc \u003e= Decimal::one() {\n            return Err(ContractError::MainPoolMinAllocFailed {});\n        }\n        config.main_pool_min_alloc = main_pool_min_alloc;\n    }\n\n    if let Some(main_pool) = main_pool {\n        if config.main_pool_min_alloc.is_zero() {\n            return Err(StdError::generic_err(\"Main pool min alloc can not be zero\").into());\n        }\n        config.main_pool = Some(deps.api.addr_validate(\u0026main_pool)?);\n    }\n\n    if let Some(remove_main_pool) = remove_main_pool {\n        if remove_main_pool {\n            config.main_pool = None;\n        }\n    }\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::default().add_attribute(\"action\", \"update_config\"))\n}\n\n/// Only contract owner can call this function.\n/// The function sets new limit of pools which are eligible to receive allocation points.\n///\n/// * **limit** is a new limit of pools which are eligible to receive allocation points.\nfn change_pools_limit(deps: DepsMut, info: MessageInfo, limit: u64) -\u003e ExecuteResult {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    config.pools_limit = validate_pools_limit(limit)?;\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::default().add_attribute(\"action\", \"change_pools_limit\"))\n}\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::UserInfo { user }** Fetch user information\n///\n/// * **QueryMsg::TuneInfo** Fetch last tuning information\n///\n/// * **QueryMsg::Config** Fetch contract config\n///\n/// * **QueryMsg::PoolInfo { pool_addr }** Fetch pool's voting information at the current period.\n///\n/// * **QueryMsg::PoolInfoAtPeriod { pool_addr, period }** Fetch pool's voting information at a specified period.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::UserInfo { user } =\u003e to_binary(\u0026user_info(deps, user)?),\n        QueryMsg::TuneInfo {} =\u003e to_binary(\u0026TUNE_INFO.load(deps.storage)?),\n        QueryMsg::Config {} =\u003e to_binary(\u0026CONFIG.load(deps.storage)?),\n        QueryMsg::PoolInfo { pool_addr } =\u003e to_binary(\u0026pool_info(deps, env, pool_addr, None)?),\n        QueryMsg::PoolInfoAtPeriod { pool_addr, period } =\u003e {\n            to_binary(\u0026pool_info(deps, env, pool_addr, Some(period))?)\n        }\n    }\n}\n\n/// Returns user information.\nfn user_info(deps: Deps, user: String) -\u003e StdResult\u003cUserInfoResponse\u003e {\n    let user_addr = deps.api.addr_validate(\u0026user)?;\n    USER_INFO\n        .may_load(deps.storage, \u0026user_addr)?\n        .map(UserInfo::into_response)\n        .ok_or_else(|| StdError::generic_err(\"User not found\"))\n}\n\n/// Returns pool's voting information at a specified period.\nfn pool_info(\n    deps: Deps,\n    env: Env,\n    pool_addr: String,\n    period: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cVotedPoolInfo\u003e {\n    let pool_addr = deps.api.addr_validate(\u0026pool_addr)?;\n    let block_period = get_period(env.block.time.seconds())?;\n    let period = period.unwrap_or(block_period);\n    get_pool_info(deps.storage, period, \u0026pool_addr)\n}\n\n/// Manages contract migration\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    Err(ContractError::MigrationError {})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","generator_controller","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse thiserror::Error;\n\n/// This enum describes contract errors\n#[derive(Error, Debug)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Basic points conversion error. {0} \u003e 10000\")]\n    BPSConverstionError(u128),\n\n    #[error(\"Basic points sum exceeds limit\")]\n    BPSLimitError {},\n\n    #[error(\"You can't vote with zero voting power\")]\n    ZeroVotingPower {},\n\n    #[error(\"{0} is the main pool. Voting or whitelisting the main pool is prohibited.\")]\n    MainPoolVoteOrWhitelistingProhibited(String),\n\n    #[error(\"main_pool_min_alloc should be more than 0 and less than 1\")]\n    MainPoolMinAllocFailed {},\n\n    #[error(\"You can only run this action every {0} days\")]\n    CooldownError(u64),\n\n    #[error(\"Invalid lp token address: {0}\")]\n    InvalidLPTokenAddress(String),\n\n    #[error(\"Votes contain duplicated pool addresses\")]\n    DuplicatedPools {},\n\n    #[error(\"There are no pools to tune\")]\n    TuneNoPools {},\n\n    #[error(\"Invalid pool number: {0}. Must be within [2, 100] range\")]\n    InvalidPoolNumber(u64),\n\n    #[error(\"The vector contains duplicated addresses\")]\n    DuplicatedVoters {},\n\n    #[error(\"Exceeded voters limit for kick blacklisted voters operation!\")]\n    KickVotersLimitExceeded {},\n\n    #[error(\"Contract can't be migrated!\")]\n    MigrationError {},\n\n    #[error(\"Whitelist cannot be empty!\")]\n    WhitelistEmpty {},\n\n    #[error(\"The pair aren't registered: {0}-{1}\")]\n    PairNotRegistered(String, String),\n\n    #[error(\"Pool is already whitelisted: {0}\")]\n    PoolIsWhitelisted(String),\n\n    #[error(\"Pool is not whitelisted: {0}\")]\n    PoolIsNotWhitelisted(String),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","generator_controller","src","lib.rs"],"content":"pub mod bps;\npub mod contract;\npub mod state;\n\n// During development this import could be replaced with another astroport version.\n// However, in production, the astroport version should be the same for all contracts.\npub use astroport_governance::astroport;\n\nmod error;\nmod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","generator_controller","src","state.rs"],"content":"use crate::astroport::common::OwnershipProposal;\nuse crate::bps::BasicPoints;\n\nuse astroport_governance::generator_controller::{\n    ConfigResponse, GaugeInfoResponse, UserInfoResponse, VotedPoolInfoResponse,\n};\nuse cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Uint128};\nuse cw_storage_plus::{Item, Map};\n\n/// This structure describes the main control config of generator controller contract.\npub type Config = ConfigResponse;\n/// This structure describes voting parameters for a specific pool.\npub type VotedPoolInfo = VotedPoolInfoResponse;\n/// This structure describes last tuning parameters.\npub type TuneInfo = GaugeInfoResponse;\n\n/// The struct describes last user's votes parameters.\n#[cw_serde]\n#[derive(Default)]\npub struct UserInfo {\n    pub vote_ts: u64,\n    pub voting_power: Uint128,\n    pub slope: Uint128,\n    pub lock_end: u64,\n    pub votes: Vec\u003c(Addr, BasicPoints)\u003e,\n}\n\nimpl UserInfo {\n    /// The function converts [`UserInfo`] object into [`UserInfoResponse`].\n    pub(crate) fn into_response(self) -\u003e UserInfoResponse {\n        let votes = self\n            .votes\n            .iter()\n            .map(|(pool_addr, bps)| (pool_addr.clone(), u16::from(*bps)))\n            .collect();\n\n        UserInfoResponse {\n            vote_ts: self.vote_ts,\n            voting_power: self.voting_power,\n            slope: self.slope,\n            lock_end: self.lock_end,\n            votes,\n        }\n    }\n}\n\n/// Stores config at the given key.\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n\n/// Stores voting parameters per pool at a specific period by key ( period -\u003e pool_addr ).\npub const POOL_VOTES: Map\u003c(u64, \u0026Addr), VotedPoolInfo\u003e = Map::new(\"pool_votes\");\n\n/// HashSet based on [`Map`]. It contains all pool addresses whose voting power \u003e 0.\npub const POOLS: Map\u003c\u0026Addr, ()\u003e = Map::new(\"pools\");\n\n/// Hashset based on [`Map`]. It stores null object by key ( pool_addr -\u003e period ).\n/// This hashset contains all periods which have saved result in [`POOL_VOTES`] for a specific pool address.\npub const POOL_PERIODS: Map\u003c(\u0026Addr, u64), ()\u003e = Map::new(\"pool_periods\");\n\n/// Slope changes for a specific pool address by key ( pool_addr -\u003e period ).\npub const POOL_SLOPE_CHANGES: Map\u003c(\u0026Addr, u64), Uint128\u003e = Map::new(\"pool_slope_changes\");\n\n/// User's voting information.\npub const USER_INFO: Map\u003c\u0026Addr, UserInfo\u003e = Map::new(\"user_info\");\n\n/// Last tuning information.\npub const TUNE_INFO: Item\u003cTuneInfo\u003e = Item::new(\"tune_info\");\n\n/// Contains a proposal to change contract ownership\npub const OWNERSHIP_PROPOSAL: Item\u003cOwnershipProposal\u003e = Item::new(\"ownership_proposal\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","generator_controller","src","utils.rs"],"content":"use std::collections::HashSet;\nuse std::ops::RangeInclusive;\n\nuse crate::astroport;\nuse astroport::asset::{pair_info_by_pool, AssetInfo};\nuse astroport::factory::PairType;\nuse astroport_governance::generator_controller::ConfigResponse;\nuse cosmwasm_std::{Addr, Deps, Order, QuerierWrapper, StdError, StdResult, Storage, Uint128};\nuse cw_storage_plus::Bound;\n\nuse crate::astroport::querier::query_pair_info;\nuse astroport_governance::utils::calc_voting_power;\n\nuse crate::bps::BasicPoints;\nuse crate::error::ContractError;\nuse crate::state::{VotedPoolInfo, POOLS, POOL_PERIODS, POOL_SLOPE_CHANGES, POOL_VOTES};\n\n/// Pools limit should be within the range `[2, 100]`\nconst POOL_NUMBER_LIMIT: RangeInclusive\u003cu64\u003e = 2..=100;\n\n/// The enum defines math operations with voting power and slope.\n#[derive(Debug)]\npub(crate) enum Operation {\n    Add,\n    Sub,\n}\n\nimpl Operation {\n    pub fn calc_slope(\u0026self, cur_slope: Uint128, slope: Uint128, bps: BasicPoints) -\u003e Uint128 {\n        match self {\n            Operation::Add =\u003e cur_slope + bps * slope,\n            Operation::Sub =\u003e cur_slope - bps * slope,\n        }\n    }\n\n    pub fn calc_voting_power(\u0026self, cur_vp: Uint128, vp: Uint128, bps: BasicPoints) -\u003e Uint128 {\n        match self {\n            Operation::Add =\u003e cur_vp + bps * vp,\n            Operation::Sub =\u003e cur_vp.saturating_sub(bps * vp),\n        }\n    }\n}\n\n/// Enum wraps [`VotedPoolInfo`] so the contract can leverage storage operations efficiently.\n#[derive(Debug)]\npub(crate) enum VotedPoolInfoResult {\n    Unchanged(VotedPoolInfo),\n    New(VotedPoolInfo),\n}\n\n/// Filters pairs (LP token address, voting parameters) by criteria:\n/// * pool's pair is registered in Factory,\n/// * pool's pair type is not in blocked list,\n/// * any of pair's token is not listed in blocked tokens list.\npub(crate) fn filter_pools(\n    querier: \u0026QuerierWrapper,\n    generator_addr: \u0026Addr,\n    factory_addr: \u0026Addr,\n    pools: Vec\u003c(Addr, Uint128)\u003e,\n    pools_limit: u64,\n) -\u003e StdResult\u003cVec\u003c(String, Uint128)\u003e\u003e {\n    let blocked_tokens: Vec\u003cAssetInfo\u003e = querier.query_wasm_smart(\n        generator_addr.clone(),\n        \u0026astroport::generator::QueryMsg::BlockedTokensList {},\n    )?;\n    let blocklisted_pair_types: Vec\u003cPairType\u003e = querier.query_wasm_smart(\n        factory_addr.clone(),\n        \u0026astroport::factory::QueryMsg::BlacklistedPairTypes {},\n    )?;\n\n    let pools = pools\n        .into_iter()\n        .filter_map(|(pool_addr, vxastro_amount)| {\n            // Check the address is a LP token and retrieve a pair info\n            let pair_info = pair_info_by_pool(querier, pool_addr).ok()?;\n            // Check a pair is registered in factory\n            query_pair_info(querier, factory_addr.clone(), \u0026pair_info.asset_infos).ok()?;\n            let condition = !blocklisted_pair_types.contains(\u0026pair_info.pair_type)\n                \u0026\u0026 !blocked_tokens.contains(\u0026pair_info.asset_infos[0])\n                \u0026\u0026 !blocked_tokens.contains(\u0026pair_info.asset_infos[1]);\n            if condition {\n                Some((pair_info.liquidity_token.to_string(), vxastro_amount))\n            } else {\n                None\n            }\n        })\n        .take(pools_limit as usize)\n        .collect();\n\n    Ok(pools)\n}\n\n/// Cancels user changes using old voting parameters for a given pool.  \n/// Firstly, it removes slope change scheduled for previous lockup end period.  \n/// Secondly, it updates voting parameters for the given period, but without user's vote.\npub(crate) fn cancel_user_changes(\n    storage: \u0026mut dyn Storage,\n    period: u64,\n    pool_addr: \u0026Addr,\n    old_bps: BasicPoints,\n    old_vp: Uint128,\n    old_slope: Uint128,\n    old_lock_end: u64,\n) -\u003e StdResult\u003c()\u003e {\n    // Cancel scheduled slope changes\n    let last_pool_period = fetch_last_pool_period(storage, period, pool_addr)?.unwrap_or(period);\n    if last_pool_period \u003c old_lock_end + 1 {\n        let end_period_key = old_lock_end + 1;\n        let old_scheduled_change = POOL_SLOPE_CHANGES.load(storage, (pool_addr, end_period_key))?;\n        let new_slope = old_scheduled_change - old_bps * old_slope;\n        if !new_slope.is_zero() {\n            POOL_SLOPE_CHANGES.save(storage, (pool_addr, end_period_key), \u0026new_slope)?\n        } else {\n            POOL_SLOPE_CHANGES.remove(storage, (pool_addr, end_period_key))\n        }\n    }\n\n    update_pool_info(\n        storage,\n        period,\n        pool_addr,\n        Some((old_bps, old_vp, old_slope, Operation::Sub)),\n    )\n    .map(|_| ())\n}\n\n/// Applies user's vote for a given pool.   \n/// Firstly, it schedules slope change for lockup end period.  \n/// Secondly, it updates voting parameters with applied user's vote.\npub(crate) fn vote_for_pool(\n    storage: \u0026mut dyn Storage,\n    period: u64,\n    pool_addr: \u0026Addr,\n    bps: BasicPoints,\n    vp: Uint128,\n    slope: Uint128,\n    lock_end: u64,\n) -\u003e StdResult\u003c()\u003e {\n    // Schedule slope changes\n    POOL_SLOPE_CHANGES.update::\u003c_, StdError\u003e(storage, (pool_addr, lock_end + 1), |slope_opt| {\n        if let Some(saved_slope) = slope_opt {\n            Ok(saved_slope + bps * slope)\n        } else {\n            Ok(bps * slope)\n        }\n    })?;\n    update_pool_info(\n        storage,\n        period,\n        pool_addr,\n        Some((bps, vp, slope, Operation::Add)),\n    )\n    .map(|_| ())\n}\n\n/// Fetches voting parameters for a given pool at specific period, applies new changes, saves it in storage\n/// and returns new voting parameters in [`VotedPoolInfo`] object.\n/// If there are no changes in 'changes' parameter\n/// and voting parameters were already calculated before the function just returns [`VotedPoolInfo`].\npub(crate) fn update_pool_info(\n    storage: \u0026mut dyn Storage,\n    period: u64,\n    pool_addr: \u0026Addr,\n    changes: Option\u003c(BasicPoints, Uint128, Uint128, Operation)\u003e,\n) -\u003e StdResult\u003cVotedPoolInfo\u003e {\n    if POOLS.may_load(storage, pool_addr)?.is_none() {\n        POOLS.save(storage, pool_addr, \u0026())?\n    }\n    let period_key = period;\n    let pool_info = match get_pool_info_mut(storage, period, pool_addr)? {\n        VotedPoolInfoResult::Unchanged(mut pool_info) | VotedPoolInfoResult::New(mut pool_info)\n            if changes.is_some() =\u003e\n        {\n            if let Some((bps, vp, slope, op)) = changes {\n                pool_info.slope = op.calc_slope(pool_info.slope, slope, bps);\n                pool_info.vxastro_amount = op.calc_voting_power(pool_info.vxastro_amount, vp, bps);\n            }\n            POOL_PERIODS.save(storage, (pool_addr, period_key), \u0026())?;\n            POOL_VOTES.save(storage, (period_key, pool_addr), \u0026pool_info)?;\n            pool_info\n        }\n        VotedPoolInfoResult::New(pool_info) =\u003e {\n            POOL_PERIODS.save(storage, (pool_addr, period_key), \u0026())?;\n            POOL_VOTES.save(storage, (period_key, pool_addr), \u0026pool_info)?;\n            pool_info\n        }\n        VotedPoolInfoResult::Unchanged(pool_info) =\u003e pool_info,\n    };\n\n    Ok(pool_info)\n}\n\n/// Returns pool info at specified period or calculates it. Saves intermediate results in storage.\npub(crate) fn get_pool_info_mut(\n    storage: \u0026mut dyn Storage,\n    period: u64,\n    pool_addr: \u0026Addr,\n) -\u003e StdResult\u003cVotedPoolInfoResult\u003e {\n    let pool_info_result = if let Some(pool_info) =\n        POOL_VOTES.may_load(storage, (period, pool_addr))?\n    {\n        VotedPoolInfoResult::Unchanged(pool_info)\n    } else {\n        let pool_info_result =\n            if let Some(mut prev_period) = fetch_last_pool_period(storage, period, pool_addr)? {\n                let mut pool_info = POOL_VOTES.load(storage, (prev_period, pool_addr))?;\n                // Recalculating passed periods\n                let scheduled_slope_changes =\n                    fetch_slope_changes(storage, pool_addr, prev_period, period)?;\n                for (recalc_period, scheduled_change) in scheduled_slope_changes {\n                    pool_info = VotedPoolInfo {\n                        vxastro_amount: calc_voting_power(\n                            pool_info.slope,\n                            pool_info.vxastro_amount,\n                            prev_period,\n                            recalc_period,\n                        ),\n                        slope: pool_info.slope - scheduled_change,\n                    };\n                    // Save intermediate result\n                    let recalc_period_key = recalc_period;\n                    POOL_PERIODS.save(storage, (pool_addr, recalc_period_key), \u0026())?;\n                    POOL_VOTES.save(storage, (recalc_period_key, pool_addr), \u0026pool_info)?;\n                    prev_period = recalc_period\n                }\n\n                VotedPoolInfo {\n                    vxastro_amount: calc_voting_power(\n                        pool_info.slope,\n                        pool_info.vxastro_amount,\n                        prev_period,\n                        period,\n                    ),\n                    ..pool_info\n                }\n            } else {\n                VotedPoolInfo::default()\n            };\n\n        VotedPoolInfoResult::New(pool_info_result)\n    };\n\n    Ok(pool_info_result)\n}\n\n/// Returns pool info at specified period or calculates it.\npub(crate) fn get_pool_info(\n    storage: \u0026dyn Storage,\n    period: u64,\n    pool_addr: \u0026Addr,\n) -\u003e StdResult\u003cVotedPoolInfo\u003e {\n    let pool_info = if let Some(pool_info) = POOL_VOTES.may_load(storage, (period, pool_addr))? {\n        pool_info\n    } else if let Some(mut prev_period) = fetch_last_pool_period(storage, period, pool_addr)? {\n        let mut pool_info = POOL_VOTES.load(storage, (prev_period, pool_addr))?;\n        // Recalculating passed periods\n        let scheduled_slope_changes = fetch_slope_changes(storage, pool_addr, prev_period, period)?;\n        for (recalc_period, scheduled_change) in scheduled_slope_changes {\n            pool_info = VotedPoolInfo {\n                vxastro_amount: calc_voting_power(\n                    pool_info.slope,\n                    pool_info.vxastro_amount,\n                    prev_period,\n                    recalc_period,\n                ),\n                slope: pool_info.slope - scheduled_change,\n            };\n            prev_period = recalc_period\n        }\n\n        VotedPoolInfo {\n            vxastro_amount: calc_voting_power(\n                pool_info.slope,\n                pool_info.vxastro_amount,\n                prev_period,\n                period,\n            ),\n            ..pool_info\n        }\n    } else {\n        VotedPoolInfo::default()\n    };\n\n    Ok(pool_info)\n}\n\n/// Fetches last period for specified pool which has saved result in [`POOL_PERIODS`].\npub(crate) fn fetch_last_pool_period(\n    storage: \u0026dyn Storage,\n    period: u64,\n    pool_addr: \u0026Addr,\n) -\u003e StdResult\u003cOption\u003cu64\u003e\u003e {\n    let period_opt = POOL_PERIODS\n        .prefix(pool_addr)\n        .range(\n            storage,\n            None,\n            Some(Bound::exclusive(period)),\n            Order::Descending,\n        )\n        .next()\n        .transpose()?\n        .map(|(period, _)| period);\n    Ok(period_opt)\n}\n\n/// Fetches all slope changes between `last_period` and `period` for specific pool.\npub(crate) fn fetch_slope_changes(\n    storage: \u0026dyn Storage,\n    pool_addr: \u0026Addr,\n    last_period: u64,\n    period: u64,\n) -\u003e StdResult\u003cVec\u003c(u64, Uint128)\u003e\u003e {\n    POOL_SLOPE_CHANGES\n        .prefix(pool_addr)\n        .range(\n            storage,\n            Some(Bound::exclusive(last_period)),\n            Some(Bound::inclusive(period)),\n            Order::Ascending,\n        )\n        .collect()\n}\n\n/// Input validation for pools limit.\npub(crate) fn validate_pools_limit(number: u64) -\u003e Result\u003cu64, ContractError\u003e {\n    if !POOL_NUMBER_LIMIT.contains(\u0026number) {\n        Err(ContractError::InvalidPoolNumber(number))\n    } else {\n        Ok(number)\n    }\n}\n\n/// Check if a pool isn't the main pool. Check if a pool is an LP token.\n/// Check if a pool is registered in the factory contract.\npub fn validate_pool(\n    deps: Deps,\n    config: \u0026ConfigResponse,\n    pool: \u0026Addr,\n) -\u003e Result\u003c(), ContractError\u003e {\n    // Voting for the main pool or updating it is prohibited\n    if let Some(main_pool) = \u0026config.main_pool {\n        if pool == main_pool {\n            return Err(ContractError::MainPoolVoteOrWhitelistingProhibited(\n                main_pool.to_string(),\n            ));\n        }\n    }\n\n    // Checks if a pool is an LP token\n    let pair_info = pair_info_by_pool(\u0026deps.querier, pool.clone())\n        .map_err(|_| ContractError::InvalidLPTokenAddress(pool.to_string()))?;\n\n    // Check if a pair is registered in the factory\n    query_pair_info(\n        \u0026deps.querier,\n        config.factory_addr.clone(),\n        \u0026pair_info.asset_infos,\n    )\n    .map_err(|_| {\n        ContractError::PairNotRegistered(\n            pair_info.asset_infos[0].to_string(),\n            pair_info.asset_infos[1].to_string(),\n        )\n    })?;\n\n    Ok(())\n}\n\n/// Checks for duplicate pools\npub fn check_duplicated(votes: \u0026[Addr]) -\u003e Result\u003c(), ContractError\u003e {\n    let mut uniq = HashSet::new();\n    if !votes.iter().all(|lp_token| uniq.insert(lp_token)) {\n        return Err(ContractError::DuplicatedPools {});\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","generator_controller","tests","integration.rs"],"content":"use astroport::asset::AssetInfo;\nuse astroport::generator::PoolInfoResponse;\nuse cosmwasm_std::{attr, Addr, Decimal, StdResult, Uint128};\nuse cw_multi_test::{App, ContractWrapper, Executor};\nuse generator_controller::astroport;\nuse std::str::FromStr;\n\nuse crate::astroport::asset::PairInfo;\nuse astroport_governance::generator_controller::{\n    ConfigResponse, ExecuteMsg, QueryMsg, VOTERS_MAX_LIMIT,\n};\nuse astroport_governance::utils::{get_period, MAX_LOCK_TIME, WEEK};\nuse astroport_tests::{\n    controller_helper::ControllerHelper, escrow_helper::MULTIPLIER, mock_app, TerraAppExtension,\n};\nuse generator_controller::state::TuneInfo;\n\n#[test]\nfn update_configs() {\n    let mut router = mock_app();\n    let owner = Addr::unchecked(\"owner\");\n    let helper = ControllerHelper::init(\u0026mut router, \u0026owner);\n\n    let config = helper.query_config(\u0026mut router).unwrap();\n    assert_eq!(config.blacklisted_voters_limit, None);\n\n    // check if user2 cannot update config\n    let err = helper\n        .update_blacklisted_limit(\u0026mut router, \"user2\", Some(4u32))\n        .unwrap_err();\n    assert_eq!(\"Unauthorized\", err.root_cause().to_string());\n\n    // successful update config by owner\n    helper\n        .update_blacklisted_limit(\u0026mut router, \"owner\", Some(4u32))\n        .unwrap();\n\n    let config = helper.query_config(\u0026mut router).unwrap();\n    assert_eq!(config.blacklisted_voters_limit, Some(4u32));\n}\n\n#[test]\nfn check_kick_holders_works() {\n    let mut router = mock_app();\n    let owner = Addr::unchecked(\"owner\");\n    let helper = ControllerHelper::init(\u0026mut router, \u0026owner);\n    let pools = vec![\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"FOO\", \"BAR\")\n            .unwrap(),\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"BAR\", \"ADN\")\n            .unwrap(),\n    ];\n\n    let err = helper\n        .vote(\u0026mut router, \"user1\", vec![(pools[0].as_str(), 1000)])\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"You can't vote with zero voting power\"\n    );\n\n    helper.escrow_helper.mint_xastro(\u0026mut router, \"owner\", 100);\n    helper.escrow_helper.mint_xastro(\u0026mut router, \"user1\", 100);\n    // Create short lock\n    helper\n        .escrow_helper\n        .create_lock(\u0026mut router, \"user1\", WEEK, 100f32)\n        .unwrap();\n\n    helper\n        .update_whitelist(\n            \u0026mut router,\n            \"owner\",\n            Some(pools.iter().map(|el| el.to_string()).collect()),\n            None,\n        )\n        .unwrap();\n\n    // Votes from user1\n    helper\n        .vote(\u0026mut router, \"user1\", vec![(pools[0].as_str(), 1000)])\n        .unwrap();\n\n    helper.escrow_helper.mint_xastro(\u0026mut router, \"user2\", 100);\n    helper\n        .escrow_helper\n        .create_lock(\u0026mut router, \"user2\", 10 * WEEK, 100f32)\n        .unwrap();\n\n    // Votes from user2\n    helper\n        .vote(\n            \u0026mut router,\n            \"user2\",\n            vec![(pools[0].as_str(), 3000), (pools[1].as_str(), 7000)],\n        )\n        .unwrap();\n\n    let ve_slope = helper\n        .escrow_helper\n        .query_lock_info(\u0026mut router, \"user2\")\n        .unwrap()\n        .slope;\n    let ve_power = helper\n        .escrow_helper\n        .query_user_vp(\u0026mut router, \"user2\")\n        .unwrap();\n    let user_info = helper.query_user_info(\u0026mut router, \"user2\").unwrap();\n    assert_eq!(ve_slope, user_info.slope);\n    assert_eq!(router.block_info().time.seconds(), user_info.vote_ts);\n    assert_eq!(\n        ve_power,\n        user_info.voting_power.u128() as f32 / MULTIPLIER as f32\n    );\n    let resp_votes = user_info\n        .votes\n        .clone()\n        .into_iter()\n        .map(|(addr, bps)| (addr.to_string(), bps.into()))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(\n        vec![(pools[0].to_string(), 3000), (pools[1].to_string(), 7000)],\n        resp_votes\n    );\n\n    // Add user2 to the blacklist\n    let res = helper\n        .escrow_helper\n        .update_blacklist(\u0026mut router, Some(vec![\"user2\".to_string()]), None)\n        .unwrap();\n    assert_eq!(\n        res.events[1].attributes[1],\n        attr(\"action\", \"update_blacklist\")\n    );\n\n    // Let's take the period for which the vote was applied.\n    let current_period = router.block_period() + 1u64;\n\n    // Get pools info before kick holder\n    let res = helper\n        .query_voted_pool_info_at_period(\u0026mut router, pools[0].as_str(), current_period)\n        .unwrap();\n    assert_eq!(Uint128::new(13_576_922), res.slope);\n    assert_eq!(Uint128::new(44_471_151), res.vxastro_amount);\n\n    let res = helper\n        .query_voted_pool_info_at_period(\u0026mut router, pools[1].as_str(), current_period)\n        .unwrap();\n    assert_eq!(Uint128::new(8_009_614), res.slope);\n    assert_eq!(Uint128::new(80_096_149), res.vxastro_amount);\n\n    // check if blacklisted voters limit exceeded for kick operation\n    let err = helper\n        .kick_holders(\n            \u0026mut router,\n            \"user1\",\n            vec![\"user2\".to_string(); (VOTERS_MAX_LIMIT + 1) as usize],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"Exceeded voters limit for kick blacklisted voters operation!\",\n        err.root_cause().to_string()\n    );\n\n    // Removes votes for user2\n    helper\n        .kick_holders(\u0026mut router, \"user1\", vec![\"user2\".to_string()])\n        .unwrap();\n\n    let ve_slope = helper\n        .escrow_helper\n        .query_lock_info(\u0026mut router, \"user2\")\n        .unwrap()\n        .slope;\n    let ve_power = helper\n        .escrow_helper\n        .query_user_vp(\u0026mut router, \"user2\")\n        .unwrap();\n\n    let user_info = helper.query_user_info(\u0026mut router, \"user2\").unwrap();\n    assert_eq!(ve_slope, user_info.slope);\n    assert_eq!(router.block_info().time.seconds(), user_info.vote_ts);\n    assert_eq!(\n        ve_power,\n        user_info.voting_power.u128() as f32 / MULTIPLIER as f32\n    );\n    assert_eq!(user_info.votes, vec![]);\n\n    // Get pool info after kick holder\n    let res = helper\n        .query_voted_pool_info_at_period(\u0026mut router, pools[0].as_str(), current_period)\n        .unwrap();\n    assert_eq!(Uint128::new(10_144_230), res.slope);\n    assert_eq!(Uint128::new(10_144_230), res.vxastro_amount);\n\n    let res1 = helper\n        .query_voted_pool_info_at_period(\u0026mut router, pools[1].as_str(), current_period)\n        .unwrap();\n    assert_eq!(Uint128::new(0), res1.slope);\n    assert_eq!(Uint128::new(0), res1.vxastro_amount);\n}\n\n#[test]\nfn check_vote_works() {\n    let mut router = mock_app();\n    let owner = Addr::unchecked(\"owner\");\n    let helper = ControllerHelper::init(\u0026mut router, \u0026owner);\n    let pools = vec![\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"FOO\", \"BAR\")\n            .unwrap(),\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"BAR\", \"ADN\")\n            .unwrap(),\n    ];\n\n    let err = helper\n        .vote(\u0026mut router, \"user1\", vec![(pools[0].as_str(), 1000)])\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"You can't vote with zero voting power\"\n    );\n\n    helper.escrow_helper.mint_xastro(\u0026mut router, \"owner\", 100);\n    helper.escrow_helper.mint_xastro(\u0026mut router, \"user1\", 100);\n    // Create short lock\n    helper\n        .escrow_helper\n        .create_lock(\u0026mut router, \"user1\", WEEK, 100f32)\n        .unwrap();\n    let err = helper\n        .vote(\u0026mut router, \"user1\", vec![(pools[0].as_str(), 1000)])\n        .unwrap_err();\n    assert_eq!(\"Whitelist cannot be empty!\", err.root_cause().to_string());\n\n    let err = helper\n        .update_whitelist(\u0026mut router, \"user1\", Some(vec![pools[0].to_string()]), None)\n        .unwrap_err();\n    assert_eq!(\"Unauthorized\", err.root_cause().to_string());\n\n    helper\n        .update_whitelist(\n            \u0026mut router,\n            \"owner\",\n            Some(pools.iter().map(|el| el.to_string()).collect()),\n            None,\n        )\n        .unwrap();\n\n    helper\n        .vote(\u0026mut router, \"user1\", vec![(pools[0].as_str(), 1000)])\n        .unwrap();\n\n    helper.escrow_helper.mint_xastro(\u0026mut router, \"user2\", 100);\n    helper\n        .escrow_helper\n        .create_lock(\u0026mut router, \"user2\", 10 * WEEK, 100f32)\n        .unwrap();\n\n    // Bps is \u003e 10000\n    let err = helper\n        .vote(\u0026mut router, \"user2\", vec![(pools[1].as_str(), 10001)])\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Basic points conversion error. 10001 \u003e 10000\"\n    );\n\n    // Bps sum is \u003e 10000\n    let err = helper\n        .vote(\n            \u0026mut router,\n            \"user2\",\n            vec![(pools[0].as_str(), 3000), (pools[1].as_str(), 8000)],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Basic points sum exceeds limit\"\n    );\n\n    // Duplicated pools\n    let err = helper\n        .vote(\n            \u0026mut router,\n            \"user2\",\n            vec![(pools[0].as_str(), 3000), (pools[0].as_str(), 7000)],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Votes contain duplicated pool addresses\"\n    );\n\n    // Valid votes\n    helper\n        .vote(\n            \u0026mut router,\n            \"user2\",\n            vec![(pools[0].as_str(), 3000), (pools[1].as_str(), 7000)],\n        )\n        .unwrap();\n\n    let err = helper\n        .vote(\n            \u0026mut router,\n            \"user2\",\n            vec![(pools[0].as_str(), 7000), (pools[1].as_str(), 3000)],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"You can only run this action every 10 days\"\n    );\n\n    let ve_slope = helper\n        .escrow_helper\n        .query_lock_info(\u0026mut router, \"user2\")\n        .unwrap()\n        .slope;\n    let ve_power = helper\n        .escrow_helper\n        .query_user_vp(\u0026mut router, \"user2\")\n        .unwrap();\n    let user_info = helper.query_user_info(\u0026mut router, \"user2\").unwrap();\n    assert_eq!(ve_slope, user_info.slope);\n    assert_eq!(router.block_info().time.seconds(), user_info.vote_ts);\n    assert_eq!(\n        ve_power,\n        user_info.voting_power.u128() as f32 / MULTIPLIER as f32\n    );\n    let resp_votes = user_info\n        .votes\n        .into_iter()\n        .map(|(addr, bps)| (addr.to_string(), bps.into()))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(\n        vec![(pools[0].to_string(), 3000), (pools[1].to_string(), 7000)],\n        resp_votes\n    );\n\n    router.next_block(86400 * 10);\n    // In 10 days user will be able to vote again\n    helper\n        .vote(\n            \u0026mut router,\n            \"user2\",\n            vec![(pools[0].as_str(), 500), (pools[1].as_str(), 9500)],\n        )\n        .unwrap();\n}\n\nfn create_unregistered_pool(\n    router: \u0026mut App,\n    helper: \u0026mut ControllerHelper,\n) -\u003e StdResult\u003cPairInfo\u003e {\n    let pair_contract = Box::new(\n        ContractWrapper::new_with_empty(\n            astroport_pair::contract::execute,\n            astroport_pair::contract::instantiate,\n            astroport_pair::contract::query,\n        )\n        .with_reply_empty(astroport_pair::contract::reply),\n    );\n\n    let pair_code_id = router.store_code(pair_contract);\n\n    let test_token1 = helper.init_cw20_token(router, \"TST\").unwrap();\n    let test_token2 = helper.init_cw20_token(router, \"TSB\").unwrap();\n\n    let pair_addr = router\n        .instantiate_contract(\n            pair_code_id,\n            Addr::unchecked(\"owner\"),\n            \u0026astroport::pair::InstantiateMsg {\n                asset_infos: vec![\n                    AssetInfo::Token {\n                        contract_addr: test_token1.clone(),\n                    },\n                    AssetInfo::Token {\n                        contract_addr: test_token2.clone(),\n                    },\n                ],\n                token_code_id: 1,\n                factory_addr: helper.factory.to_string(),\n                init_params: None,\n            },\n            \u0026[],\n            \"Unregistered pair\".to_string(),\n            None,\n        )\n        .unwrap();\n\n    let res: PairInfo = router\n        .wrap()\n        .query_wasm_smart(pair_addr, \u0026astroport::pair::QueryMsg::Pair {})?;\n\n    Ok(res)\n}\n\n#[test]\nfn check_tuning() {\n    let mut router = mock_app();\n    let owner = \"owner\";\n    let owner_addr = Addr::unchecked(owner);\n    let mut helper = ControllerHelper::init(\u0026mut router, \u0026owner_addr);\n    let user1 = \"user1\";\n    let user2 = \"user2\";\n    let user3 = \"user3\";\n    let ve_locks = vec![(user1, 10), (user2, 5), (user3, 50)];\n\n    let pools = vec![\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"FOO\", \"BAR\")\n            .unwrap(),\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"BAR\", \"ADN\")\n            .unwrap(),\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"FOO\", \"ADN\")\n            .unwrap(),\n    ];\n\n    helper\n        .update_whitelist(\n            \u0026mut router,\n            \"owner\",\n            Some(pools.iter().map(|el| el.to_string()).collect()),\n            None,\n        )\n        .unwrap();\n\n    let err = helper\n        .update_whitelist(\u0026mut router, \"owner\", Some(vec![pools[0].to_string()]), None)\n        .unwrap_err();\n    assert_eq!(\"Generic error: The resulting whitelist contains duplicated pools. It's either provided 'add' list contains duplicated pools or some of the added pools are already whitelisted.\", err.root_cause().to_string());\n\n    let config_resp = helper.query_config(\u0026mut router).unwrap();\n    assert_eq!(config_resp.whitelisted_pools, pools);\n\n    for (user, duration) in ve_locks {\n        helper.escrow_helper.mint_xastro(\u0026mut router, user, 1000);\n        helper\n            .escrow_helper\n            .create_lock(\u0026mut router, user, duration * WEEK, 100f32)\n            .unwrap();\n    }\n\n    let res = create_unregistered_pool(\u0026mut router, \u0026mut helper).unwrap();\n    let err = helper\n        .vote(\n            \u0026mut router,\n            user1,\n            vec![\n                (pools[0].as_str(), 5000),\n                (pools[1].as_str(), 4000),\n                (res.liquidity_token.as_str(), 1000),\n            ],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"Pool is not whitelisted: contract23\",\n        err.root_cause().to_string()\n    );\n\n    let err = helper\n        .vote(\n            \u0026mut router,\n            user1,\n            vec![\n                (pools[0].as_str(), 5000),\n                (pools[1].as_str(), 2000),\n                (pools[1].as_str(), 2000),\n            ],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"Votes contain duplicated pool addresses\",\n        err.root_cause().to_string()\n    );\n\n    helper\n        .vote(\n            \u0026mut router,\n            user1,\n            vec![(pools[0].as_str(), 5000), (pools[1].as_str(), 5000)],\n        )\n        .unwrap();\n\n    helper\n        .vote(\n            \u0026mut router,\n            user2,\n            vec![\n                (pools[0].as_str(), 5000),\n                (pools[1].as_str(), 2000),\n                (pools[2].as_str(), 3000),\n            ],\n        )\n        .unwrap();\n    helper\n        .vote(\n            \u0026mut router,\n            user3,\n            vec![\n                (pools[0].as_str(), 2000),\n                (pools[1].as_str(), 3000),\n                (pools[2].as_str(), 5000),\n            ],\n        )\n        .unwrap();\n\n    // The contract was just created so we need to wait for 2 weeks\n    let err = helper.tune(\u0026mut router).unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"You can only run this action every 14 days\"\n    );\n\n    router.next_block(WEEK);\n    let err = helper.tune(\u0026mut router).unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"You can only run this action every 14 days\"\n    );\n\n    router.next_block(WEEK);\n\n    helper.tune(\u0026mut router).unwrap();\n\n    let resp: TuneInfo = router\n        .wrap()\n        .query_wasm_smart(helper.controller.clone(), \u0026QueryMsg::TuneInfo {})\n        .unwrap();\n    assert_eq!(get_period(resp.tune_ts).unwrap(), router.block_period());\n    assert_eq!(resp.pool_alloc_points.len(), pools.len());\n    let total_apoints: u128 = resp\n        .pool_alloc_points\n        .iter()\n        .cloned()\n        .map(|(_, apoints)| apoints.u128())\n        .sum();\n    assert_eq!(total_apoints, 357423036);\n\n    router.next_block(2 * WEEK);\n    // Reduce pools limit 5 -\u003e 2 (5 is initial limit in integration tests)\n    let limit = 2u64;\n    let err = router\n        .execute_contract(\n            Addr::unchecked(\"somebody\"),\n            helper.controller.clone(),\n            \u0026ExecuteMsg::ChangePoolsLimit { limit },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Unauthorized\");\n\n    router\n        .execute_contract(\n            owner_addr.clone(),\n            helper.controller.clone(),\n            \u0026ExecuteMsg::ChangePoolsLimit { limit },\n            \u0026[],\n        )\n        .unwrap();\n\n    let err = router\n        .execute_contract(\n            owner_addr.clone(),\n            helper.controller.clone(),\n            \u0026ExecuteMsg::ChangePoolsLimit { limit: 101 },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Invalid pool number: 101. Must be within [2, 100] range\"\n    );\n\n    helper.tune(\u0026mut router).unwrap();\n\n    let resp: TuneInfo = router\n        .wrap()\n        .query_wasm_smart(helper.controller.clone(), \u0026QueryMsg::TuneInfo {})\n        .unwrap();\n    assert_eq!(get_period(resp.tune_ts).unwrap(), router.block_period());\n    assert_eq!(resp.pool_alloc_points.len(), limit as usize);\n    let total_apoints: u128 = resp\n        .pool_alloc_points\n        .iter()\n        .cloned()\n        .map(|(_, apoints)| apoints.u128())\n        .sum();\n    assert_eq!(total_apoints, 191009600);\n\n    // Check alloc points are properly set in generator\n    for (pool_addr, apoints) in resp.pool_alloc_points {\n        let resp: PoolInfoResponse = router\n            .wrap()\n            .query_wasm_smart(\n                helper.generator.clone(),\n                \u0026astroport::generator::QueryMsg::PoolInfo {\n                    lp_token: pool_addr.to_string(),\n                },\n            )\n            .unwrap();\n        assert_eq!(apoints, resp.alloc_point)\n    }\n\n    // Check the last pool did not receive alloc points\n    let generator_resp: PoolInfoResponse = router\n        .wrap()\n        .query_wasm_smart(\n            helper.generator.clone(),\n            \u0026astroport::generator::QueryMsg::PoolInfo {\n                lp_token: pools[2].to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(generator_resp.alloc_point.u128(), 0)\n}\n\n#[test]\nfn check_bad_pools_filtering() {\n    let mut router = mock_app();\n    let owner = \"owner\";\n    let owner_addr = Addr::unchecked(owner);\n    let helper = ControllerHelper::init(\u0026mut router, \u0026owner_addr);\n    let user = \"user1\";\n\n    let foo_token = helper.init_cw20_token(\u0026mut router, \"FOO\").unwrap();\n    let bar_token = helper.init_cw20_token(\u0026mut router, \"BAR\").unwrap();\n    let adn_token = helper.init_cw20_token(\u0026mut router, \"ADN\").unwrap();\n    let pools = vec![\n        helper\n            .create_pool(\u0026mut router, \u0026foo_token, \u0026bar_token)\n            .unwrap(),\n        helper\n            .create_pool(\u0026mut router, \u0026foo_token, \u0026adn_token)\n            .unwrap(),\n        helper\n            .create_pool(\u0026mut router, \u0026bar_token, \u0026adn_token)\n            .unwrap(),\n    ];\n\n    helper.escrow_helper.mint_xastro(\u0026mut router, user, 1000);\n    helper\n        .escrow_helper\n        .create_lock(\u0026mut router, user, 10 * WEEK, 100f32)\n        .unwrap();\n\n    let err = helper\n        .update_whitelist(\n            \u0026mut router,\n            \"owner\",\n            Some(vec![(\"random_pool\".to_string())]),\n            None,\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Invalid lp token address: random_pool\"\n    );\n\n    helper\n        .update_whitelist(\n            \u0026mut router,\n            \"owner\",\n            Some(pools.iter().map(|el| el.to_string()).collect()),\n            None,\n        )\n        .unwrap();\n\n    helper\n        .vote(\u0026mut router, user, vec![(pools[0].as_str(), 5000)])\n        .unwrap();\n\n    router.next_block(2 * WEEK);\n\n    helper.tune(\u0026mut router).unwrap();\n    let resp: TuneInfo = router\n        .wrap()\n        .query_wasm_smart(helper.controller.clone(), \u0026QueryMsg::TuneInfo {})\n        .unwrap();\n    // There was only one valid pool\n    assert_eq!(resp.pool_alloc_points.len(), 1);\n\n    router.next_block(2 * WEEK);\n\n    // Deregister first pair\n    let asset_infos = vec![\n        AssetInfo::Token {\n            contract_addr: foo_token.clone(),\n        },\n        AssetInfo::Token {\n            contract_addr: bar_token.clone(),\n        },\n    ];\n    router\n        .execute_contract(\n            owner_addr.clone(),\n            helper.factory.clone(),\n            \u0026astroport::factory::ExecuteMsg::Deregister {\n                asset_infos: asset_infos.to_vec(),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // We cannot vote for deregistered pool\n    let err = helper\n        .vote(\u0026mut router, user, vec![(pools[0].as_str(), 10000)])\n        .unwrap_err();\n    assert_eq!(\n        \"The pair aren't registered: contract8-contract9\",\n        err.root_cause().to_string()\n    );\n\n    let err = helper.tune(\u0026mut router).unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"There are no pools to tune\");\n\n    router.next_block(2 * WEEK);\n\n    // Blocking FOO token so pair[0] and pair[1] become blocked as well\n    let foo_asset_info = AssetInfo::Token {\n        contract_addr: foo_token.clone(),\n    };\n    router\n        .execute_contract(\n            owner_addr.clone(),\n            helper.generator.clone(),\n            \u0026astroport::generator::ExecuteMsg::UpdateBlockedTokenslist {\n                add: Some(vec![foo_asset_info]),\n                remove: None,\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Voting for 2 valid pools\n    helper\n        .vote(\n            \u0026mut router,\n            user,\n            vec![(pools[1].as_str(), 1000), (pools[2].as_str(), 8000)],\n        )\n        .unwrap();\n\n    router.next_block(WEEK);\n    helper.tune(\u0026mut router).unwrap();\n\n    let resp: TuneInfo = router\n        .wrap()\n        .query_wasm_smart(helper.controller.clone(), \u0026QueryMsg::TuneInfo {})\n        .unwrap();\n    // Only one pool is eligible to receive alloc points\n    assert_eq!(resp.pool_alloc_points.len(), 1);\n    let total_apoints: u128 = resp\n        .pool_alloc_points\n        .iter()\n        .cloned()\n        .map(|(_, apoints)| apoints.u128())\n        .sum();\n    assert_eq!(total_apoints, 36615382)\n}\n\n#[test]\nfn check_update_owner() {\n    let mut app = mock_app();\n    let owner = Addr::unchecked(\"owner\");\n    let helper = ControllerHelper::init(\u0026mut app, \u0026owner);\n\n    let new_owner = String::from(\"new_owner\");\n\n    // New owner\n    let msg = ExecuteMsg::ProposeNewOwner {\n        new_owner: new_owner.clone(),\n        expires_in: 100, // seconds\n    };\n\n    // Unauthed check\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"not_owner\"),\n            helper.controller.clone(),\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Generic error: Unauthorized\");\n\n    // Claim before proposal\n    let err = app\n        .execute_contract(\n            Addr::unchecked(new_owner.clone()),\n            helper.controller.clone(),\n            \u0026ExecuteMsg::ClaimOwnership {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Ownership proposal not found\"\n    );\n\n    // Propose new owner\n    app.execute_contract(\n        Addr::unchecked(\"owner\"),\n        helper.controller.clone(),\n        \u0026msg,\n        \u0026[],\n    )\n    .unwrap();\n\n    // Claim from invalid addr\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"invalid_addr\"),\n            helper.controller.clone(),\n            \u0026ExecuteMsg::ClaimOwnership {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Generic error: Unauthorized\");\n\n    // Claim ownership\n    app.execute_contract(\n        Addr::unchecked(new_owner.clone()),\n        helper.controller.clone(),\n        \u0026ExecuteMsg::ClaimOwnership {},\n        \u0026[],\n    )\n    .unwrap();\n\n    // Let's query the contract state\n    let msg = QueryMsg::Config {};\n    let res: ConfigResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026helper.controller, \u0026msg)\n        .unwrap();\n\n    assert_eq!(res.owner, new_owner)\n}\n\n#[test]\nfn check_main_pool() {\n    let mut router = mock_app();\n    let owner_addr = Addr::unchecked(\"owner\");\n    let helper = ControllerHelper::init(\u0026mut router, \u0026owner_addr);\n    let pools = vec![\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"FOO\", \"BAR\")\n            .unwrap(),\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"BAR\", \"ADN\")\n            .unwrap(),\n        helper\n            .create_pool_with_tokens(\u0026mut router, \"FOO\", \"ADN\")\n            .unwrap(),\n    ];\n\n    helper.escrow_helper.mint_xastro(\u0026mut router, \"owner\", 100);\n\n    for user in [\"user1\", \"user2\"] {\n        helper.escrow_helper.mint_xastro(\u0026mut router, user, 100);\n        helper\n            .escrow_helper\n            .create_lock(\u0026mut router, user, MAX_LOCK_TIME, 100f32)\n            .unwrap();\n    }\n\n    helper\n        .update_whitelist(\n            \u0026mut router,\n            \"owner\",\n            Some(pools.iter().map(|el| el.to_string()).collect()),\n            None,\n        )\n        .unwrap();\n\n    helper\n        .vote(\n            \u0026mut router,\n            \"user1\",\n            vec![\n                (pools[0].as_str(), 1000),\n                (pools[1].as_str(), 5000),\n                (pools[2].as_str(), 4000),\n            ],\n        )\n        .unwrap();\n    let block_period = router.block_period();\n    let main_pool_info = helper\n        .query_voted_pool_info_at_period(\u0026mut router, pools[0].as_str(), block_period + 2)\n        .unwrap();\n    assert_eq!(main_pool_info.vxastro_amount.u128(), 24759614);\n\n    let err = helper\n        .update_main_pool(\n            \u0026mut router,\n            \"owner\",\n            Some(\u0026pools[0]),\n            Some(Decimal::zero()),\n            false,\n        )\n        .unwrap_err();\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"main_pool_min_alloc should be more than 0 and less than 1\"\n    );\n    let err = helper\n        .update_main_pool(\n            \u0026mut router,\n            \"owner\",\n            Some(\u0026pools[0]),\n            Some(Decimal::one()),\n            false,\n        )\n        .unwrap_err();\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"main_pool_min_alloc should be more than 0 and less than 1\"\n    );\n    helper\n        .update_main_pool(\n            \u0026mut router,\n            \"owner\",\n            Some(\u0026pools[0]),\n            Decimal::from_str(\"0.3\").ok(),\n            false,\n        )\n        .unwrap();\n\n    // From now users can't vote for the main pool\n    let err = helper\n        .vote(\n            \u0026mut router,\n            \"user2\",\n            vec![(pools[0].as_str(), 1000), (pools[1].as_str(), 9000)],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"contract11 is the main pool. Voting or whitelisting the main pool is prohibited.\"\n    );\n\n    router\n        .execute_contract(\n            owner_addr.clone(),\n            helper.controller.clone(),\n            \u0026ExecuteMsg::ChangePoolsLimit { limit: 2 },\n            \u0026[],\n        )\n        .unwrap();\n\n    router.next_block(2 * WEEK);\n    helper.tune(\u0026mut router).unwrap();\n\n    let resp: TuneInfo = router\n        .wrap()\n        .query_wasm_smart(helper.controller.clone(), \u0026QueryMsg::TuneInfo {})\n        .unwrap();\n    // 2 (limit) + 1 (main pool)\n    assert_eq!(resp.pool_alloc_points.len(), 3 as usize);\n    let total_apoints: Uint128 = resp\n        .pool_alloc_points\n        .iter()\n        .map(|(_, apoints)| apoints)\n        .sum();\n    assert_eq!(total_apoints.u128(), 318337891);\n    let main_pool_contribution = resp\n        .pool_alloc_points\n        .iter()\n        .find(|(pool, _)| pool == \u0026pools[0]);\n    assert_eq!(\n        main_pool_contribution.unwrap().1,\n        (total_apoints * Decimal::from_str(\"0.3\").unwrap())\n    );\n\n    // Remove the main pool\n    helper\n        .update_main_pool(\u0026mut router, \"owner\", None, None, true)\n        .unwrap();\n\n    router.next_block(2 * WEEK);\n    helper.tune(\u0026mut router).unwrap();\n\n    let resp: TuneInfo = router\n        .wrap()\n        .query_wasm_smart(helper.controller.clone(), \u0026QueryMsg::TuneInfo {})\n        .unwrap();\n    // The main pool was removed\n    assert_eq!(resp.pool_alloc_points.len(), 2 as usize);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","generator_controller","tests","math_test.rs"],"content":"use std::cmp::Ordering;\nuse std::collections::HashMap;\n\nuse anyhow::Result;\nuse cosmwasm_std::{Addr, Uint128};\nuse cw_multi_test::{App, AppResponse, Executor};\nuse itertools::Itertools;\nuse proptest::prelude::*;\n\nuse astroport_governance::generator_controller::ExecuteMsg;\nuse astroport_governance::utils::{calc_voting_power, MAX_LOCK_TIME, WEEK};\nuse generator_controller::bps::BasicPoints;\nuse Event::*;\nuse VeEvent::*;\n\nuse astroport_tests::{\n    controller_helper::ControllerHelper, escrow_helper::MULTIPLIER, mock_app, TerraAppExtension,\n};\n\n#[derive(Clone, Debug)]\nenum Event {\n    Vote(Vec\u003c((String, String), u16)\u003e),\n    TunePools,\n    ChangePoolLimit(u64),\n}\n\n#[derive(Clone, Debug)]\nenum VeEvent {\n    CreateLock(f64, u64),\n    IncreaseTime(u64),\n    ExtendLock(f64),\n    Withdraw,\n}\n\nstruct Simulator {\n    user_votes: HashMap\u003cString, HashMap\u003cString, u16\u003e\u003e,\n    locks: HashMap\u003cString, (Uint128, u64, f32)\u003e,\n    helper: ControllerHelper,\n    router: App,\n    owner: Addr,\n    limit: u64,\n    pairs: HashMap\u003c(String, String), Addr\u003e,\n}\n\nimpl Simulator {\n    pub fn init\u003cT: Clone + Into\u003cString\u003e\u003e(users: \u0026[T]) -\u003e Self {\n        let mut router = mock_app();\n        let owner = Addr::unchecked(\"owner\");\n        Self {\n            helper: ControllerHelper::init(\u0026mut router, \u0026owner),\n            user_votes: users\n                .iter()\n                .cloned()\n                .map(|user| (user.into(), HashMap::new()))\n                .collect(),\n            locks: HashMap::new(),\n            limit: 5,\n            pairs: HashMap::new(),\n            router,\n            owner,\n        }\n    }\n\n    fn escrow_events_router(\u0026mut self, user: \u0026str, event: VeEvent) {\n        // We don't check voting escrow errors\n        let _ = match event {\n            CreateLock(amount, interval) =\u003e {\n                self.helper\n                    .escrow_helper\n                    .mint_xastro(\u0026mut self.router, user, amount as u64);\n                self.helper.escrow_helper.create_lock(\n                    \u0026mut self.router,\n                    user,\n                    interval,\n                    amount as f32,\n                )\n            }\n            IncreaseTime(interval) =\u003e {\n                self.helper\n                    .escrow_helper\n                    .extend_lock_time(\u0026mut self.router, user, interval)\n            }\n            ExtendLock(amount) =\u003e {\n                self.helper\n                    .escrow_helper\n                    .mint_xastro(\u0026mut self.router, user, amount as u64);\n                self.helper\n                    .escrow_helper\n                    .extend_lock_amount(\u0026mut self.router, user, amount as f32)\n            }\n            Withdraw =\u003e self.helper.escrow_helper.withdraw(\u0026mut self.router, user),\n        };\n    }\n\n    fn vote(\u0026mut self, user: \u0026str, votes: Vec\u003c((String, String), u16)\u003e) -\u003e Result\u003cAppResponse\u003e {\n        let votes: Vec\u003c_\u003e = votes\n            .iter()\n            .map(|(tokens, bps)| {\n                let addr = self\n                    .pairs\n                    .get(tokens)\n                    .cloned()\n                    .expect(\u0026format!(\"Pair {}-{} was not found\", tokens.0, tokens.1));\n                (addr, *bps)\n            })\n            .collect();\n        self.helper\n            .vote(\u0026mut self.router, user, votes.clone())\n            .map(|response| {\n                let lock_info = self\n                    .helper\n                    .escrow_helper\n                    .query_lock_info(\u0026mut self.router, user)\n                    .unwrap();\n                let vp = self\n                    .helper\n                    .escrow_helper\n                    .query_user_vp(\u0026mut self.router, user)\n                    .unwrap();\n                self.locks.insert(\n                    user.to_string(),\n                    (lock_info.slope, self.router.block_period(), vp),\n                );\n                self.user_votes.insert(user.to_string(), HashMap::new());\n                for (pool, bps) in votes {\n                    self.user_votes\n                        .get_mut(user)\n                        .expect(\"User not found!\")\n                        .insert(pool.to_string(), bps);\n                }\n                let user_info = self.helper.query_user_info(\u0026mut self.router, user).unwrap();\n                let total_apoints: u16 = user_info\n                    .votes\n                    .iter()\n                    .cloned()\n                    .map(|pair| u16::from(pair.1))\n                    .sum();\n                if total_apoints \u003e 10000 {\n                    panic!(\"{} \u003e 10000\", total_apoints)\n                }\n                assert_eq!(user_info.vote_ts, self.router.block_info().time.seconds());\n                response\n            })\n    }\n\n    fn change_pool_limit(\u0026mut self, limit: u64) -\u003e Result\u003cAppResponse\u003e {\n        self.router\n            .execute_contract(\n                self.owner.clone(),\n                self.helper.controller.clone(),\n                \u0026ExecuteMsg::ChangePoolsLimit { limit },\n                \u0026[],\n            )\n            .map(|response| {\n                self.limit = limit;\n                response\n            })\n    }\n\n    pub fn event_router(\u0026mut self, user: \u0026str, event: Event) {\n        println!(\"User {} Event {:?}\", user, event);\n        match event {\n            Vote(votes) =\u003e {\n                if let Err(err) = self.vote(user, votes) {\n                    println!(\"{}\", err);\n                }\n            }\n            TunePools =\u003e {\n                if let Err(err) = self.helper.tune(\u0026mut self.router) {\n                    println!(\"{}\", err);\n                }\n            }\n            ChangePoolLimit(limit) =\u003e {\n                if let Err(err) = self.change_pool_limit(limit) {\n                    println!(\"{}\", err);\n                }\n            }\n        }\n    }\n\n    pub fn register_pools(\u0026mut self, tokens: \u0026[String]) {\n        for token1 in tokens {\n            for token2 in tokens {\n                if matches!(token1.cmp(token2), Ordering::Less) {\n                    self.pairs.insert(\n                        (token1.to_string(), token2.to_string()),\n                        self.helper\n                            .create_pool_with_tokens(\u0026mut self.router, token1, token2)\n                            .unwrap(),\n                    );\n                }\n            }\n        }\n    }\n\n    pub fn simulate_case(\n        \u0026mut self,\n        tokens: \u0026[String],\n        ve_events_tuples: \u0026[(usize, String, VeEvent)],\n        events_tuples: \u0026[(usize, String, Event)],\n    ) {\n        self.register_pools(tokens);\n        let pools = self\n            .pairs\n            .values()\n            .map(|pool_addr| pool_addr.to_string())\n            .collect_vec();\n\n        let mut events: Vec\u003cVec\u003c(String, Event)\u003e\u003e = vec![vec![]; MAX_PERIOD + 1];\n        let mut ve_events: Vec\u003cVec\u003c(String, VeEvent)\u003e\u003e = vec![vec![]; MAX_PERIOD + 1];\n\n        for (period, user, event) in events_tuples.iter().cloned() {\n            events[period].push((user, event));\n        }\n        for (period, user, event) in ve_events_tuples.iter().cloned() {\n            ve_events[period].push((user, event))\n        }\n\n        for period in 0..events.len() {\n            // vxASTRO events\n            if let Some(period_events) = ve_events.get(period) {\n                for (user, event) in period_events {\n                    self.escrow_events_router(user, event.clone())\n                }\n            }\n            // Generator controller events\n            if let Some(period_events) = events.get(period) {\n                if !period_events.is_empty() {\n                    println!(\"Period {}:\", period);\n                }\n                for (user, event) in period_events {\n                    self.event_router(user, event.clone())\n                }\n            }\n\n            let mut voted_pools: HashMap\u003cString, f32\u003e = HashMap::new();\n\n            // Checking calculations\n            for user in self.user_votes.keys() {\n                let votes = self.user_votes.get(user).unwrap();\n                if let Some((slope, start, vp)) = self.locks.get(user) {\n                    let user_vp = calc_voting_power(\n                        *slope,\n                        Uint128::from((*vp * MULTIPLIER as f32) as u128),\n                        *start,\n                        period as u64,\n                    );\n                    let user_vp = user_vp.u128() as f32 / MULTIPLIER as f32;\n                    votes.iter().for_each(|(pool, \u0026bps)| {\n                        let vp = voted_pools.entry(pool.clone()).or_default();\n                        *vp += (bps as f32 / BasicPoints::MAX as f32) * user_vp\n                    })\n                }\n            }\n            let block_period = self.router.block_period();\n            for pool_addr in \u0026pools {\n                let pool_vp = self\n                    .helper\n                    .query_voted_pool_info_at_period(\u0026mut self.router, pool_addr, block_period + 1)\n                    .unwrap()\n                    .vxastro_amount\n                    .u128() as f32\n                    / MULTIPLIER as f32;\n                let real_vp = voted_pools.get(pool_addr).cloned().unwrap_or(0f32);\n                if (pool_vp - real_vp).abs() \u003e= 10e-3 {\n                    assert_eq!(pool_vp, real_vp, \"Period: {}, pool: {}\", period, pool_addr)\n                }\n            }\n            self.router.next_block(WEEK);\n        }\n    }\n}\n\nconst MAX_PERIOD: usize = 20;\nconst MAX_USERS: usize = 10;\nconst MAX_POOLS: usize = 5;\nconst MAX_EVENTS: usize = 100;\n\nfn escrow_events_strategy() -\u003e impl Strategy\u003cValue = VeEvent\u003e {\n    prop_oneof![\n        Just(VeEvent::Withdraw),\n        (1f64..=100f64).prop_map(VeEvent::ExtendLock),\n        (WEEK..MAX_LOCK_TIME).prop_map(VeEvent::IncreaseTime),\n        ((1f64..=100f64), WEEK..MAX_LOCK_TIME).prop_map(|(a, b)| VeEvent::CreateLock(a, b)),\n    ]\n}\n\nfn vote_strategy(tokens: Vec\u003cString\u003e) -\u003e impl Strategy\u003cValue = Event\u003e {\n    prop::collection::vec(\n        (prop::sample::subsequence(tokens, 2), 1..=2500u16),\n        1..MAX_POOLS,\n    )\n    .prop_filter_map(\n        \"Accepting only BPS sum \u003c= 10000\",\n        |vec: Vec\u003c(Vec\u003cString\u003e, u16)\u003e| {\n            let votes = vec\n                .iter()\n                .into_grouping_map_by(|(pair, _)| {\n                    let mut pair = pair.clone();\n                    pair.sort();\n                    (pair[0].clone(), pair[1].clone())\n                })\n                .aggregate(|acc, _, (_, val)| Some(acc.unwrap_or(0) + *val))\n                .into_iter()\n                .collect_vec();\n            if votes.iter().map(|(_, bps)| bps).sum::\u003cu16\u003e() \u003c= 10000 {\n                Some(Event::Vote(votes))\n            } else {\n                None\n            }\n        },\n    )\n}\n\nfn controller_events_strategy(tokens: Vec\u003cString\u003e) -\u003e impl Strategy\u003cValue = Event\u003e {\n    prop_oneof![\n        Just(Event::TunePools),\n        (2..=MAX_POOLS as u64).prop_map(Event::ChangePoolLimit),\n        vote_strategy(tokens)\n    ]\n}\n\nfn generate_cases() -\u003e impl Strategy\u003c\n    Value = (\n        Vec\u003cString\u003e,\n        Vec\u003cString\u003e,\n        Vec\u003c(usize, String, VeEvent)\u003e,\n        Vec\u003c(usize, String, Event)\u003e,\n    ),\n\u003e {\n    let tokens_strategy =\n        prop::collection::hash_set(\"[A-Z]{3}\", MAX_POOLS * MAX_POOLS / 2 - MAX_POOLS);\n    let users_strategy = prop::collection::vec(\"[a-z]{10}\", 1..MAX_USERS);\n    (users_strategy, tokens_strategy).prop_flat_map(|(users, tokens)| {\n        (\n            Just(users.clone()),\n            Just(tokens.iter().cloned().collect()),\n            prop::collection::vec(\n                (\n                    1..=MAX_PERIOD,\n                    prop::sample::select(users.clone()),\n                    escrow_events_strategy(),\n                ),\n                0..MAX_EVENTS,\n            ),\n            prop::collection::vec(\n                (\n                    1..=MAX_PERIOD,\n                    prop::sample::select(users),\n                    controller_events_strategy(tokens.iter().cloned().collect_vec()),\n                ),\n                0..MAX_EVENTS,\n            ),\n        )\n    })\n}\n\nproptest! {\n    #[test]\n    fn run_simulations(\n        case in generate_cases()\n    ) {\n        let (users, tokens, ve_events_tuples, events_tuples) = case;\n        let mut simulator = Simulator::init(\u0026users);\n        simulator.simulate_case(\u0026tokens, \u0026ve_events_tuples[..], \u0026events_tuples[..]);\n    }\n}\n\n#[test]\nfn exact_simulation() {\n    let case = (\n        [\"rsgnawburh\", \"kxhuagnkvo\"],\n        [\"FOO\", \"BAR\"],\n        [\n            (4, \"rsgnawburh\", CreateLock(100.0, 1809600)),\n            (5, \"rsgnawburh\", IncreaseTime(604800)),\n            (6, \"kxhuagnkvo\", CreateLock(100.0, 604800)),\n        ],\n        [\n            (\n                4,\n                \"rsgnawburh\",\n                Vote(vec![((\"BAR\".to_string(), \"FOO\".to_string()), 10000)]),\n            ),\n            (\n                6,\n                \"kxhuagnkvo\",\n                Vote(vec![((\"BAR\".to_string(), \"FOO\".to_string()), 10000)]),\n            ),\n            (\n                6,\n                \"rsgnawburh\",\n                Vote(vec![((\"BAR\".to_string(), \"FOO\".to_string()), 10000)]),\n            ),\n        ],\n    );\n\n    let (users, tokens, ve_events_tuples, events_tuples) = case;\n    let tokens = tokens.iter().map(|item| item.to_string()).collect_vec();\n    let ve_events_tuples = ve_events_tuples\n        .iter()\n        .map(|(period, user, event)| (*period, user.to_string(), event.clone()))\n        .collect_vec();\n    let events_tuples = events_tuples\n        .iter()\n        .map(|(period, user, event)| (*period, user.to_string(), event.clone()))\n        .collect_vec();\n\n    let mut simulator = Simulator::init(\u0026users);\n    simulator.simulate_case(\u0026tokens, \u0026ve_events_tuples[..], \u0026events_tuples[..]);\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","contract.rs"],"content":"use cosmwasm_std::{entry_point, DepsMut, Env, MessageInfo, Response};\nuse cw2::set_contract_version;\n\nuse astroport::staking::{ConfigResponse, QueryMsg};\nuse astroport_governance::hub::{Config, InstantiateMsg, MigrateMsg};\n\nuse crate::{error::ContractError, state::CONFIG};\n\n/// Contract name that is used for migration.\nconst CONTRACT_NAME: \u0026str = \"astroport-hub\";\n/// Contract version that is used for migration.\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Instantiates the contract, storing the config and querying the staking contract.\n/// Returns a `Response` object on successful execution or a `ContractError` on failure.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    // Query staking contract for ASTRO and xASTRO address\n    let staking_config: ConfigResponse = deps\n        .querier\n        .query_wasm_smart(\u0026msg.staking_addr, \u0026QueryMsg::Config {})?;\n\n    let config = Config {\n        owner: deps.api.addr_validate(\u0026msg.owner)?,\n        assembly_addr: deps.api.addr_validate(\u0026msg.assembly_addr)?,\n        cw20_ics20_addr: deps.api.addr_validate(\u0026msg.cw20_ics20_addr)?,\n        staking_addr: deps.api.addr_validate(\u0026msg.staking_addr)?,\n        token_addr: staking_config.deposit_token_addr,\n        xtoken_addr: staking_config.share_token_addr,\n        generator_controller_addr: deps.api.addr_validate(\u0026msg.generator_controller_addr)?,\n        ibc_timeout_seconds: msg.ibc_timeout_seconds,\n    };\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::default())\n}\n\n/// Migrates the contract to a new version.\n#[entry_point]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    // TODO: Return error\n    Ok(Response::default())\n}\n","traces":[{"line":17,"address":[15214476,15217558,15213184],"length":1,"stats":{"Line":10},"fn_name":"instantiate"},{"line":23,"address":[994472,994250,994366],"length":1,"stats":{"Line":21},"fn_name":null},{"line":26,"address":[994598,994434,994442,994888],"length":1,"stats":{"Line":24},"fn_name":null},{"line":28,"address":[994438,994824],"length":1,"stats":{"Line":10},"fn_name":null},{"line":31,"address":[15213766,15214222,15214014],"length":1,"stats":{"Line":20},"fn_name":null},{"line":32,"address":[995158,995491,995605,995391],"length":1,"stats":{"Line":30},"fn_name":null},{"line":33,"address":[995555,996016,995818],"length":1,"stats":{"Line":21},"fn_name":null},{"line":34,"address":[995966,996292,996574],"length":1,"stats":{"Line":21},"fn_name":null},{"line":35,"address":[996444],"length":1,"stats":{"Line":12},"fn_name":null},{"line":36,"address":[996484],"length":1,"stats":{"Line":9},"fn_name":null},{"line":37,"address":[996907,997352,996524,997037],"length":1,"stats":{"Line":33},"fn_name":null},{"line":38,"address":[997069],"length":1,"stats":{"Line":9},"fn_name":null},{"line":40,"address":[997304,997930,997848],"length":1,"stats":{"Line":13},"fn_name":null},{"line":42,"address":[997900,998295],"length":1,"stats":{"Line":12},"fn_name":null},{"line":47,"address":[998680,998544],"length":1,"stats":{"Line":0},"fn_name":"migrate"},{"line":49,"address":[998625,998566],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":14,"coverable":16},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse serde_json_wasm::de::Error as SerdeError;\nuse thiserror::Error;\n\n/// This enum describes Hub's contract errors\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unable to parse: {0}\")]\n    ParseError(#[from] std::num::ParseIntError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"You can not send 0 tokens\")]\n    ZeroAmount {},\n\n    #[error(\"The provided address does not have any funds\")]\n    NoFunds {},\n\n    #[error(\"The action {} is not allowed via an IBC memo\", action)]\n    NotMemoAction { action: String },\n\n    #[error(\n        \"The action {} is not allowed via IBC and must be actioned via a tranfer memo\",\n        action\n    )]\n    NotIBCAction { action: String },\n\n    #[error(\"Memo does not conform to the expected format: {}\", reason)]\n    InvalidMemo { reason: SerdeError },\n\n    #[error(\"Got a submessage reply with unknown id: {id}\")]\n    UnknownReplyId { id: u64 },\n\n    #[error(\"Invalid submessage {0}\", reason)]\n    InvalidSubmessage { reason: String },\n\n    #[error(\"Outpost already added, remove it first: {0}\", address)]\n    OutpostAlreadyAdded { address: String },\n\n    #[error(\"No Outpost found that matches the message channels\")]\n    UnknownOutpost {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","execute.rs"],"content":"use cosmwasm_std::{\n    entry_point, from_binary, to_binary, Addr, CosmosMsg, DepsMut, Env, MessageInfo, Response,\n    StdError, StdResult, SubMsg, WasmMsg,\n};\nuse cw20::{Cw20ExecuteMsg, Cw20ReceiveMsg};\n\nuse astroport::common::{claim_ownership, drop_ownership_proposal, propose_new_owner};\nuse astroport_governance::{\n    hub::{Config, Cw20HookMsg, ExecuteMsg},\n    interchain::Hub,\n};\n\nuse crate::{\n    error::ContractError,\n    reply::STAKE_ID,\n    state::{\n        OutpostChannels, ReplyData, CONFIG, OUTPOSTS, OWNERSHIP_PROPOSAL, REPLY_DATA, USER_FUNDS,\n    },\n};\n\n/// Exposes all the execute functions available in the contract.\n///\n/// ## Execute messages\n/// * **ExecuteMsg::Receive(msg)** Receives a message of type [`Cw20ReceiveMsg`] and processes\n/// it depending on the received template.\n///\n/// * **ExecuteMsg::UpdateConfig { assembly_addr, cw20_ics20_addr }** Update parameters in the Hub contract. Only the owner is allowed to\n/// update the config\n///\n/// * **ExecuteMsg::AddOutpost { outpost_addr, cw20_ics20_channel }** Add an Outpost to the contract,\n/// allowing new IBC connections and IBC messages\n///\n/// * **ExecuteMsg::RemoveOutpost { outpost_addr }** Removes an Outpost from the contract,\n/// blocking new IBC connections as well as any IBC messages\n///\n/// * **ExecuteMsg::ProposeNewOwner { new_owner, expires_in }** Creates a new request to change\n/// contract ownership.\n///\n/// * **ExecuteMsg::DropOwnershipProposal {}** Removes a request to change contract ownership.\n///\n/// * **ExecuteMsg::ClaimOwnership {}** Claims contract ownership.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::Receive(msg) =\u003e receive_cw20(deps, env, info, msg),\n        ExecuteMsg::UpdateConfig {\n            assembly_addr,\n            cw20_ics20_addr,\n        } =\u003e update_config(deps, env, info, assembly_addr, cw20_ics20_addr),\n        ExecuteMsg::AddOutpost {\n            outpost_addr,\n            cw20_ics20_channel,\n        } =\u003e add_outpost(deps, env, info, outpost_addr, cw20_ics20_channel),\n        ExecuteMsg::RemoveOutpost { outpost_addr } =\u003e remove_outpost(deps, env, info, outpost_addr),\n        ExecuteMsg::ProposeNewOwner {\n            new_owner,\n            expires_in,\n        } =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n\n            propose_new_owner(\n                deps,\n                info,\n                env,\n                new_owner,\n                expires_in,\n                config.owner,\n                OWNERSHIP_PROPOSAL,\n            )\n            .map_err(Into::into)\n        }\n        ExecuteMsg::DropOwnershipProposal {} =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n\n            drop_ownership_proposal(deps, info, config.owner, OWNERSHIP_PROPOSAL)\n                .map_err(Into::into)\n        }\n        ExecuteMsg::ClaimOwnership {} =\u003e {\n            claim_ownership(deps, info, env, OWNERSHIP_PROPOSAL, |deps, new_owner| {\n                CONFIG\n                    .update::\u003c_, StdError\u003e(deps.storage, |mut v| {\n                        v.owner = new_owner;\n                        Ok(v)\n                    })\n                    .map(|_| ())\n            })\n            .map_err(Into::into)\n        }\n    }\n}\n\n/// Receives a message of type [`Cw20ReceiveMsg`] and processes it depending on\n/// the received template\n///\n/// Funds received here must be from the CW20-ICS20 contract and is used for\n/// actions initiated from an Outpost that require ASTRO tokens\n///\n/// * **cw20_msg** CW20 message to process\nfn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // We only allow ASTRO tokens to be sent here\n    if info.sender != config.token_addr {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    // The sender of the ASTRO tokens must be the CW20-ICS20 contract\n    if cw20_msg.sender != config.cw20_ics20_addr {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    // We can't do anything with no tokens\n    if cw20_msg.amount.is_zero() {\n        return Err(ContractError::ZeroAmount {});\n    }\n\n    // Match the CW20 template\n    match from_binary(\u0026cw20_msg.msg)? {\n        Cw20HookMsg::OutpostMemo {\n            channel,\n            sender,\n            receiver,\n            memo,\n        } =\u003e handle_outpost_memo(deps, env, cw20_msg, channel, sender, receiver, memo),\n        Cw20HookMsg::TransferFailure { receiver } =\u003e {\n            handle_transfer_failure(deps, info, cw20_msg, receiver)\n        }\n    }\n}\n\n/// Handle the JSON memo from an Outpost by matching against the available\n/// actions.\n///\n/// If the memo is not in a valid format for the actions it is\n/// considered invalid.\n///\n/// If the memo wasn't intended for us we forward it to the original\n/// intended receiver\nfn handle_outpost_memo(\n    deps: DepsMut,\n    env: Env,\n    msg: Cw20ReceiveMsg,\n    receiving_channel: String,\n    original_sender: String,\n    original_receiver: String,\n    memo: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // If the receiver is not our contract we assume this is a transfer\n    // and the memo wasn't intended for us and the transfer should be completed\n    if env.contract.address != original_receiver {\n        let msg = handle_message_memo(deps, msg, original_receiver)?;\n        return Ok(Response::default()\n            .add_message(msg)\n            .add_attribute(\"hub\", \"handle_memo\")\n            .add_attribute(\"memo_type\", \"message\")\n            .add_attribute(\"sender\", original_sender));\n    }\n\n    // But if this was intended for us, parse and handle the memo\n    let sub_msg: SubMsg = match serde_json_wasm::from_str::\u003cHub\u003e(memo.as_str()) {\n        Ok(hub) =\u003e match hub {\n            Hub::Stake {} =\u003e handle_stake_instruction(\n                deps,\n                env,\n                msg,\n                receiving_channel,\n                original_sender.clone(),\n            )?,\n            _ =\u003e {\n                return Err(ContractError::NotMemoAction {\n                    action: hub.to_string(),\n                })\n            }\n        },\n        Err(reason) =\u003e {\n            // This memo doesn't match any of our action formats\n            // In case the receiver is set to our handler contract we\n            // assume the funds were intended to have a valid action but\n            // are invalid, thus we need to fail the transaction and return\n            // the funds\n            return Err(ContractError::InvalidMemo { reason });\n        }\n    };\n\n    Ok(Response::default()\n        .add_submessage(sub_msg)\n        .add_attribute(\"hub\", \"handle_memo\")\n        .add_attribute(\"memo_type\", \"instruction\")\n        .add_attribute(\"sender\", original_sender))\n}\n\n/// Handle a stake instruction sent via memo from an Outpost\n///\n/// The full amount is staked and the resulting xASTRO is sent to the\n/// original sender on the Outpost\nfn handle_stake_instruction(\n    deps: DepsMut,\n    _env: Env,\n    msg: Cw20ReceiveMsg,\n    receiving_channel: String,\n    original_sender: String,\n) -\u003e Result\u003cSubMsg, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Stake all the received ASTRO tokens\n    // We need a SubMessage here to ensure we only mint the actual\n    // amount of ASTRO that was staked, which *might* not the full amount sent\n    let enter_msg = astroport::staking::Cw20HookMsg::Enter {};\n    let send_msg = Cw20ExecuteMsg::Send {\n        contract: config.staking_addr.to_string(),\n        amount: msg.amount,\n        msg: to_binary(\u0026enter_msg)?,\n    };\n\n    // Execute the message, we're using a CW20, so no funds added here\n    let stake_msg = WasmMsg::Execute {\n        contract_addr: config.token_addr.to_string(),\n        msg: to_binary(\u0026send_msg)?,\n        funds: vec![],\n    };\n\n    // Temporarily save the data needed for the SubMessage reply\n    let reply_data = ReplyData {\n        receiver: original_sender,\n        receiving_channel,\n    };\n    REPLY_DATA.save(deps.storage, \u0026reply_data)?;\n\n    Ok(SubMsg::reply_always(stake_msg, STAKE_ID))\n}\n\n/// Handle a memo that were sent to a different recipient and doesn't require\n/// us to action\nfn handle_message_memo(\n    deps: DepsMut,\n    msg: Cw20ReceiveMsg,\n    original_receiver: String,\n) -\u003e Result\u003cCosmosMsg, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Transfer the ASTRO to the original receiver\n    let msg = Cw20ExecuteMsg::Transfer {\n        recipient: original_receiver,\n        amount: msg.amount,\n    };\n    Ok(WasmMsg::Execute {\n        contract_addr: config.token_addr.to_string(),\n        msg: to_binary(\u0026msg)?,\n        funds: vec![],\n    }\n    .into())\n}\n\n/// Update the Hub config\nfn update_config(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    assembly_addr: Option\u003cString\u003e,\n    cw20_ics20_addr: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    // Only owner can update the config\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(assembly_addr) = assembly_addr {\n        config.assembly_addr = deps.api.addr_validate(\u0026assembly_addr)?;\n    }\n\n    if let Some(cw20_ics20_addr) = cw20_ics20_addr {\n        config.cw20_ics20_addr = deps.api.addr_validate(\u0026cw20_ics20_addr)?;\n    }\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::default())\n}\n\n/// Add an Outpost to the Hub\n///\n/// Adding an Outpost requires the Outpost address and the CW20-ICS20 channel\n/// where funds will be sent through. Adding an Outpost will allow a new IBC\n/// channel to be established with the Outpost and the Hub\nfn add_outpost(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    outpost_addr: String,\n    cw20_ics20_channel: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Only owner can add Outposts\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let result = OUTPOSTS.load(deps.storage, outpost_addr.clone());\n    if result.is_ok() {\n        return Err(ContractError::OutpostAlreadyAdded {\n            address: outpost_addr,\n        });\n    }\n\n    // The Outpost channel will be determined during the IBC handshake\n    let outpost = OutpostChannels {\n        outpost: determine_outpost_channel(),\n        cw20_ics20: cw20_ics20_channel.clone(),\n    };\n\n    // Store the CW20-ICS20 transfer channel for the Outpost\n    OUTPOSTS.save(deps.storage, outpost_addr.clone(), \u0026outpost)?;\n\n    Ok(Response::default()\n        .add_attribute(\"action\", \"add_outpost\")\n        .add_attribute(\"address\", outpost_addr)\n        .add_attribute(\"cw20_ics20_channel\", cw20_ics20_channel))\n}\n\n/// Remove and Outpost from the Hub\n///\n/// Removing an Outpost will block new IBC channels to be established between the\n/// Hub and the provided Outpost. All IBC messages will also fail\n///\n/// IMPORTANT: This does not close any existing IBC channels\nfn remove_outpost(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    outpost_addr: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Only owner can remove Outposts\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    OUTPOSTS.remove(deps.storage, outpost_addr.clone());\n\n    Ok(Response::default()\n        .add_attribute(\"action\", \"remove_outpost\")\n        .add_attribute(\"address\", outpost_addr))\n}\n\n/// Handle failed CW20-ICS20 IBC transfers\n///\n/// If a CW20-ICS20 IBC transfer fails that we initiated, we receive the original\n/// tokens back and need to store them for the user to retrieve manually\n///\n/// Once funds are held here, the original user will need to issue a withdraw\n/// transaction on the Outpost to retrieve their funds.\nfn handle_transfer_failure(\n    deps: DepsMut,\n    info: MessageInfo,\n    msg: Cw20ReceiveMsg,\n    receiver: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let user_addr = Addr::unchecked(receiver.clone());\n    USER_FUNDS.update(deps.storage, user_addr, |balance| -\u003e StdResult\u003c_\u003e {\n        Ok(balance.unwrap_or_default().checked_add(msg.amount)?)\n    })?;\n\n    Ok(Response::default()\n        .add_attribute(\"outpost_handler\", \"handle_transfer_failure\")\n        .add_attribute(\"sender\", info.sender)\n        .add_attribute(\"og_receiver\", receiver))\n}\n\n/// Determine the channel for an Outpost contract\n///\n/// This is only used for testing and must return None when deployed on-chain\n/// The channel will be determined and stored during the creation of the channel\n#[cfg(not(feature = \"mock-channels\"))]\nfn determine_outpost_channel() -\u003e Option\u003cString\u003e {\n    None\n}\n\n/// Determine the channel for an Outpost contract\n///\n/// This is only used for testing and sets the channel to a known value\n/// to be able to mock incoming messages\n#[cfg(feature = \"mock-channels\")]\nfn determine_outpost_channel() -\u003e Option\u003cString\u003e {\n    Some(\"channel-3\".to_string())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::{testing::mock_info, Uint128};\n\n    use crate::{\n        contract::instantiate,\n        execute::execute,\n        mock::{\n            mock_all, ASSEMBLY, ASTRO_TOKEN, GENERATOR_CONTROLLER, OWNER, STAKING, XASTRO_TOKEN,\n        },\n        query::query,\n    };\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Adding and removing Outposts work correctly\n    //\n    // Expect Error\n    //      - Adding an Outpost with duplicate address\n    //      - Adding an Outpost when not the owner\n    //      - Removing an Outpost when not the owner\n    //\n    #[test]\n    fn add_remove_outpost() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"wasm1contractaddress1\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"wasm1contractaddress2\".to_string(),\n                cw20_ics20_channel: \"channel-2\".to_string(),\n            },\n        )\n        .unwrap();\n\n        let outposts = query(\n            deps.as_ref(),\n            env.clone(),\n            astroport_governance::hub::QueryMsg::Outposts {},\n        )\n        .unwrap();\n\n        assert_eq!(\n            outposts,\n            to_binary(\u0026vec![\n                astroport_governance::hub::OutpostConfig {\n                    address: \"wasm1contractaddress1\".to_string(),\n                    channel: \"channel-3\".to_string(),\n                    cw20_ics20_channel: \"channel-1\".to_string(),\n                },\n                astroport_governance::hub::OutpostConfig {\n                    address: \"wasm1contractaddress2\".to_string(),\n                    channel: \"channel-3\".to_string(),\n                    cw20_ics20_channel: \"channel-2\".to_string(),\n                }\n            ])\n            .unwrap()\n        );\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::RemoveOutpost {\n                outpost_addr: \"wasm1contractaddress1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        let outposts = query(\n            deps.as_ref(),\n            env.clone(),\n            astroport_governance::hub::QueryMsg::Outposts {},\n        )\n        .unwrap();\n\n        assert_eq!(\n            outposts,\n            to_binary(\u0026vec![astroport_governance::hub::OutpostConfig {\n                address: \"wasm1contractaddress2\".to_string(),\n                channel: \"channel-3\".to_string(),\n                cw20_ics20_channel: \"channel-2\".to_string(),\n            },])\n            .unwrap()\n        );\n\n        // Must not allow duplicate Outpost addresses\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"wasm1contractaddress2\".to_string(),\n                cw20_ics20_channel: \"channel-2\".to_string(),\n            },\n        )\n        .unwrap_err();\n        assert!(matches!(\n            err,\n            ContractError::OutpostAlreadyAdded { address: _ }\n        ));\n\n        // Must not allow adding if not the owner\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(\"not_owner\", \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"wasm1contractaddress3\".to_string(),\n                cw20_ics20_channel: \"channel-4\".to_string(),\n            },\n        )\n        .unwrap_err();\n        assert!(matches!(err, ContractError::Unauthorized {}));\n\n        // Must not allow removing if not the owner\n        let err = execute(\n            deps.as_mut(),\n            env,\n            mock_info(\"not_owner\", \u0026[]),\n            astroport_governance::hub::ExecuteMsg::RemoveOutpost {\n                outpost_addr: \"wasm1contractaddress2\".to_string(),\n            },\n        )\n        .unwrap_err();\n        assert!(matches!(err, ContractError::Unauthorized {}));\n    }\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Updating config works\n    //\n    // Expect Error\n    //      - Updating config with invalid addresses\n    //      - Updating config when not the owner\n    //\n    #[test]\n    fn update_config() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        let config = query(\n            deps.as_ref(),\n            env.clone(),\n            astroport_governance::hub::QueryMsg::Config {},\n        )\n        .unwrap();\n\n        // Ensure the config set during instantiation is correct\n        assert_eq!(\n            config,\n            to_binary(\u0026astroport_governance::hub::Config {\n                owner: Addr::unchecked(OWNER),\n                assembly_addr: Addr::unchecked(ASSEMBLY),\n                cw20_ics20_addr: Addr::unchecked(\"cw20_ics20\"),\n                staking_addr: Addr::unchecked(STAKING),\n                token_addr: Addr::unchecked(ASTRO_TOKEN),\n                xtoken_addr: Addr::unchecked(XASTRO_TOKEN),\n                generator_controller_addr: Addr::unchecked(GENERATOR_CONTROLLER),\n                ibc_timeout_seconds: 10,\n            })\n            .unwrap()\n        );\n\n        // Update the Assembly and CW20-ICS20 addresses\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::UpdateConfig {\n                assembly_addr: Some(\"new_assembly\".to_string()),\n                cw20_ics20_addr: Some(\"new_cw20_ics20\".to_string()),\n            },\n        )\n        .unwrap();\n\n        // Query the new config\n        let config = query(\n            deps.as_ref(),\n            env.clone(),\n            astroport_governance::hub::QueryMsg::Config {},\n        )\n        .unwrap();\n\n        assert_eq!(\n            config,\n            to_binary(\u0026astroport_governance::hub::Config {\n                owner: Addr::unchecked(OWNER),\n                assembly_addr: Addr::unchecked(\"new_assembly\"),\n                cw20_ics20_addr: Addr::unchecked(\"new_cw20_ics20\"),\n                staking_addr: Addr::unchecked(STAKING),\n                token_addr: Addr::unchecked(ASTRO_TOKEN),\n                xtoken_addr: Addr::unchecked(XASTRO_TOKEN),\n                generator_controller_addr: Addr::unchecked(GENERATOR_CONTROLLER),\n                ibc_timeout_seconds: 10,\n            })\n            .unwrap()\n        );\n\n        // Must not allow updating with invalid addresses\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::UpdateConfig {\n                assembly_addr: Some(\"\".to_string()),\n                cw20_ics20_addr: None,\n            },\n        )\n        .unwrap_err();\n\n        assert!(matches!(err, ContractError::Std(_)));\n\n        // Must not allow updating if not the owner\n        let err = execute(\n            deps.as_mut(),\n            env,\n            mock_info(\"not_owner\", \u0026[]),\n            astroport_governance::hub::ExecuteMsg::UpdateConfig {\n                assembly_addr: Some(\"\".to_string()),\n                cw20_ics20_addr: None,\n            },\n        )\n        .unwrap_err();\n\n        assert!(matches!(err, ContractError::Unauthorized {}));\n    }\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Sending the funds results in correct balances\n    //\n    // Expect Error\n    //      - When not sent by the CW20-ICS20 contract\n    //      - When tokens are not ASTRO\n    //      - When amount is zero\n    //\n    // This tests that balances are correctly tracked by the contract in case of\n    // IBC failures that result in funds getting stuck on the Hub\n    #[test]\n    fn cw20_ics20_transfer_failure() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        let user1 = \"user1\";\n        let user2 = \"user2\";\n        let user1_funds = Uint128::from(100u128);\n        let user2_funds = Uint128::from(300u128);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        // Add an allowed Outpost\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"outpost\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        // Transfer failures are only allowed to be recorded when sent by the\n        // CW20-ICS20 contract\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::Receive(Cw20ReceiveMsg {\n                sender: \"cw20_ics20\".to_string(),\n                amount: user1_funds,\n                msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::TransferFailure {\n                    receiver: user1.to_owned(),\n                })\n                .unwrap(),\n            }),\n        )\n        .unwrap_err();\n\n        assert!(matches!(err, ContractError::Unauthorized {}));\n\n        // Transfer failures must only accept ASTRO tokens\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(\"cw20_ics20\", \u0026[]),\n            astroport_governance::hub::ExecuteMsg::Receive(Cw20ReceiveMsg {\n                sender: \"cw20_ics20\".to_string(),\n                amount: user1_funds,\n                msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::TransferFailure {\n                    receiver: user1.to_owned(),\n                })\n                .unwrap(),\n            }),\n        )\n        .unwrap_err();\n\n        assert!(matches!(err, ContractError::Unauthorized {}));\n\n        // Transfer failures will must not accept zero amounts\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(ASTRO_TOKEN, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::Receive(Cw20ReceiveMsg {\n                sender: \"cw20_ics20\".to_string(),\n                amount: Uint128::zero(),\n                msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::TransferFailure {\n                    receiver: user1.to_owned(),\n                })\n                .unwrap(),\n            }),\n        )\n        .unwrap_err();\n\n        assert!(matches!(err, ContractError::ZeroAmount {}));\n\n        // Add a valid failure for user\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(ASTRO_TOKEN, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::Receive(Cw20ReceiveMsg {\n                sender: \"cw20_ics20\".to_string(),\n                amount: user1_funds,\n                msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::TransferFailure {\n                    receiver: user1.to_owned(),\n                })\n                .unwrap(),\n            }),\n        )\n        .unwrap();\n\n        // Verify that the amount was added to the user's balance\n        let stuck_funds = USER_FUNDS\n            .load(\u0026deps.storage, Addr::unchecked(user1))\n            .unwrap();\n\n        assert_eq!(stuck_funds, user1_funds);\n\n        execute(\n            deps.as_mut(),\n            env,\n            mock_info(ASTRO_TOKEN, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::Receive(Cw20ReceiveMsg {\n                sender: \"cw20_ics20\".to_string(),\n                amount: user2_funds,\n                msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::TransferFailure {\n                    receiver: user2.to_owned(),\n                })\n                .unwrap(),\n            }),\n        )\n        .unwrap();\n\n        // Verify that the amount was added to the user's balance\n        let stuck_funds = USER_FUNDS\n            .load(\u0026deps.storage, Addr::unchecked(user2))\n            .unwrap();\n\n        assert_eq!(stuck_funds, user2_funds);\n    }\n}\n","traces":[{"line":43,"address":[795353,791776,793669],"length":1,"stats":{"Line":3},"fn_name":"execute"},{"line":49,"address":[791816],"length":1,"stats":{"Line":9},"fn_name":null},{"line":50,"address":[795329,791934],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[792151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[792376],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[795314,792601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[792811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[792828,794562,794151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[794289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[794332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[794399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[794439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[793442,792865,793178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[793306,793602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[792912,793134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[1700137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[1700095,1700192,1700390],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":87,"address":[1700315,1700222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[1700342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[1700416,1700417],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":104,"address":[776904,777914,776128],"length":1,"stats":{"Line":2},"fn_name":"receive_cw20"},{"line":110,"address":[776299,776438,776165],"length":1,"stats":{"Line":4},"fn_name":null},{"line":113,"address":[776407,776590],"length":1,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[776633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[776701,776601],"length":1,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[776732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[776712,776783],"length":1,"stats":{"Line":4},"fn_name":null},{"line":124,"address":[776818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[776884,776794,776915],"length":1,"stats":{"Line":6},"fn_name":null},{"line":129,"address":[777831,777401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[777611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[777813,777643],"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[781166,779047,777968],"length":1,"stats":{"Line":1},"fn_name":"handle_outpost_memo"},{"line":160,"address":[778249,778056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[778575,778301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[778781,778545,778928],"length":1,"stats":{"Line":3},"fn_name":null},{"line":163,"address":[778717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[778897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[778263,779098],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[779130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[779396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[779471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[779534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[779573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[779670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[779611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[779187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[779251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[780882,780611,780735],"length":1,"stats":{"Line":3},"fn_name":null},{"line":196,"address":[780671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[780851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[781200,783710,781804],"length":1,"stats":{"Line":1},"fn_name":"handle_stake_instruction"},{"line":213,"address":[781514,781368,781242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[781471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[781479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[781667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[781699,781747,781983,781824],"length":1,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[781948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[782259,782211,782402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[782375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[782956,782879,783168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[783558,783012],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[783728,784376,785122],"length":1,"stats":{"Line":1},"fn_name":"handle_message_memo"},{"line":249,"address":[783755,784107,783857],"length":1,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[784005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[784890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[784072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[784322,784497,784274,784406],"length":1,"stats":{"Line":3},"fn_name":null},{"line":259,"address":[784470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[787683,786340,785152],"length":1,"stats":{"Line":1},"fn_name":"update_config"},{"line":272,"address":[785206,785344,785489],"length":1,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[785664,785455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[785713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[785675,785796],"length":1,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[786211,785973,785827],"length":1,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[786364,785875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":284,"address":[786395,786788,786550],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[786446,786917,786999],"length":1,"stats":{"Line":2},"fn_name":null},{"line":289,"address":[786969,787368],"length":1,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[788761,789646,787712],"length":1,"stats":{"Line":8},"fn_name":"add_outpost"},{"line":304,"address":[787872,788014,787754],"length":1,"stats":{"Line":11},"fn_name":null},{"line":307,"address":[787983,788169],"length":1,"stats":{"Line":10},"fn_name":null},{"line":308,"address":[788226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[788185,788303],"length":1,"stats":{"Line":11},"fn_name":null},{"line":312,"address":[788396,788341],"length":1,"stats":{"Line":10},"fn_name":null},{"line":313,"address":[788473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[788430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[788410],"length":1,"stats":{"Line":2},"fn_name":null},{"line":321,"address":[788589],"length":1,"stats":{"Line":8},"fn_name":null},{"line":325,"address":[788821,788726,788938],"length":1,"stats":{"Line":11},"fn_name":null},{"line":327,"address":[789396,789313,789225,788911],"length":1,"stats":{"Line":27},"fn_name":null},{"line":329,"address":[789282],"length":1,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[789365],"length":1,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[789664,790701,790639],"length":1,"stats":{"Line":1},"fn_name":"remove_outpost"},{"line":345,"address":[789803,789701,789939],"length":1,"stats":{"Line":2},"fn_name":null},{"line":348,"address":[789911,790091],"length":1,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[790150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[790363,790107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[790385,790492],"length":1,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[790461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[790720,791606,791673],"length":1,"stats":{"Line":1},"fn_name":"handle_transfer_failure"},{"line":372,"address":[790853,790764],"length":1,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[790883,791119],"length":1,"stats":{"Line":2},"fn_name":null},{"line":374,"address":[1700000,1699877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":377,"address":[791362,791274,791034,791441],"length":1,"stats":{"Line":4},"fn_name":null},{"line":379,"address":[791331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[791410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":397,"address":[791696],"length":1,"stats":{"Line":9},"fn_name":"determine_outpost_channel"},{"line":398,"address":[791709],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":93,"coverable":109},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","ibc.rs"],"content":"use cosmwasm_std::{\n    entry_point, from_binary, to_binary, Deps, DepsMut, Env, Ibc3ChannelOpenResponse,\n    IbcBasicResponse, IbcChannelCloseMsg, IbcChannelConnectMsg, IbcChannelOpenMsg,\n    IbcChannelOpenResponse, IbcOrder, IbcPacketAckMsg, IbcPacketReceiveMsg, IbcPacketTimeoutMsg,\n    IbcReceiveResponse, StdError, StdResult, SubMsg,\n};\n\nuse astroport_governance::interchain::{get_contract_from_ibc_port, Hub, Outpost, Response};\n\nuse crate::{\n    error::ContractError,\n    ibc_governance::{\n        handle_ibc_cast_assembly_vote, handle_ibc_cast_emissions_vote, handle_ibc_unlock,\n    },\n    ibc_misc::handle_ibc_withdraw_stuck_funds,\n    ibc_query::handle_ibc_query_proposal,\n    ibc_staking::{construct_unstake_msg, handle_ibc_unstake},\n    reply::UNSTAKE_ID,\n    state::OUTPOSTS,\n};\n\npub const IBC_APP_VERSION: \u0026str = \"astroport-outpost-v1\";\npub const IBC_ORDERING: IbcOrder = IbcOrder::Unordered;\n\n/// Handle the opening of a new IBC channel\n///\n/// We verify that the connection is using the correct configuration\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_channel_open(\n    _deps: DepsMut,\n    _env: Env,\n    msg: IbcChannelOpenMsg,\n) -\u003e Result\u003cIbcChannelOpenResponse, ContractError\u003e {\n    let channel = msg.channel();\n\n    if channel.order != IBC_ORDERING {\n        return Err(ContractError::Std(StdError::generic_err(\n            \"Ordering is invalid. The channel must be unordered\".to_string(),\n        )));\n    }\n    if channel.version != IBC_APP_VERSION {\n        return Err(ContractError::Std(StdError::generic_err(format!(\n            \"Must set version to `{IBC_APP_VERSION}`\"\n        ))));\n    }\n\n    if let Some(counter_version) = msg.counterparty_version() {\n        if counter_version != IBC_APP_VERSION {\n            return Err(ContractError::Std(StdError::generic_err(format!(\n                \"Counterparty version must be `{IBC_APP_VERSION}`\"\n            ))));\n        }\n    }\n\n    Ok(Some(Ibc3ChannelOpenResponse {\n        version: IBC_APP_VERSION.to_string(),\n    }))\n}\n\n/// Handle the connection of a new IBC channel\n///\n/// We verify that the connection is being made to an allowed Outpost and\n/// if the channel has not been set, add it\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_channel_connect(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcChannelConnectMsg,\n) -\u003e Result\u003cIbcBasicResponse, ContractError\u003e {\n    let channel = msg.channel();\n\n    // Ensure only a listed Outpost can connect, if allowed and not added yet - add it now\n    let counterparty_port =\n        get_contract_from_ibc_port(channel.counterparty_endpoint.port_id.as_str());\n    OUTPOSTS.update(deps.storage, counterparty_port.to_string(), |outpost| {\n        outpost\n            .ok_or(ContractError::Std(StdError::generic_err(format!(\n                \"Connection with `{}` is not allowed\",\n                counterparty_port\n            ))))\n            .and_then(|mut channels| match channels.outpost {\n                // If we already have the channel set, fail\n                Some(_) =\u003e Err(ContractError::Std(StdError::generic_err(format!(\n                    \"Channel with `{}` has already been set\",\n                    counterparty_port\n                )))),\n                None =\u003e {\n                    channels.outpost = Some(channel.endpoint.channel_id.clone());\n                    Ok(channels)\n                }\n            })\n    })?;\n\n    Ok(IbcBasicResponse::new()\n        .add_attribute(\"action\", \"ibc_connect\")\n        .add_attribute(\"channel_id\", \u0026channel.endpoint.channel_id))\n}\n\n/// Handle the receiving the packets while wrapping the actual call to provide\n/// returning errors as an acknowledgement.\n///\n/// This allows the original caller from another chain to handle the failure\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_packet_receive(\n    deps: DepsMut,\n    env: Env,\n    msg: IbcPacketReceiveMsg,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    block_unauthorized_packets(deps.as_ref(), msg.packet.src.port_id.clone())?;\n\n    do_packet_receive(deps, env, msg).or_else(|err| {\n        // Construct an error acknowledgement that can be handled on the Outpost\n        let ack_data = to_binary(\u0026Response::new_error(err.to_string())).unwrap();\n\n        Ok(IbcReceiveResponse::new()\n            .add_attribute(\"action\", \"ibc_packet_receive\")\n            .add_attribute(\"error\", err.to_string())\n            .set_ack(ack_data))\n    })\n}\n\n/// Process the received packet and return the response\n///\n/// Packets are expected to be wrapped in the Hub format, if it doesn't conform\n/// it will be failed.\n///\n/// If a ContractError is returned, it will be wrapped into a Response\n/// containing the error to be handled on the Outpost\nfn do_packet_receive(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcPacketReceiveMsg,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    // Parse the packet data into a Hub message\n    let outpost_msg: Hub = from_binary(\u0026msg.packet.data)?;\n    match outpost_msg {\n        Hub::QueryProposal { id } =\u003e handle_ibc_query_proposal(deps, id),\n        Hub::CastAssemblyVote {\n            proposal_id,\n            voter,\n            vote_option,\n            voting_power,\n        } =\u003e handle_ibc_cast_assembly_vote(deps, proposal_id, voter, vote_option, voting_power),\n        Hub::CastEmissionsVote {\n            voter,\n            voting_power,\n            votes,\n        } =\u003e handle_ibc_cast_emissions_vote(deps, voter, voting_power, votes),\n        Hub::Unstake { receiver, amount } =\u003e {\n            handle_ibc_unstake(deps, msg.packet.dest.channel_id, receiver, amount)\n        }\n        Hub::KickUnlockedVoter { voter } =\u003e handle_ibc_unlock(deps, voter),\n        Hub::WithdrawFunds { user } =\u003e {\n            handle_ibc_withdraw_stuck_funds(deps, msg.packet.dest.channel_id, user)\n        }\n        _ =\u003e Err(ContractError::NotIBCAction {\n            action: outpost_msg.to_string(),\n        }),\n    }\n}\n\n/// Handle IBC packet timeouts for messages we sent\n///\n/// Timeouts will cause certain actions to be reversed and, when applicable, return\n/// funds to the user\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_packet_timeout(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcPacketTimeoutMsg,\n) -\u003e Result\u003cIbcBasicResponse, ContractError\u003e {\n    // We check the destination port for timeouts as that is where the original\n    // packet was sent to\n    block_unauthorized_packets(deps.as_ref(), msg.packet.dest.port_id)?;\n\n    let failed_msg: Outpost = from_binary(\u0026msg.packet.data)?;\n    match failed_msg {\n        Outpost::MintXAstro { receiver, amount } =\u003e {\n            // If we get a timeout on a packet to mint remote xASTRO\n            // we need to undo the transaction and return the original ASTRO\n            // If we get another timeout returning the original ASTRO the funds\n            // will be held in this contract to withdraw later\n            let msg =\n                construct_unstake_msg(deps, msg.packet.dest.channel_id, receiver.clone(), amount)?;\n            let sub_msg = SubMsg::reply_always(msg, UNSTAKE_ID);\n\n            Ok(IbcBasicResponse::new()\n                .add_attribute(\"action\", \"ibc_packet_timeout\")\n                .add_submessage(sub_msg)\n                .add_attribute(\"original_action\", \"mint_remote_xastro\")\n                .add_attribute(\"original_receiver\", receiver)\n                .add_attribute(\"original_amount\", amount.to_string()))\n        }\n    }\n}\n\n/// Handle IBC packet acknowledgements for messages we sent\n///\n/// We don't need acks for now, we handle failures instead\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_packet_ack(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcPacketAckMsg,\n) -\u003e Result\u003cIbcBasicResponse, ContractError\u003e {\n    // We check the destination port for acks as that is where the original\n    // packet was sent to\n    block_unauthorized_packets(deps.as_ref(), msg.original_packet.dest.port_id)?;\n    Ok(IbcBasicResponse::new().add_attribute(\"action\", \"ibc_packet_ack\"))\n}\n\n/// Handle the closing of IBC channels, which we don't allow\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_channel_close(\n    _deps: DepsMut,\n    _env: Env,\n    _channel: IbcChannelCloseMsg,\n) -\u003e StdResult\u003cIbcBasicResponse\u003e {\n    Err(StdError::generic_err(\"Closing channel is not allowed\"))\n}\n\n/// Checks the provided port against the Outpost list.\n///\n/// If the port doesn't exist, this function will  return an error, effectively blocking the packet.\nfn block_unauthorized_packets(deps: Deps, port_id: String) -\u003e Result\u003c(), ContractError\u003e {\n    let counterparty_port = get_contract_from_ibc_port(port_id.as_str());\n    OUTPOSTS\n        .load(deps.storage, counterparty_port.to_string())\n        .map(|_| ())\n        .map_err(|_| ContractError::Unauthorized {})\n}\n","traces":[{"line":29,"address":[1716707,1716734,1715584],"length":1,"stats":{"Line":0},"fn_name":"ibc_channel_open"},{"line":34,"address":[1715619,1715681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1715689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[1715782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[1715755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[1715733,1715875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[1715910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[1715886,1716151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[1716228,1716292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[1716298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[1716602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[1716258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[1717606,1717633,1716752],"length":1,"stats":{"Line":0},"fn_name":"ibc_channel_connect"},{"line":70,"address":[1716854,1716792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[1716862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[1065371,1064880,1065344],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":76,"address":[1065234,1064906,1065305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[1064954,1065031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[1065392,1066034,1065424,1065279],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":83,"address":[1065512,1065585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[1065481,1065791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[1065957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[1717483,1717403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[1717479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[1717648,1718210],"length":1,"stats":{"Line":6},"fn_name":"ibc_packet_receive"},{"line":109,"address":[1717680,1717777,1718024],"length":1,"stats":{"Line":12},"fn_name":null},{"line":111,"address":[1066411,1066192,1066828],"length":1,"stats":{"Line":9},"fn_name":"{closure#0}"},{"line":113,"address":[1066213,1066280],"length":1,"stats":{"Line":4},"fn_name":null},{"line":115,"address":[1066463,1066761,1066602,1066699],"length":1,"stats":{"Line":7},"fn_name":null},{"line":116,"address":[1066538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[1066554,1066734,1066657],"length":1,"stats":{"Line":4},"fn_name":null},{"line":118,"address":[1066665],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[1712768,1714392,1715234],"length":1,"stats":{"Line":6},"fn_name":"do_packet_receive"},{"line":135,"address":[1712808,1713233,1712952],"length":1,"stats":{"Line":13},"fn_name":null},{"line":136,"address":[1713187],"length":1,"stats":{"Line":7},"fn_name":null},{"line":137,"address":[1713481,1714292],"length":1,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[1713579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[1713676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[1713786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[1713846,1714286],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[1714284,1713914],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[1713981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[1714282,1714015],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[1714144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[1713461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[1721115,1719248,1718256],"length":1,"stats":{"Line":0},"fn_name":"ibc_packet_timeout"},{"line":174,"address":[1718288,1718437,1718565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[1718680,1718980,1718541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[1718825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[1719281,1719699,1719229,1718905,1719081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[1720174,1719543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[1720239,1720456,1720337,1720652,1720182,1720579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[1720291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[1720503,1720416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[1720644,1720511,1720769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[1722381,1721136,1721522],"length":1,"stats":{"Line":0},"fn_name":"ibc_packet_ack"},{"line":208,"address":[1721162,1721241,1721367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[1721340,1721822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[1722548,1722400,1722612],"length":1,"stats":{"Line":0},"fn_name":"ibc_channel_close"},{"line":219,"address":[1722424,1722494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[1715550,1715264],"length":1,"stats":{"Line":6},"fn_name":"block_unauthorized_packets"},{"line":226,"address":[1715367,1715299],"length":1,"stats":{"Line":12},"fn_name":null},{"line":227,"address":[1715459],"length":1,"stats":{"Line":6},"fn_name":null},{"line":228,"address":[1715419],"length":1,"stats":{"Line":6},"fn_name":null},{"line":229,"address":[1064817,1064816],"length":1,"stats":{"Line":12},"fn_name":"{closure#0}"},{"line":230,"address":[1064832,1064855],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"}],"covered":24,"coverable":66},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","ibc_governance.rs"],"content":"use cosmwasm_std::{to_binary, Addr, DepsMut, IbcReceiveResponse, Uint128, WasmMsg};\n\nuse astroport_governance::{\n    assembly::ProposalVoteOption, generator_controller_lite, interchain::Response,\n};\n\nuse crate::{error::ContractError, state::CONFIG};\n\n/// Handle an IBC message to cast a vote on an Assembly proposal from an Outpost\n/// and return an IBC acknowledgement\n///\n/// The Outpost is responsible for checking and sending the voting power of the\n/// voter, we add an additional check to make sure that the voting power is not\n/// more than the xASTRO minted remotely via this channel\npub fn handle_ibc_cast_assembly_vote(\n    deps: DepsMut,\n    proposal_id: u64,\n    voter: Addr,\n    vote_option: ProposalVoteOption,\n    voting_power: Uint128,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // TODO Invariant check, voting power can't be more than the xASTRO sent via this channel\n\n    // Cast the vote in the Assembly\n    let vote_msg = astroport_governance::assembly::ExecuteMsg::CastOutpostVote {\n        proposal_id,\n        voter: voter.clone(),\n        vote: vote_option,\n        voting_power,\n    };\n    let msg = WasmMsg::Execute {\n        contract_addr: config.assembly_addr.to_string(),\n        msg: to_binary(\u0026vote_msg)?,\n        funds: vec![],\n    };\n\n    // If the vote succeeds, the ack will be sent back to the Outpost\n    let ack_data = to_binary(\u0026Response::new_success(\n        \"cast_assembly_vote\".to_owned(),\n        voter.to_string(),\n    ))?;\n\n    Ok(IbcReceiveResponse::new().add_message(msg).set_ack(ack_data))\n}\n\n/// Handle an IBC message to cast a vote on emissions during a voting period\n/// from an Outpost and return an IBC acknowledgement\n///\n/// The Outpost is responsible for checking and sending the voting power of the\n/// voter, we add an additional check to make sure that the voting power is not\n/// more than the xASTRO minted remotely via this channel. vxASTRO lite does\n/// not boost voting power and must be equal to the deposit\npub fn handle_ibc_cast_emissions_vote(\n    deps: DepsMut,\n    voter: Addr,\n    voting_power: Uint128,\n    votes: Vec\u003c(String, u16)\u003e,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // TODO Invariant check, voting power can't be more than the xASTRO sent via this channel\n\n    // Cast the emissions vote\n    let vote_msg = generator_controller_lite::ExecuteMsg::OutpostVote {\n        voter: voter.clone(),\n        votes,\n        voting_power,\n    };\n    let msg = WasmMsg::Execute {\n        contract_addr: config.generator_controller_addr.to_string(),\n        msg: to_binary(\u0026vote_msg)?,\n        funds: vec![],\n    };\n\n    // If the vote succeeds, the ack will be sent back to the Outpost\n    let ack_data = to_binary(\u0026Response::new_success(\n        \"cast_emissions_vote\".to_owned(),\n        voter.to_string(),\n    ))?;\n\n    Ok(IbcReceiveResponse::new().add_message(msg).set_ack(ack_data))\n}\n\n/// Handle an IBC message to kick an unlocked voter from the Outpost.\n///\n/// We rely on the Outpost to verify the unlock before sending it here. If this\n/// transaction succeeds, the voting power will be removed immediately\npub fn handle_ibc_unlock(deps: DepsMut, user: Addr) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Remove the vxASTRO voter's voting power\n    let unlock_msg = generator_controller_lite::ExecuteMsg::KickUnlockedOutpostVoter {\n        unlocked_voter: user.clone(),\n    };\n    let msg = WasmMsg::Execute {\n        contract_addr: config.generator_controller_addr.to_string(),\n        msg: to_binary(\u0026unlock_msg)?,\n        funds: vec![],\n    };\n\n    // If the vote succeeds, the ack will be sent back to the Outpost\n    let ack_data = to_binary(\u0026Response::new_success(\n        \"kick_unlocked\".to_owned(),\n        user.to_string(),\n    ))?;\n\n    Ok(IbcReceiveResponse::new().add_message(msg).set_ack(ack_data))\n}\n\n#[cfg(test)]\nmod tests {\n    use astroport_governance::interchain::Hub;\n    use cosmwasm_std::{from_binary, testing::mock_info, IbcPacketReceiveMsg, ReplyOn, SubMsg};\n\n    use super::*;\n    use crate::{\n        contract::instantiate,\n        execute::execute,\n        ibc::ibc_packet_receive,\n        mock::{mock_all, mock_ibc_packet, ASSEMBLY, GENERATOR_CONTROLLER, OWNER, STAKING},\n    };\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Submitting the vote results in an Assembly message\n    //\n    // Expect Error\n    //      - An error is returned instead\n    #[test]\n    fn ibc_assembly_vote() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        let voter = \"voter1234\";\n        let voting_power = Uint128::from(100u128);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"outpost\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        let proposal_id = 1u64;\n        let vote_option = ProposalVoteOption::For;\n\n        let ibc_unstake = to_binary(\u0026Hub::CastAssemblyVote {\n            proposal_id,\n            voter: Addr::unchecked(voter),\n            vote_option,\n            voting_power,\n        })\n        .unwrap();\n        let recv_packet = mock_ibc_packet(\"default\", ibc_unstake);\n\n        let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n        let res = ibc_packet_receive(deps.as_mut(), env, msg).unwrap();\n\n        let hub_respone: Response = from_binary(\u0026res.acknowledgement).unwrap();\n        match hub_respone {\n            Response::Result { error, .. } =\u003e {\n                assert!(error.is_none());\n            }\n            _ =\u003e panic!(\"Wrong response type\"),\n        }\n\n        assert_eq!(res.messages.len(), 1);\n\n        let assembly_msg = to_binary(\n            \u0026astroport_governance::assembly::ExecuteMsg::CastOutpostVote {\n                proposal_id,\n                vote: ProposalVoteOption::For,\n                voter: Addr::unchecked(voter),\n                voting_power,\n            },\n        )\n        .unwrap();\n\n        assert_eq!(\n            res.messages[0],\n            SubMsg {\n                id: 0,\n                gas_limit: None,\n                reply_on: ReplyOn::Never,\n                msg: WasmMsg::Execute {\n                    contract_addr: ASSEMBLY.to_string(),\n                    msg: assembly_msg,\n                    funds: vec![],\n                }\n                .into(),\n            }\n        );\n    }\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Submitting the vote results in a Generator controller message\n    //\n    // Expect Error\n    //      - An error is returned instead\n    #[test]\n    fn ibc_emissions_vote() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        let voter = \"voter1234\";\n        let voting_power = Uint128::from(100u128);\n        let votes = vec![(\"pooladdress\".to_string(), 10000)];\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"outpost\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        let ibc_unstake = to_binary(\u0026Hub::CastEmissionsVote {\n            voter: Addr::unchecked(voter),\n            voting_power,\n            votes: votes.clone(),\n        })\n        .unwrap();\n        let recv_packet = mock_ibc_packet(\"channel-3\", ibc_unstake);\n\n        let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n        let res = ibc_packet_receive(deps.as_mut(), env, msg).unwrap();\n\n        let hub_respone: Response = from_binary(\u0026res.acknowledgement).unwrap();\n        match hub_respone {\n            Response::Result { error, .. } =\u003e {\n                assert!(error.is_none());\n            }\n            _ =\u003e panic!(\"Wrong response type\"),\n        }\n\n        assert_eq!(res.messages.len(), 1);\n\n        let generator_controller_msg = to_binary(\n            \u0026astroport_governance::generator_controller_lite::ExecuteMsg::OutpostVote {\n                voter: Addr::unchecked(voter),\n                voting_power,\n                votes,\n            },\n        )\n        .unwrap();\n\n        assert_eq!(\n            res.messages[0],\n            SubMsg {\n                id: 0,\n                gas_limit: None,\n                reply_on: ReplyOn::Never,\n                msg: WasmMsg::Execute {\n                    contract_addr: GENERATOR_CONTROLLER.to_string(),\n                    msg: generator_controller_msg,\n                    funds: vec![],\n                }\n                .into(),\n            }\n        );\n    }\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Kicking the user results in a Generator controller message\n    //\n    // Expect Error\n    //      - An error is returned instead\n    #[test]\n    fn ibc_kick_unlocked() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        let voter = \"voter1234\";\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        // Add an allowed Outpost\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"outpost\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        // Kick the voter\n        let ibc_kick_unlocked = to_binary(\u0026Hub::KickUnlockedVoter {\n            voter: Addr::unchecked(voter),\n        })\n        .unwrap();\n        let recv_packet = mock_ibc_packet(\"channel-3\", ibc_kick_unlocked);\n\n        let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n        let res = ibc_packet_receive(deps.as_mut(), env, msg).unwrap();\n\n        let hub_respone: Response = from_binary(\u0026res.acknowledgement).unwrap();\n        match hub_respone {\n            Response::Result { error, .. } =\u003e {\n                assert!(error.is_none());\n            }\n            _ =\u003e panic!(\"Wrong response type\"),\n        }\n\n        // We must have one message\n        assert_eq!(res.messages.len(), 1);\n\n        // Verify that the message matches the expected message\n        let controller_msg = to_binary(\n        \u0026astroport_governance::generator_controller_lite::ExecuteMsg::KickUnlockedOutpostVoter {\n            unlocked_voter: Addr::unchecked(voter),\n        },\n        )\n        .unwrap();\n\n        assert_eq!(\n            res.messages[0],\n            SubMsg {\n                id: 0,\n                gas_limit: None,\n                reply_on: ReplyOn::Never,\n                msg: WasmMsg::Execute {\n                    contract_addr: GENERATOR_CONTROLLER.to_string(),\n                    msg: controller_msg,\n                    funds: vec![],\n                }\n                .into(),\n            }\n        );\n    }\n}\n","traces":[{"line":15,"address":[1270576,1271325,1272828],"length":1,"stats":{"Line":1},"fn_name":"handle_ibc_cast_assembly_vote"},{"line":22,"address":[1270901,1270662,1270772],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[1270886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[1271139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[1271336,1271223,1271271,1271427],"length":1,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[1271400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[1272252,1271964,1272037,1271897],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[1271763,1271836],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[1271844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[1272396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[1273633,1272848,1275225],"length":1,"stats":{"Line":1},"fn_name":"handle_ibc_cast_emissions_vote"},{"line":61,"address":[1273158,1273027,1272901],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[1273143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1273444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[1273531,1273735,1273644,1273579],"length":1,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[1273708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[1274272,1274345,1274560,1274205],"length":1,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[1274071,1274144],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[1274152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[1274774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[1277390,1275248,1275887],"length":1,"stats":{"Line":1},"fn_name":"handle_ibc_unlock"},{"line":91,"address":[1275270,1275380,1275509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[1275494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[1275698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[1275898,1275833,1275785,1275989],"length":1,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[1275962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[1276459,1276526,1276814,1276599],"length":1,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[1276325,1276398],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[1276406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[1276958],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":30,"coverable":30},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","ibc_misc.rs"],"content":"use cosmwasm_std::{to_binary, Addr, DepsMut, IbcReceiveResponse, WasmMsg};\nuse cw20::Cw20ExecuteMsg;\n\nuse astroport_governance::interchain::{Response, TransferMsg};\n\nuse crate::{\n    error::ContractError,\n    state::{get_transfer_channel_from_outpost_channel, CONFIG, USER_FUNDS},\n};\n\n/// Handle an IBC message to withdraw funds stuck on the Hub\n///\n/// In some cases where the CW20-ICS20 IBC transfer to the Outpost user fails\n/// (due to timeout or otherwise), the funds will be stuck on the Hub chain. In\n/// such a case the CW20-ICS20 contract will send the funds back here and this\n/// function will attempt to send them back to the user.\npub fn handle_ibc_withdraw_stuck_funds(\n    deps: DepsMut,\n    receive_channel: String,\n    user: Addr,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Check if this user has any funds stuck on the Hub chain\n    let balance = USER_FUNDS.load(deps.storage, user.clone())?;\n    if balance.is_zero() {\n        return Err(ContractError::NoFunds {});\n    }\n\n    // Map the channel the request was received on to the channel used in the\n    // CW20-ICS20 transfer\n    // We can use the request channel safely as the Outpost contract enforces the\n    // address, we can't receive a request for funds for a different address from an\n    // incorrect Outpost\n    // Example, and Injective address can't request funds from a Neutron channel\n    let outpost_channels =\n        get_transfer_channel_from_outpost_channel(deps.as_ref(), \u0026receive_channel)?;\n\n    // User has funds, try to send it back to them\n    let transfer_msg = TransferMsg {\n        channel: outpost_channels.cw20_ics20,\n        remote_address: user.to_string(),\n        timeout: Some(config.ibc_timeout_seconds),\n        memo: None,\n    };\n\n    let send_msg = Cw20ExecuteMsg::Send {\n        contract: config.cw20_ics20_addr.to_string(),\n        amount: balance,\n        msg: to_binary(\u0026transfer_msg)?,\n    };\n\n    let msg = WasmMsg::Execute {\n        contract_addr: config.token_addr.to_string(),\n        msg: to_binary(\u0026send_msg)?,\n        funds: vec![],\n    };\n\n    // This acknowledgement only indicates that the withdraw was processed without\n    // error, not that the funds were successfully transferred over IBC to the user\n    let ack_data = to_binary(\u0026Response::new_success(\n        \"withdraw_funds\".to_owned(),\n        user.to_string(),\n    ))?;\n\n    // We're sending everything back to the user, so we can delete their balance\n    // If this fails again, the balance will be re-added from the CW20-ICS20 contract\n    USER_FUNDS.remove(deps.storage, user);\n\n    Ok(IbcReceiveResponse::new().set_ack(ack_data).add_message(msg))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use astroport_governance::interchain::{self, Hub, TransferMsg};\n    use cosmwasm_std::{\n        from_binary, testing::mock_info, IbcPacketReceiveMsg, ReplyOn, SubMsg, Uint128,\n    };\n    use cw20::Cw20ReceiveMsg;\n\n    use crate::{\n        contract::instantiate,\n        execute::execute,\n        ibc::ibc_packet_receive,\n        mock::{mock_all, mock_ibc_packet, ASSEMBLY, GENERATOR_CONTROLLER, OWNER, STAKING},\n    };\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Withdrawing stuck funds results in IBC message\n    //\n    // Expect Error\n    //      - When address has no funds stuck\n    //\n    // This tests that balances are correctly tracked by the contract in case of\n    // IBC failures that result in funds getting stuck on the Hub\n    #[test]\n    fn ibc_withdraw_stuck_funds() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        let stuck_amount = Uint128::from(100u128);\n        let user = \"user1\";\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"outpost\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        // Add a valid failure\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(\"astro\", \u0026[]),\n            astroport_governance::hub::ExecuteMsg::Receive(Cw20ReceiveMsg {\n                sender: \"cw20_ics20\".to_string(),\n                amount: stuck_amount,\n                msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::TransferFailure {\n                    receiver: user.to_owned(),\n                })\n                .unwrap(),\n            }),\n        )\n        .unwrap();\n\n        // Withdraw must fail if the user has no funds stuck\n        let ibc_withdraw = to_binary(\u0026Hub::WithdrawFunds {\n            user: Addr::unchecked(\"not_user\"),\n        })\n        .unwrap();\n        let recv_packet = mock_ibc_packet(\"channel-3\", ibc_withdraw);\n        let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n        let res = ibc_packet_receive(deps.as_mut(), env.clone(), msg).unwrap();\n\n        let hub_respone: interchain::Response = from_binary(\u0026res.acknowledgement).unwrap();\n        match hub_respone {\n            interchain::Response::Result { error, .. } =\u003e {\n                assert!(error.is_some());\n                assert_eq!(\n                    error.unwrap(),\n                    \"cosmwasm_std::math::uint128::Uint128 not found\"\n                );\n            }\n            _ =\u003e panic!(\"Wrong response type\"),\n        }\n\n        // Our user has funds stuck, so withdrawal must succeed\n        let ibc_withdraw = to_binary(\u0026Hub::WithdrawFunds {\n            user: Addr::unchecked(user),\n        })\n        .unwrap();\n        let recv_packet = mock_ibc_packet(\"channel-3\", ibc_withdraw);\n\n        let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n        let res = ibc_packet_receive(deps.as_mut(), env, msg).unwrap();\n\n        let hub_respone: interchain::Response = from_binary(\u0026res.acknowledgement).unwrap();\n        match hub_respone {\n            interchain::Response::Result { address, error, .. } =\u003e {\n                assert!(error.is_none());\n                assert_eq!(address.unwrap(), user);\n            }\n            _ =\u003e panic!(\"Wrong response type\"),\n        }\n\n        // We must see one message being emitted from the withdraw\n        assert_eq!(res.messages.len(), 1);\n\n        // It must be a CW20-ICS20 transfer message\n        let ibc_transfer_msg = to_binary(\u0026TransferMsg {\n            remote_address: user.to_string(),\n            channel: \"channel-1\".to_string(),\n            timeout: Some(10),\n            memo: None,\n        })\n        .unwrap();\n        let cw_send_msg = to_binary(\u0026Cw20ExecuteMsg::Send {\n            contract: \"cw20_ics20\".to_string(),\n            amount: stuck_amount,\n            msg: ibc_transfer_msg,\n        })\n        .unwrap();\n\n        assert_eq!(\n            res.messages[0],\n            SubMsg {\n                id: 0,\n                gas_limit: None,\n                reply_on: ReplyOn::Never,\n                msg: WasmMsg::Execute {\n                    contract_addr: \"astro\".to_string(),\n                    msg: cw_send_msg,\n                    funds: vec![],\n                }\n                .into(),\n            }\n        );\n    }\n}\n","traces":[{"line":17,"address":[1712743,1708832,1710303],"length":1,"stats":{"Line":1},"fn_name":"handle_ibc_withdraw_stuck_funds"},{"line":22,"address":[1708864,1708998,1709154],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[1709315,1709114,1709483],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[1709597,1709455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[1709632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1709608,1709963,1709685],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[1709896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[1709936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[1710108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[1710276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[1710441,1710666,1710393],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[1710631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[1711088,1710897,1710945],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[1711061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[1711558,1711913,1711625,1711698],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[1711497,1711424],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[1711505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[1712147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1712207],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":18,"coverable":19},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","ibc_query.rs"],"content":"use cosmwasm_std::{to_binary, DepsMut, IbcReceiveResponse};\n\nuse astroport_governance::{assembly::Proposal, assembly::QueryMsg, interchain::Response};\n\nuse crate::{error::ContractError, state::CONFIG};\n\n/// Query the Assembly for a proposal and return the result in an\n/// IBC acknowledgement\n///\n/// If the proposal doesn't exist, the Outpost will see a generic ABCI error\n/// and not \"proposal not found\" due to limitations in wasmd\npub fn handle_ibc_query_proposal(\n    deps: DepsMut,\n    id: u64,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    let mut proposal: Proposal = deps.querier.query_wasm_smart(\n        config.assembly_addr,\n        \u0026QueryMsg::Proposal { proposal_id: id },\n    )?;\n\n    // TODO Check if we can retrieve the proposal even with thousands of voters\n    proposal.for_voters = vec![];\n    proposal.against_voters = vec![];\n\n    let ack_data = to_binary(\u0026Response::QueryProposal(Box::new(proposal)))?;\n    Ok(IbcReceiveResponse::new()\n        .set_ack(ack_data)\n        .add_attribute(\"query\", \"proposal\")\n        .add_attribute(\"proposal_id\", id.to_string()))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use astroport_governance::interchain::Hub;\n    use cosmwasm_std::{from_binary, testing::mock_info, Addr, IbcPacketReceiveMsg, Uint64};\n\n    use crate::{\n        contract::instantiate,\n        execute::execute,\n        ibc::ibc_packet_receive,\n        mock::{mock_all, mock_ibc_packet, ASSEMBLY, GENERATOR_CONTROLLER, OWNER, STAKING},\n    };\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Proposal should not be queried without Assembly\n\n    #[test]\n    fn query_proposal_fails_invalid_assembly() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: \"invalid\".to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"outpost\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        let ibc_query_proposal = to_binary(\u0026Hub::QueryProposal { id: 1 }).unwrap();\n        let recv_packet = mock_ibc_packet(\"channel-3\", ibc_query_proposal);\n\n        let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n        let res = ibc_packet_receive(deps.as_mut(), env, msg).unwrap();\n\n        let ack: Response = from_binary(\u0026res.acknowledgement).unwrap();\n        match ack {\n            Response::Result { error, .. } =\u003e {\n                assert!(error.is_some());\n            }\n            _ =\u003e panic!(\"Wrong response type\"),\n        }\n\n        // No messages should be emitted\n        assert_eq!(res.messages.len(), 0);\n    }\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - An IBC ack contains the correct information\n\n    #[test]\n    fn query_proposal() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"outpost\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        let ibc_query_proposal = to_binary(\u0026Hub::QueryProposal { id: 1 }).unwrap();\n        let recv_packet = mock_ibc_packet(\"channel-3\", ibc_query_proposal);\n\n        let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n        let res = ibc_packet_receive(deps.as_mut(), env, msg).unwrap();\n\n        let ack: Response = from_binary(\u0026res.acknowledgement).unwrap();\n        match ack {\n            Response::QueryProposal(proposal) =\u003e {\n                assert_eq!(proposal.proposal_id, Uint64::from(1u64));\n            }\n            _ =\u003e panic!(\"Wrong response type\"),\n        }\n\n        // No message must be emitted, the ack contains the data\n        assert_eq!(res.messages.len(), 0);\n    }\n}\n","traces":[{"line":12,"address":[1161888,1163934,1162610],"length":1,"stats":{"Line":2},"fn_name":"handle_ibc_query_proposal"},{"line":16,"address":[1161915,1162224],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[1162352,1162217,1162124,1162569],"length":1,"stats":{"Line":7},"fn_name":null},{"line":19,"address":[1162128],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[1162168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[1162780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[1162937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[1163086,1163274],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[1164290,1164003,1164222,1164062],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[1164022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[1164149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[1164157,1164282,1164415],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":12,"coverable":12},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","ibc_staking.rs"],"content":"use cosmwasm_std::{to_binary, DepsMut, IbcReceiveResponse, SubMsg, Uint128, WasmMsg};\nuse cw20::Cw20ExecuteMsg;\n\nuse astroport_governance::interchain::Response;\n\nuse crate::{\n    error::ContractError,\n    reply::UNSTAKE_ID,\n    state::{ReplyData, CONFIG, REPLY_DATA},\n};\n\n/// Handle an unstake command from an Outpost\n///\n/// Once the xASTRO has been unstaked, the resulting ASTRO will be sent back\n/// to the user on the Outpost\npub fn handle_ibc_unstake(\n    deps: DepsMut,\n    receive_channel: String,\n    receiver: String,\n    amount: Uint128,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    let msg = construct_unstake_msg(deps, receive_channel, receiver.clone(), amount)?;\n    // Add to SubMessage to handle the reply\n    let sub_msg = SubMsg::reply_always(msg, UNSTAKE_ID);\n\n    // Set the acknowledgement. This is only to indicate that the unstake\n    // was processed without error, not that the funds were successfully\n    let ack_data = to_binary(\u0026Response::new_success(\"unstake\".to_owned(), receiver))?;\n\n    // TODO Invariant check, can't unstake more than the xASTRO in this contract\n\n    Ok(IbcReceiveResponse::new()\n        .set_ack(ack_data)\n        .add_submessage(sub_msg))\n}\n\n/// Create the messages and state to correctly handle the unstaking of xASTRO\npub fn construct_unstake_msg(\n    deps: DepsMut,\n    receiving_channel: String,\n    receiver: String,\n    amount: Uint128,\n) -\u003e Result\u003cWasmMsg, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Unstake the received xASTRO amount\n    // We need a SubMessage here to ensure that we send the correct amount\n    // of ASTRO to the receiver as the ratio isn't 1:1\n    let leave_msg = astroport::staking::Cw20HookMsg::Leave {};\n    let send_msg = Cw20ExecuteMsg::Send {\n        contract: config.staking_addr.to_string(),\n        amount,\n        msg: to_binary(\u0026leave_msg)?,\n    };\n\n    // Send the xASTRO held in the contract to the Staking contract\n    let msg = WasmMsg::Execute {\n        contract_addr: config.xtoken_addr.to_string(),\n        msg: to_binary(\u0026send_msg)?,\n        funds: vec![],\n    };\n\n    // Temporarily save the data needed for the SubMessage reply\n    let reply_data = ReplyData {\n        receiver,\n        receiving_channel,\n    };\n    REPLY_DATA.save(deps.storage, \u0026reply_data)?;\n\n    Ok(msg)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use astroport_governance::interchain::{Hub, TransferMsg};\n    use cosmwasm_std::{\n        from_binary, testing::mock_info, Addr, Event, IbcPacketReceiveMsg, Reply, ReplyOn,\n        SubMsgResponse, SubMsgResult,\n    };\n\n    use crate::{\n        contract::instantiate,\n        execute::execute,\n        ibc::ibc_packet_receive,\n        mock::{\n            mock_all, mock_ibc_packet, ASSEMBLY, ASTRO_TOKEN, GENERATOR_CONTROLLER, OWNER, STAKING,\n            XASTRO_TOKEN,\n        },\n        reply::reply,\n    };\n\n    // Test Cases:\n    //\n    // Expect Success\n    //      - Proposal should not be queried without Assembly\n\n    #[test]\n    fn ibc_unstake() {\n        let (mut deps, env, info) = mock_all(OWNER);\n\n        let unstaker = \"unstaker\";\n        let unstake_amount = Uint128::from(100u128);\n\n        instantiate(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            astroport_governance::hub::InstantiateMsg {\n                owner: OWNER.to_string(),\n                assembly_addr: ASSEMBLY.to_string(),\n                cw20_ics20_addr: \"cw20_ics20\".to_string(),\n                staking_addr: STAKING.to_string(),\n                generator_controller_addr: GENERATOR_CONTROLLER.to_string(),\n                ibc_timeout_seconds: 10,\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            mock_info(OWNER, \u0026[]),\n            astroport_governance::hub::ExecuteMsg::AddOutpost {\n                outpost_addr: \"outpost\".to_string(),\n                cw20_ics20_channel: \"channel-1\".to_string(),\n            },\n        )\n        .unwrap();\n\n        let ibc_unstake = to_binary(\u0026Hub::Unstake {\n            receiver: unstaker.to_owned(),\n            amount: unstake_amount,\n        })\n        .unwrap();\n        let recv_packet = mock_ibc_packet(\"channel-3\", ibc_unstake);\n\n        let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n        let res = ibc_packet_receive(deps.as_mut(), env.clone(), msg).unwrap();\n\n        let ack: Response = from_binary(\u0026res.acknowledgement).unwrap();\n        match ack {\n            Response::Result { error, .. } =\u003e {\n                assert!(error.is_none());\n            }\n            _ =\u003e panic!(\"Wrong response type\"),\n        }\n\n        // Should have exactly one message\n        assert_eq!(res.messages.len(), 1);\n\n        // Verify that the unstake message matches the expected message\n        let unstake_msg = to_binary(\u0026astroport::staking::Cw20HookMsg::Leave {}).unwrap();\n        let send_msg = to_binary(\u0026Cw20ExecuteMsg::Send {\n            contract: STAKING.to_string(),\n            amount: unstake_amount,\n            msg: unstake_msg,\n        })\n        .unwrap();\n\n        // We should see the unstake SubMessagge\n        assert_eq!(\n            res.messages[0],\n            SubMsg {\n                id: 9001,\n                gas_limit: None,\n                reply_on: ReplyOn::Always,\n                msg: WasmMsg::Execute {\n                    contract_addr: XASTRO_TOKEN.to_string(),\n                    msg: send_msg,\n                    funds: vec![],\n                }\n                .into(),\n            }\n        );\n\n        // Construct the reply from the staking contract that will be returned\n        // to the contract\n        let unstake_event = Event::new(\"unstake\".to_string())\n            .add_attribute(\"astro_amount\", unstake_amount.to_string());\n        let unstake_reply = Reply {\n            id: 9001,\n            result: SubMsgResult::Ok(SubMsgResponse {\n                events: vec![unstake_event],\n                data: None,\n            }),\n        };\n\n        let res = reply(deps.as_mut(), env, unstake_reply).unwrap();\n\n        // We must have one CW20-ICS20 transfer message\n        assert_eq!(res.messages.len(), 1);\n\n        // Contruct the CW20-ICS20 ASTRO token transfer we expect to see\n        let transfer_msg = to_binary(\u0026TransferMsg {\n            channel: \"channel-1\".to_string(),\n            remote_address: unstaker.to_string(),\n            timeout: Some(10),\n            memo: None,\n        })\n        .unwrap();\n        let send_msg = to_binary(\u0026Cw20ExecuteMsg::Send {\n            contract: \"cw20_ics20\".to_string(),\n            amount: unstake_amount,\n            msg: transfer_msg,\n        })\n        .unwrap();\n\n        // We should see the ASTRO token transfer\n        assert_eq!(\n            res.messages[0],\n            SubMsg {\n                id: 0,\n                gas_limit: None,\n                reply_on: ReplyOn::Never,\n                msg: WasmMsg::Execute {\n                    contract_addr: ASTRO_TOKEN.to_string(),\n                    msg: send_msg,\n                    funds: vec![],\n                }\n                .into(),\n            }\n        );\n    }\n}\n","traces":[{"line":16,"address":[1588641,1586880,1587200],"length":1,"stats":{"Line":1},"fn_name":"handle_ibc_unstake"},{"line":22,"address":[1587181,1587627,1586941,1587233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[1587783,1587483],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[1587861,1587791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[1588499,1588416,1588357],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[1588376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[1588451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[1588672,1589269,1591052],"length":1,"stats":{"Line":1},"fn_name":"construct_unstake_msg"},{"line":44,"address":[1589000,1588730,1588856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[1588957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[1588965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1589212,1589290,1589164,1589449],"length":1,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[1589414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[1589677,1589725,1589868],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[1589841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[1590422,1590345,1590709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[1590483],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":17,"coverable":17},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","lib.rs"],"content":"pub mod contract;\npub mod error;\npub mod execute;\npub mod ibc;\npub mod ibc_governance;\npub mod ibc_misc;\npub mod ibc_query;\npub mod ibc_staking;\npub mod query;\npub mod reply;\npub mod state;\n\n#[cfg(test)]\nmod mock;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","mock.rs"],"content":"#[cfg(test)]\n// use crate::execute;\n// use crate::{contract::instantiate, execute::execute, ibc::ibc_packet_receive};\n// use crate::{\n//     ibc::{ibc_channel_connect, ibc_channel_open, IBC_APP_VERSION},\n//     testing_querier::{mock_dependencies, WasmMockQuerier},\n// };\nuse astroport_core::token::BalanceResponse;\nuse astroport_cw20_ics20::{\n    ibc::{Ics20Packet, ICS20_ORDERING, ICS20_VERSION},\n    state::ChannelInfo,\n};\nuse astroport_governance::assembly::ProposalVoteOption;\nuse astroport_governance::interchain::{Hub, Response};\nuse cosmwasm_std::{from_binary, IbcPacketReceiveMsg, ReplyOn, SubMsg, Uint64, WasmMsg};\nuse cosmwasm_std::{\n    testing::{mock_env, mock_info, MockApi, MockQuerier, MockStorage},\n    to_binary, Addr, Binary, DepsMut, Env, IbcChannel, IbcChannelConnectMsg, IbcChannelOpenMsg,\n    IbcEndpoint, IbcOrder, IbcPacket, MessageInfo, OwnedDeps, StdResult, Timestamp, Uint128,\n};\nuse cw20::Cw20QueryMsg;\nuse cw_multi_test::{App, AppBuilder, BankKeeper};\n\nuse cosmwasm_std::testing::MOCK_CONTRACT_ADDR;\nuse cosmwasm_std::{\n    from_slice, Coin, Empty, Querier, QuerierResult, QueryRequest, SystemError, SystemResult,\n    WasmQuery,\n};\nuse std::collections::HashMap;\n\npub const DEFAULT_TIMEOUT: u64 = 3600; // 1 hour,\npub const CONTRACT_PORT: \u0026str = \"ibc:wasm1234567890abcdef\";\npub const REMOTE_PORT: \u0026str = \"wasm.outpost\";\npub const CONNECTION_ID: \u0026str = \"connection-2\";\npub const OWNER: \u0026str = \"owner\";\npub const ASSEMBLY: \u0026str = \"assembly\";\npub const GENERATOR_CONTROLLER: \u0026str = \"generator_controller\";\npub const STAKING: \u0026str = \"staking\";\npub const ASTRO_TOKEN: \u0026str = \"astro\";\npub const XASTRO_TOKEN: \u0026str = \"xastro\";\n\npub fn mock_app() -\u003e App {\n    let mut env = mock_env();\n    env.block.time = Timestamp::from_seconds(1689152294);\n    let api = MockApi::default();\n    let bank = BankKeeper::new();\n    let storage = MockStorage::new();\n\n    AppBuilder::new()\n        .with_api(api)\n        .with_block(env.block)\n        .with_bank(bank)\n        .with_storage(storage)\n        .build(|_, _, _| {})\n}\n\n/// mock_dependencies is a drop-in replacement for cosmwasm_std::testing::mock_dependencies.\n/// This uses the Astroport CustomQuerier.\n#[cfg(test)]\npub fn mock_dependencies() -\u003e OwnedDeps\u003cMockStorage, MockApi, WasmMockQuerier\u003e {\n    let custom_querier: WasmMockQuerier =\n        WasmMockQuerier::new(MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026[])]));\n\n    OwnedDeps {\n        storage: MockStorage::default(),\n        api: MockApi::default(),\n        querier: custom_querier,\n        custom_query_type: Default::default(),\n    }\n}\n\npub struct WasmMockQuerier {\n    base: MockQuerier\u003cEmpty\u003e,\n}\n\nimpl Querier for WasmMockQuerier {\n    fn raw_query(\u0026self, bin_request: \u0026[u8]) -\u003e QuerierResult {\n        // MockQuerier doesn't support Custom, so we ignore it completely\n        let request: QueryRequest\u003cEmpty\u003e = match from_slice(bin_request) {\n            Ok(v) =\u003e v,\n            Err(e) =\u003e {\n                return SystemResult::Err(SystemError::InvalidRequest {\n                    error: format!(\"Parsing query request: {}\", e),\n                    request: bin_request.into(),\n                })\n            }\n        };\n        self.handle_query(\u0026request)\n    }\n}\n\nimpl WasmMockQuerier {\n    pub fn handle_query(\u0026self, request: \u0026QueryRequest\u003cEmpty\u003e) -\u003e QuerierResult {\n        match \u0026request {\n            QueryRequest::Wasm(WasmQuery::Smart { contract_addr, msg }) =\u003e {\n                if contract_addr == STAKING {\n                    match from_binary(\u0026msg).unwrap() {\n                        astroport_core::staking::QueryMsg::Config {} =\u003e {\n                            let config = astroport_core::staking::ConfigResponse {\n                                deposit_token_addr: Addr::unchecked(\"astro\"),\n                                share_token_addr: Addr::unchecked(\"xastro\"),\n                            };\n\n                            SystemResult::Ok(to_binary(\u0026config).into())\n                        }\n                        _ =\u003e {\n                            panic!(\"DO NOT ENTER HERE\")\n                        }\n                    }\n                } else {\n                    if contract_addr != ASSEMBLY {\n                        return SystemResult::Err(SystemError::Unknown {});\n                    }\n                    match from_binary(\u0026msg).unwrap() {\n                        astroport_governance::assembly::QueryMsg::Proposal { proposal_id } =\u003e {\n                            let proposal = astroport_governance::assembly::Proposal {\n                                proposal_id: Uint64::from(proposal_id),\n                                submitter: Addr::unchecked(\"submitter\"),\n                                status: astroport_governance::assembly::ProposalStatus::Active,\n                                for_power: Uint128::zero(),\n                                against_power: Uint128::zero(),\n                                for_voters: vec![],\n                                against_voters: vec![],\n                                start_block: 1,\n                                start_time: 12345,\n                                end_block: 5,\n                                delayed_end_block: 10,\n                                expiration_block: 15,\n                                title: \"Test title\".to_string(),\n                                description: \"Test description\".to_string(),\n                                link: None,\n                                messages: None,\n                                deposit_amount: Uint128::one(),\n                                ibc_channel: None,\n                            };\n                            SystemResult::Ok(to_binary(\u0026proposal).into())\n                        }\n                        _ =\u003e {\n                            panic!(\"DO NOT ENTER HERE\")\n                        }\n                    }\n                }\n            }\n            _ =\u003e self.base.handle_query(request),\n        }\n    }\n}\n\nimpl WasmMockQuerier {\n    pub fn new(base: MockQuerier\u003cEmpty\u003e) -\u003e Self {\n        WasmMockQuerier { base }\n    }\n}\n\npub fn mock_all(\n    sender: \u0026str,\n) -\u003e (\n    OwnedDeps\u003cMockStorage, MockApi, WasmMockQuerier\u003e,\n    Env,\n    MessageInfo,\n) {\n    let deps = mock_dependencies();\n    let env = mock_env();\n    let info = mock_info(sender, \u0026[]);\n    (deps, env, info)\n}\n\npub fn check_token_balance(app: \u0026mut App, token: \u0026Addr, address: \u0026Addr, expected: u128) {\n    let msg = Cw20QueryMsg::Balance {\n        address: address.to_string(),\n    };\n    let res: StdResult\u003cBalanceResponse\u003e = app.wrap().query_wasm_smart(token, \u0026msg);\n    assert_eq!(res.unwrap().balance, Uint128::from(expected));\n}\n\n// pub fn mock_channel(channel_id: \u0026str) -\u003e IbcChannel {\n//     IbcChannel::new(\n//         IbcEndpoint {\n//             port_id: CONTRACT_PORT.into(),\n//             channel_id: channel_id.into(),\n//         },\n//         IbcEndpoint {\n//             port_id: REMOTE_PORT.into(),\n//             channel_id: format!(\"{}5\", channel_id),\n//         },\n//         IbcOrder::Unordered,\n//         IBC_APP_VERSION,\n//         CONNECTION_ID,\n//     )\n// }\n\n// pub fn mock_channel_info(channel_id: \u0026str) -\u003e ChannelInfo {\n//     ChannelInfo {\n//         id: channel_id.to_string(),\n//         counterparty_endpoint: IbcEndpoint {\n//             port_id: REMOTE_PORT.into(),\n//             channel_id: format!(\"{}5\", channel_id),\n//         },\n//         connection_id: CONNECTION_ID.into(),\n//     }\n// }\n\n// we simulate instantiate and ack here\n// pub fn add_channel(mut deps: DepsMut, channel_id: \u0026str) {\n//     let channel = mock_channel(channel_id);\n//     let open_msg = IbcChannelOpenMsg::new_init(channel.clone());\n//     ibc_channel_open(deps.branch(), mock_env(), open_msg).unwrap();\n//     let connect_msg = IbcChannelConnectMsg::new_ack(channel, IBC_APP_VERSION);\n//     ibc_channel_connect(deps.branch(), mock_env(), connect_msg).unwrap();\n// }\n\n// pub fn mock_receive_packet(\n//     my_channel: \u0026str,\n//     amount: u128,\n//     denom: \u0026str,\n//     receiver: \u0026str,\n//     memo: Option\u003cString\u003e,\n// ) -\u003e IbcPacket {\n//     let data = Ics20Packet {\n//         // this is returning a foreign (our) token, thus denom is \u003cport\u003e/\u003cchannel\u003e/\u003cdenom\u003e\n//         denom: format!(\"{}/{}/{}\", REMOTE_PORT, \"channel-1234\", denom),\n//         amount: amount.into(),\n//         sender: \"remote-sender\".to_string(),\n//         receiver: receiver.to_string(),\n//         memo,\n//     };\n//     print!(\"Packet denom: {}\", \u0026data.denom);\n//     IbcPacket::new(\n//         to_binary(\u0026data).unwrap(),\n//         IbcEndpoint {\n//             port_id: REMOTE_PORT.to_string(),\n//             channel_id: \"channel-1234\".to_string(),\n//         },\n//         IbcEndpoint {\n//             port_id: CONTRACT_PORT.to_string(),\n//             channel_id: my_channel.to_string(),\n//         },\n//         3,\n//         Timestamp::from_seconds(1665321069).into(),\n//     )\n// }\n\npub fn mock_ibc_packet(my_channel: \u0026str, data: Binary) -\u003e IbcPacket {\n    IbcPacket::new(\n        data,\n        IbcEndpoint {\n            port_id: REMOTE_PORT.to_string(),\n            channel_id: \"channel-3\".to_string(),\n        },\n        IbcEndpoint {\n            port_id: CONTRACT_PORT.to_string(),\n            channel_id: my_channel.to_string(),\n        },\n        3,\n        Timestamp::from_seconds(1665321069).into(),\n    )\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","query.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{to_binary, Binary, Deps, Env, Order, StdResult};\n\nuse crate::state::{CONFIG, OUTPOSTS};\nuse astroport_governance::hub::{OutpostConfig, QueryMsg};\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::Config {}** Returns core contract settings stored in the [`Config`] structure.\n///\n/// * **QueryMsg::Outposts { }** Returns a [`Vec\u003cOutpostResponse\u003e`] containing the active Outposts\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Config {} =\u003e to_binary(\u0026CONFIG.load(deps.storage)?),\n        QueryMsg::Outposts {} =\u003e query_outposts(deps),\n    }\n}\n\n/// Return a list of Outpost in the format of `OutpostConfig`\nfn query_outposts(deps: Deps) -\u003e StdResult\u003cBinary\u003e {\n    let outposts: Vec\u003cOutpostConfig\u003e = OUTPOSTS\n        .range(deps.storage, None, None, Order::Ascending)\n        .map(|item| {\n            let (key, value) = item.unwrap();\n            OutpostConfig {\n                address: key,\n                channel: value.outpost.unwrap_or_default(),\n                cw20_ics20_channel: value.cw20_ics20,\n            }\n        })\n        .collect();\n    to_binary(\u0026outposts)\n}\n","traces":[{"line":15,"address":[994158,993632],"length":1,"stats":{"Line":2},"fn_name":"query"},{"line":16,"address":[993667],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[994098,993851,993687],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[993726,993817],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[993597,993424],"length":1,"stats":{"Line":2},"fn_name":"query_outposts"},{"line":24,"address":[993469],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[993444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[833504,833968,834031],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":27,"address":[833542],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[833837],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[833653],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[833687],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[833798],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[993536],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":14,"coverable":14},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","reply.rs"],"content":"use cosmwasm_std::{\n    entry_point, to_binary, CosmosMsg, DepsMut, Env, IbcMsg, Reply, Response, SubMsgResult,\n    Uint128, WasmMsg,\n};\nuse cw20::Cw20ExecuteMsg;\n\nuse astroport_governance::interchain::{Outpost, TransferMsg};\n\nuse crate::{\n    error::ContractError,\n    state::{\n        get_outpost_from_cw20ics20_channel, get_transfer_channel_from_outpost_channel, CONFIG,\n        REPLY_DATA,\n    },\n};\n\n/// Reply ID when staking tokens\npub const STAKE_ID: u64 = 9000;\n/// Reply ID when unstaking tokens\npub const UNSTAKE_ID: u64 = 9001;\n\n/// Handle SubMessage replies\n///\n/// To correctly handle staking and unstaking amount we execute the calls using\n/// SubMessages and the replies are handled here\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(deps: DepsMut, env: Env, reply: Reply) -\u003e Result\u003cResponse, ContractError\u003e {\n    match reply.id {\n        STAKE_ID =\u003e handle_stake_reply(deps, env, reply),\n        UNSTAKE_ID =\u003e handle_unstake_reply(deps, reply),\n        _ =\u003e Err(ContractError::UnknownReplyId { id: reply.id }),\n    }\n}\n\n/// Handle the reply from a staking transaction\nfn handle_stake_reply(deps: DepsMut, env: Env, reply: Reply) -\u003e Result\u003cResponse, ContractError\u003e {\n    match reply.result {\n        SubMsgResult::Ok(response) =\u003e {\n            // TODO response.data is blank on Terra, investigate why this is\n            // let Some(response_data) = \u0026response.data else {\n            //     return Err(ContractError::InvalidSubmessage{reason: \"No data in staking response\".to_string()});\n            // };\n\n            let config = CONFIG.load(deps.storage)?;\n\n            // Extract the correct xASTRO amount minted from the staking\n            // transaction. xASTRO isn't *always* minted at a 1:1 ratio\n            let mut xastro_amount: Uint128 = Uint128::zero();\n            for event in response.events {\n                for attribute in event.attributes {\n                    if attribute.key == \"xastro_amount\" {\n                        let val = attribute.value.parse::\u003cu64\u003e()?;\n                        xastro_amount = Uint128::from(val);\n                        break;\n                    }\n                }\n            }\n\n            // Load the temporary data stored before the SubMessage was executed\n            let reply_data = REPLY_DATA.load(deps.storage)?;\n\n            // The channel we received the ASTRO to stake on was the CW20-ICS20\n            // channel, we need to determine the channel to use for minting the\n            // xASTRO be checking the known Outposts\n            let outpost_channels =\n                get_outpost_from_cw20ics20_channel(deps.as_ref(), \u0026reply_data.receiving_channel)?;\n            let outpost_channel = outpost_channels\n                .outpost\n                .ok_or(ContractError::UnknownOutpost {})?;\n\n            // Submit an IBC transaction to mint the same amount of xASTRO\n            // we received from staking on the Outpost\n            let mint_remote = Outpost::MintXAstro {\n                amount: xastro_amount,\n                receiver: reply_data.receiver.clone(),\n            };\n            let msg = CosmosMsg::Ibc(IbcMsg::SendPacket {\n                channel_id: outpost_channel.clone(),\n                data: to_binary(\u0026mint_remote)?,\n                timeout: env\n                    .block\n                    .time\n                    .plus_seconds(config.ibc_timeout_seconds)\n                    .into(),\n            });\n\n            Ok(Response::new()\n                .add_message(msg)\n                .add_attribute(\"action\", \"mint_remote_xastro\")\n                .add_attribute(\"amount\", xastro_amount)\n                .add_attribute(\"channel\", outpost_channel)\n                .add_attribute(\"receiver\", reply_data.receiver))\n        }\n        // In the case where staking fails, the funds will either automatically be returned\n        // through the CW20-ICS20 contract or the user will need to manually withdraw them\n        // from this contract. In either case, we don't need to do anything here as the\n        // original staking memo is already a SubMessage in the CW20-ICS20 contract\n        SubMsgResult::Err(err) =\u003e Err(ContractError::InvalidSubmessage { reason: err }),\n    }\n}\n\n/// Handle the reply from an unstaking transaction\nfn handle_unstake_reply(deps: DepsMut, reply: Reply) -\u003e Result\u003cResponse, ContractError\u003e {\n    match reply.result {\n        SubMsgResult::Ok(response) =\u003e {\n            // TODO response.data is blank on Terra, investigate why this is\n            // let Some(response_data) = \u0026response.data else {\n            //     return Err(ContractError::InvalidSubmessage{reason: \"No data in staking response\".to_string()});\n            // };\n\n            let config = CONFIG.load(deps.storage)?;\n\n            // Extract the correct ASTRO amount returned from the unstaking\n            // transaction. ASTRO isn't returned at a 1:1 ratio, the returned\n            // ASTRO will most likely be more\n            let mut astro_amount: Uint128 = Uint128::zero();\n            for event in response.events {\n                for attribute in event.attributes {\n                    if attribute.key == \"astro_amount\" {\n                        let val = attribute.value.parse::\u003cu64\u003e()?;\n                        astro_amount = Uint128::from(val);\n                        break;\n                    }\n                }\n            }\n\n            // Load the temporary data stored before the SubMessage was executed\n            let reply_data = REPLY_DATA.load(deps.storage)?;\n\n            // The channel we received the unstaking from was the Outpost contract\n            // channel, we need to determine the channel to use for sending the\n            // ASTRO back using the CW20-ICS20 contract\n            let outpost_channels = get_transfer_channel_from_outpost_channel(\n                deps.as_ref(),\n                \u0026reply_data.receiving_channel,\n            )?;\n\n            // Send the ASTRO back to the unstaking user on the Outpost chain\n            // via the CW20-ICS20 contract\n            let transfer_msg = TransferMsg {\n                channel: outpost_channels.cw20_ics20.clone(),\n                remote_address: reply_data.receiver.clone(),\n                timeout: Some(config.ibc_timeout_seconds),\n                memo: None,\n            };\n\n            let transfer = Cw20ExecuteMsg::Send {\n                contract: config.cw20_ics20_addr.to_string(),\n                amount: astro_amount,\n                msg: to_binary(\u0026transfer_msg)?,\n            };\n\n            let wasm_msg = WasmMsg::Execute {\n                contract_addr: config.token_addr.to_string(),\n                msg: to_binary(\u0026transfer)?,\n                funds: vec![],\n            };\n\n            // TODO: Invariant checks\n            // TODO: We probably need to keep track of the channel balance\n            // and ensure we don't send more than the channel has\n            // Same mechanism as the CW20-ICS20 contract\n\n            Ok(Response::new()\n                .add_message(wasm_msg)\n                .add_attribute(\"action\", \"return_unstaked_astro\")\n                .add_attribute(\"amount\", astro_amount)\n                .add_attribute(\"channel\", outpost_channels.cw20_ics20)\n                .add_attribute(\"receiver\", reply_data.receiver))\n        }\n        // If unstaking fails the error will be returned to the Outpost that would undo\n        // the burning of xASTRO and return the tokens to the user\n        SubMsgResult::Err(err) =\u003e Err(ContractError::InvalidSubmessage { reason: err }),\n    }\n}\n","traces":[{"line":27,"address":[1559938,1559969,1559456],"length":1,"stats":{"Line":2},"fn_name":"reply"},{"line":28,"address":[1559487],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[1559909,1559647],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[1559907,1559791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[1559566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1551432,1549648,1554504],"length":1,"stats":{"Line":1},"fn_name":"handle_stake_reply"},{"line":37,"address":[1549695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[1549776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[1550211,1549819,1550074],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[1550375,1550180],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[1550391,1551355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[1550779,1550676,1551309],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[1551087,1551013],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[1551115,1551258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1551394,1551226],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[1551473,1551696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1551838,1552145,1551666],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[1552127,1552052,1552552,1552316],"length":1,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[1552488,1552092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[1552450],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[1553430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[1552705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[1553003,1552840,1552792],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[1553411,1552964,1552976],"length":1,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[1552968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[1554063,1553702,1553976,1553826,1553901],"length":1,"stats":{"Line":5},"fn_name":null},{"line":88,"address":[1553762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[1553885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[1553936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[1554023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[1549867],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[1558414,1554528,1556272],"length":1,"stats":{"Line":1},"fn_name":"handle_unstake_reply"},{"line":104,"address":[1554561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[1554628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[1554671,1554920,1555054],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[1555215,1555026],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[1556195,1555231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[1555619,1556149,1555516],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[1555927,1555853],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[1556098,1555955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[1556234,1556066],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[1556310,1556530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[1556500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[1556672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[1556886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[1557082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[1557150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[1557318],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[1557705,1557478,1557430],"length":1,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[1557667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[1557984,1558130,1557936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[1558100],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[1558793,1558943,1559030,1558868,1558589],"length":1,"stats":{"Line":5},"fn_name":null},{"line":165,"address":[1558649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[1558852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[1558903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[1558990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[1554716],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":56,"coverable":58},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","src","state.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Deps, Order, Uint128};\nuse cw_storage_plus::{Item, Map};\n\nuse astroport::common::OwnershipProposal;\nuse astroport_governance::hub::Config;\n\nuse crate::error::ContractError;\n\n/// Holds temporary data used in the staking/unstaking replies\n#[cw_serde]\npub struct ReplyData {\n    /// The address that should receive the staked/unstaked tokens\n    pub receiver: String,\n    /// The IBC channel the original request was received on\n    pub receiving_channel: String,\n}\n\n/// Holds the IBC channels that are allowed to communicate with the Hub\n#[cw_serde]\npub struct OutpostChannels {\n    /// The channel of the Outpost contract on the remote chain\n    pub outpost: Option\u003cString\u003e,\n    /// The channel to send ASTRO CW20-ICS20 tokens through\n    pub cw20_ics20: String,\n}\n\n/// Stores the contract config\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n\n/// Stores data for reply endpoint.\npub const REPLY_DATA: Item\u003cReplyData\u003e = Item::new(\"reply_data\");\n\n/// Stores funds that got stuck on the Hub chain due to IBC transfer failures\n/// when using cross-chain actions\npub const USER_FUNDS: Map\u003cAddr, Uint128\u003e = Map::new(\"user_funds\");\n\n/// Contains a proposal to change contract ownership\npub const OWNERSHIP_PROPOSAL: Item\u003cOwnershipProposal\u003e = Item::new(\"ownership_proposal\");\n\n/// Contains a map of outpost addresses to their IBC channels that are allowed\n/// to communicate with the Hub over IBC\npub const OUTPOSTS: Map\u003cString, OutpostChannels\u003e = Map::new(\"channel_map\");\n\n/// Get the Outpost channels for a given CW20-ICS20 channel\n///\n/// The Outposts must be configured and connected before this will return any values\npub fn get_outpost_from_cw20ics20_channel(\n    deps: Deps,\n    cw20ics20_channel: \u0026str,\n) -\u003e Result\u003cOutpostChannels, ContractError\u003e {\n    let outpost_opt = OUTPOSTS\n        .range(deps.storage, None, None, Order::Ascending)\n        .find_map(|item| {\n            let (_, value) = item.ok()?;\n            if value.cw20_ics20 == cw20ics20_channel {\n                Some(value)\n            } else {\n                None\n            }\n        });\n\n    match outpost_opt {\n        Some(outpost) =\u003e Ok(outpost),\n        None =\u003e Err(ContractError::UnknownOutpost {}),\n    }\n}\n\n/// Get the Outpost channels for a given contract channel\n///\n/// The Outposts must be configured and connected before this will return any values\npub fn get_transfer_channel_from_outpost_channel(\n    deps: Deps,\n    outpost_channel: \u0026str,\n) -\u003e Result\u003cOutpostChannels, ContractError\u003e {\n    let outpost_opt = OUTPOSTS\n        .range(deps.storage, None, None, Order::Ascending)\n        .find_map(|item| {\n            let (_, value) = item.ok()?;\n            if value.outpost == Some(outpost_channel.to_string()) {\n                Some(value)\n            } else {\n                None\n            }\n        });\n\n    match outpost_opt {\n        Some(outpost) =\u003e Ok(outpost),\n        None =\u003e Err(ContractError::UnknownOutpost {}),\n    }\n}\n","traces":[{"line":48,"address":[1229568,1229750],"length":1,"stats":{"Line":1},"fn_name":"get_outpost_from_cw20ics20_channel"},{"line":52,"address":[15803641,15803699],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[15803613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[15803691],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[15424699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[15425057,15425125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[15425127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[915158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[1229810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[1229871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1229840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[1230175,1229952],"length":1,"stats":{"Line":1},"fn_name":"get_transfer_channel_from_outpost_channel"},{"line":76,"address":[1230096,1230026],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[1229998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[15804116],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[15425275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[915855,915821,915661],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[915857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[915847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[1230235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[1230297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[1230266],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":18,"coverable":22},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","tests","helper.rs"],"content":"// #[cfg(test)]\n// // use crate::execute;\n// // use crate::{contract::instantiate, execute::execute, ibc::ibc_packet_receive};\n// // use crate::{\n// //     ibc::{ibc_channel_connect, ibc_channel_open, IBC_APP_VERSION},\n// //     testing_querier::{mock_dependencies, WasmMockQuerier},\n// // };\n// use astroport_core::token::BalanceResponse;\n// use astroport_cw20_ics20::{\n//     ibc::{Ics20Packet, ICS20_ORDERING, ICS20_VERSION},\n//     state::ChannelInfo,\n// };\n// use astroport_governance::assembly::ProposalVoteOption;\n// use astroport_governance::interchain::{Hub, Response};\n// use cosmwasm_std::{from_binary, IbcPacketReceiveMsg, ReplyOn, SubMsg, Uint64, WasmMsg};\n// use cosmwasm_std::{\n//     testing::{mock_env, mock_info, MockApi, MockQuerier, MockStorage},\n//     to_binary, Addr, Binary, DepsMut, Env, IbcChannel, IbcChannelConnectMsg, IbcChannelOpenMsg,\n//     IbcEndpoint, IbcOrder, IbcPacket, MessageInfo, OwnedDeps, StdResult, Timestamp, Uint128,\n// };\n// use cw20::Cw20QueryMsg;\n// use cw_multi_test::{App, AppBuilder, BankKeeper};\n\n// use cosmwasm_std::testing::MOCK_CONTRACT_ADDR;\n// use cosmwasm_std::{\n//     from_slice, Coin, Empty, Querier, QuerierResult, QueryRequest, SystemError, SystemResult,\n//     WasmQuery,\n// };\n// use std::collections::HashMap;\n\n// pub const DEFAULT_TIMEOUT: u64 = 3600; // 1 hour,\n// pub const CONTRACT_PORT: \u0026str = \"ibc:wasm1234567890abcdef\";\n// pub const REMOTE_PORT: \u0026str = \"wasm.outpost\";\n// pub const CONNECTION_ID: \u0026str = \"connection-2\";\n\n// pub fn mock_app() -\u003e App {\n//     let mut env = mock_env();\n//     env.block.time = Timestamp::from_seconds(1689152294);\n//     let api = MockApi::default();\n//     let bank = BankKeeper::new();\n//     let storage = MockStorage::new();\n\n//     AppBuilder::new()\n//         .with_api(api)\n//         .with_block(env.block)\n//         .with_bank(bank)\n//         .with_storage(storage)\n//         .build(|_, _, _| {})\n// }\n\n// /// mock_dependencies is a drop-in replacement for cosmwasm_std::testing::mock_dependencies.\n// /// This uses the Astroport CustomQuerier.\n// #[cfg(test)]\n// pub fn mock_dependencies() -\u003e OwnedDeps\u003cMockStorage, MockApi, WasmMockQuerier\u003e {\n//     let custom_querier: WasmMockQuerier =\n//         WasmMockQuerier::new(MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026[])]));\n\n//     OwnedDeps {\n//         storage: MockStorage::default(),\n//         api: MockApi::default(),\n//         querier: custom_querier,\n//         custom_query_type: Default::default(),\n//     }\n// }\n\n// pub struct WasmMockQuerier {\n//     base: MockQuerier\u003cEmpty\u003e,\n// }\n\n// impl Querier for WasmMockQuerier {\n//     fn raw_query(\u0026self, bin_request: \u0026[u8]) -\u003e QuerierResult {\n//         // MockQuerier doesn't support Custom, so we ignore it completely\n//         let request: QueryRequest\u003cEmpty\u003e = match from_slice(bin_request) {\n//             Ok(v) =\u003e v,\n//             Err(e) =\u003e {\n//                 return SystemResult::Err(SystemError::InvalidRequest {\n//                     error: format!(\"Parsing query request: {}\", e),\n//                     request: bin_request.into(),\n//                 })\n//             }\n//         };\n//         self.handle_query(\u0026request)\n//     }\n// }\n\n// impl WasmMockQuerier {\n//     pub fn handle_query(\u0026self, request: \u0026QueryRequest\u003cEmpty\u003e) -\u003e QuerierResult {\n//         match \u0026request {\n//             QueryRequest::Wasm(WasmQuery::Smart { contract_addr, msg }) =\u003e {\n//                 if contract_addr == \"staking\" {\n//                     match from_binary(\u0026msg).unwrap() {\n//                         astroport_core::staking::QueryMsg::Config {} =\u003e {\n//                             let config = astroport_core::staking::ConfigResponse {\n//                                 deposit_token_addr: Addr::unchecked(\"astro\"),\n//                                 share_token_addr: Addr::unchecked(\"xastro\"),\n//                             };\n\n//                             SystemResult::Ok(to_binary(\u0026config).into())\n//                         }\n//                         _ =\u003e {\n//                             panic!(\"DO NOT ENTER HERE\")\n//                         }\n//                     }\n//                 } else {\n//                     match from_binary(\u0026msg).unwrap() {\n//                         astroport_governance::assembly::QueryMsg::Proposal { proposal_id } =\u003e {\n//                             let proposal = astroport_governance::assembly::Proposal {\n//                                 proposal_id: Uint64::from(proposal_id),\n//                                 submitter: Addr::unchecked(\"submitter\"),\n//                                 status: astroport_governance::assembly::ProposalStatus::Active,\n//                                 for_power: Uint128::zero(),\n//                                 against_power: Uint128::zero(),\n//                                 for_voters: vec![],\n//                                 against_voters: vec![],\n//                                 start_block: 1,\n//                                 start_time: 12345,\n//                                 end_block: 5,\n//                                 delayed_end_block: 10,\n//                                 expiration_block: 15,\n//                                 title: \"Test title\".to_string(),\n//                                 description: \"Test description\".to_string(),\n//                                 link: None,\n//                                 messages: None,\n//                                 deposit_amount: Uint128::one(),\n//                                 ibc_channel: None,\n//                             };\n//                             SystemResult::Ok(to_binary(\u0026proposal).into())\n//                         }\n//                         _ =\u003e {\n//                             println!(\"===========================\");\n//                             println!(\"{}\", msg);\n//                             panic!(\"DO NOT ENTER HEREzz\")\n//                         }\n//                     }\n//                 }\n//             }\n//             _ =\u003e self.base.handle_query(request),\n//         }\n//     }\n// }\n\n// impl WasmMockQuerier {\n//     pub fn new(base: MockQuerier\u003cEmpty\u003e) -\u003e Self {\n//         WasmMockQuerier { base }\n//     }\n// }\n\n// pub fn mock_all(\n//     sender: \u0026str,\n// ) -\u003e (\n//     OwnedDeps\u003cMockStorage, MockApi, WasmMockQuerier\u003e,\n//     Env,\n//     MessageInfo,\n// ) {\n//     let deps = mock_dependencies();\n//     let env = mock_env();\n//     let info = mock_info(sender, \u0026[]);\n//     (deps, env, info)\n// }\n\n// pub fn check_token_balance(app: \u0026mut App, token: \u0026Addr, address: \u0026Addr, expected: u128) {\n//     let msg = Cw20QueryMsg::Balance {\n//         address: address.to_string(),\n//     };\n//     let res: StdResult\u003cBalanceResponse\u003e = app.wrap().query_wasm_smart(token, \u0026msg);\n//     assert_eq!(res.unwrap().balance, Uint128::from(expected));\n// }\n\n// // pub fn mock_channel(channel_id: \u0026str) -\u003e IbcChannel {\n// //     IbcChannel::new(\n// //         IbcEndpoint {\n// //             port_id: CONTRACT_PORT.into(),\n// //             channel_id: channel_id.into(),\n// //         },\n// //         IbcEndpoint {\n// //             port_id: REMOTE_PORT.into(),\n// //             channel_id: format!(\"{}5\", channel_id),\n// //         },\n// //         IbcOrder::Unordered,\n// //         IBC_APP_VERSION,\n// //         CONNECTION_ID,\n// //     )\n// // }\n\n// // pub fn mock_channel_info(channel_id: \u0026str) -\u003e ChannelInfo {\n// //     ChannelInfo {\n// //         id: channel_id.to_string(),\n// //         counterparty_endpoint: IbcEndpoint {\n// //             port_id: REMOTE_PORT.into(),\n// //             channel_id: format!(\"{}5\", channel_id),\n// //         },\n// //         connection_id: CONNECTION_ID.into(),\n// //     }\n// // }\n\n// // we simulate instantiate and ack here\n// // pub fn add_channel(mut deps: DepsMut, channel_id: \u0026str) {\n// //     let channel = mock_channel(channel_id);\n// //     let open_msg = IbcChannelOpenMsg::new_init(channel.clone());\n// //     ibc_channel_open(deps.branch(), mock_env(), open_msg).unwrap();\n// //     let connect_msg = IbcChannelConnectMsg::new_ack(channel, IBC_APP_VERSION);\n// //     ibc_channel_connect(deps.branch(), mock_env(), connect_msg).unwrap();\n// // }\n\n// // pub fn mock_receive_packet(\n// //     my_channel: \u0026str,\n// //     amount: u128,\n// //     denom: \u0026str,\n// //     receiver: \u0026str,\n// //     memo: Option\u003cString\u003e,\n// // ) -\u003e IbcPacket {\n// //     let data = Ics20Packet {\n// //         // this is returning a foreign (our) token, thus denom is \u003cport\u003e/\u003cchannel\u003e/\u003cdenom\u003e\n// //         denom: format!(\"{}/{}/{}\", REMOTE_PORT, \"channel-1234\", denom),\n// //         amount: amount.into(),\n// //         sender: \"remote-sender\".to_string(),\n// //         receiver: receiver.to_string(),\n// //         memo,\n// //     };\n// //     print!(\"Packet denom: {}\", \u0026data.denom);\n// //     IbcPacket::new(\n// //         to_binary(\u0026data).unwrap(),\n// //         IbcEndpoint {\n// //             port_id: REMOTE_PORT.to_string(),\n// //             channel_id: \"channel-1234\".to_string(),\n// //         },\n// //         IbcEndpoint {\n// //             port_id: CONTRACT_PORT.to_string(),\n// //             channel_id: my_channel.to_string(),\n// //         },\n// //         3,\n// //         Timestamp::from_seconds(1665321069).into(),\n// //     )\n// // }\n\n// pub fn mock_ibc_packet(my_channel: \u0026str, data: Binary) -\u003e IbcPacket {\n//     IbcPacket::new(\n//         data,\n//         IbcEndpoint {\n//             port_id: REMOTE_PORT.to_string(),\n//             channel_id: \"channel-3\".to_string(),\n//         },\n//         IbcEndpoint {\n//             port_id: CONTRACT_PORT.to_string(),\n//             channel_id: my_channel.to_string(),\n//         },\n//         3,\n//         Timestamp::from_seconds(1665321069).into(),\n//     )\n// }\n\n// // pub fn setup_channels(channels: \u0026[\u0026str]) -\u003e OwnedDeps\u003cMockStorage, MockApi, WasmMockQuerier\u003e {\n// //     let mut deps = mock_dependencies();\n\n// //     for channel in channels {\n// //         add_channel(deps.as_mut(), channel);\n// //     }\n// //     deps\n// // }\n\n// // #[test]\n// // fn ibc_assembly_vote() {\n// //     pub const OWNER: \u0026str = \"owner\";\n\n// //     let (mut deps, env, info) = mock_all(OWNER);\n\n// //     let token_contract = \"astro\";\n// //     let assembly_contract = \"assembly\";\n// //     let cw20_ics20_contract = \"cw20_ics20\";\n// //     let voter = \"voter1234\";\n// //     let voting_power = Uint128::from(100u128);\n\n// //     instantiate(\n// //         deps.as_mut(),\n// //         env.clone(),\n// //         info,\n// //         astroport_governance::hub::InstantiateMsg {\n// //             owner: \"owner\".to_string(),\n// //             assembly_addr: assembly_contract.to_string(),\n// //             cw20_ics20_addr: \"cw20_ics20\".to_string(),\n// //             staking_addr: \"staking\".to_string(),\n// //             generator_controller_addr: \"generator_controller\".to_string(),\n// //             ibc_timeout_seconds: 10,\n// //         },\n// //     )\n// //     .unwrap();\n\n// //     execute(\n// //         deps.as_mut(),\n// //         env.clone(),\n// //         mock_info(\"owner\", \u0026[]),\n// //         astroport_governance::hub::ExecuteMsg::AddOutpost {\n// //             outpost_addr: \"outpost\".to_string(),\n// //             cw20_ics20_channel: \"channel-1\".to_string(),\n// //         },\n// //     )\n// //     .unwrap();\n\n// //     let proposal_id = 1u64;\n// //     let vote_option = ProposalVoteOption::For;\n\n// //     let ibc_unstake = to_binary(\u0026Hub::CastAssemblyVote {\n// //         proposal_id,\n// //         voter: Addr::unchecked(voter),\n// //         vote_option,\n// //         voting_power,\n// //     })\n// //     .unwrap();\n// //     let recv_packet = mock_ibc_packet(\"channel-3\", ibc_unstake);\n\n// //     let msg = IbcPacketReceiveMsg::new(recv_packet, Addr::unchecked(\"relayer\"));\n// //     let res = ibc_packet_receive(deps.as_mut(), env.clone(), msg).unwrap();\n\n// //     let hub_respone: Response = from_binary(\u0026res.acknowledgement).unwrap();\n// //     match hub_respone {\n// //         Response::Result {\n// //             action,\n// //             address,\n// //             error,\n// //         } =\u003e {\n// //             assert!(error.is_none());\n// //             // assert!(generic.success);\n// //             // assert_eq!(generic.address, voter.to_string());\n// //             // assert_eq!(generic.action, \"cast_assembly_vote\");\n// //             // assert_eq!(generic.message, \"Success\");\n// //         }\n// //         _ =\u003e panic!(\"Wrong response type\"),\n// //     }\n\n// //     assert_eq!(res.messages.len(), 1);\n\n// //     let assembly_msg = to_binary(\n// //         \u0026astroport_governance::assembly::ExecuteMsg::CastOutpostVote {\n// //             proposal_id,\n// //             vote: ProposalVoteOption::For,\n// //             voter: Addr::unchecked(voter),\n// //             voting_power,\n// //         },\n// //     )\n// //     .unwrap();\n\n// //     assert_eq!(\n// //         res.messages[0],\n// //         SubMsg {\n// //             id: 0,\n// //             gas_limit: None,\n// //             reply_on: ReplyOn::Never,\n// //             msg: WasmMsg::Execute {\n// //                 contract_addr: assembly_contract.to_string(),\n// //                 msg: assembly_msg,\n// //                 funds: vec![],\n// //             }\n// //             .into(),\n// //         }\n// //     );\n// // }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","tests","memo.rs"],"content":"use astroport_hub;\n\nuse std::ops::RangeInclusive;\n\nuse astroport_core::token::Cw20Coin;\nuse astroport_cw20_ics20::msg::AllowMsg;\nuse cosmwasm_std::{to_binary, Addr, QueryRequest, Uint128, WasmQuery};\nuse cw20::Cw20ExecuteMsg;\nuse cw_multi_test::{ContractWrapper, Executor};\n\nmod mock;\nuse crate::mock::{check_token_balance, mock_app};\n\nconst VOTING_PERIOD_INTERVAL: RangeInclusive\u003cu64\u003e = 200..=7 * 12342;\nconst DEPOSIT_INTERVAL: RangeInclusive\u003cu128\u003e = 1000..=60000000000;\nconst PROPOSAL_VOTING_PERIOD: u64 = *VOTING_PERIOD_INTERVAL.start();\nconst PROPOSAL_EFFECTIVE_DELAY: u64 = 12_342;\nconst PROPOSAL_EXPIRATION_PERIOD: u64 = 86_399;\nconst PROPOSAL_REQUIRED_DEPOSIT: u128 = *DEPOSIT_INTERVAL.start();\nconst PROPOSAL_REQUIRED_QUORUM: \u0026str = \"0.50\";\nconst PROPOSAL_REQUIRED_THRESHOLD: \u0026str = \"0.60\";\n\n#[test]\nfn receive_invalid_memo() {\n    let send_channel = \"channel-9\";\n\n    let owner = Addr::unchecked(\"terraowner01\");\n\n    let mut router = mock_app();\n\n    let token_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_token::contract::execute,\n        astroport_token::contract::instantiate,\n        astroport_token::contract::query,\n    ));\n\n    let token_code = router.store_code(token_contract);\n\n    let token_default_instantiate_msg = astroport_core::token::InstantiateMsg {\n        name: \"Astroport Token\".to_string(),\n        symbol: \"ASTRO\".to_string(),\n        decimals: 6,\n        initial_balances: vec![Cw20Coin {\n            address: owner.to_string(),\n            amount: Uint128::from(1_000_000_000_000u64),\n        }],\n        mint: None,\n        marketing: None,\n    };\n\n    let token_instance = router\n        .instantiate_contract(\n            token_code,\n            owner.clone(),\n            \u0026token_default_instantiate_msg,\n            \u0026[],\n            \"ASTRO Token\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n        astro_assembly::contract::execute,\n        astro_assembly::contract::instantiate,\n        astro_assembly::contract::query,\n    ));\n\n    let assembly_code = router.store_code(assembly_contract);\n\n    let assembly_default_instantiate_msg = astroport_governance::assembly::InstantiateMsg {\n        xastro_token_addr: \"nocontract\".to_string(), //escrow_helper.xastro_token.to_string(),\n        vxastro_token_addr: None,\n        voting_escrow_delegator_addr: None,\n        ibc_controller: None,\n        generator_controller_addr: None,\n        hub_addr: None,\n        builder_unlock_addr: \"nocontract\".to_string(),\n        proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n        proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n        proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n        proposal_required_deposit: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n        proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n        proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n        whitelisted_links: vec![\"https://some.link/\".to_string()],\n    };\n\n    let assembly_instance = router\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026assembly_default_instantiate_msg,\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let cw20_ics20_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_cw20_ics20::contract::execute,\n        astroport_cw20_ics20::contract::instantiate,\n        astroport_cw20_ics20::contract::query,\n    ));\n\n    let cw20_ics20_code = router.store_code(cw20_ics20_contract);\n\n    let cw20_ics20_instantiate_msg = astroport_cw20_ics20::msg::InitMsg {\n        default_timeout: 10,\n        gov_contract: owner.to_string(),\n        allowlist: vec![AllowMsg {\n            contract: token_instance.to_string(),\n            gas_limit: None,\n        }],\n        default_gas_limit: None,\n        memo_handler: None,\n    };\n\n    let cw20_ics20_instance = router\n        .instantiate_contract(\n            cw20_ics20_code,\n            owner.clone(),\n            \u0026cw20_ics20_instantiate_msg,\n            \u0026[],\n            \"CW20-ICS20\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    // Set up staking\n    let staking_contract = Box::new(\n        ContractWrapper::new_with_empty(\n            astroport_staking::contract::execute,\n            astroport_staking::contract::instantiate,\n            astroport_staking::contract::query,\n        )\n        .with_reply_empty(astroport_staking::contract::reply),\n    );\n\n    let staking_code_id = router.store_code(staking_contract);\n\n    let msg = astroport_core::staking::InstantiateMsg {\n        owner: owner.to_string(),\n        token_code_id: token_code,\n        deposit_token_addr: token_instance.to_string(),\n        marketing: None,\n    };\n    let staking_instance = router\n        .instantiate_contract(\n            staking_code_id,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            String::from(\"xASTRO\"),\n            None,\n        )\n        .unwrap();\n\n    let outpost_handler_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_hub::execute::execute,\n        astroport_hub::contract::instantiate,\n        astroport_hub::query::query,\n    ));\n\n    let outpost_handler_code = router.store_code(outpost_handler_contract);\n\n    let outpost_handler_instantiate_msg = astroport_governance::hub::InstantiateMsg {\n        owner: owner.to_string(),\n        assembly_addr: assembly_instance.to_string(),\n        cw20_ics20_addr: cw20_ics20_instance.to_string(),\n        staking_addr: staking_instance.to_string(),\n        generator_controller_addr: \"generator_controller\".to_string(),\n        ibc_timeout_seconds: 10,\n    };\n\n    let outpost_handler_instance = router\n        .instantiate_contract(\n            outpost_handler_code,\n            owner.clone(),\n            \u0026outpost_handler_instantiate_msg,\n            \u0026[],\n            \"Outpost handler\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let msg = Cw20ExecuteMsg::Transfer {\n        recipient: cw20_ics20_instance.to_string(),\n        amount: Uint128::from(100u64),\n    };\n\n    router\n        .execute_contract(owner.clone(), token_instance.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    check_token_balance(\u0026mut router, \u0026token_instance, \u0026cw20_ics20_instance, 100u128);\n\n    let msg = Cw20ExecuteMsg::Send {\n        contract: outpost_handler_instance.to_string(),\n        msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::OutpostMemo {\n            channel: send_channel.to_string(),\n            sender: owner.to_string(),\n            receiver: outpost_handler_instance.to_string(),\n            memo: \"{invalid_json\".to_string(),\n        })\n        .unwrap(),\n        amount: Uint128::from(100u64),\n    };\n\n    let res = router\n        .execute_contract(\n            Addr::unchecked(cw20_ics20_instance),\n            token_instance.clone(),\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        res.root_cause().to_string(),\n        \"Memo does not conform to the expected format: Invalid type\"\n    );\n    // TODO Update outpost handler config\n\n    // Try to send an invalid Memo\n    // The contract must hold nothing\n    check_token_balance(\n        \u0026mut router,\n        \u0026token_instance,\n        \u0026outpost_handler_instance,\n        0u128,\n    );\n\n    // Instantiate all the contracts we need to load this contract\n}\n\n#[test]\nfn receive_standard_transfer_memo() {\n    let send_channel = \"channel-9\";\n    let cw20_addr = \"token-addr\";\n    let cw20_denom = \"cw20:token-addr\";\n    let gas_limit = 1234567;\n\n    // let recv_packet = mock_receive_packet(send_channel, 100000, cw20_denom, \"local-rcpt\", None);\n\n    let owner = Addr::unchecked(\"terraowner01\");\n    let hub_user = Addr::unchecked(\"terrauser01\");\n    let outpost_user = Addr::unchecked(\"injuser01\");\n\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n\n    let token_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_token::contract::execute,\n        astroport_token::contract::instantiate,\n        astroport_token::contract::query,\n    ));\n\n    let token_code = router.store_code(token_contract);\n\n    let token_default_instantiate_msg = astroport_core::token::InstantiateMsg {\n        name: \"Astroport Token\".to_string(),\n        symbol: \"ASTRO\".to_string(),\n        decimals: 6,\n        initial_balances: vec![Cw20Coin {\n            address: owner.to_string(),\n            amount: Uint128::from(1_000_000_000_000u64),\n        }],\n        mint: None,\n        marketing: None,\n    };\n\n    let token_instance = router\n        .instantiate_contract(\n            token_code,\n            owner.clone(),\n            \u0026token_default_instantiate_msg,\n            \u0026[],\n            \"ASTRO Token\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n        astro_assembly::contract::execute,\n        astro_assembly::contract::instantiate,\n        astro_assembly::contract::query,\n    ));\n\n    let assembly_code = router.store_code(assembly_contract);\n\n    let assembly_default_instantiate_msg = astroport_governance::assembly::InstantiateMsg {\n        xastro_token_addr: \"nocontract\".to_string(), //escrow_helper.xastro_token.to_string(),\n        vxastro_token_addr: None,\n        voting_escrow_delegator_addr: None,\n        ibc_controller: None,\n        generator_controller_addr: None,\n        hub_addr: None,\n        builder_unlock_addr: \"nocontract\".to_string(),\n        proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n        proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n        proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n        proposal_required_deposit: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n        proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n        proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n        whitelisted_links: vec![\"https://some.link/\".to_string()],\n    };\n\n    let assembly_instance = router\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026assembly_default_instantiate_msg,\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let cw20_ics20_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_cw20_ics20::contract::execute,\n        astroport_cw20_ics20::contract::instantiate,\n        astroport_cw20_ics20::contract::query,\n    ));\n\n    let cw20_ics20_code = router.store_code(cw20_ics20_contract);\n\n    let cw20_ics20_instantiate_msg = astroport_cw20_ics20::msg::InitMsg {\n        default_timeout: 10,\n        gov_contract: owner.to_string(),\n        allowlist: vec![AllowMsg {\n            contract: token_instance.to_string(),\n            gas_limit: None,\n        }],\n        default_gas_limit: None,\n        memo_handler: None,\n    };\n\n    let cw20_ics20_instance = router\n        .instantiate_contract(\n            cw20_ics20_code,\n            owner.clone(),\n            \u0026cw20_ics20_instantiate_msg,\n            \u0026[],\n            \"CW20-ICS20\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let msg = Cw20ExecuteMsg::Transfer {\n        recipient: cw20_ics20_instance.to_string(),\n        amount: Uint128::from(100u64),\n    };\n\n    router\n        .execute_contract(owner.clone(), token_instance.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    // Set up staking\n    let staking_contract = Box::new(\n        ContractWrapper::new_with_empty(\n            astroport_staking::contract::execute,\n            astroport_staking::contract::instantiate,\n            astroport_staking::contract::query,\n        )\n        .with_reply_empty(astroport_staking::contract::reply),\n    );\n\n    let staking_code_id = router.store_code(staking_contract);\n\n    let msg = astroport_core::staking::InstantiateMsg {\n        owner: owner.to_string(),\n        token_code_id: token_code,\n        deposit_token_addr: token_instance.to_string(),\n        marketing: None,\n    };\n    let staking_instance = router\n        .instantiate_contract(\n            staking_code_id,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            String::from(\"xASTRO\"),\n            None,\n        )\n        .unwrap();\n\n    let outpost_handler_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_hub::execute::execute,\n        astroport_hub::contract::instantiate,\n        astroport_hub::query::query,\n    ));\n\n    let outpost_handler_code = router.store_code(outpost_handler_contract);\n\n    let outpost_handler_instantiate_msg = astroport_governance::hub::InstantiateMsg {\n        owner: owner.to_string(),\n        assembly_addr: assembly_instance.to_string(),\n        cw20_ics20_addr: cw20_ics20_instance.to_string(),\n        staking_addr: staking_instance.to_string(),\n        generator_controller_addr: \"assembly\".to_string(),\n        ibc_timeout_seconds: 10,\n    };\n\n    check_token_balance(\u0026mut router, \u0026token_instance, \u0026hub_user, 0u128);\n\n    let outpost_handler_instance = router\n        .instantiate_contract(\n            outpost_handler_code,\n            owner.clone(),\n            \u0026outpost_handler_instantiate_msg,\n            \u0026[],\n            \"Outpost handler\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let msg = Cw20ExecuteMsg::Send {\n        contract: outpost_handler_instance.to_string(),\n        msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::OutpostMemo {\n            channel: send_channel.to_string(),\n            sender: owner.to_string(),\n            receiver: hub_user.to_string(),\n            memo: \"Standard memo that should not be processed\".to_string(),\n        })\n        .unwrap(),\n        amount: Uint128::from(100u64),\n    };\n\n    let res = router.execute_contract(\n        Addr::unchecked(cw20_ics20_instance),\n        token_instance.clone(),\n        \u0026msg,\n        \u0026[],\n    );\n    assert!(res.is_ok());\n\n    // Check that the balance of Hub user increased\n    check_token_balance(\u0026mut router, \u0026token_instance, \u0026hub_user, 100u128);\n    // The contract must hold nothing\n    check_token_balance(\n        \u0026mut router,\n        \u0026token_instance,\n        \u0026outpost_handler_instance,\n        0u128,\n    );\n}\n\n#[test]\n#[cfg(test)]\nfn receive_stake_memo() {\n    let send_channel = \"channel-9\";\n    let cw20_addr = \"token-addr\";\n    let cw20_denom = \"cw20:token-addr\";\n    let gas_limit = 1234567;\n\n    // let recv_packet = mock_receive_packet(send_channel, 100000, cw20_denom, \"local-rcpt\", None);\n\n    let owner = Addr::unchecked(\"terraowner01\");\n    let hub_user = Addr::unchecked(\"terrauser01\");\n    let outpost_user = Addr::unchecked(\"injuser01\");\n\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n\n    let token_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_token::contract::execute,\n        astroport_token::contract::instantiate,\n        astroport_token::contract::query,\n    ));\n\n    let token_code = router.store_code(token_contract);\n\n    let token_default_instantiate_msg = astroport_core::token::InstantiateMsg {\n        name: \"Astroport Token\".to_string(),\n        symbol: \"ASTRO\".to_string(),\n        decimals: 6,\n        initial_balances: vec![Cw20Coin {\n            address: owner.to_string(),\n            amount: Uint128::from(1_000_000_000_000u64),\n        }],\n        mint: None,\n        marketing: None,\n    };\n\n    let token_instance = router\n        .instantiate_contract(\n            token_code,\n            owner.clone(),\n            \u0026token_default_instantiate_msg,\n            \u0026[],\n            \"ASTRO Token\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n        astro_assembly::contract::execute,\n        astro_assembly::contract::instantiate,\n        astro_assembly::contract::query,\n    ));\n\n    let assembly_code = router.store_code(assembly_contract);\n\n    let assembly_default_instantiate_msg = astroport_governance::assembly::InstantiateMsg {\n        xastro_token_addr: \"nocontract\".to_string(), //escrow_helper.xastro_token.to_string(),\n        vxastro_token_addr: None,\n        voting_escrow_delegator_addr: None,\n        ibc_controller: None,\n        generator_controller_addr: None,\n        hub_addr: None,\n        builder_unlock_addr: \"nocontract\".to_string(),\n        proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n        proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n        proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n        proposal_required_deposit: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n        proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n        proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n        whitelisted_links: vec![\"https://some.link/\".to_string()],\n    };\n\n    let assembly_instance = router\n        .instantiate_contract(\n            assembly_code,\n            owner.clone(),\n            \u0026assembly_default_instantiate_msg,\n            \u0026[],\n            \"Assembly\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let cw20_ics20_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_cw20_ics20::contract::execute,\n        astroport_cw20_ics20::contract::instantiate,\n        astroport_cw20_ics20::contract::query,\n    ));\n\n    let cw20_ics20_code = router.store_code(cw20_ics20_contract);\n\n    let cw20_ics20_instantiate_msg = astroport_cw20_ics20::msg::InitMsg {\n        default_timeout: 10,\n        gov_contract: owner.to_string(),\n        allowlist: vec![AllowMsg {\n            contract: token_instance.to_string(),\n            gas_limit: None,\n        }],\n        default_gas_limit: None,\n        memo_handler: None,\n    };\n\n    let cw20_ics20_instance = router\n        .instantiate_contract(\n            cw20_ics20_code,\n            owner.clone(),\n            \u0026cw20_ics20_instantiate_msg,\n            \u0026[],\n            \"CW20-ICS20\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let msg = Cw20ExecuteMsg::Transfer {\n        recipient: cw20_ics20_instance.to_string(),\n        amount: Uint128::from(100000u64),\n    };\n\n    router\n        .execute_contract(owner.clone(), token_instance.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    // let (astro_token_instance, staking_instance, _) =\n    //     instantiate_contracts(\u0026mut router, owner.clone());\n\n    // Set up staking\n    let staking_contract = Box::new(\n        ContractWrapper::new_with_empty(\n            astroport_staking::contract::execute,\n            astroport_staking::contract::instantiate,\n            astroport_staking::contract::query,\n        )\n        .with_reply_empty(astroport_staking::contract::reply),\n    );\n\n    let staking_code_id = router.store_code(staking_contract);\n\n    let msg = astroport_core::staking::InstantiateMsg {\n        owner: owner.to_string(),\n        token_code_id: token_code,\n        deposit_token_addr: token_instance.to_string(),\n        marketing: None,\n    };\n    let staking_instance = router\n        .instantiate_contract(\n            staking_code_id,\n            owner.clone(),\n            \u0026msg,\n            \u0026[],\n            String::from(\"xASTRO\"),\n            None,\n        )\n        .unwrap();\n\n    let msg = astroport_core::staking::QueryMsg::Config {};\n    let res = router\n        .wrap()\n        .query::\u003castroport_core::staking::ConfigResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: staking_instance.to_string(),\n            msg: to_binary(\u0026msg).unwrap(),\n        }))\n        .unwrap();\n    let x_astro_token_instance = res.share_token_addr;\n\n    let outpost_handler_contract = Box::new(\n        ContractWrapper::new_with_empty(\n            astroport_hub::execute::execute,\n            astroport_hub::contract::instantiate,\n            astroport_hub::query::query,\n        )\n        .with_reply(astroport_hub::reply::reply),\n    );\n\n    let outpost_handler_code = router.store_code(outpost_handler_contract);\n\n    let outpost_handler_instantiate_msg = astroport_governance::hub::InstantiateMsg {\n        owner: owner.to_string(),\n        assembly_addr: assembly_instance.to_string(),\n        cw20_ics20_addr: cw20_ics20_instance.to_string(),\n        staking_addr: staking_instance.to_string(),\n        generator_controller_addr: \"generator_controller\".to_string(),\n        ibc_timeout_seconds: 10,\n    };\n\n    let outpost_handler_instance = router\n        .instantiate_contract(\n            outpost_handler_code,\n            owner.clone(),\n            \u0026outpost_handler_instantiate_msg,\n            \u0026[],\n            \"Outpost handler\".to_string(),\n            Some(owner.to_string()),\n        )\n        .unwrap();\n\n    let msg = astroport_governance::hub::ExecuteMsg::AddOutpost {\n        outpost_addr: \"outpost\".to_owned(),\n        cw20_ics20_channel: \"channel-1\".to_owned(),\n    };\n\n    // Add an outpost\n    let res = router\n        .execute_contract(\n            Addr::unchecked(owner.clone()),\n            outpost_handler_instance.clone(),\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let msg = Cw20ExecuteMsg::Send {\n        contract: outpost_handler_instance.to_string(),\n        msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::OutpostMemo {\n            channel: \"channel-1\".to_string(),\n            sender: owner.to_string(),\n            receiver: outpost_handler_instance.to_string(),\n            memo: \"{\\\"stake\\\": {}}\".to_string(),\n        })\n        .unwrap(),\n        amount: Uint128::from(100u64),\n    };\n\n    // First staker must send more that 1000astro, otherwise staking will fail, we test for fail here\n    let res = router\n        .execute_contract(\n            Addr::unchecked(cw20_ics20_instance.clone()),\n            token_instance.clone(),\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n            res.root_cause().to_string(),\n        \"Invalid submessage error executing WasmMsg:\\nsender: contract5\\nExecute { contract_addr: \\\"contract0\\\", msg: {\\\"send\\\":{\\\"contract\\\":\\\"contract3\\\",\\\"amount\\\":\\\"100\\\",\\\"msg\\\":\\\"eyJlbnRlciI6e319\\\"}}, funds: [] }\");\n\n    let msg = Cw20ExecuteMsg::Send {\n        contract: outpost_handler_instance.to_string(),\n        msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::OutpostMemo {\n            channel: \"channel-1\".to_string(),\n            sender: owner.to_string(),\n            receiver: outpost_handler_instance.to_string(),\n            memo: \"{\\\"stake\\\": {}}\".to_string(),\n        })\n        .unwrap(),\n        amount: Uint128::from(10000u64),\n    };\n\n    // Check that the contract blocks anyone else\n    let res = router\n        .execute_contract(owner.clone(), token_instance.clone(), \u0026msg, \u0026[])\n        .unwrap_err();\n    assert_eq!(res.root_cause().to_string(), \"Unauthorized\");\n\n    let query_msg = astroport_governance::hub::QueryMsg::Outposts {};\n    let res: Vec\u003castroport_governance::hub::OutpostConfig\u003e = router\n        .wrap()\n        .query_wasm_smart(outpost_handler_instance, \u0026query_msg)\n        .unwrap();\n\n    // Check that the contract emits a mint IBC message\n    // cw-multitest doesn't support IBC yet, and thus will return the IBC message as an error\n    // We check the format against that error\n    let res = router\n        .execute_contract(\n            Addr::unchecked(cw20_ics20_instance),\n            token_instance,\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n            res.root_cause().to_string(),\n            \"Unexpected exec msg SendPacket { channel_id: \\\"channel-3\\\", data: Binary(7b226d696e745f785f617374726f223a7b227265636569766572223a2274657272616f776e65723031222c22616d6f756e74223a2239303030227d7d), timeout: IbcTimeout { block: None, timestamp: Some(Timestamp(Uint64(1689152304000000000))) } } from Addr(\\\"contract5\\\")\"\n        );\n\n    // We will always receive this error since we can't actually establish an IBC connection that would\n    // construct the valid outpost link\n    // let res = router\n    //     .execute_contract(Addr::unchecked(cw20_ics20_instance), token_instance, \u0026msg, \u0026[])\n    //     .unwrap_err();\n    // assert_eq!(\n    //     res.root_cause().to_string(),\n    //     \"No Outpost found that matches the message channels\"\n    // );\n}\n\n// use std::ops::RangeInclusive;\n\n// use astroport_cw20_ics20::msg::AllowMsg;\n\n// use astroport_hub::mock::mock_app;\n// use cosmwasm_std::{Addr, Uint128};\n// use cw20::Cw20Coin;\n// use cw_multi_test::ContractWrapper;\n\n// #[cfg(test)]\n// mod helper;\n\n// const VOTING_PERIOD_INTERVAL: RangeInclusive\u003cu64\u003e = 200..=7 * 12342;\n// const DEPOSIT_INTERVAL: RangeInclusive\u003cu128\u003e = 1000..=60000000000;\n// const PROPOSAL_VOTING_PERIOD: u64 = *VOTING_PERIOD_INTERVAL.start();\n// const PROPOSAL_EFFECTIVE_DELAY: u64 = 12_342;\n// const PROPOSAL_EXPIRATION_PERIOD: u64 = 86_399;\n// const PROPOSAL_REQUIRED_DEPOSIT: u128 = *DEPOSIT_INTERVAL.start();\n// const PROPOSAL_REQUIRED_QUORUM: \u0026str = \"0.50\";\n// const PROPOSAL_REQUIRED_THRESHOLD: \u0026str = \"0.60\";\n\n// #[test]\n// fn update_config() {\n//     let send_channel = \"channel-9\";\n//     let cw20_addr = \"token-addr\";\n//     let cw20_denom = \"cw20:token-addr\";\n//     let gas_limit = 1234567;\n\n//     // let recv_packet = mock_receive_packet(send_channel, 100000, cw20_denom, \"local-rcpt\", None);\n\n//     let owner = Addr::unchecked(\"terraowner01\");\n//     let hub_user = Addr::unchecked(\"terrauser01\");\n//     let outpost_user = Addr::unchecked(\"injuser01\");\n\n//     let mut router = mock_app();\n//     let router_ref = \u0026mut router;\n\n//     let token_contract = Box::new(ContractWrapper::new_with_empty(\n//         astroport_token::contract::execute,\n//         astroport_token::contract::instantiate,\n//         astroport_token::contract::query,\n//     ));\n\n//     let token_code = router.store_code(token_contract);\n\n//     let token_default_instantiate_msg = astroport_core::token::InstantiateMsg {\n//         name: \"Astroport Token\".to_string(),\n//         symbol: \"ASTRO\".to_string(),\n//         decimals: 6,\n//         initial_balances: vec![Cw20Coin {\n//             address: owner.to_string(),\n//             amount: Uint128::from(1_000_000_000_000u64),\n//         }],\n//         mint: None,\n//         marketing: None,\n//     };\n\n//     let token_instance = router\n//         .instantiate_contract(\n//             token_code,\n//             owner.clone(),\n//             \u0026token_default_instantiate_msg,\n//             \u0026[],\n//             \"ASTRO Token\".to_string(),\n//             Some(owner.to_string()),\n//         )\n//         .unwrap();\n\n//     let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n//         astro_assembly::contract::execute,\n//         astro_assembly::contract::instantiate,\n//         astro_assembly::contract::query,\n//     ));\n\n//     let assembly_code = router.store_code(assembly_contract);\n\n//     let assembly_default_instantiate_msg = astroport_governance::assembly::InstantiateMsg {\n//         xastro_token_addr: \"nocontract\".to_string(), //escrow_helper.xastro_token.to_string(),\n//         vxastro_token_addr: None,\n//         voting_escrow_delegator_addr: None,\n//         ibc_controller: None,\n//         generator_controller_addr: None,\n//         hub_addr: None,\n//         builder_unlock_addr: \"nocontract\".to_string(),\n//         proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n//         proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n//         proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n//         proposal_required_deposit: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n//         proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n//         proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n//         whitelisted_links: vec![\"https://some.link/\".to_string()],\n//     };\n\n//     let assembly_instance = router\n//         .instantiate_contract(\n//             assembly_code,\n//             owner.clone(),\n//             \u0026assembly_default_instantiate_msg,\n//             \u0026[],\n//             \"Assembly\".to_string(),\n//             Some(owner.to_string()),\n//         )\n//         .unwrap();\n\n//     let cw20_ics20_contract = Box::new(ContractWrapper::new_with_empty(\n//         astroport_cw20_ics20::contract::execute,\n//         astroport_cw20_ics20::contract::instantiate,\n//         astroport_cw20_ics20::contract::query,\n//     ));\n\n//     let cw20_ics20_code = router.store_code(cw20_ics20_contract);\n\n//     let cw20_ics20_instantiate_msg = astroport_cw20_ics20::msg::InitMsg {\n//         default_timeout: 10,\n//         gov_contract: owner.to_string(),\n//         allowlist: vec![AllowMsg {\n//             contract: token_instance.to_string(),\n//             gas_limit: None,\n//         }],\n//         default_gas_limit: None,\n//         memo_handler: None,\n//     };\n\n//     let cw20_ics20_instance = router\n//         .instantiate_contract(\n//             cw20_ics20_code,\n//             owner.clone(),\n//             \u0026cw20_ics20_instantiate_msg,\n//             \u0026[],\n//             \"CW20-ICS20\".to_string(),\n//             Some(owner.to_string()),\n//         )\n//         .unwrap();\n\n//     // Set up staking\n//     let staking_contract = Box::new(\n//         ContractWrapper::new_with_empty(\n//             astroport_staking::contract::execute,\n//             astroport_staking::contract::instantiate,\n//             astroport_staking::contract::query,\n//         )\n//         .with_reply_empty(astroport_staking::contract::reply),\n//     );\n\n//     let staking_code_id = router.store_code(staking_contract);\n\n//     let msg = astroport_core::staking::InstantiateMsg {\n//         owner: owner.to_string(),\n//         token_code_id: token_code,\n//         deposit_token_addr: token_instance.to_string(),\n//         marketing: None,\n//     };\n//     let staking_instance = router\n//         .instantiate_contract(\n//             staking_code_id,\n//             owner.clone(),\n//             \u0026msg,\n//             \u0026[],\n//             String::from(\"xASTRO\"),\n//             None,\n//         )\n//         .unwrap();\n\n//     let outpost_handler_contract = Box::new(ContractWrapper::new_with_empty(\n//         astroport_hub::execute::execute,\n//         astroport_hub::contract::instantiate,\n//         astroport_hub::query::query,\n//     ));\n\n//     let outpost_handler_code = router.store_code(outpost_handler_contract);\n\n//     let outpost_handler_instantiate_msg = astroport_governance::hub::InstantiateMsg {\n//         owner: owner.to_string(),\n//         assembly_addr: assembly_instance.to_string(),\n//         cw20_ics20_addr: cw20_ics20_instance.to_string(),\n//         staking_addr: staking_instance.to_string(),\n//         generator_controller_addr: \"generator_controller\".to_string(),\n//         ibc_timeout_seconds: 10,\n//     };\n\n//     let outpost_handler_instance = router\n//         .instantiate_contract(\n//             outpost_handler_code,\n//             owner.clone(),\n//             \u0026outpost_handler_instantiate_msg,\n//             \u0026[],\n//             \"Outpost handler\".to_string(),\n//             Some(owner.to_string()),\n//         )\n//         .unwrap();\n// }\n\n// // #[cfg(test)]\n// // mod tests {\n// // use super::*;\n\n// //     use std::{cell::RefCell, ops::RangeInclusive, rc::Rc};\n\n// //     use astroport_core::{\n// //         querier::query_balance,\n// //         token::{BalanceResponse, Cw20Coin},\n// //     };\n// //     use astroport_cw20_ics20::msg::AllowMsg;\n// //     use astroport_governance::hub;\n// //     use cosmwasm_std::{\n// //         testing::{mock_env, MockApi, MockStorage},\n// //         to_binary, Addr, Coin, QueryRequest, StdResult, Timestamp, Uint128, WasmQuery,\n// //     };\n// //     use cw20::{Cw20ExecuteMsg, Cw20QueryMsg};\n// //     use cw_multi_test::{App, AppBuilder, BankKeeper, BasicApp, ContractWrapper, Executor};\n\n// //     use crate::helper::{check_token_balance, mock_app};\n\n// //     const VOTING_PERIOD_INTERVAL: RangeInclusive\u003cu64\u003e = 200..=7 * 12342;\n// //     const DEPOSIT_INTERVAL: RangeInclusive\u003cu128\u003e = 1000..=60000000000;\n// //     const PROPOSAL_VOTING_PERIOD: u64 = *VOTING_PERIOD_INTERVAL.start();\n// //     const PROPOSAL_EFFECTIVE_DELAY: u64 = 12_342;\n// //     const PROPOSAL_EXPIRATION_PERIOD: u64 = 86_399;\n// //     const PROPOSAL_REQUIRED_DEPOSIT: u128 = *DEPOSIT_INTERVAL.start();\n// //     const PROPOSAL_REQUIRED_QUORUM: \u0026str = \"0.50\";\n// //     const PROPOSAL_REQUIRED_THRESHOLD: \u0026str = \"0.60\";\n\n// //     #[test]\n// //     fn receive_invalid_memo() {\n// //         let send_channel = \"channel-9\";\n// //         let cw20_addr = \"token-addr\";\n// //         let cw20_denom = \"cw20:token-addr\";\n// //         let gas_limit = 1234567;\n\n// //         // let recv_packet = mock_receive_packet(send_channel, 100000, cw20_denom, \"local-rcpt\", None);\n\n// //         let owner = Addr::unchecked(\"terraowner01\");\n// //         let hub_user = Addr::unchecked(\"terrauser01\");\n// //         let outpost_user = Addr::unchecked(\"injuser01\");\n\n// //         let mut router = mock_app();\n// //         let router_ref = \u0026mut router;\n\n// //         let token_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astroport_token::contract::execute,\n// //             astroport_token::contract::instantiate,\n// //             astroport_token::contract::query,\n// //         ));\n\n// //         let token_code = router.store_code(token_contract);\n\n// //         let token_default_instantiate_msg = astroport_core::token::InstantiateMsg {\n// //             name: \"Astroport Token\".to_string(),\n// //             symbol: \"ASTRO\".to_string(),\n// //             decimals: 6,\n// //             initial_balances: vec![Cw20Coin {\n// //                 address: owner.to_string(),\n// //                 amount: Uint128::from(1_000_000_000_000u64),\n// //             }],\n// //             mint: None,\n// //             marketing: None,\n// //         };\n\n// //         let token_instance = router\n// //             .instantiate_contract(\n// //                 token_code,\n// //                 owner.clone(),\n// //                 \u0026token_default_instantiate_msg,\n// //                 \u0026[],\n// //                 \"ASTRO Token\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astro_assembly::contract::execute,\n// //             astro_assembly::contract::instantiate,\n// //             astro_assembly::contract::query,\n// //         ));\n\n// //         let assembly_code = router.store_code(assembly_contract);\n\n// //         let assembly_default_instantiate_msg = astroport_governance::assembly::InstantiateMsg {\n// //             xastro_token_addr: \"nocontract\".to_string(), //escrow_helper.xastro_token.to_string(),\n// //             vxastro_token_addr: None,\n// //             voting_escrow_delegator_addr: None,\n// //             ibc_controller: None,\n// //             generator_controller_addr: None,\n// //             hub_addr: None,\n// //             builder_unlock_addr: \"nocontract\".to_string(),\n// //             proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n// //             proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n// //             proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n// //             proposal_required_deposit: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n// //             proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n// //             proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n// //             whitelisted_links: vec![\"https://some.link/\".to_string()],\n// //         };\n\n// //         let assembly_instance = router\n// //             .instantiate_contract(\n// //                 assembly_code,\n// //                 owner.clone(),\n// //                 \u0026assembly_default_instantiate_msg,\n// //                 \u0026[],\n// //                 \"Assembly\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let cw20_ics20_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astroport_cw20_ics20::contract::execute,\n// //             astroport_cw20_ics20::contract::instantiate,\n// //             astroport_cw20_ics20::contract::query,\n// //         ));\n\n// //         let cw20_ics20_code = router.store_code(cw20_ics20_contract);\n\n// //         let cw20_ics20_instantiate_msg = astroport_cw20_ics20::msg::InitMsg {\n// //             default_timeout: 10,\n// //             gov_contract: owner.to_string(),\n// //             allowlist: vec![AllowMsg {\n// //                 contract: token_instance.to_string(),\n// //                 gas_limit: None,\n// //             }],\n// //             default_gas_limit: None,\n// //             memo_handler: None,\n// //         };\n\n// //         let cw20_ics20_instance = router\n// //             .instantiate_contract(\n// //                 cw20_ics20_code,\n// //                 owner.clone(),\n// //                 \u0026cw20_ics20_instantiate_msg,\n// //                 \u0026[],\n// //                 \"CW20-ICS20\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         // Set up staking\n// //         let staking_contract = Box::new(\n// //             ContractWrapper::new_with_empty(\n// //                 astroport_staking::contract::execute,\n// //                 astroport_staking::contract::instantiate,\n// //                 astroport_staking::contract::query,\n// //             )\n// //             .with_reply_empty(astroport_staking::contract::reply),\n// //         );\n\n// //         let staking_code_id = router.store_code(staking_contract);\n\n// //         let msg = astroport_core::staking::InstantiateMsg {\n// //             owner: owner.to_string(),\n// //             token_code_id: token_code,\n// //             deposit_token_addr: token_instance.to_string(),\n// //             marketing: None,\n// //         };\n// //         let staking_instance = router\n// //             .instantiate_contract(\n// //                 staking_code_id,\n// //                 owner.clone(),\n// //                 \u0026msg,\n// //                 \u0026[],\n// //                 String::from(\"xASTRO\"),\n// //                 None,\n// //             )\n// //             .unwrap();\n\n// //         let outpost_handler_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astroport_hub::execute::execute,\n// //             astroport_hub::contract::instantiate,\n// //             astroport_hub::query::query,\n// //         ));\n\n// //         let outpost_handler_code = router.store_code(outpost_handler_contract);\n\n// //         let outpost_handler_instantiate_msg = astroport_governance::hub::InstantiateMsg {\n// //             owner: owner.to_string(),\n// //             assembly_addr: assembly_instance.to_string(),\n// //             cw20_ics20_addr: cw20_ics20_instance.to_string(),\n// //             staking_addr: staking_instance.to_string(),\n// //             generator_controller_addr: \"generator_controller\".to_string(),\n// //             ibc_timeout_seconds: 10,\n// //         };\n\n// //         let outpost_handler_instance = router\n// //             .instantiate_contract(\n// //                 outpost_handler_code,\n// //                 owner.clone(),\n// //                 \u0026outpost_handler_instantiate_msg,\n// //                 \u0026[],\n// //                 \"Outpost handler\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let msg = Cw20ExecuteMsg::Transfer {\n// //             recipient: cw20_ics20_instance.to_string(),\n// //             amount: Uint128::from(100u64),\n// //         };\n\n// //         router.execute_contract(owner.clone(), token_instance.clone(), \u0026msg, \u0026[]).unwrap();\n\n// //         check_token_balance(\n// //             \u0026mut router,\n// //             \u0026token_instance,\n// //             \u0026cw20_ics20_instance,\n// //             100u128,\n// //         );\n\n// //         let msg = Cw20ExecuteMsg::Send {\n// //             contract: outpost_handler_instance.to_string(),\n// //             msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::OutpostMemo {\n// //                 channel: send_channel.to_string(),\n// //                 sender: owner.to_string(),\n// //                 receiver: outpost_handler_instance.to_string(),\n// //                 memo: \"{invalid_json\".to_string(),\n// //             })\n// //             .unwrap(),\n// //             amount: Uint128::from(100u64),\n// //         };\n\n// //         let res = router\n// //             .execute_contract(Addr::unchecked(cw20_ics20_instance), token_instance.clone(), \u0026msg, \u0026[])\n// //             .unwrap_err();\n// //         assert_eq!(\n// //             res.root_cause().to_string(),\n// //             \"Memo does not conform to the expected format: Invalid type\"\n// //         );\n// //         // TODO Update outpost handler config\n\n// //         // Try to send an invalid Memo\n// //         // The contract must hold nothing\n// //         check_token_balance(\n// //             \u0026mut router,\n// //             \u0026token_instance,\n// //             \u0026outpost_handler_instance,\n// //             0u128,\n// //         );\n\n// //         // Instantiate all the contracts we need to load this contract\n// //     }\n\n// //     #[test]\n// //     fn receive_standard_transfer_memo() {\n// //         let send_channel = \"channel-9\";\n// //         let cw20_addr = \"token-addr\";\n// //         let cw20_denom = \"cw20:token-addr\";\n// //         let gas_limit = 1234567;\n\n// //         // let recv_packet = mock_receive_packet(send_channel, 100000, cw20_denom, \"local-rcpt\", None);\n\n// //         let owner = Addr::unchecked(\"terraowner01\");\n// //         let hub_user = Addr::unchecked(\"terrauser01\");\n// //         let outpost_user = Addr::unchecked(\"injuser01\");\n\n// //         let mut router = mock_app();\n// //         let router_ref = \u0026mut router;\n\n// //         let token_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astroport_token::contract::execute,\n// //             astroport_token::contract::instantiate,\n// //             astroport_token::contract::query,\n// //         ));\n\n// //         let token_code = router.store_code(token_contract);\n\n// //         let token_default_instantiate_msg = astroport_core::token::InstantiateMsg {\n// //             name: \"Astroport Token\".to_string(),\n// //             symbol: \"ASTRO\".to_string(),\n// //             decimals: 6,\n// //             initial_balances: vec![Cw20Coin {\n// //                 address: owner.to_string(),\n// //                 amount: Uint128::from(1_000_000_000_000u64),\n// //             }],\n// //             mint: None,\n// //             marketing: None,\n// //         };\n\n// //         let token_instance = router\n// //             .instantiate_contract(\n// //                 token_code,\n// //                 owner.clone(),\n// //                 \u0026token_default_instantiate_msg,\n// //                 \u0026[],\n// //                 \"ASTRO Token\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astro_assembly::contract::execute,\n// //             astro_assembly::contract::instantiate,\n// //             astro_assembly::contract::query,\n// //         ));\n\n// //         let assembly_code = router.store_code(assembly_contract);\n\n// //         let assembly_default_instantiate_msg = astroport_governance::assembly::InstantiateMsg {\n// //             xastro_token_addr: \"nocontract\".to_string(), //escrow_helper.xastro_token.to_string(),\n// //             vxastro_token_addr: None,\n// //             voting_escrow_delegator_addr: None,\n// //             ibc_controller: None,\n// //             generator_controller_addr: None,\n// //             hub_addr: None,\n// //             builder_unlock_addr: \"nocontract\".to_string(),\n// //             proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n// //             proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n// //             proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n// //             proposal_required_deposit: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n// //             proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n// //             proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n// //             whitelisted_links: vec![\"https://some.link/\".to_string()],\n// //         };\n\n// //         let assembly_instance = router\n// //             .instantiate_contract(\n// //                 assembly_code,\n// //                 owner.clone(),\n// //                 \u0026assembly_default_instantiate_msg,\n// //                 \u0026[],\n// //                 \"Assembly\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let cw20_ics20_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astroport_cw20_ics20::contract::execute,\n// //             astroport_cw20_ics20::contract::instantiate,\n// //             astroport_cw20_ics20::contract::query,\n// //         ));\n\n// //         let cw20_ics20_code = router.store_code(cw20_ics20_contract);\n\n// //         let cw20_ics20_instantiate_msg = astroport_cw20_ics20::msg::InitMsg {\n// //             default_timeout: 10,\n// //             gov_contract: owner.to_string(),\n// //             allowlist: vec![AllowMsg {\n// //                 contract: token_instance.to_string(),\n// //                 gas_limit: None,\n// //             }],\n// //             default_gas_limit: None,\n// //             memo_handler: None,\n// //         };\n\n// //         let cw20_ics20_instance = router\n// //             .instantiate_contract(\n// //                 cw20_ics20_code,\n// //                 owner.clone(),\n// //                 \u0026cw20_ics20_instantiate_msg,\n// //                 \u0026[],\n// //                 \"CW20-ICS20\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let msg = Cw20ExecuteMsg::Transfer {\n// //             recipient: cw20_ics20_instance.to_string(),\n// //             amount: Uint128::from(100u64),\n// //         };\n\n// //         router.execute_contract(owner.clone(), token_instance.clone(), \u0026msg, \u0026[]).unwrap();\n\n// //         // Set up staking\n// //         let staking_contract = Box::new(\n// //             ContractWrapper::new_with_empty(\n// //                 astroport_staking::contract::execute,\n// //                 astroport_staking::contract::instantiate,\n// //                 astroport_staking::contract::query,\n// //             )\n// //             .with_reply_empty(astroport_staking::contract::reply),\n// //         );\n\n// //         let staking_code_id = router.store_code(staking_contract);\n\n// //         let msg = astroport_core::staking::InstantiateMsg {\n// //             owner: owner.to_string(),\n// //             token_code_id: token_code,\n// //             deposit_token_addr: token_instance.to_string(),\n// //             marketing: None,\n// //         };\n// //         let staking_instance = router\n// //             .instantiate_contract(\n// //                 staking_code_id,\n// //                 owner.clone(),\n// //                 \u0026msg,\n// //                 \u0026[],\n// //                 String::from(\"xASTRO\"),\n// //                 None,\n// //             )\n// //             .unwrap();\n\n// //         let outpost_handler_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astroport_hub::execute::execute,\n// //             astroport_hub::contract::instantiate,\n// //             astroport_hub::query::query,\n// //         ));\n\n// //         let outpost_handler_code = router.store_code(outpost_handler_contract);\n\n// //         let outpost_handler_instantiate_msg = astroport_governance::hub::InstantiateMsg {\n// //             owner: owner.to_string(),\n// //             assembly_addr: assembly_instance.to_string(),\n// //             cw20_ics20_addr: cw20_ics20_instance.to_string(),\n// //             staking_addr: staking_instance.to_string(),\n// //             generator_controller_addr: \"assembly\".to_string(),\n// //             ibc_timeout_seconds: 10,\n// //         };\n\n// //         check_token_balance(\u0026mut router, \u0026token_instance, \u0026hub_user, 0u128);\n\n// //         let outpost_handler_instance = router\n// //             .instantiate_contract(\n// //                 outpost_handler_code,\n// //                 owner.clone(),\n// //                 \u0026outpost_handler_instantiate_msg,\n// //                 \u0026[],\n// //                 \"Outpost handler\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let msg = Cw20ExecuteMsg::Send {\n// //             contract: outpost_handler_instance.to_string(),\n// //             msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::OutpostMemo {\n// //                 channel: send_channel.to_string(),\n// //                 sender: owner.to_string(),\n// //                 receiver: hub_user.to_string(),\n// //                 memo: \"Standard memo that should not be processed\".to_string(),\n// //             })\n// //             .unwrap(),\n// //             amount: Uint128::from(100u64),\n// //         };\n\n// //         let res = router.execute_contract(Addr::unchecked(cw20_ics20_instance), token_instance.clone(), \u0026msg, \u0026[]);\n// //         assert!(res.is_ok());\n\n// //         // Check that the balance of Hub user increased\n// //         check_token_balance(\u0026mut router, \u0026token_instance, \u0026hub_user, 100u128);\n// //         // The contract must hold nothing\n// //         check_token_balance(\n// //             \u0026mut router,\n// //             \u0026token_instance,\n// //             \u0026outpost_handler_instance,\n// //             0u128,\n// //         );\n// //     }\n\n// //     #[test]\n// //     #[cfg(test)]\n// //     fn receive_stake_memo() {\n// //         let send_channel = \"channel-9\";\n// //         let cw20_addr = \"token-addr\";\n// //         let cw20_denom = \"cw20:token-addr\";\n// //         let gas_limit = 1234567;\n\n// //         // let recv_packet = mock_receive_packet(send_channel, 100000, cw20_denom, \"local-rcpt\", None);\n\n// //         let owner = Addr::unchecked(\"terraowner01\");\n// //         let hub_user = Addr::unchecked(\"terrauser01\");\n// //         let outpost_user = Addr::unchecked(\"injuser01\");\n\n// //         let mut router = mock_app();\n// //         let router_ref = \u0026mut router;\n\n// //         let token_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astroport_token::contract::execute,\n// //             astroport_token::contract::instantiate,\n// //             astroport_token::contract::query,\n// //         ));\n\n// //         let token_code = router.store_code(token_contract);\n\n// //         let token_default_instantiate_msg = astroport_core::token::InstantiateMsg {\n// //             name: \"Astroport Token\".to_string(),\n// //             symbol: \"ASTRO\".to_string(),\n// //             decimals: 6,\n// //             initial_balances: vec![Cw20Coin {\n// //                 address: owner.to_string(),\n// //                 amount: Uint128::from(1_000_000_000_000u64),\n// //             }],\n// //             mint: None,\n// //             marketing: None,\n// //         };\n\n// //         let token_instance = router\n// //             .instantiate_contract(\n// //                 token_code,\n// //                 owner.clone(),\n// //                 \u0026token_default_instantiate_msg,\n// //                 \u0026[],\n// //                 \"ASTRO Token\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let assembly_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astro_assembly::contract::execute,\n// //             astro_assembly::contract::instantiate,\n// //             astro_assembly::contract::query,\n// //         ));\n\n// //         let assembly_code = router.store_code(assembly_contract);\n\n// //         let assembly_default_instantiate_msg = astroport_governance::assembly::InstantiateMsg {\n// //             xastro_token_addr: \"nocontract\".to_string(), //escrow_helper.xastro_token.to_string(),\n// //             vxastro_token_addr: None,\n// //             voting_escrow_delegator_addr: None,\n// //             ibc_controller: None,\n// //             generator_controller_addr: None,\n// //             hub_addr: None,\n// //             builder_unlock_addr: \"nocontract\".to_string(),\n// //             proposal_voting_period: PROPOSAL_VOTING_PERIOD,\n// //             proposal_effective_delay: PROPOSAL_EFFECTIVE_DELAY,\n// //             proposal_expiration_period: PROPOSAL_EXPIRATION_PERIOD,\n// //             proposal_required_deposit: Uint128::from(PROPOSAL_REQUIRED_DEPOSIT),\n// //             proposal_required_quorum: String::from(PROPOSAL_REQUIRED_QUORUM),\n// //             proposal_required_threshold: String::from(PROPOSAL_REQUIRED_THRESHOLD),\n// //             whitelisted_links: vec![\"https://some.link/\".to_string()],\n// //         };\n\n// //         let assembly_instance = router\n// //             .instantiate_contract(\n// //                 assembly_code,\n// //                 owner.clone(),\n// //                 \u0026assembly_default_instantiate_msg,\n// //                 \u0026[],\n// //                 \"Assembly\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let cw20_ics20_contract = Box::new(ContractWrapper::new_with_empty(\n// //             astroport_cw20_ics20::contract::execute,\n// //             astroport_cw20_ics20::contract::instantiate,\n// //             astroport_cw20_ics20::contract::query,\n// //         ));\n\n// //         let cw20_ics20_code = router.store_code(cw20_ics20_contract);\n\n// //         let cw20_ics20_instantiate_msg = astroport_cw20_ics20::msg::InitMsg {\n// //             default_timeout: 10,\n// //             gov_contract: owner.to_string(),\n// //             allowlist: vec![AllowMsg {\n// //                 contract: token_instance.to_string(),\n// //                 gas_limit: None,\n// //             }],\n// //             default_gas_limit: None,\n// //             memo_handler: None,\n// //         };\n\n// //         let cw20_ics20_instance = router\n// //             .instantiate_contract(\n// //                 cw20_ics20_code,\n// //                 owner.clone(),\n// //                 \u0026cw20_ics20_instantiate_msg,\n// //                 \u0026[],\n// //                 \"CW20-ICS20\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let msg = Cw20ExecuteMsg::Transfer {\n// //             recipient: cw20_ics20_instance.to_string(),\n// //             amount: Uint128::from(100000u64),\n// //         };\n\n// //         router.execute_contract(owner.clone(), token_instance.clone(), \u0026msg, \u0026[]).unwrap();\n\n// //         // let (astro_token_instance, staking_instance, _) =\n// //         //     instantiate_contracts(\u0026mut router, owner.clone());\n\n// //         // Set up staking\n// //         let staking_contract = Box::new(\n// //             ContractWrapper::new_with_empty(\n// //                 astroport_staking::contract::execute,\n// //                 astroport_staking::contract::instantiate,\n// //                 astroport_staking::contract::query,\n// //             )\n// //             .with_reply_empty(astroport_staking::contract::reply),\n// //         );\n\n// //         let staking_code_id = router.store_code(staking_contract);\n\n// //         let msg = astroport_core::staking::InstantiateMsg {\n// //             owner: owner.to_string(),\n// //             token_code_id: token_code,\n// //             deposit_token_addr: token_instance.to_string(),\n// //             marketing: None,\n// //         };\n// //         let staking_instance = router\n// //             .instantiate_contract(\n// //                 staking_code_id,\n// //                 owner.clone(),\n// //                 \u0026msg,\n// //                 \u0026[],\n// //                 String::from(\"xASTRO\"),\n// //                 None,\n// //             )\n// //             .unwrap();\n\n// //         let msg = astroport_core::staking::QueryMsg::Config {};\n// //         let res = router\n// //             .wrap()\n// //             .query::\u003castroport_core::staking::ConfigResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n// //                 contract_addr: staking_instance.to_string(),\n// //                 msg: to_binary(\u0026msg).unwrap(),\n// //             }))\n// //             .unwrap();\n// //         let x_astro_token_instance = res.share_token_addr;\n\n// //         let outpost_handler_contract = Box::new(\n// //             ContractWrapper::new_with_empty(\n// //                 astroport_hub::execute::execute,\n// //                 astroport_hub::contract::instantiate,\n// //                 astroport_hub::query::query,\n// //             )\n// //             .with_reply(astroport_hub::reply::reply),\n// //         );\n\n// //         let outpost_handler_code = router.store_code(outpost_handler_contract);\n\n// //         let outpost_handler_instantiate_msg = astroport_governance::hub::InstantiateMsg {\n// //             owner: owner.to_string(),\n// //             assembly_addr: assembly_instance.to_string(),\n// //             cw20_ics20_addr: cw20_ics20_instance.to_string(),\n// //             staking_addr: staking_instance.to_string(),\n// //             generator_controller_addr: \"generator_controller\".to_string(),\n// //             ibc_timeout_seconds: 10,\n// //         };\n\n// //         let outpost_handler_instance = router\n// //             .instantiate_contract(\n// //                 outpost_handler_code,\n// //                 owner.clone(),\n// //                 \u0026outpost_handler_instantiate_msg,\n// //                 \u0026[],\n// //                 \"Outpost handler\".to_string(),\n// //                 Some(owner.to_string()),\n// //             )\n// //             .unwrap();\n\n// //         let msg = hub::ExecuteMsg::AddOutpost { outpost_addr: \"outpost\".to_owned(), cw20_ics20_channel: \"channel-1\".to_owned() };\n\n// //         // Add an outpost\n// //         let res = router\n// //             .execute_contract(Addr::unchecked(owner.clone()), outpost_handler_instance.clone(), \u0026msg, \u0026[])\n// //             .unwrap();\n\n// //         let msg = Cw20ExecuteMsg::Send {\n// //             contract: outpost_handler_instance.to_string(),\n// //             msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::OutpostMemo {\n// //                 channel: \"channel-1\".to_string(),\n// //                 sender: owner.to_string(),\n// //                 receiver: outpost_handler_instance.to_string(),\n// //                 memo: \"{\\\"stake\\\": {}}\".to_string(),\n// //             })\n// //             .unwrap(),\n// //             amount: Uint128::from(100u64),\n// //         };\n\n// //         // First staker must send more that 1000astro, otherwise staking will fail, we test for fail here\n// //         let res = router\n// //             .execute_contract(Addr::unchecked(cw20_ics20_instance.clone()), token_instance.clone(), \u0026msg, \u0026[])\n// //             .unwrap_err();\n// //         assert_eq!(\n// //             res.root_cause().to_string(),\n// //         \"Invalid submessage error executing WasmMsg:\\nsender: contract5\\nExecute { contract_addr: \\\"contract0\\\", msg: {\\\"send\\\":{\\\"contract\\\":\\\"contract3\\\",\\\"amount\\\":\\\"100\\\",\\\"msg\\\":\\\"eyJlbnRlciI6e319\\\"}}, funds: [] }\");\n\n// //         let msg = Cw20ExecuteMsg::Send {\n// //             contract: outpost_handler_instance.to_string(),\n// //             msg: to_binary(\u0026astroport_governance::hub::Cw20HookMsg::OutpostMemo {\n// //                 channel: \"channel-1\".to_string(),\n// //                 sender: owner.to_string(),\n// //                 receiver: outpost_handler_instance.to_string(),\n// //                 memo: \"{\\\"stake\\\": {}}\".to_string(),\n// //             })\n// //             .unwrap(),\n// //             amount: Uint128::from(10000u64),\n// //         };\n\n// //         // Check that the contract blocks anyone else\n// //         let res = router\n// //             .execute_contract(owner.clone(), token_instance.clone(), \u0026msg, \u0026[])\n// //             .unwrap_err();\n// //         assert_eq!(\n// //             res.root_cause().to_string(),\n// //             \"Unauthorized\"\n// //         );\n\n// //         let query_msg = astroport_governance::hub::QueryMsg::Outposts {  };\n// //         let res: Vec\u003chub::OutpostConfig\u003e = router.wrap().query_wasm_smart(outpost_handler_instance, \u0026query_msg).unwrap();\n// //         println!(\"Outposts: {:?}\", res);\n\n// //         // Check that the contract emits a mint IBC message\n// //         // cw-multitest doesn't support IBC yet, and thus will return the IBC message as an error\n// //         // We check the format against that error\n// //         let res = router\n// //             .execute_contract(Addr::unchecked(cw20_ics20_instance), token_instance, \u0026msg, \u0026[])\n// //             .unwrap_err();\n// //         assert_eq!(\n// //             res.root_cause().to_string(),\n// //             \"Unexpected exec msg SendPacket { channel_id: \\\"channel-1\\\", data: Binary(7b226d696e74223a7b227265636569766572223a2274657272616f776e65723031222c22616d6f756e74223a2239303030227d7d), timeout: IbcTimeout { block: None, timestamp: Some(Timestamp(Uint64(1689152304000000000))) } } from Addr(\\\"contract5\\\")\"\n// //         );\n\n// //         // We will always receive this error since we can't actually establish an IBC connection that would\n// //         // construct the valid outpost link\n// //         // let res = router\n// //         //     .execute_contract(Addr::unchecked(cw20_ics20_instance), token_instance, \u0026msg, \u0026[])\n// //         //     .unwrap_err();\n// //         // assert_eq!(\n// //         //     res.root_cause().to_string(),\n// //         //     \"No Outpost found that matches the message channels\"\n// //         // );\n// //     }\n\n// // }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","hub","tests","mock.rs"],"content":"// use crate::execute;\n// use crate::{contract::instantiate, execute::execute, ibc::ibc_packet_receive};\n// use crate::{\n//     ibc::{ibc_channel_connect, ibc_channel_open, IBC_APP_VERSION},\n//     testing_querier::{mock_dependencies, WasmMockQuerier},\n// };\nuse astroport_core::token::BalanceResponse;\nuse astroport_cw20_ics20::{\n    ibc::{Ics20Packet, ICS20_ORDERING, ICS20_VERSION},\n    state::ChannelInfo,\n};\nuse astroport_governance::assembly::ProposalVoteOption;\nuse astroport_governance::interchain::{Hub, Response};\nuse cosmwasm_std::{from_binary, IbcPacketReceiveMsg, ReplyOn, SubMsg, Uint64, WasmMsg};\nuse cosmwasm_std::{\n    testing::{mock_env, mock_info, MockApi, MockQuerier, MockStorage},\n    to_binary, Addr, Binary, DepsMut, Env, IbcChannel, IbcChannelConnectMsg, IbcChannelOpenMsg,\n    IbcEndpoint, IbcOrder, IbcPacket, MessageInfo, OwnedDeps, StdResult, Timestamp, Uint128,\n};\nuse cw20::Cw20QueryMsg;\nuse cw_multi_test::{App, AppBuilder, BankKeeper};\n\nuse cosmwasm_std::testing::MOCK_CONTRACT_ADDR;\nuse cosmwasm_std::{\n    from_slice, Coin, Empty, Querier, QuerierResult, QueryRequest, SystemError, SystemResult,\n    WasmQuery,\n};\nuse std::collections::HashMap;\n\npub const DEFAULT_TIMEOUT: u64 = 3600; // 1 hour,\npub const CONTRACT_PORT: \u0026str = \"ibc:wasm1234567890abcdef\";\npub const REMOTE_PORT: \u0026str = \"wasm.outpost\";\npub const CONNECTION_ID: \u0026str = \"connection-2\";\n\n// TODO: Move here\n// const VOTING_PERIOD_INTERVAL: RangeInclusive\u003cu64\u003e = 200..=7 * 12342;\n//     const DEPOSIT_INTERVAL: RangeInclusive\u003cu128\u003e = 1000..=60000000000;\n//     const PROPOSAL_VOTING_PERIOD: u64 = *VOTING_PERIOD_INTERVAL.start();\n//     const PROPOSAL_EFFECTIVE_DELAY: u64 = 12_342;\n//     const PROPOSAL_EXPIRATION_PERIOD: u64 = 86_399;\n//     const PROPOSAL_REQUIRED_DEPOSIT: u128 = *DEPOSIT_INTERVAL.start();\n//     const PROPOSAL_REQUIRED_QUORUM: \u0026str = \"0.50\";\n//     const PROPOSAL_REQUIRED_THRESHOLD: \u0026str = \"0.60\";\n\npub fn mock_app() -\u003e App {\n    let mut env = mock_env();\n    env.block.time = Timestamp::from_seconds(1689152294);\n    let api = MockApi::default();\n    let bank = BankKeeper::new();\n    let storage = MockStorage::new();\n\n    AppBuilder::new()\n        .with_api(api)\n        .with_block(env.block)\n        .with_bank(bank)\n        .with_storage(storage)\n        .build(|_, _, _| {})\n}\n\npub fn check_token_balance(app: \u0026mut App, token: \u0026Addr, address: \u0026Addr, expected: u128) {\n    let msg = Cw20QueryMsg::Balance {\n        address: address.to_string(),\n    };\n    let res: StdResult\u003cBalanceResponse\u003e = app.wrap().query_wasm_smart(token, \u0026msg);\n    assert_eq!(res.unwrap().balance, Uint128::from(expected));\n}\n","traces":[{"line":45,"address":[795469,795512,794944],"length":1,"stats":{"Line":1},"fn_name":"mock_app"},{"line":46,"address":[794961],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[795066,794999],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[795071],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[795098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[795109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[795379,795125,795291,795213],"length":1,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[795220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[795321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[878173,878144],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":60,"address":[795536,796142],"length":1,"stats":{"Line":1},"fn_name":"check_token_balance"},{"line":62,"address":[795616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[795678,795751],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[796096,795795],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":14,"coverable":14},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","nft","examples","nft_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, export_schema_with_title, remove_schemas, schema_for};\nuse cosmwasm_std::Empty;\n\nuse cw721::{\n    AllNftInfoResponse, ApprovalResponse, ApprovalsResponse, ContractInfoResponse, NftInfoResponse,\n    NumTokensResponse, OperatorsResponse, OwnerOfResponse, TokensResponse,\n};\n\nuse cw721_base::{ExecuteMsg, Extension, InstantiateMsg, MinterResponse, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema_with_title(\n        \u0026schema_for!(ExecuteMsg\u003cExtension, Empty\u003e),\n        \u0026out_dir,\n        \"ExecuteMsg\",\n    );\n    export_schema(\u0026schema_for!(QueryMsg\u003cEmpty\u003e), \u0026out_dir);\n    export_schema_with_title(\n        \u0026schema_for!(AllNftInfoResponse\u003cExtension\u003e),\n        \u0026out_dir,\n        \"AllNftInfoResponse\",\n    );\n    export_schema(\u0026schema_for!(ApprovalResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(ApprovalsResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(OperatorsResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(ContractInfoResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(MinterResponse), \u0026out_dir);\n    export_schema_with_title(\n        \u0026schema_for!(NftInfoResponse\u003cExtension\u003e),\n        \u0026out_dir,\n        \"NftInfoResponse\",\n    );\n    export_schema(\u0026schema_for!(NumTokensResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(OwnerOfResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(TokensResponse), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","nft","src","contract.rs"],"content":"use cosmwasm_std::{\n    entry_point, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,\n};\n\nuse astroport_governance::nft::MigrateMsg;\nuse cw2::set_contract_version;\nuse cw721::ContractInfoResponse;\nuse cw721_base::msg::{ExecuteMsg, InstantiateMsg};\nuse cw721_base::state::Cw721Contract;\nuse cw721_base::{ContractError, Extension, QueryMsg};\n\n/// Contract name that is used for migration.\nconst CONTRACT_NAME: \u0026str = \"astroport-nft\";\n/// Contract version that is used for migration.\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Creates a new contract with the specified parameters in the [`InstantiateMsg`].\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    let info = ContractInfoResponse {\n        name: msg.name,\n        symbol: msg.symbol,\n    };\n    let tract = Cw721Contract::\u003cExtension, Empty, Empty, Empty\u003e::default();\n    tract.contract_info.save(deps.storage, \u0026info)?;\n\n    let minter = deps.api.addr_validate(msg.minter.as_str())?;\n    tract.minter.save(deps.storage, \u0026minter)?;\n    Ok(Response::default())\n}\n\n/// Exposes execute functions available in the contract.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg\u003cExtension, Empty\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let tract = Cw721Contract::\u003cExtension, Empty, Empty, Empty\u003e::default();\n    tract.execute(deps, env, info, msg)\n}\n\n/// Exposes queries available in the contract.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg\u003cEmpty\u003e) -\u003e StdResult\u003cBinary\u003e {\n    let tract = Cw721Contract::\u003cExtension, Empty, Empty, Empty\u003e::default();\n    tract.query(deps, env, msg)\n}\n\n/// Used for contract migration. Returns a default object of type [`Response`].\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    Ok(Response::default())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","nft","src","lib.rs"],"content":"pub mod contract;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","contract.rs"],"content":"use cosmwasm_std::{entry_point, Addr, DepsMut, Env, MessageInfo, Response};\nuse cw2::set_contract_version;\n\nuse astroport_governance::outpost::{Config, InstantiateMsg, MigrateMsg};\n\nuse crate::error::ContractError;\nuse crate::state::CONFIG;\n\n/// Contract name that is used for migration.\nconst CONTRACT_NAME: \u0026str = \"astroport-outpost\";\n/// Contract version that is used for migration.\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Instantiates the contract, storing the config.\n/// Returns a `Response` object on successful execution or a `ContractError` on failure.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    let config = Config {\n        owner: deps.api.addr_validate(\u0026msg.owner)?,\n        hub_addr: Addr::unchecked(msg.hub_addr),\n        // The Hub channel will be set when the connection is established\n        hub_channel: None,\n        xastro_token_addr: deps.api.addr_validate(\u0026msg.xastro_token_addr)?,\n        vxastro_token_addr: deps.api.addr_validate(\u0026msg.vxastro_token_addr)?,\n        ibc_timeout_seconds: msg.ibc_timeout_seconds,\n    };\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::default())\n}\n\n/// Migrates the contract to a new version.\n#[entry_point]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    // TODO: Return error\n    Ok(Response::default())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","error.rs"],"content":"use cosmwasm_std::{OverflowError, StdError};\nuse thiserror::Error;\n\n/// This enum describes bribes contract errors\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"You can not send 0 tokens\")]\n    ZeroAmount {},\n\n    #[error(\n        \"Proposal {0} is being queried from the Hub, please try again in a few minutes\",\n        proposal_id\n    )]\n    PendingVoteExists { proposal_id: u64 },\n\n    #[error(\n        \"The address has no voting power at the start of the proposal: {0}\",\n        address\n    )]\n    NoVotingPower { address: String },\n\n    #[error(\"The IBC channel to the Hub has not been set\")]\n    MissingHubChannel {},\n}\n\nimpl From\u003cOverflowError\u003e for ContractError {\n    fn from(o: OverflowError) -\u003e Self {\n        StdError::from(o).into()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","execute.rs"],"content":"use cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    from_binary, to_binary, Addr, CosmosMsg, DepsMut, Env, IbcMsg, MessageInfo, Response, StdError,\n    WasmMsg,\n};\nuse cw20::{Cw20ExecuteMsg, Cw20ReceiveMsg};\n\nuse astroport::common::{claim_ownership, drop_ownership_proposal, propose_new_owner};\nuse astroport_governance::outpost::Config;\nuse astroport_governance::{\n    assembly::ProposalVoteOption,\n    interchain::Hub,\n    outpost::{Cw20HookMsg, ExecuteMsg},\n    voting_escrow_lite::get_emissions_voting_power,\n};\n\nuse crate::query::get_user_voting_power;\nuse crate::{\n    error::ContractError,\n    state::{PendingVote, CONFIG, OWNERSHIP_PROPOSAL, PENDING_VOTES, PROPOSALS_CACHE},\n};\n\n/// Exposes all the execute functions available in the contract.\n///\n/// ## Execute messages\n/// * **ExecuteMsg::Receive(cw20_msg)** Receives a message of type [`Cw20ReceiveMsg`] and processes\n/// it depending on the received template.\n///\n/// RemoveOutpost { outpost_addr } Removes an outpost from the hub but does not close the channel, but all messages will be rejected\n///\n/// * **ExecuteMsg::Receive(msg)** Receives a message of type [`Cw20ReceiveMsg`] and processes\n/// it depending on the received template.\n///\n/// * **ExecuteMsg::UpdateConfig { hub_addr }** Update parameters in the Outpost contract. Only the owner is allowed to\n/// update the config\n///\n/// * **ExecuteMsg::CastAssemblyVote { proposal_id, vote }** Cast a vote on an Assembly proposal from an Outpost\n///\n/// * **ExecuteMsg::CastEmissionsVote { votes }** Cast a vote during an emissions voting period\n///\n/// * **ExecuteMsg::KickUnlocked { user }** Kick an unlocked voter's voting power from the Generator Controller on the Hub\n///\n/// * **ExecuteMsg::WithdrawHubFunds {}** Withdraw stuck funds from the Hub in case of specific IBC failures\n///\n/// * **ExecuteMsg::ProposeNewOwner { new_owner, expires_in }** Creates a new request to change\n/// contract ownership.\n///\n/// * **ExecuteMsg::DropOwnershipProposal {}** Removes a request to change contract ownership.\n///\n/// * **ExecuteMsg::ClaimOwnership {}** Claims contract ownership.\n///\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::Receive(msg) =\u003e receive_cw20(deps, env, info, msg),\n        ExecuteMsg::UpdateConfig { hub_addr } =\u003e update_config(deps, env, info, hub_addr),\n        ExecuteMsg::CastAssemblyVote { proposal_id, vote } =\u003e {\n            cast_assembly_vote(deps, env, info, proposal_id, vote)\n        }\n        ExecuteMsg::CastEmissionsVote { votes } =\u003e cast_emissions_vote(deps, env, info, votes),\n        ExecuteMsg::KickUnlocked { user } =\u003e kick_unlocked(deps, env, info, user),\n        ExecuteMsg::WithdrawHubFunds {} =\u003e withdraw_hub_funds(deps, env, info),\n        ExecuteMsg::ProposeNewOwner {\n            new_owner,\n            expires_in,\n        } =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n\n            propose_new_owner(\n                deps,\n                info,\n                env,\n                new_owner,\n                expires_in,\n                config.owner,\n                OWNERSHIP_PROPOSAL,\n            )\n            .map_err(Into::into)\n        }\n        ExecuteMsg::DropOwnershipProposal {} =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n\n            drop_ownership_proposal(deps, info, config.owner, OWNERSHIP_PROPOSAL)\n                .map_err(Into::into)\n        }\n        ExecuteMsg::ClaimOwnership {} =\u003e {\n            claim_ownership(deps, info, env, OWNERSHIP_PROPOSAL, |deps, new_owner| {\n                CONFIG\n                    .update::\u003c_, StdError\u003e(deps.storage, |mut v| {\n                        v.owner = new_owner;\n                        Ok(v)\n                    })\n                    .map(|_| ())\n            })\n            .map_err(Into::into)\n        }\n    }\n}\n\n/// Receives a message of type [`Cw20ReceiveMsg`] and processes it depending on\n/// the received template\n///\n/// Funds received here must be from the xASTRO contract and is used for\n/// unstaking.\n///\n/// * **cw20_msg** CW20 message to process\nfn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // We only allow xASTRO tokens to be sent here\n    if info.sender != config.xastro_token_addr {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    match from_binary(\u0026cw20_msg.msg)? {\n        Cw20HookMsg::Unstake {} =\u003e execute_remote_unstake(deps, env, info, cw20_msg),\n    }\n}\n\n/// Start the process of unstaking xASTRO from the Hub\n///\n/// This burns the xASTRO we previously received and sends the unstake message\n/// to the Hub where to original xASTRO will be unstaked and ASTRO returned\n/// to the sender of this transaction.\n///\n/// Note: Incase of IBC failures they xASTRO will be returned to the user or\n/// they'll need to withdraw the unstaked ASTRO from the Hub using ExecuteMsg::WithdrawHubFunds\nfn execute_remote_unstake(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    msg: Cw20ReceiveMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Tokens must be sent\n    if msg.amount.is_zero() {\n        return Err(ContractError::ZeroAmount {});\n    }\n\n    // Burn the xASTRO tokens we previously minted\n    let burn_msg = Cw20ExecuteMsg::Burn { amount: msg.amount };\n    let wasm_msg = WasmMsg::Execute {\n        contract_addr: config.xastro_token_addr.to_string(),\n        msg: to_binary(\u0026burn_msg)?,\n        funds: vec![],\n    };\n\n    let hub_channel = config\n        .hub_channel\n        .ok_or(ContractError::MissingHubChannel {})?;\n\n    // Construct the unstake message to send to the Hub\n    let unstake = Hub::Unstake {\n        receiver: msg.sender.to_string(),\n        amount: msg.amount,\n    };\n    let hub_unstake_msg: CosmosMsg = CosmosMsg::Ibc(IbcMsg::SendPacket {\n        channel_id: hub_channel.clone(),\n        data: to_binary(\u0026unstake)?,\n        timeout: env\n            .block\n            .time\n            .plus_seconds(config.ibc_timeout_seconds)\n            .into(),\n    });\n\n    Ok(Response::default()\n        .add_message(wasm_msg)\n        .add_message(hub_unstake_msg)\n        .add_attribute(\"action\", unstake.to_string())\n        .add_attribute(\"amount\", msg.amount.to_string())\n        .add_attribute(\"channel\", hub_channel))\n}\n\n/// Update the Outpost config\nfn update_config(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    hub_addr: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    // Only owner can update the config\n    if info.sender != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(hub_addr) = hub_addr {\n        // We can't validate the Hub address\n        config.hub_addr = Addr::unchecked(hub_addr);\n        // If a new Hub address is set, we clear the channel to allow a\n        // new channel to be set\n        config.hub_channel = None;\n    }\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::default())\n}\n\n/// Cast a vote on a proposal from an Outpost\n///\n/// To validate the xASTRO holdings at the time the proposal was created we first\n/// query the Hub for the proposal information if it hasn't been queried yet. Once\n/// the proposal information is received we validate the vote and submit it\nfn cast_assembly_vote(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    proposal_id: u64,\n    vote_option: ProposalVoteOption,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // If we have this proposal in our local cached already, we can continue\n    // with fetching the voting power and submitting the vote\n    if let Some(proposal) = PROPOSALS_CACHE.may_load(deps.storage, proposal_id)? {\n        let voting_power =\n            get_user_voting_power(deps.as_ref(), info.sender.clone(), proposal.start_time)?;\n\n        if voting_power.is_zero() {\n            return Err(ContractError::NoVotingPower {\n                address: info.sender.to_string(),\n            });\n        }\n\n        let hub_channel = config\n            .hub_channel\n            .ok_or(ContractError::MissingHubChannel {})?;\n\n        // Construct the vote message and submit it to the Hub\n        let cast_vote = Hub::CastAssemblyVote {\n            proposal_id: proposal.proposal_id.u64(),\n            vote_option,\n            voter: info.sender.clone(),\n            voting_power,\n        };\n        let hub_msg = CosmosMsg::Ibc(IbcMsg::SendPacket {\n            channel_id: hub_channel,\n            data: to_binary(\u0026cast_vote)?,\n            timeout: env\n                .block\n                .time\n                .plus_seconds(config.ibc_timeout_seconds)\n                .into(),\n        });\n        return Ok(Response::new()\n            .add_message(hub_msg)\n            .add_attribute(\"action\", cast_vote.to_string())\n            .add_attribute(\"user\", info.sender.to_string()));\n    }\n\n    // If we don't have the proposal in our local cache it means that no\n    // vote has been cast from this Outpost for this proposal\n    // In this case we temporarily store the vote and submit an IBC transaction\n    // to fetch the proposal information. When the information is received via\n    // an IBC reply, we validate the data and submit the actual vote\n\n    // If we already have a pending vote for this proposal we return an error\n    // as we're waiting for the proposal IBC query to return. We can't store\n    // lots of votes as we have no way to automatically submit them without\n    // the risk of running out of gas\n    if (PENDING_VOTES.may_load(deps.storage, proposal_id)?).is_some() {\n        return Err(ContractError::PendingVoteExists { proposal_id });\n    }\n\n    // Temporarily store the vote\n    let pending_vote = PendingVote {\n        proposal_id,\n        voter: info.sender,\n        vote_option,\n    };\n    PENDING_VOTES.save(deps.storage, proposal_id, \u0026pending_vote)?;\n\n    let hub_channel = config\n        .hub_channel\n        .ok_or(ContractError::MissingHubChannel {})?;\n\n    // Query for proposal\n    let query_proposal = Hub::QueryProposal { id: proposal_id };\n    let hub_query_msg = CosmosMsg::Ibc(IbcMsg::SendPacket {\n        channel_id: hub_channel,\n        data: to_binary(\u0026query_proposal)?,\n        timeout: env\n            .block\n            .time\n            .plus_seconds(config.ibc_timeout_seconds)\n            .into(),\n    });\n\n    Ok(Response::default()\n        .add_message(hub_query_msg)\n        .add_attribute(\"action\", query_proposal.to_string())\n        .add_attribute(\"id\", proposal_id.to_string()))\n}\n\n/// Cast a vote on emissions during a vxASTRO voting period\n///\n/// We validate the voting power by checking the vxASTRO power at this\n/// moment as vxASTRO lite does not have any warmup period\nfn cast_emissions_vote(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    votes: Vec\u003c(String, u16)\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Validate vxASTRO voting power\n    let vxastro_voting_power = get_emissions_voting_power(\n        \u0026deps.querier,\n        config.vxastro_token_addr,\n        info.sender.clone(),\n    )?;\n\n    if vxastro_voting_power.is_zero() {\n        return Err(ContractError::NoVotingPower {\n            address: info.sender.to_string(),\n        });\n    }\n\n    let hub_channel = config\n        .hub_channel\n        .ok_or(ContractError::MissingHubChannel {})?;\n\n    // Construct the vote message and submit it to the Hub\n    let cast_vote = Hub::CastEmissionsVote {\n        voter: info.sender.clone(),\n        voting_power: vxastro_voting_power,\n        votes,\n    };\n    let hub_msg = CosmosMsg::Ibc(IbcMsg::SendPacket {\n        channel_id: hub_channel,\n        data: to_binary(\u0026cast_vote)?,\n        timeout: env\n            .block\n            .time\n            .plus_seconds(config.ibc_timeout_seconds)\n            .into(),\n    });\n    Ok(Response::new()\n        .add_message(hub_msg)\n        .add_attribute(\"action\", cast_vote.to_string())\n        .add_attribute(\"user\", info.sender.to_string()))\n}\n\n/// Kick an unlocked voter from the Generator Controller on the Hub\n/// which will remove their voting power immediately.\n///\n/// We only finalise the unlock in the vxASTRO contract when this kick is\n/// successful\nfn kick_unlocked(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    user: Addr,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // This may only be called from the vxASTRO lite contract\n    if info.sender != config.vxastro_token_addr {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let hub_channel = config\n        .hub_channel\n        .ok_or(ContractError::MissingHubChannel {})?;\n\n    // Construct the kick message and submit it to the Hub\n    let kick_unlocked = Hub::KickUnlockedVoter {\n        voter: user.clone(),\n    };\n    let hub_msg = CosmosMsg::Ibc(IbcMsg::SendPacket {\n        channel_id: hub_channel,\n        data: to_binary(\u0026kick_unlocked)?,\n        timeout: env\n            .block\n            .time\n            .plus_seconds(config.ibc_timeout_seconds)\n            .into(),\n    });\n\n    Ok(Response::new()\n        .add_message(hub_msg)\n        .add_attribute(\"action\", kick_unlocked.to_string())\n        .add_attribute(\"user\", user))\n}\n\n/// Submit a request to withdraw / retry sending funds stuck on the Hub\n/// back to the sender address. This is possible because of IBC failures.\n///\n/// This will only return the funds of the user executing this transaction.\nfn withdraw_hub_funds(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    let hub_channel = config\n        .hub_channel\n        .ok_or(ContractError::MissingHubChannel {})?;\n\n    // Construct the withdraw message and submit it to the Hub\n    let withdraw = Hub::WithdrawFunds {\n        user: info.sender.clone(),\n    };\n    let hub_msg = CosmosMsg::Ibc(IbcMsg::SendPacket {\n        channel_id: hub_channel,\n        data: to_binary(\u0026withdraw)?,\n        timeout: env\n            .block\n            .time\n            .plus_seconds(config.ibc_timeout_seconds)\n            .into(),\n    });\n\n    Ok(Response::new()\n        .add_message(hub_msg)\n        .add_attribute(\"action\", withdraw.to_string())\n        .add_attribute(\"user\", info.sender.to_string()))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","ibc.rs"],"content":"use cosmwasm_std::{\n    ensure, entry_point, from_binary, to_binary, CosmosMsg, Deps, DepsMut, Env,\n    Ibc3ChannelOpenResponse, IbcBasicResponse, IbcChannelCloseMsg, IbcChannelConnectMsg,\n    IbcChannelOpenMsg, IbcChannelOpenResponse, IbcMsg, IbcOrder, IbcPacketAckMsg,\n    IbcPacketReceiveMsg, IbcPacketTimeoutMsg, IbcReceiveResponse, StdError, StdResult,\n};\n\nuse astroport_governance::interchain::{get_contract_from_ibc_port, Hub, Outpost, Response};\n\nuse crate::{\n    error::ContractError,\n    ibc_failure::handle_failed_messages,\n    ibc_mint::handle_ibc_xastro_mint,\n    query::get_user_voting_power,\n    state::{CachedProposal, CONFIG, PENDING_VOTES, PROPOSALS_CACHE},\n};\n\npub const IBC_APP_VERSION: \u0026str = \"astroport-outpost-v1\";\npub const IBC_ORDERING: IbcOrder = IbcOrder::Unordered;\n\n/// Handle the opening of a new IBC channel\n///\n/// We verify that the connection is using the correct configuration\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_channel_open(\n    _deps: DepsMut,\n    _env: Env,\n    msg: IbcChannelOpenMsg,\n) -\u003e Result\u003cIbcChannelOpenResponse, ContractError\u003e {\n    let channel = msg.channel();\n\n    if channel.order != IBC_ORDERING {\n        return Err(ContractError::Std(StdError::generic_err(\n            \"Ordering is invalid. The channel must be unordered\".to_string(),\n        )));\n    }\n    if channel.version != IBC_APP_VERSION {\n        return Err(ContractError::Std(StdError::generic_err(format!(\n            \"Must set version to `{IBC_APP_VERSION}`\"\n        ))));\n    }\n\n    if let Some(counter_version) = msg.counterparty_version() {\n        if counter_version != IBC_APP_VERSION {\n            return Err(ContractError::Std(StdError::generic_err(format!(\n                \"Counterparty version must be `{IBC_APP_VERSION}`\"\n            ))));\n        }\n    }\n\n    Ok(Some(Ibc3ChannelOpenResponse {\n        version: IBC_APP_VERSION.to_string(),\n    }))\n}\n\n/// Handle the connection of a new IBC channel\n///\n/// We verify that the connection is being made to the configured Hub and\n/// if the channel has not been set, add it\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_channel_connect(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcChannelConnectMsg,\n) -\u003e Result\u003cIbcBasicResponse, ContractError\u003e {\n    let channel = msg.channel();\n\n    // Only a connection to the Hub is allowed\n    let counterparty_port =\n        get_contract_from_ibc_port(channel.counterparty_endpoint.port_id.as_str());\n\n    CONFIG.update(deps.storage, |mut config| {\n        // Block unauthorised connections\n        if config.hub_addr != counterparty_port {\n            return Err(ContractError::Std(StdError::generic_err(format!(\n                \"Connection with `{}` is not allowed\",\n                counterparty_port\n            ))));\n        }\n\n        // If the channel is already set, fail\n        if config.hub_channel.is_some() {\n            return Err(ContractError::Std(StdError::generic_err(\n                \"Hub channel is already set\".to_string(),\n            )));\n        }\n\n        // Update the known channel to the Hub\n        config.hub_channel = Some(channel.endpoint.channel_id.to_string());\n        Ok(config)\n    })?;\n\n    Ok(IbcBasicResponse::new()\n        .add_attribute(\"action\", \"ibc_connect\")\n        .add_attribute(\"channel_id\", \u0026channel.endpoint.channel_id))\n}\n\n/// Handle the receiving the packets while wrapping the actual call to provide\n/// returning errors as an acknowledgement.\n///\n/// This allows the original caller from another chain to handle the failure\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_packet_receive(\n    deps: DepsMut,\n    env: Env,\n    msg: IbcPacketReceiveMsg,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    block_unauthorized_packets(deps.as_ref(), msg.packet.src.port_id.clone())?;\n\n    do_packet_receive(deps, env, msg).or_else(|err| {\n        // Construct an error acknowledgement that can be handled on the Outpost\n        let ack_data = to_binary(\u0026Response::new_error(err.to_string())).unwrap();\n\n        Ok(IbcReceiveResponse::new()\n            .add_attribute(\"action\", \"ibc_packet_receive\")\n            .add_attribute(\"error\", err.to_string())\n            .set_ack(ack_data))\n    })\n}\n\n/// Process the received packet and return the response\n///\n/// Packets are expected to be wrapped in the Outpost format, if it doesn't conform\n/// it will be failed.\n///\n/// If a ContractError is returned, it will be wrapped into a Response\n/// containing the error to be handled on the Outpost\nfn do_packet_receive(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcPacketReceiveMsg,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    // Parse the packet data into a Hub message\n    let hub_msg: Outpost = from_binary(\u0026msg.packet.data)?;\n    match hub_msg {\n        Outpost::MintXAstro { receiver, amount } =\u003e handle_ibc_xastro_mint(deps, receiver, amount),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_packet_timeout(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcPacketTimeoutMsg,\n) -\u003e Result\u003cIbcBasicResponse, ContractError\u003e {\n    // We check the destination port for timeouts as that is where the original\n    // packet was sent to\n    block_unauthorized_packets(deps.as_ref(), msg.packet.dest.port_id.clone())?;\n\n    let mut response = IbcBasicResponse::new().add_attribute(\"action\", \"ibc_packet_timeout\");\n\n    // In case of an IBC timeout we might need to reverse actions similar\n    // to failed messages.\n    // We look at the original packet to determine what failed and take\n    // the appropriate action\n    let failed_msg: Hub = from_binary(\u0026msg.packet.data)?;\n    response = handle_failed_messages(deps, failed_msg, response)?;\n\n    Ok(response)\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_packet_ack(\n    deps: DepsMut,\n    env: Env,\n    msg: IbcPacketAckMsg,\n) -\u003e Result\u003cIbcBasicResponse, ContractError\u003e {\n    // We check the destination port for acks as that is where the original\n    // packet was sent to\n    block_unauthorized_packets(deps.as_ref(), msg.original_packet.dest.port_id)?;\n\n    let mut response = IbcBasicResponse::new().add_attribute(\"action\", \"ibc_packet_ack\");\n\n    let ack: Result\u003cResponse, StdError\u003e = from_binary(\u0026msg.acknowledgement.data);\n    match ack {\n        Ok(hub_response) =\u003e {\n            match hub_response {\n                Response::QueryProposal(proposal) =\u003e {\n                    // We cache the proposal ID and start time for future vote\n                    // checks without needing to query the Hub again\n                    let cached_proposal = CachedProposal {\n                        proposal_id: proposal.proposal_id,\n                        start_time: proposal.start_time,\n                    };\n\n                    PROPOSALS_CACHE.save(\n                        deps.storage,\n                        cached_proposal.proposal_id.u64(),\n                        \u0026cached_proposal,\n                    )?;\n\n                    // We need to submit the initial vote that triggered this\n                    // proposal to be queried from the pending vote cache\n                    if let Some(pending_vote) =\n                        PENDING_VOTES.may_load(deps.storage, proposal.proposal_id.u64())?\n                    {\n                        let config = CONFIG.load(deps.storage)?;\n\n                        let voting_power = get_user_voting_power(\n                            deps.as_ref(),\n                            pending_vote.voter.clone(),\n                            proposal.start_time,\n                        )?;\n\n                        if voting_power.is_zero() {\n                            return Err(ContractError::NoVotingPower {\n                                address: pending_vote.voter.to_string(),\n                            });\n                        }\n\n                        let hub_channel = config\n                            .hub_channel\n                            .ok_or(ContractError::MissingHubChannel {})?;\n\n                        // Construct the vote message and submit it to the Hub\n                        let cast_vote = Hub::CastAssemblyVote {\n                            proposal_id: proposal.proposal_id.u64(),\n                            vote_option: pending_vote.vote_option,\n                            voter: pending_vote.voter.clone(),\n                            voting_power,\n                        };\n                        let hub_msg = CosmosMsg::Ibc(IbcMsg::SendPacket {\n                            channel_id: hub_channel,\n                            data: to_binary(\u0026cast_vote)?,\n                            timeout: env\n                                .block\n                                .time\n                                .plus_seconds(config.ibc_timeout_seconds)\n                                .into(),\n                        });\n                        response = response\n                            .add_message(hub_msg)\n                            .add_attribute(\"action\", cast_vote.to_string())\n                            .add_attribute(\"user\", pending_vote.voter.to_string());\n\n                        // Remove this pending vote from the cache\n                        PENDING_VOTES.remove(deps.storage, proposal.proposal_id.u64());\n                    }\n\n                    response = response\n                        .add_attribute(\"hub_response\", \"query_response\")\n                        .add_attribute(\"response_type\", \"proposal\")\n                        .add_attribute(\"proposal_id\", proposal.proposal_id.to_string())\n                        .add_attribute(\"proposal_start\", proposal.start_time.to_string())\n                }\n                Response::Result {\n                    action,\n                    address,\n                    error,\n                } =\u003e {\n                    response = response\n                        .add_attribute(\"action\", action.unwrap_or(\"unknown\".to_string()))\n                        .add_attribute(\"user\", address.unwrap_or(\"unknown\".to_string()))\n                        .add_attribute(\"err\", error.unwrap_or(\"none\".to_string()))\n                }\n            }\n        }\n        Err(err) =\u003e {\n            // In case of error, ack.data will be in the format similar to\n            // {\"error\":\"ABCI code: 5: error handling packet: see events for details\"}\n            // but the events do not contain the details\n            //\n            // Instead we look at the original packet to determine what failed,\n            // the reason for the failure can't be determined at this time due\n            // to a limitation in wasmd/wasmvm. For us we just need to know what failed,\n            // the reason is not required to continue\n            // See https://github.com/CosmWasm/cosmwasm/issues/1707\n\n            let raw_error = base64::encode(\u0026msg.acknowledgement.data);\n            // Attach the errors to the response\n            response = response\n                .add_attribute(\"raw_error\", raw_error)\n                .add_attribute(\"ack_error\", err.to_string());\n\n            // Handle the possible failures\n            let original: Hub = from_binary(\u0026msg.original_packet.data)?;\n            response = handle_failed_messages(deps, original, response)?;\n        }\n    }\n    Ok(response)\n}\n\n/// Handle the closing of IBC channels, which we don't allow\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn ibc_channel_close(\n    _deps: DepsMut,\n    _env: Env,\n    _channel: IbcChannelCloseMsg,\n) -\u003e StdResult\u003cIbcBasicResponse\u003e {\n    Err(StdError::generic_err(\"Closing channel is not allowed\"))\n}\n\n/// Checks the provided port against the known Hub.\n///\n/// If the port doesn't exist, this function will  return an error, effectively blocking the packet.\nfn block_unauthorized_packets(deps: Deps, port_id: String) -\u003e Result\u003c(), ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n    let counterparty_port = get_contract_from_ibc_port(port_id.as_str());\n    ensure!(\n        config.hub_addr == counterparty_port,\n        ContractError::Unauthorized {}\n    );\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","ibc_failure.rs"],"content":"use cosmwasm_std::{DepsMut, IbcBasicResponse};\n\nuse astroport_governance::interchain::Hub;\n\nuse crate::{error::ContractError, ibc_mint::mint_xastro_msg, state::PENDING_VOTES};\n\npub fn handle_failed_messages(\n    deps: DepsMut,\n    failed_msg: Hub,\n    mut response: IbcBasicResponse,\n) -\u003e Result\u003cIbcBasicResponse, ContractError\u003e {\n    match failed_msg.clone() {\n        Hub::CastAssemblyVote { voter, .. } =\u003e {\n            response = response\n                .add_attribute(\"action\", failed_msg.to_string())\n                .add_attribute(\"user\", voter.to_string());\n        }\n        Hub::CastEmissionsVote { voter, .. } =\u003e {\n            response = response\n                .add_attribute(\"action\", failed_msg.to_string())\n                .add_attribute(\"user\", voter.to_string());\n        }\n        Hub::QueryProposal { id } =\u003e {\n            // If the proposal query failed we need to remove the pending vote\n            // otherwise no other vote will be possible for this proposal\n            let pending_vote = PENDING_VOTES.load(deps.storage, id)?;\n            PENDING_VOTES.remove(deps.storage, id);\n\n            response = response\n                .add_attribute(\"action\", failed_msg.to_string())\n                .add_attribute(\"user\", pending_vote.voter.to_string());\n        }\n\n        Hub::Unstake { receiver, amount } =\u003e {\n            // Unstaking involves us burning the received xASTRO before\n            // sending the unstake message to the Hub. If the unstaking\n            // fails we need to mint the xASTRO back to the user\n            let msg = mint_xastro_msg(deps.as_ref(), receiver.clone(), amount)?;\n            response = response\n                .add_message(msg)\n                .add_attribute(\"action\", failed_msg.to_string())\n                .add_attribute(\"user\", receiver);\n        }\n        Hub::KickUnlockedVoter { .. } =\u003e {\n            // TODO: If this failed, we _must_ relock, or actually, without success, unlock must not complete\n        }\n        Hub::WithdrawFunds { user } =\u003e {\n            response = response\n                .add_attribute(\"action\", failed_msg.to_string())\n                .add_attribute(\"user\", user.to_string());\n        }\n        // Not all Hub responses will be received here, we only handle the ones we have\n        // control over\n        _ =\u003e {\n            response = response.add_attribute(\"action\", failed_msg.to_string());\n        }\n    }\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","ibc_mint.rs"],"content":"use astroport_governance::interchain::Response;\nuse cosmwasm_std::{to_binary, Deps, DepsMut, IbcReceiveResponse, Uint128, WasmMsg};\nuse cw20::Cw20ExecuteMsg;\n\nuse crate::{error::ContractError, state::CONFIG};\n\n/// Mint new xASTRO based on the message received from the Hub, it cannot be\n/// called directly.\n///\n/// This is called in response to a staking message sent to the Hub\npub fn handle_ibc_xastro_mint(\n    deps: DepsMut,\n    recipient: String,\n    amount: Uint128,\n) -\u003e Result\u003cIbcReceiveResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Mint the new amount of xASTRO to the recipient that originally initiated\n    // the ASTRO staking\n    let mint_msg = Cw20ExecuteMsg::Mint {\n        recipient: recipient.clone(),\n        amount,\n    };\n    let msg = WasmMsg::Execute {\n        contract_addr: config.xastro_token_addr.to_string(),\n        msg: to_binary(\u0026mint_msg)?,\n        funds: vec![],\n    };\n\n    // If the minting succeeds, the ack will be sent back to the Hub\n    let ack_data = to_binary(\u0026Response::new_success(\n        \"mint_xastro\".to_owned(),\n        recipient.to_string(),\n    ))?;\n\n    let response = IbcReceiveResponse::new()\n        .add_message(msg)\n        .set_ack(ack_data)\n        .add_attribute(\"action\", \"mint_xastro\")\n        .add_attribute(\"user\", recipient)\n        .add_attribute(\"amount\", amount);\n\n    Ok(response)\n}\n\n/// Create a new message to mint xASTRO to a specific address\npub fn mint_xastro_msg(\n    deps: Deps,\n    recipient: String,\n    amount: Uint128,\n) -\u003e Result\u003cWasmMsg, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    let mint_msg = Cw20ExecuteMsg::Mint { recipient, amount };\n    Ok(WasmMsg::Execute {\n        contract_addr: config.xastro_token_addr.to_string(),\n        msg: to_binary(\u0026mint_msg)?,\n        funds: vec![],\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","lib.rs"],"content":"pub mod contract;\npub mod error;\npub mod execute;\npub mod ibc;\npub mod ibc_failure;\npub mod ibc_mint;\npub mod query;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","query.rs"],"content":"use cosmwasm_std::{entry_point, to_binary, Addr, Binary, Deps, Env, StdResult, Uint128};\n\nuse astroport::xastro_outpost_token::get_voting_power_at_time;\nuse astroport_governance::outpost::QueryMsg;\nuse astroport_governance::voting_escrow_lite::get_user_deposit_at_time;\n\nuse crate::error::ContractError;\nuse crate::state::CONFIG;\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::Config {}** Returns the config of the Outpost\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Config {} =\u003e to_binary(\u0026CONFIG.load(deps.storage)?),\n    }\n}\n\npub fn get_user_voting_power(\n    deps: Deps,\n    user: Addr,\n    proposal_start: u64,\n) -\u003e Result\u003cUint128, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    // Get the user's xASTRO balance at the time the proposal was added\n    let voting_power = get_voting_power_at_time(\n        \u0026deps.querier,\n        config.xastro_token_addr.clone(),\n        user.clone(),\n        proposal_start,\n    )\n    .unwrap_or(Uint128::zero());\n\n    // Get the user's underlying xASTRO deposit at the time the proposal was added\n    let vxastro_balance = get_user_deposit_at_time(\n        \u0026deps.querier,\n        config.vxastro_token_addr,\n        user,\n        proposal_start,\n    )\n    .unwrap_or(Uint128::zero());\n\n    Ok(voting_power.checked_add(vxastro_balance)?)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","outpost","src","state.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Uint64};\nuse cw_storage_plus::{Item, Map};\n\nuse astroport::common::OwnershipProposal;\nuse astroport_governance::{assembly::ProposalVoteOption, outpost::Config};\n\n#[cw_serde]\npub struct CachedProposal {\n    /// Unique proposal ID\n    pub proposal_id: Uint64,\n    /// Start time of proposal\n    pub start_time: u64,\n}\n\n#[cw_serde]\npub struct PendingVote {\n    /// The proposal ID to vote on\n    pub proposal_id: u64,\n    /// The user voting\n    pub voter: Addr,\n    /// The choice in vote\n    pub vote_option: ProposalVoteOption,\n}\n\n/// Store the contract config\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n\n/// Store a local cache of proposals to verify votes are allowed\npub const PROPOSALS_CACHE: Map\u003cu64, CachedProposal\u003e = Map::new(\"proposals_cache\");\n\n/// Store the pending votes for a proposal while the information is being\n/// retrieved from the Hub\npub const PENDING_VOTES: Map\u003cu64, PendingVote\u003e = Map::new(\"pending_votes\");\n\n/// Contains a proposal to change contract ownership\npub const OWNERSHIP_PROPOSAL: Item\u003cOwnershipProposal\u003e = Item::new(\"ownership_proposal\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","examples","schema.rs"],"content":"use astroport_governance::voting_escrow::{ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};\nuse cosmwasm_schema::write_api;\n\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        query: QueryMsg,\n        execute: ExecuteMsg,\n        migrate: MigrateMsg,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","src","contract.rs"],"content":"use crate::astroport;\nuse astroport::common::{claim_ownership, drop_ownership_proposal, propose_new_owner};\nuse astroport_governance::astroport::DecimalCheckedOps;\n\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    attr, from_binary, to_binary, Addr, Binary, CosmosMsg, Deps, DepsMut, Env, MessageInfo,\n    Response, StdError, StdResult, Storage, Uint128, WasmMsg,\n};\nuse cw2::set_contract_version;\nuse cw20::{\n    BalanceResponse, Cw20ExecuteMsg, Cw20QueryMsg, Cw20ReceiveMsg, Logo, LogoInfo,\n    MarketingInfoResponse, MinterResponse, TokenInfoResponse,\n};\nuse cw20_base::contract::{\n    execute_update_marketing, execute_upload_logo, query_download_logo, query_marketing_info,\n};\nuse cw20_base::state::{MinterData, TokenInfo, LOGO, MARKETING_INFO, TOKEN_INFO};\n\nuse crate::astroport::asset::addr_opt_validate;\nuse crate::astroport::common::validate_addresses;\nuse astroport_governance::utils::{get_period, get_periods_count, EPOCH_START, WEEK};\nuse astroport_governance::voting_escrow::{\n    BlacklistedVotersResponse, ConfigResponse, Cw20HookMsg, ExecuteMsg, InstantiateMsg,\n    LockInfoResponse, MigrateMsg, QueryMsg, VotingPowerResponse, DEFAULT_LIMIT, MAX_LIMIT,\n};\n\nuse crate::error::ContractError;\nuse crate::marketing_validation::{validate_marketing_info, validate_whitelist_links};\nuse crate::state::{\n    Config, Lock, Point, BLACKLIST, CONFIG, HISTORY, LAST_SLOPE_CHANGE, LOCKED, OWNERSHIP_PROPOSAL,\n};\nuse crate::utils::{\n    adjust_vp_and_slope, blacklist_check, calc_coefficient, calc_voting_power,\n    cancel_scheduled_slope, fetch_last_checkpoint, fetch_slope_changes, schedule_slope_change,\n    time_limits_check, xastro_token_check,\n};\n\n/// Contract name that is used for migration.\nconst CONTRACT_NAME: \u0026str = \"astro-voting-escrow\";\n/// Contract version that is used for migration.\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Creates a new contract with the specified parameters in [`InstantiateMsg`].\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n    let deposit_token_addr = deps.api.addr_validate(\u0026msg.deposit_token_addr)?;\n\n    let xastro_minter_resp: MinterResponse = deps\n        .querier\n        .query_wasm_smart(\u0026deposit_token_addr, \u0026Cw20QueryMsg::Minter {})?;\n    let staking_config: crate::astroport::staking::ConfigResponse = deps.querier.query_wasm_smart(\n        \u0026xastro_minter_resp.minter,\n        \u0026crate::astroport::staking::QueryMsg::Config {},\n    )?;\n\n    validate_whitelist_links(\u0026msg.logo_urls_whitelist)?;\n    let guardian_addr = addr_opt_validate(deps.api, \u0026msg.guardian_addr)?;\n\n    let config = Config {\n        owner: deps.api.addr_validate(\u0026msg.owner)?,\n        guardian_addr,\n        deposit_token_addr,\n        astro_addr: staking_config.deposit_token_addr,\n        xastro_staking_addr: deps.api.addr_validate(\u0026xastro_minter_resp.minter)?,\n        logo_urls_whitelist: msg.logo_urls_whitelist.clone(),\n    };\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    let cur_period = get_period(env.block.time.seconds())?;\n    let point = Point {\n        power: Uint128::zero(),\n        start: cur_period,\n        end: 0,\n        slope: Default::default(),\n    };\n    HISTORY.save(\n        deps.storage,\n        (env.contract.address.clone(), cur_period),\n        \u0026point,\n    )?;\n    BLACKLIST.save(deps.storage, \u0026vec![])?;\n\n    if let Some(marketing) = msg.marketing {\n        if msg.logo_urls_whitelist.is_empty() {\n            return Err(StdError::generic_err(\"Logo URLs whitelist can not be empty\").into());\n        }\n\n        validate_marketing_info(\n            marketing.project.as_ref(),\n            marketing.description.as_ref(),\n            marketing.logo.as_ref(),\n            \u0026config.logo_urls_whitelist,\n        )?;\n\n        let logo = if let Some(logo) = marketing.logo {\n            LOGO.save(deps.storage, \u0026logo)?;\n\n            match logo {\n                Logo::Url(url) =\u003e Some(LogoInfo::Url(url)),\n                Logo::Embedded(_) =\u003e Some(LogoInfo::Embedded),\n            }\n        } else {\n            None\n        };\n\n        let data = MarketingInfoResponse {\n            project: marketing.project,\n            description: marketing.description,\n            marketing: addr_opt_validate(deps.api, \u0026marketing.marketing)?,\n            logo,\n        };\n        MARKETING_INFO.save(deps.storage, \u0026data)?;\n    }\n\n    // Store token info\n    let data = TokenInfo {\n        name: \"Vote Escrowed xASTRO\".to_string(),\n        symbol: \"vxASTRO\".to_string(),\n        decimals: 6,\n        total_supply: Uint128::zero(),\n        mint: Some(MinterData {\n            minter: env.contract.address,\n            cap: None,\n        }),\n    };\n\n    TOKEN_INFO.save(deps.storage, \u0026data)?;\n\n    Ok(Response::default())\n}\n\n/// Exposes all the execute functions available in the contract.\n///\n/// ## Execute messages\n/// * **ExecuteMsg::ExtendLockTime { time }** Increase a staker's lock time.\n///\n/// * **ExecuteMsg::Receive(msg)** Parse incoming messages coming from the xASTRO token contract.\n///\n/// * **ExecuteMsg::Withdraw {}** Withdraw all xASTRO from a lock position if the lock has expired.\n///\n/// * **ExecuteMsg::ProposeNewOwner { owner, expires_in }** Creates a new request to change contract ownership.\n///\n/// * **ExecuteMsg::DropOwnershipProposal {}** Removes a request to change contract ownership.\n///\n/// * **ExecuteMsg::ClaimOwnership {}** Claims contract ownership.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::ExtendLockTime { time } =\u003e extend_lock_time(deps, env, info, time),\n        ExecuteMsg::Receive(msg) =\u003e receive_cw20(deps, env, info, msg),\n        ExecuteMsg::Withdraw {} =\u003e withdraw(deps, env, info),\n        ExecuteMsg::ProposeNewOwner {\n            new_owner,\n            expires_in,\n        } =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n            propose_new_owner(\n                deps,\n                info,\n                env,\n                new_owner,\n                expires_in,\n                config.owner,\n                OWNERSHIP_PROPOSAL,\n            )\n            .map_err(Into::into)\n        }\n        ExecuteMsg::DropOwnershipProposal {} =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n\n            drop_ownership_proposal(deps, info, config.owner, OWNERSHIP_PROPOSAL)\n                .map_err(Into::into)\n        }\n        ExecuteMsg::ClaimOwnership {} =\u003e {\n            claim_ownership(deps, info, env, OWNERSHIP_PROPOSAL, |deps, new_owner| {\n                CONFIG\n                    .update::\u003c_, StdError\u003e(deps.storage, |mut v| {\n                        v.owner = new_owner;\n                        Ok(v)\n                    })\n                    .map(|_| ())\n            })\n            .map_err(Into::into)\n        }\n        ExecuteMsg::UpdateBlacklist {\n            append_addrs,\n            remove_addrs,\n        } =\u003e update_blacklist(deps, env, info, append_addrs, remove_addrs),\n        ExecuteMsg::UpdateMarketing {\n            project,\n            description,\n            marketing,\n        } =\u003e {\n            validate_marketing_info(project.as_ref(), description.as_ref(), None, \u0026[])?;\n            execute_update_marketing(deps, env, info, project, description, marketing)\n                .map_err(Into::into)\n        }\n        ExecuteMsg::UploadLogo(logo) =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n            validate_marketing_info(None, None, Some(\u0026logo), \u0026config.logo_urls_whitelist)?;\n            execute_upload_logo(deps, env, info, logo).map_err(Into::into)\n        }\n        ExecuteMsg::SetLogoUrlsWhitelist { whitelist } =\u003e {\n            let mut config = CONFIG.load(deps.storage)?;\n            let marketing_info = MARKETING_INFO.load(deps.storage)?;\n            if info.sender != config.owner \u0026\u0026 Some(info.sender) != marketing_info.marketing {\n                Err(ContractError::Unauthorized {})\n            } else {\n                validate_whitelist_links(\u0026whitelist)?;\n                config.logo_urls_whitelist = whitelist;\n                CONFIG.save(deps.storage, \u0026config)?;\n                Ok(Response::default().add_attribute(\"action\", \"set_logo_urls_whitelist\"))\n            }\n        }\n        ExecuteMsg::UpdateConfig { new_guardian } =\u003e {\n            execute_update_config(deps, info, new_guardian)\n        }\n    }\n}\n\n/// Checkpoint the total voting power (total supply of vxASTRO).\n/// This function fetches the last available vxASTRO checkpoint, recalculates passed periods since the checkpoint and until now,\n/// applies slope changes and saves all recalculated periods in [`HISTORY`].\n///\n/// * **add_voting_power** amount of vxASTRO to add to the total.\n///\n/// * **reduce_power** amount of vxASTRO to subtract from the total.\n///\n/// * **old_slope** old slope applied to the total voting power (vxASTRO supply).\n///\n/// * **new_slope** new slope to be applied to the total voting power (vxASTRO supply).\nfn checkpoint_total(\n    storage: \u0026mut dyn Storage,\n    env: Env,\n    add_voting_power: Option\u003cUint128\u003e,\n    reduce_power: Option\u003cUint128\u003e,\n    old_slope: Uint128,\n    new_slope: Uint128,\n) -\u003e StdResult\u003c()\u003e {\n    let cur_period = get_period(env.block.time.seconds())?;\n    let cur_period_key = cur_period;\n    let contract_addr = env.contract.address;\n    let add_voting_power = add_voting_power.unwrap_or_default();\n\n    // Get last checkpoint\n    let last_checkpoint = fetch_last_checkpoint(storage, \u0026contract_addr, cur_period_key)?;\n    let new_point = if let Some((_, mut point)) = last_checkpoint {\n        let last_slope_change = LAST_SLOPE_CHANGE.may_load(storage)?.unwrap_or(0);\n        if last_slope_change \u003c cur_period {\n            let scheduled_slope_changes =\n                fetch_slope_changes(storage, last_slope_change, cur_period)?;\n            // Recalculating passed points\n            for (recalc_period, scheduled_change) in scheduled_slope_changes {\n                point = Point {\n                    power: calc_voting_power(\u0026point, recalc_period),\n                    start: recalc_period,\n                    slope: point.slope - scheduled_change,\n                    ..point\n                };\n                HISTORY.save(storage, (contract_addr.clone(), recalc_period), \u0026point)?\n            }\n\n            LAST_SLOPE_CHANGE.save(storage, \u0026cur_period)?\n        }\n\n        let new_power = (calc_voting_power(\u0026point, cur_period) + add_voting_power)\n            .saturating_sub(reduce_power.unwrap_or_default());\n\n        Point {\n            power: new_power,\n            slope: point.slope - old_slope + new_slope,\n            start: cur_period,\n            ..point\n        }\n    } else {\n        Point {\n            power: add_voting_power,\n            slope: new_slope,\n            start: cur_period,\n            end: 0, // we don't use 'end' in total voting power calculations\n        }\n    };\n    HISTORY.save(storage, (contract_addr, cur_period_key), \u0026new_point)\n}\n\n/// Checkpoint a user's voting power (vxASTRO balance).\n/// This function fetches the user's last available checkpoint, calculates the user's current voting power, applies slope changes based on\n/// `add_amount` and `new_end` parameters, schedules slope changes for total voting power and saves the new checkpoint for the current\n/// period in [`HISTORY`] (using the user's address).\n/// If a user already checkpointed themselves for the current period, then this function uses the current checkpoint as the latest\n/// available one.\n///\n/// * **addr** staker for which we checkpoint the voting power.\n///\n/// * **add_amount** amount of vxASTRO to add to the staker's balance.\n///\n/// * **new_end** new lock time for the staker's vxASTRO position.\nfn checkpoint(\n    deps: DepsMut,\n    env: Env,\n    addr: Addr,\n    add_amount: Option\u003cUint128\u003e,\n    new_end: Option\u003cu64\u003e,\n) -\u003e StdResult\u003c()\u003e {\n    let cur_period = get_period(env.block.time.seconds())?;\n    let cur_period_key = cur_period;\n    let add_amount = add_amount.unwrap_or_default();\n    let mut old_slope = Default::default();\n    let mut add_voting_power = Uint128::zero();\n\n    // Get the last user checkpoint\n    let last_checkpoint = fetch_last_checkpoint(deps.storage, \u0026addr, cur_period_key)?;\n    let new_point = if let Some((_, point)) = last_checkpoint {\n        let end = new_end.unwrap_or(point.end);\n        let dt = end.saturating_sub(cur_period);\n        let current_power = calc_voting_power(\u0026point, cur_period);\n        let new_slope = if dt != 0 {\n            if end \u003e point.end \u0026\u0026 add_amount.is_zero() {\n                // This is extend_lock_time. Recalculating user's voting power\n                let mut lock = LOCKED.load(deps.storage, addr.clone())?;\n                let mut new_voting_power = calc_coefficient(dt).checked_mul_uint128(lock.amount)?;\n                let slope = adjust_vp_and_slope(\u0026mut new_voting_power, dt)?;\n                // new_voting_power should always be \u003e= current_power. saturating_sub is used for extra safety\n                add_voting_power = new_voting_power.saturating_sub(current_power);\n                lock.last_extend_lock_period = cur_period;\n                LOCKED.save(deps.storage, addr.clone(), \u0026lock, env.block.height)?;\n                slope\n            } else {\n                // This is an increase in the user's lock amount\n                let raw_add_voting_power = calc_coefficient(dt).checked_mul_uint128(add_amount)?;\n                let mut new_voting_power = current_power.checked_add(raw_add_voting_power)?;\n                let slope = adjust_vp_and_slope(\u0026mut new_voting_power, dt)?;\n                // new_voting_power should always be \u003e= current_power. saturating_sub is used for extra safety\n                add_voting_power = new_voting_power.saturating_sub(current_power);\n                slope\n            }\n        } else {\n            Uint128::zero()\n        };\n\n        // Cancel the previously scheduled slope change\n        cancel_scheduled_slope(deps.storage, point.slope, point.end)?;\n\n        // We need to subtract the slope point from the total voting power slope\n        old_slope = point.slope;\n\n        Point {\n            power: current_power + add_voting_power,\n            slope: new_slope,\n            start: cur_period,\n            end,\n        }\n    } else {\n        // This error can't happen since this if-branch is intended for checkpoint creation\n        let end =\n            new_end.ok_or_else(|| StdError::generic_err(\"Checkpoint initialization error\"))?;\n        let dt = end - cur_period;\n        add_voting_power = calc_coefficient(dt).checked_mul_uint128(add_amount)?;\n        let slope = adjust_vp_and_slope(\u0026mut add_voting_power, dt)?;\n        Point {\n            power: add_voting_power,\n            slope,\n            start: cur_period,\n            end,\n        }\n    };\n\n    // Schedule a slope change\n    schedule_slope_change(deps.storage, new_point.slope, new_point.end)?;\n\n    HISTORY.save(deps.storage, (addr, cur_period_key), \u0026new_point)?;\n    checkpoint_total(\n        deps.storage,\n        env,\n        Some(add_voting_power),\n        None,\n        old_slope,\n        new_point.slope,\n    )\n}\n\n/// Receives a message of type [`Cw20ReceiveMsg`] and processes it depending on the received template.\n///\n/// * **cw20_msg** CW20 message to process.\nfn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    xastro_token_check(deps.storage, info.sender)?;\n    let sender = Addr::unchecked(cw20_msg.sender);\n    blacklist_check(deps.storage, \u0026sender)?;\n\n    match from_binary(\u0026cw20_msg.msg)? {\n        Cw20HookMsg::CreateLock { time } =\u003e create_lock(deps, env, sender, cw20_msg.amount, time),\n        Cw20HookMsg::ExtendLockAmount {} =\u003e deposit_for(deps, env, cw20_msg.amount, sender),\n        Cw20HookMsg::DepositFor { user } =\u003e {\n            let addr = deps.api.addr_validate(\u0026user)?;\n            blacklist_check(deps.storage, \u0026addr)?;\n            deposit_for(deps, env, cw20_msg.amount, addr)\n        }\n    }\n}\n\n/// Creates a lock for the user that lasts for the specified time duration (in seconds).\n/// Checks that the user is locking xASTRO tokens.\n/// Checks that the lock time is within [`WEEK`]..[`MAX_LOCK_TIME`].\n/// Creates a lock if it doesn't exist and triggers a [`checkpoint`] for the staker.\n/// If a lock already exists, then a [`ContractError`] is returned.\n///\n/// * **user** staker for which we create a lock position.\n///\n/// * **amount** amount of xASTRO deposited in the lock position.\n///\n/// * **time** duration of the lock.\nfn create_lock(\n    deps: DepsMut,\n    env: Env,\n    user: Addr,\n    amount: Uint128,\n    time: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    time_limits_check(time)?;\n\n    let block_period = get_period(env.block.time.seconds())?;\n    let end = block_period + get_periods_count(time);\n\n    LOCKED.update(deps.storage, user.clone(), env.block.height, |lock_opt| {\n        if lock_opt.is_some() \u0026\u0026 !lock_opt.unwrap().amount.is_zero() {\n            return Err(ContractError::LockAlreadyExists {});\n        }\n        Ok(Lock {\n            amount,\n            start: block_period,\n            end,\n            last_extend_lock_period: block_period,\n        })\n    })?;\n\n    checkpoint(deps, env, user, Some(amount), Some(end))?;\n\n    Ok(Response::default().add_attribute(\"action\", \"create_lock\"))\n}\n\n/// Deposits an 'amount' of xASTRO tokens into 'user''s lock.\n/// Checks that the user is transferring and locking xASTRO.\n/// Triggers a [`checkpoint`] for the user.\n/// If the user does not have a lock, then a [`ContractError`] is returned.\n///\n/// * **amount** amount of xASTRO to deposit.\n///\n/// * **user** user who's lock amount will increase.\nfn deposit_for(\n    deps: DepsMut,\n    env: Env,\n    amount: Uint128,\n    user: Addr,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    LOCKED.update(\n        deps.storage,\n        user.clone(),\n        env.block.height,\n        |lock_opt| match lock_opt {\n            Some(mut lock) if !lock.amount.is_zero() =\u003e {\n                if lock.end \u003c= get_period(env.block.time.seconds())? {\n                    Err(ContractError::LockExpired {})\n                } else {\n                    lock.amount += amount;\n                    Ok(lock)\n                }\n            }\n            _ =\u003e Err(ContractError::LockDoesNotExist {}),\n        },\n    )?;\n    checkpoint(deps, env, user, Some(amount), None)?;\n\n    Ok(Response::default().add_attribute(\"action\", \"deposit_for\"))\n}\n\n/// Withdraws the whole amount of locked xASTRO from a specific user lock.\n/// If the user lock doesn't exist or if it has not yet expired, then a [`ContractError`] is returned.\nfn withdraw(deps: DepsMut, env: Env, info: MessageInfo) -\u003e Result\u003cResponse, ContractError\u003e {\n    let sender = info.sender;\n    // 'LockDoesNotExist' is thrown either when a lock does not exist in LOCKED or when a lock exists but lock.amount == 0\n    let mut lock = LOCKED\n        .may_load(deps.storage, sender.clone())?\n        .filter(|lock| !lock.amount.is_zero())\n        .ok_or(ContractError::LockDoesNotExist {})?;\n\n    let cur_period = get_period(env.block.time.seconds())?;\n    if lock.end \u003e cur_period {\n        Err(ContractError::LockHasNotExpired {})\n    } else {\n        let config = CONFIG.load(deps.storage)?;\n        let transfer_msg = CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: config.deposit_token_addr.to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                recipient: sender.to_string(),\n                amount: lock.amount,\n            })?,\n            funds: vec![],\n        });\n        lock.amount = Uint128::zero();\n        LOCKED.save(deps.storage, sender.clone(), \u0026lock, env.block.height)?;\n\n        // We need to checkpoint and eliminate the slope influence on a future lock\n        HISTORY.save(\n            deps.storage,\n            (sender, cur_period),\n            \u0026Point {\n                power: Uint128::zero(),\n                start: cur_period,\n                end: cur_period,\n                slope: Default::default(),\n            },\n        )?;\n\n        Ok(Response::default()\n            .add_message(transfer_msg)\n            .add_attribute(\"action\", \"withdraw\"))\n    }\n}\n\n/// Increase the current lock time for a staker by a specified time period.\n/// Evaluates that the `time` is within [`WEEK`]..[`MAX_LOCK_TIME`]\n/// and then it triggers a [`checkpoint`].\n/// If the user lock doesn't exist or if it expired, then a [`ContractError`] is returned.\n///\n/// ## Note\n/// The time is added to the lock's `end`.\n/// For example, at period 0, the user has their xASTRO locked for 3 weeks.\n/// In 1 week, they increase their lock time by 10 weeks, thus the unlock period becomes 13 weeks.\n///\n/// * **time** increase in lock time applied to the staker's position.\nfn extend_lock_time(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    time: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let user = info.sender;\n    blacklist_check(deps.storage, \u0026user)?;\n    let mut lock = LOCKED\n        .may_load(deps.storage, user.clone())?\n        .filter(|lock| !lock.amount.is_zero())\n        .ok_or(ContractError::LockDoesNotExist {})?;\n\n    // Disable the ability to extend the lock time by less than a week\n    time_limits_check(time)?;\n\n    if lock.end \u003c= get_period(env.block.time.seconds())? {\n        return Err(ContractError::LockExpired {});\n    };\n\n    // Should not exceed MAX_LOCK_TIME\n    time_limits_check(EPOCH_START + lock.end * WEEK + time - env.block.time.seconds())?;\n    lock.end += get_periods_count(time);\n    LOCKED.save(deps.storage, user.clone(), \u0026lock, env.block.height)?;\n\n    checkpoint(deps, env, user, None, Some(lock.end))?;\n\n    Ok(Response::default().add_attribute(\"action\", \"extend_lock_time\"))\n}\n\n/// Update the staker blacklist. Whitelists addresses specified in 'remove_addrs'\n/// and blacklists new addresses specified in 'append_addrs'. Nullifies staker voting power and\n/// cancels their contribution in the total voting power (total vxASTRO supply).\n///\n/// * **append_addrs** array of addresses to blacklist.\n///\n/// * **remove_addrs** array of addresses to whitelist.\nfn update_blacklist(\n    mut deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    append_addrs: Option\u003cVec\u003cString\u003e\u003e,\n    remove_addrs: Option\u003cVec\u003cString\u003e\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n    // Permission check\n    if info.sender != config.owner \u0026\u0026 Some(info.sender) != config.guardian_addr {\n        return Err(ContractError::Unauthorized {});\n    }\n    let append_addrs = append_addrs.unwrap_or_default();\n    let remove_addrs = remove_addrs.unwrap_or_default();\n    let blacklist = BLACKLIST.load(deps.storage)?;\n    let append: Vec\u003c_\u003e = validate_addresses(deps.api, \u0026append_addrs)?\n        .into_iter()\n        .filter(|addr| !blacklist.contains(addr))\n        .collect();\n    let remove: Vec\u003c_\u003e = validate_addresses(deps.api, \u0026remove_addrs)?\n        .into_iter()\n        .filter(|addr| blacklist.contains(addr))\n        .collect();\n\n    if append.is_empty() \u0026\u0026 remove.is_empty() {\n        return Err(StdError::generic_err(\"Append and remove arrays are empty\").into());\n    }\n\n    let cur_period = get_period(env.block.time.seconds())?;\n    let cur_period_key = cur_period;\n    let mut reduce_total_vp = Uint128::zero(); // accumulator for decreasing total voting power\n    let mut old_slopes = Uint128::zero(); // accumulator for old slopes\n\n    for addr in append.iter() {\n        let last_checkpoint = fetch_last_checkpoint(deps.storage, addr, cur_period_key)?;\n        if let Some((_, point)) = last_checkpoint {\n            // We need to checkpoint with zero power and zero slope\n            HISTORY.save(\n                deps.storage,\n                (addr.clone(), cur_period_key),\n                \u0026Point {\n                    power: Uint128::zero(),\n                    slope: Default::default(),\n                    start: cur_period,\n                    end: cur_period,\n                },\n            )?;\n\n            let cur_power = calc_voting_power(\u0026point, cur_period);\n            // User's contribution is already zero. Skipping them\n            if cur_power.is_zero() {\n                continue;\n            }\n\n            // User's contribution in the total voting power calculation\n            reduce_total_vp += cur_power;\n            old_slopes += point.slope;\n            cancel_scheduled_slope(deps.storage, point.slope, point.end)?;\n        }\n    }\n\n    if !reduce_total_vp.is_zero() || !old_slopes.is_zero() {\n        // Trigger a total voting power recalculation\n        checkpoint_total(\n            deps.storage,\n            env.clone(),\n            None,\n            Some(reduce_total_vp),\n            old_slopes,\n            Default::default(),\n        )?;\n    }\n\n    for addr in remove.iter() {\n        let lock_opt = LOCKED.may_load(deps.storage, addr.clone())?;\n        if let Some(Lock { amount, end, .. }) = lock_opt {\n            checkpoint(\n                deps.branch(),\n                env.clone(),\n                addr.clone(),\n                Some(amount),\n                Some(end),\n            )?;\n        }\n    }\n\n    BLACKLIST.update(deps.storage, |blacklist| -\u003e StdResult\u003cVec\u003cAddr\u003e\u003e {\n        let mut updated_blacklist: Vec\u003c_\u003e = blacklist\n            .into_iter()\n            .filter(|addr| !remove.contains(addr))\n            .collect();\n        updated_blacklist.extend(append);\n        Ok(updated_blacklist)\n    })?;\n\n    let mut attrs = vec![attr(\"action\", \"update_blacklist\")];\n    if !append_addrs.is_empty() {\n        attrs.push(attr(\"added_addresses\", append_addrs.join(\",\")))\n    }\n    if !remove_addrs.is_empty() {\n        attrs.push(attr(\"removed_addresses\", remove_addrs.join(\",\")))\n    }\n\n    Ok(Response::default().add_attributes(attrs))\n}\n\n/// Updates contracts' guardian address.\nfn execute_update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    new_guardian: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut cfg = CONFIG.load(deps.storage)?;\n\n    if cfg.owner != info.sender {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(new_guardian) = new_guardian {\n        cfg.guardian_addr = Some(deps.api.addr_validate(\u0026new_guardian)?);\n    }\n\n    CONFIG.save(deps.storage, \u0026cfg)?;\n\n    Ok(Response::default().add_attribute(\"action\", \"execute_update_config\"))\n}\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::TotalVotingPower {}** Fetch the total voting power (vxASTRO supply) at the current block.\n///\n/// * **QueryMsg::UserVotingPower { user }** Fetch the user's voting power (vxASTRO balance) at the current block.\n///\n/// * **QueryMsg::TotalVotingPowerAt { time }** Fetch the total voting power (vxASTRO supply) at a specified timestamp.\n///\n/// * **QueryMsg::UserVotingPowerAt { time }** Fetch the user's voting power (vxASTRO balance) at a specified timestamp.\n///\n/// * **QueryMsg::LockInfo { user }** Fetch a user's lock information.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::CheckVotersAreBlacklisted { voters } =\u003e {\n            to_binary(\u0026check_voters_are_blacklisted(deps, voters)?)\n        }\n        QueryMsg::BlacklistedVoters { start_after, limit } =\u003e {\n            to_binary(\u0026get_blacklisted_voters(deps, start_after, limit)?)\n        }\n        QueryMsg::TotalVotingPower {} =\u003e to_binary(\u0026get_total_voting_power(deps, env, None)?),\n        QueryMsg::UserVotingPower { user } =\u003e {\n            to_binary(\u0026get_user_voting_power(deps, env, user, None)?)\n        }\n        QueryMsg::TotalVotingPowerAt { time } =\u003e {\n            to_binary(\u0026get_total_voting_power(deps, env, Some(time))?)\n        }\n        QueryMsg::TotalVotingPowerAtPeriod { period } =\u003e {\n            to_binary(\u0026get_total_voting_power_at_period(deps, env, period)?)\n        }\n        QueryMsg::UserVotingPowerAt { user, time } =\u003e {\n            to_binary(\u0026get_user_voting_power(deps, env, user, Some(time))?)\n        }\n        QueryMsg::UserVotingPowerAtPeriod { user, period } =\u003e {\n            to_binary(\u0026get_user_voting_power_at_period(deps, user, period)?)\n        }\n        QueryMsg::LockInfo { user } =\u003e to_binary(\u0026get_user_lock_info(deps, env, user)?),\n        QueryMsg::UserDepositAtHeight { user, height } =\u003e {\n            to_binary(\u0026get_user_deposit_at_height(deps, user, height)?)\n        }\n        QueryMsg::Config {} =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n            to_binary(\u0026ConfigResponse {\n                owner: config.owner.to_string(),\n                guardian_addr: config.guardian_addr,\n                deposit_token_addr: config.deposit_token_addr.to_string(),\n                astro_addr: config.astro_addr.to_string(),\n                xastro_staking_addr: config.xastro_staking_addr.to_string(),\n                logo_urls_whitelist: config.logo_urls_whitelist,\n            })\n        }\n        QueryMsg::Balance { address } =\u003e to_binary(\u0026get_user_balance(deps, env, address)?),\n        QueryMsg::TokenInfo {} =\u003e to_binary(\u0026query_token_info(deps, env)?),\n        QueryMsg::MarketingInfo {} =\u003e to_binary(\u0026query_marketing_info(deps)?),\n        QueryMsg::DownloadLogo {} =\u003e to_binary(\u0026query_download_logo(deps)?),\n    }\n}\n\n/// Checks if specified addresses are blacklisted.\n///\n/// * **voters** addresses to check if they are blacklisted.\npub fn check_voters_are_blacklisted(\n    deps: Deps,\n    voters: Vec\u003cString\u003e,\n) -\u003e StdResult\u003cBlacklistedVotersResponse\u003e {\n    let black_list = BLACKLIST.load(deps.storage)?;\n\n    for voter in voters {\n        let voter_addr = deps.api.addr_validate(voter.as_str())?;\n        if !black_list.contains(\u0026voter_addr) {\n            return Ok(BlacklistedVotersResponse::VotersNotBlacklisted { voter });\n        }\n    }\n\n    Ok(BlacklistedVotersResponse::VotersBlacklisted {})\n}\n\n/// Returns a list of blacklisted voters.\n///\n/// * **start_after** is an optional field that specifies whether the function should return\n/// a list of voters starting from a specific address onward.\n///\n/// * **limit** max amount of voters addresses to return.\npub fn get_blacklisted_voters(\n    deps: Deps,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cVec\u003cAddr\u003e\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let mut black_list = BLACKLIST.load(deps.storage)?;\n\n    if black_list.is_empty() {\n        return Ok(vec![]);\n    }\n\n    black_list.sort();\n\n    let mut start_index = Default::default();\n    if let Some(start_after) = start_after {\n        let start_addr = deps.api.addr_validate(start_after.as_str())?;\n        start_index = black_list\n            .iter()\n            .position(|addr| *addr == start_addr)\n            .ok_or_else(|| {\n                StdError::generic_err(format!(\n                    \"The {} address is not blacklisted\",\n                    start_addr.as_str()\n                ))\n            })?\n            + 1; // start from the next element of the slice\n    }\n\n    // validate end index of the slice\n    let end_index = (start_index + limit).min(black_list.len());\n\n    Ok(black_list[start_index..end_index].to_vec())\n}\n\n/// Return a user's lock information.\n///\n/// * **user** user for which we return lock information.\nfn get_user_lock_info(deps: Deps, env: Env, user: String) -\u003e StdResult\u003cLockInfoResponse\u003e {\n    let addr = deps.api.addr_validate(\u0026user)?;\n    if let Some(lock) = LOCKED.may_load(deps.storage, addr.clone())? {\n        let cur_period = get_period(env.block.time.seconds())?;\n        let slope = fetch_last_checkpoint(deps.storage, \u0026addr, cur_period)?\n            .map(|(_, point)| point.slope)\n            .unwrap_or_default();\n        let resp = LockInfoResponse {\n            amount: lock.amount,\n            coefficient: calc_coefficient(lock.end - lock.last_extend_lock_period),\n            start: lock.start,\n            end: lock.end,\n            slope,\n        };\n        Ok(resp)\n    } else {\n        Err(StdError::generic_err(\"User is not found\"))\n    }\n}\n\n/// Return a user's staked xASTRO amount at a given block height.\n///\n/// * **user** user for which we return lock information.\n///\n/// * **block_height** block height at which we return the staked xASTRO amount.\nfn get_user_deposit_at_height(deps: Deps, user: String, block_height: u64) -\u003e StdResult\u003cUint128\u003e {\n    let addr = deps.api.addr_validate(\u0026user)?;\n    let locked_opt = LOCKED.may_load_at_height(deps.storage, addr, block_height)?;\n    if let Some(lock) = locked_opt {\n        Ok(lock.amount)\n    } else {\n        Ok(Uint128::zero())\n    }\n}\n\n/// Calculates a user's voting power at a given timestamp.\n/// If time is None, then it calculates the user's voting power at the current block.\n///\n/// * **user** user/staker for which we fetch the current voting power (vxASTRO balance).\n///\n/// * **time** timestamp at which to fetch the user's voting power (vxASTRO balance).\nfn get_user_voting_power(\n    deps: Deps,\n    env: Env,\n    user: String,\n    time: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cVotingPowerResponse\u003e {\n    let period = get_period(time.unwrap_or_else(|| env.block.time.seconds()))?;\n    get_user_voting_power_at_period(deps, user, period)\n}\n\n/// Calculates a user's voting power at a given period number.\n///\n/// * **user** user/staker for which we fetch the current voting power (vxASTRO balance).\n///\n/// * **period** period number at which to fetch the user's voting power (vxASTRO balance).\nfn get_user_voting_power_at_period(\n    deps: Deps,\n    user: String,\n    period: u64,\n) -\u003e StdResult\u003cVotingPowerResponse\u003e {\n    let user = deps.api.addr_validate(\u0026user)?;\n    let last_checkpoint = fetch_last_checkpoint(deps.storage, \u0026user, period)?;\n\n    if let Some(point) = last_checkpoint.map(|(_, point)| point) {\n        // The voting power point at the specified `time` was found\n        let voting_power = if point.start == period {\n            point.power\n        } else {\n            // The point before the intended period was found, thus we can calculate the user's voting power for the period we want\n            calc_voting_power(\u0026point, period)\n        };\n        Ok(VotingPowerResponse { voting_power })\n    } else {\n        // User not found\n        Ok(VotingPowerResponse {\n            voting_power: Uint128::zero(),\n        })\n    }\n}\n\n/// Calculates a user's voting power at the current block.\n///\n/// * **user** user/staker for which we fetch the current voting power (vxASTRO balance).\nfn get_user_balance(deps: Deps, env: Env, user: String) -\u003e StdResult\u003cBalanceResponse\u003e {\n    let vp_response = get_user_voting_power(deps, env, user, None)?;\n    Ok(BalanceResponse {\n        balance: vp_response.voting_power,\n    })\n}\n\n/// Calculates the total voting power (total vxASTRO supply) at the given timestamp.\n/// If `time` is None, then it calculates the total voting power at the current block.\n///\n/// * **time** timestamp at which we fetch the total voting power (vxASTRO supply).\nfn get_total_voting_power(\n    deps: Deps,\n    env: Env,\n    time: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cVotingPowerResponse\u003e {\n    let period = get_period(time.unwrap_or_else(|| env.block.time.seconds()))?;\n    get_total_voting_power_at_period(deps, env, period)\n}\n\n/// Calculates the total voting power (total vxASTRO supply) at the given period number.\n///\n/// * **period** period number at which we fetch the total voting power (vxASTRO supply).\nfn get_total_voting_power_at_period(\n    deps: Deps,\n    env: Env,\n    period: u64,\n) -\u003e StdResult\u003cVotingPowerResponse\u003e {\n    let last_checkpoint = fetch_last_checkpoint(deps.storage, \u0026env.contract.address, period)?;\n\n    let point = last_checkpoint.map_or(\n        Point {\n            power: Uint128::zero(),\n            start: period,\n            end: period,\n            slope: Default::default(),\n        },\n        |(_, point)| point,\n    );\n\n    let voting_power = if point.start == period {\n        point.power\n    } else {\n        let scheduled_slope_changes = fetch_slope_changes(deps.storage, point.start, period)?;\n        let mut init_point = point;\n        for (recalc_period, scheduled_change) in scheduled_slope_changes {\n            init_point = Point {\n                power: calc_voting_power(\u0026init_point, recalc_period),\n                start: recalc_period,\n                slope: init_point.slope - scheduled_change,\n                ..init_point\n            }\n        }\n        calc_voting_power(\u0026init_point, period)\n    };\n\n    Ok(VotingPowerResponse { voting_power })\n}\n\n/// Fetch the vxASTRO token information, such as the token name, symbol, decimals and total supply (total voting power).\nfn query_token_info(deps: Deps, env: Env) -\u003e StdResult\u003cTokenInfoResponse\u003e {\n    let info = TOKEN_INFO.load(deps.storage)?;\n    let total_vp = get_total_voting_power(deps, env, None)?;\n    let res = TokenInfoResponse {\n        name: info.name,\n        symbol: info.symbol,\n        decimals: info.decimals,\n        total_supply: total_vp.voting_power,\n    };\n    Ok(res)\n}\n\n/// Manages contract migration.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    Err(ContractError::MigrationError {})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse cw20_base::ContractError as cw20baseError;\nuse thiserror::Error;\n\n/// This enum describes vxASTRO contract errors\n#[derive(Error, Debug)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"{0}\")]\n    Cw20Base(#[from] cw20baseError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Lock already exists\")]\n    LockAlreadyExists {},\n\n    #[error(\"Lock does not exist\")]\n    LockDoesNotExist {},\n\n    #[error(\"Lock time must be within limits (week \u003c= lock time \u003c 2 years)\")]\n    LockTimeLimitsError {},\n\n    #[error(\"The lock time has not yet expired\")]\n    LockHasNotExpired {},\n\n    #[error(\"The lock expired. Withdraw and create new lock\")]\n    LockExpired {},\n\n    #[error(\"The {0} address is blacklisted\")]\n    AddressBlacklisted(String),\n\n    #[error(\"Marketing info validation error: {0}\")]\n    MarketingInfoValidationError(String),\n\n    #[error(\"Contract can't be migrated!\")]\n    MigrationError {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","src","lib.rs"],"content":"pub mod contract;\npub mod state;\n\n// During development this import could be replaced with another astroport version.\n// However, in production, the astroport version should be the same for all contracts.\npub use astroport_governance::astroport;\n\npub mod error;\nmod marketing_validation;\nmod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","src","marketing_validation.rs"],"content":"use crate::error::ContractError;\nuse crate::error::ContractError::MarketingInfoValidationError;\n\nuse cosmwasm_std::StdError;\nuse cw20::Logo;\n\nconst SAFE_TEXT_CHARS: \u0026str = \"!\u0026?#()*+'-.,/\\\"\";\nconst SAFE_LINK_CHARS: \u0026str = \"-_:/?#@!$\u0026()*+,;=.~[]'%\";\n\nfn validate_text(text: \u0026str, name: \u0026str) -\u003e Result\u003c(), ContractError\u003e {\n    if text.chars().any(|c| {\n        !c.is_ascii_alphanumeric() \u0026\u0026 !c.is_ascii_whitespace() \u0026\u0026 !SAFE_TEXT_CHARS.contains(c)\n    }) {\n        Err(MarketingInfoValidationError(format!(\n            \"{name} contains invalid characters: {text}\"\n        )))\n    } else {\n        Ok(())\n    }\n}\n\npub fn validate_whitelist_links(links: \u0026[String]) -\u003e Result\u003c(), ContractError\u003e {\n    links.iter().try_for_each(|link| {\n        if !link.ends_with('/') {\n            return Err(MarketingInfoValidationError(format!(\n                \"Whitelist link should end with '/': {link}\"\n            )));\n        }\n        validate_link(link)\n    })\n}\n\npub fn validate_link(link: \u0026String) -\u003e Result\u003c(), ContractError\u003e {\n    if link\n        .chars()\n        .any(|c| !c.is_ascii_alphanumeric() \u0026\u0026 !SAFE_LINK_CHARS.contains(c))\n    {\n        Err(StdError::generic_err(format!(\"Link contains invalid characters: {link}\")).into())\n    } else {\n        Ok(())\n    }\n}\n\nfn check_link(link: \u0026String, whitelisted_links: \u0026[String]) -\u003e Result\u003c(), ContractError\u003e {\n    if validate_link(link).is_err() {\n        Err(MarketingInfoValidationError(format!(\n            \"Logo link is invalid: {link}\"\n        )))\n    } else if !whitelisted_links.iter().any(|wl| link.starts_with(wl)) {\n        Err(MarketingInfoValidationError(format!(\n            \"Logo link is not whitelisted: {link}\"\n        )))\n    } else {\n        Ok(())\n    }\n}\n\npub(crate) fn validate_marketing_info(\n    project: Option\u003c\u0026String\u003e,\n    description: Option\u003c\u0026String\u003e,\n    logo: Option\u003c\u0026Logo\u003e,\n    whitelisted_links: \u0026[String],\n) -\u003e Result\u003c(), ContractError\u003e {\n    if let Some(description) = description {\n        validate_text(description, \"description\")?;\n    }\n    if let Some(project) = project {\n        validate_text(project, \"project\")?;\n    }\n    if let Some(Logo::Url(url)) = logo {\n        check_link(url, whitelisted_links)?;\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","src","state.rs"],"content":"use crate::astroport::common::OwnershipProposal;\nuse cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Uint128};\nuse cw_storage_plus::{Item, Map, SnapshotMap, Strategy};\n\n/// This structure stores the main parameters for the voting escrow contract.\n#[cw_serde]\npub struct Config {\n    /// Address that's allowed to change contract parameters\n    pub owner: Addr,\n    /// Address that can only blacklist vxASTRO stakers and remove their governance power\n    pub guardian_addr: Option\u003cAddr\u003e,\n    /// The xASTRO token contract address\n    pub deposit_token_addr: Addr,\n    /// The address of $ASTRO\n    pub astro_addr: Addr,\n    /// The address of $xASTRO staking contract\n    pub xastro_staking_addr: Addr,\n    /// The list of whitelisted logo urls prefixes\n    pub logo_urls_whitelist: Vec\u003cString\u003e,\n}\n\n/// This structure stores points along the checkpoint history for every vxASTRO staker.\n#[cw_serde]\npub struct Point {\n    /// The staker's vxASTRO voting power\n    pub power: Uint128,\n    /// The start period when the staker's voting power start to decrease\n    pub start: u64,\n    /// The period when the lock should expire\n    pub end: u64,\n    /// Weekly voting power decay\n    pub slope: Uint128,\n}\n\n/// This structure stores data about the lockup position for a specific vxASTRO staker.\n#[cw_serde]\npub struct Lock {\n    /// The total amount of xASTRO tokens that were deposited in the vxASTRO position\n    pub amount: Uint128,\n    /// The start period when the lock was created\n    pub start: u64,\n    /// The timestamp when the lock position expires\n    pub end: u64,\n    /// the last period when the lock's time was increased\n    pub last_extend_lock_period: u64,\n}\n\n/// Stores the contract config at the given key\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n\n/// Stores all user lock history\npub const LOCKED: SnapshotMap\u003cAddr, Lock\u003e = SnapshotMap::new(\n    \"locked\",\n    \"locked__checkpoints\",\n    \"locked__changelog\",\n    Strategy::EveryBlock,\n);\n\n/// Stores the checkpoint history for every staker (addr =\u003e period)\n/// Total voting power checkpoints are stored using a (contract_addr =\u003e period) key\npub const HISTORY: Map\u003c(Addr, u64), Point\u003e = Map::new(\"history\");\n\n/// Scheduled slope changes per period (week)\npub const SLOPE_CHANGES: Map\u003cu64, Uint128\u003e = Map::new(\"slope_changes\");\n\n/// Last period when a scheduled slope change was applied\npub const LAST_SLOPE_CHANGE: Item\u003cu64\u003e = Item::new(\"last_slope_change\");\n\n/// Contains a proposal to change contract ownership\npub const OWNERSHIP_PROPOSAL: Item\u003cOwnershipProposal\u003e = Item::new(\"ownership_proposal\");\n\n/// Contains blacklisted staker addresses\npub const BLACKLIST: Item\u003cVec\u003cAddr\u003e\u003e = Item::new(\"blacklist\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","src","utils.rs"],"content":"use crate::error::ContractError;\nuse astroport_governance::utils::{get_periods_count, MAX_LOCK_TIME, WEEK};\n\nuse cosmwasm_std::{Addr, Decimal, Order, StdResult, Storage, Uint128};\nuse cw_storage_plus::Bound;\n\nuse crate::state::{Point, BLACKLIST, CONFIG, HISTORY, LAST_SLOPE_CHANGE, SLOPE_CHANGES};\n\n/// Checks that a timestamp is within limits.\npub(crate) fn time_limits_check(time: u64) -\u003e Result\u003c(), ContractError\u003e {\n    if !(WEEK..=MAX_LOCK_TIME).contains(\u0026time) {\n        Err(ContractError::LockTimeLimitsError {})\n    } else {\n        Ok(())\n    }\n}\n\n/// Checks that the sender is the xASTRO token.\npub(crate) fn xastro_token_check(storage: \u0026dyn Storage, sender: Addr) -\u003e Result\u003c(), ContractError\u003e {\n    let config = CONFIG.load(storage)?;\n    if sender != config.deposit_token_addr {\n        Err(ContractError::Unauthorized {})\n    } else {\n        Ok(())\n    }\n}\n\n/// Checks if the blacklist contains a specific address.\npub(crate) fn blacklist_check(storage: \u0026dyn Storage, addr: \u0026Addr) -\u003e Result\u003c(), ContractError\u003e {\n    let blacklist = BLACKLIST.load(storage)?;\n    if blacklist.contains(addr) {\n        Err(ContractError::AddressBlacklisted(addr.to_string()))\n    } else {\n        Ok(())\n    }\n}\n\n/// Adjusting voting power according to the slope. The maximum loss is 103/104 * 104 which is\n/// 0.000103 vxASTRO.\npub(crate) fn adjust_vp_and_slope(vp: \u0026mut Uint128, dt: u64) -\u003e StdResult\u003cUint128\u003e {\n    let slope = vp.checked_div(Uint128::from(dt))?;\n    *vp = slope * Uint128::from(dt);\n    Ok(slope)\n}\n\n/// Main function used to calculate a user's voting power at a specific period as: previous_power - slope*(x - previous_x).\npub(crate) fn calc_voting_power(point: \u0026Point, period: u64) -\u003e Uint128 {\n    let shift = point\n        .slope\n        .checked_mul(Uint128::from(period - point.start))\n        .unwrap_or_else(|_| Uint128::zero());\n    point\n        .power\n        .checked_sub(shift)\n        .unwrap_or_else(|_| Uint128::zero())\n}\n\n/// Coefficient calculation where 0 [`WEEK`] is equal to 1 and [`MAX_LOCK_TIME`] is 2.5.\npub(crate) fn calc_coefficient(interval: u64) -\u003e Decimal {\n    // coefficient = 1 + 1.5 * (end - start) / MAX_LOCK_TIME\n    Decimal::one() + Decimal::from_ratio(15_u64 * interval, get_periods_count(MAX_LOCK_TIME) * 10)\n}\n\n/// Fetches the last checkpoint in [`HISTORY`] for the given address.\npub(crate) fn fetch_last_checkpoint(\n    storage: \u0026dyn Storage,\n    addr: \u0026Addr,\n    period_key: u64,\n) -\u003e StdResult\u003cOption\u003c(u64, Point)\u003e\u003e {\n    HISTORY\n        .prefix(addr.clone())\n        .range(\n            storage,\n            None,\n            Some(Bound::inclusive(period_key)),\n            Order::Descending,\n        )\n        .next()\n        .transpose()\n}\n\n/// Cancels scheduled slope change of total voting power only if the given period is in future.\n/// Removes scheduled slope change if it became zero.\npub(crate) fn cancel_scheduled_slope(\n    storage: \u0026mut dyn Storage,\n    slope: Uint128,\n    period: u64,\n) -\u003e StdResult\u003c()\u003e {\n    let end_period_key = period;\n    let last_slope_change = LAST_SLOPE_CHANGE.may_load(storage)?.unwrap_or(0);\n    match SLOPE_CHANGES.may_load(storage, end_period_key)? {\n        // We do not need to schedule a slope change in the past\n        Some(old_scheduled_change) if period \u003e last_slope_change =\u003e {\n            let new_slope = old_scheduled_change - slope;\n            if !new_slope.is_zero() {\n                SLOPE_CHANGES.save(storage, end_period_key, \u0026(old_scheduled_change - slope))\n            } else {\n                SLOPE_CHANGES.remove(storage, end_period_key);\n                Ok(())\n            }\n        }\n        _ =\u003e Ok(()),\n    }\n}\n\n/// Schedules slope change of total voting power in the given period.\npub(crate) fn schedule_slope_change(\n    storage: \u0026mut dyn Storage,\n    slope: Uint128,\n    period: u64,\n) -\u003e StdResult\u003c()\u003e {\n    if !slope.is_zero() {\n        SLOPE_CHANGES\n            .update(storage, period, |slope_opt| -\u003e StdResult\u003cUint128\u003e {\n                if let Some(pslope) = slope_opt {\n                    Ok(pslope + slope)\n                } else {\n                    Ok(slope)\n                }\n            })\n            .map(|_| ())\n    } else {\n        Ok(())\n    }\n}\n\n/// Fetches all slope changes between `last_slope_change` and `period`.\npub(crate) fn fetch_slope_changes(\n    storage: \u0026dyn Storage,\n    last_slope_change: u64,\n    period: u64,\n) -\u003e StdResult\u003cVec\u003c(u64, Uint128)\u003e\u003e {\n    SLOPE_CHANGES\n        .range(\n            storage,\n            Some(Bound::exclusive(last_slope_change)),\n            Some(Bound::inclusive(period)),\n            Order::Ascending,\n        )\n        .collect()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","tests","integration.rs"],"content":"use astroport::token as astro;\nuse cosmwasm_std::{attr, to_binary, Addr, Fraction, StdError, Uint128};\nuse cw20::{Cw20ExecuteMsg, Logo, LogoInfo, MarketingInfoResponse, MinterResponse};\nuse cw_multi_test::{next_block, ContractWrapper, Executor};\nuse voting_escrow::astroport;\n\nuse astroport_governance::utils::{get_period, MAX_LOCK_TIME, WEEK};\nuse astroport_governance::voting_escrow::{\n    ConfigResponse, Cw20HookMsg, ExecuteMsg, LockInfoResponse, QueryMsg,\n};\n\nuse crate::test_utils::{mock_app, Helper, MULTIPLIER};\n\nmod test_utils;\n\n#[test]\nfn lock_unlock_logic() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    helper.mint_xastro(router_ref, \"owner\", 100);\n\n    // Mint ASTRO, stake it and mint xASTRO\n    helper.mint_xastro(router_ref, \"user\", 100);\n    helper.check_xastro_balance(router_ref, \"user\", 100);\n\n    // Create invalid vx position\n    let err = helper\n        .create_lock(router_ref, \"user\", WEEK - 1, 1f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Lock time must be within limits (week \u003c= lock time \u003c 2 years)\"\n    );\n    let err = helper\n        .create_lock(router_ref, \"user\", MAX_LOCK_TIME + 1, 1f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Lock time must be within limits (week \u003c= lock time \u003c 2 years)\"\n    );\n    let err = helper\n        .create_lock(router_ref, \"user\", WEEK, 101f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        format!(\n            \"Cannot Sub with {} and {}\",\n            100 * MULTIPLIER,\n            101 * MULTIPLIER\n        )\n    );\n\n    // Try to increase the lock time for a position that doesn't exist\n    let err = helper\n        .extend_lock_time(router_ref, \"user\", MAX_LOCK_TIME)\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Lock does not exist\");\n\n    // Try to withdraw from a non-existent lock\n    let err = helper.withdraw(router_ref, \"user\").unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Lock does not exist\");\n\n    // Try to deposit more xASTRO in a position that does not already exist\n    let err = helper\n        .extend_lock_amount(router_ref, \"user\", 1f32)\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Lock does not exist\");\n\n    // Current total voting power is 0\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 0.0);\n\n    // Create valid voting escrow lock\n    helper\n        .create_lock(router_ref, \"user\", WEEK * 2, 90f32)\n        .unwrap();\n    // Check that 90 xASTRO were actually debited\n    helper.check_xastro_balance(router_ref, \"user\", 10);\n    helper.check_xastro_balance(router_ref, helper.voting_instance.as_str(), 90);\n\n    // A user can have a single vxASTRO position\n    let err = helper\n        .create_lock(router_ref, \"user\", MAX_LOCK_TIME, 1f32)\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Lock already exists\");\n\n    // Try to increase the lock time by less than a week\n    let err = helper\n        .extend_lock_time(router_ref, \"user\", 86400)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Lock time must be within limits (week \u003c= lock time \u003c 2 years)\"\n    );\n\n    // Try to exceed MAX_LOCK_TIME\n    // We locked for 2 weeks so increasing by MAX_LOCK_TIME - week is impossible\n    let err = helper\n        .extend_lock_time(router_ref, \"user\", MAX_LOCK_TIME - WEEK)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Lock time must be within limits (week \u003c= lock time \u003c 2 years)\"\n    );\n\n    // Add more xASTRO to the existing position\n    helper.extend_lock_amount(router_ref, \"user\", 9f32).unwrap();\n    helper.check_xastro_balance(router_ref, \"user\", 1);\n    helper.check_xastro_balance(router_ref, helper.voting_instance.as_str(), 99);\n\n    // Try to withdraw from a non-expired lock\n    let err = helper.withdraw(router_ref, \"user\").unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The lock time has not yet expired\"\n    );\n\n    // Go in the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK));\n\n    // The lock has not yet expired since we locked for 2 weeks\n    let err = helper.withdraw(router_ref, \"user\").unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The lock time has not yet expired\"\n    );\n\n    // Go to the future again\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK));\n\n    // Try to add more xASTRO to an expired position\n    let err = helper\n        .extend_lock_amount(router_ref, \"user\", 1f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The lock expired. Withdraw and create new lock\"\n    );\n    // Try to increase the lock time for an expired position\n    let err = helper\n        .extend_lock_time(router_ref, \"user\", WEEK)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The lock expired. Withdraw and create new lock\"\n    );\n\n    // Imagine the user will withdraw their expired lock in 5 weeks\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(5 * WEEK));\n\n    // Time has passed so we can withdraw\n    helper.withdraw(router_ref, \"user\").unwrap();\n    helper.check_xastro_balance(router_ref, \"user\", 100);\n    helper.check_xastro_balance(router_ref, helper.voting_instance.as_str(), 0);\n\n    // Check that the lock has disappeared\n    let err = helper\n        .extend_lock_amount(router_ref, \"user\", 1f32)\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Lock does not exist\");\n}\n\n#[test]\nfn random_token_lock() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    let random_token_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_token::contract::execute,\n        astroport_token::contract::instantiate,\n        astroport_token::contract::query,\n    ));\n    let random_token_code_id = router.store_code(random_token_contract);\n\n    let msg = astro::InstantiateMsg {\n        name: String::from(\"Random token\"),\n        symbol: String::from(\"FOO\"),\n        decimals: 6,\n        initial_balances: vec![],\n        mint: Some(MinterResponse {\n            minter: helper.owner.to_string(),\n            cap: None,\n        }),\n        marketing: None,\n    };\n\n    let random_token = router\n        .instantiate_contract(\n            random_token_code_id,\n            helper.owner.clone(),\n            \u0026msg,\n            \u0026[],\n            String::from(\"FOO\"),\n            None,\n        )\n        .unwrap();\n\n    let msg = cw20::Cw20ExecuteMsg::Mint {\n        recipient: String::from(\"user\"),\n        amount: Uint128::from(100_u128),\n    };\n\n    router\n        .execute_contract(helper.owner.clone(), random_token.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    let cw20msg = Cw20ExecuteMsg::Send {\n        contract: helper.voting_instance.to_string(),\n        amount: Uint128::from(10_u128),\n        msg: to_binary(\u0026Cw20HookMsg::CreateLock { time: WEEK }).unwrap(),\n    };\n    let err = router\n        .execute_contract(Addr::unchecked(\"user\"), random_token, \u0026cw20msg, \u0026[])\n        .unwrap_err();\n\n    assert_eq!(err.root_cause().to_string(), \"Unauthorized\");\n}\n\n#[test]\nfn new_lock_after_lock_expired() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let helper = Helper::init(router_ref, Addr::unchecked(\"owner\"));\n\n    helper.mint_xastro(router_ref, \"owner\", 100);\n\n    // Mint ASTRO, stake it and mint xASTRO\n    helper.mint_xastro(router_ref, \"user\", 100);\n\n    helper\n        .create_lock(router_ref, \"user\", WEEK * 5, 50f32)\n        .unwrap();\n\n    let vp = helper.query_user_vp(router_ref, \"user\").unwrap();\n    assert_eq!(vp, 53.605762);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 53.605762);\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK * 5));\n\n    helper.withdraw(router_ref, \"user\").unwrap();\n    helper.check_xastro_balance(router_ref, \"user\", 100);\n\n    let vp = helper.query_user_vp(router_ref, \"user\").unwrap();\n    assert_eq!(vp, 0.0);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 0.0);\n\n    // Create a new lock in 3 weeks from now\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK * 3));\n\n    helper\n        .create_lock(router_ref, \"user\", WEEK * 5, 100f32)\n        .unwrap();\n\n    let vp = helper.query_user_vp(router_ref, \"user\").unwrap();\n    assert_eq!(vp, 107.21153);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 107.21153);\n}\n\n/// Plot for this test case generated at tests/plots/constant_decay.png\n#[test]\nfn voting_constant_decay() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let helper = Helper::init(router_ref, Addr::unchecked(\"owner\"));\n\n    // Mint ASTRO, stake it and mint xASTRO\n    helper.mint_xastro(router_ref, \"user\", 100);\n    helper.mint_xastro(router_ref, \"user2\", 50);\n\n    helper\n        .create_lock(router_ref, \"user\", WEEK * 10, 30f32)\n        .unwrap();\n\n    let vp = helper.query_user_vp(router_ref, \"user\").unwrap();\n    assert_eq!(vp, 34.32692);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 34.32692);\n\n    // Since user2 did not lock their xASTRO, the contract does not have any information\n    let vp = helper.query_user_vp(router_ref, \"user2\").unwrap();\n    assert_eq!(vp, 0.0);\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK * 5));\n\n    // We can check voting power in the past\n    let res = helper\n        .query_user_vp_at(\n            router_ref,\n            \"user\",\n            router_ref.block_info().time.seconds() - WEEK,\n        )\n        .unwrap();\n    assert_eq!(res, 20.596151);\n    let res = helper\n        .query_user_vp_at(\n            router_ref,\n            \"user\",\n            router_ref.block_info().time.seconds() - 3 * WEEK,\n        )\n        .unwrap();\n    assert_eq!(res, 27.461536);\n    let res = helper\n        .query_total_vp_at(\n            router_ref,\n            router_ref.block_info().time.seconds() - 5 * WEEK,\n        )\n        .unwrap();\n    assert_eq!(res, 34.32692);\n\n    // And we can even check voting power in the future\n    let res = helper\n        .query_user_vp_at(\n            router_ref,\n            \"user\",\n            router_ref.block_info().time.seconds() + WEEK,\n        )\n        .unwrap();\n    assert_eq!(res, 13.730768);\n    let res = helper\n        .query_user_vp_at(\n            router_ref,\n            \"user\",\n            router_ref.block_info().time.seconds() + 5 * WEEK,\n        )\n        .unwrap();\n    assert_eq!(res, 0.0);\n\n    // Create lock for user2\n    helper\n        .create_lock(router_ref, \"user2\", WEEK * 6, 50f32)\n        .unwrap();\n\n    let vp = helper.query_user_vp(router_ref, \"user\").unwrap();\n    assert_eq!(vp, 17.16346);\n    let vp = helper.query_user_vp(router_ref, \"user2\").unwrap();\n    assert_eq!(vp, 54.32692);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 71.49039);\n    let res = helper\n        .query_total_vp_at(\n            router_ref,\n            router_ref.block_info().time.seconds() + 4 * WEEK,\n        )\n        .unwrap();\n    assert_eq!(res, 21.541666);\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK * 5));\n    let vp = helper.query_user_vp(router_ref, \"user\").unwrap();\n    assert_eq!(vp, 0.0);\n    let vp = helper.query_user_vp(router_ref, \"user2\").unwrap();\n    assert_eq!(vp, 9.054487);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 9.054487);\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK));\n    let vp = helper.query_user_vp(router_ref, \"user2\").unwrap();\n    assert_eq!(vp, 0.0);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 0.0);\n}\n\n/// Plot for this test case is generated at tests/plots/variable_decay.png\n#[test]\nfn voting_variable_decay() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let helper = Helper::init(router_ref, Addr::unchecked(\"owner\"));\n\n    // Mint ASTRO, stake it and mint xASTRO\n    helper.mint_xastro(router_ref, \"owner\", 100);\n    helper.mint_xastro(router_ref, \"user\", 100);\n    helper.mint_xastro(router_ref, \"user2\", 100);\n\n    helper\n        .create_lock(router_ref, \"user\", WEEK * 10, 30f32)\n        .unwrap();\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK * 5));\n\n    // Create lock for user2\n    helper\n        .create_lock(router_ref, \"user2\", WEEK * 6, 50f32)\n        .unwrap();\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 71.49039);\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK * 4));\n\n    helper\n        .extend_lock_amount(router_ref, \"user\", 70f32)\n        .unwrap();\n    helper\n        .extend_lock_time(router_ref, \"user2\", WEEK * 8)\n        .unwrap();\n    let vp = helper.query_user_vp(router_ref, \"user\").unwrap();\n    assert_eq!(vp, 74.44231);\n    let vp = helper.query_user_vp(router_ref, \"user2\").unwrap();\n    assert_eq!(vp, 57.21153);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 131.65384);\n\n    let res = helper\n        .query_user_vp_at(\n            router_ref,\n            \"user2\",\n            router_ref.block_info().time.seconds() + 4 * WEEK,\n        )\n        .unwrap();\n    assert_eq!(res, 34.32692);\n    let res = helper\n        .query_total_vp_at(router_ref, router_ref.block_info().time.seconds() + WEEK)\n        .unwrap();\n    assert_eq!(res, 51.490376);\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(WEEK));\n    let vp = helper.query_user_vp(router_ref, \"user\").unwrap();\n    assert_eq!(vp, 0.0);\n    let vp = helper.query_user_vp(router_ref, \"user2\").unwrap();\n    assert_eq!(vp, 51.490376);\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 51.490376);\n}\n\n#[test]\nfn check_queries() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    helper.mint_xastro(router_ref, \"owner\", 100);\n\n    // Mint ASTRO, stake it and mint xASTRO\n    helper.mint_xastro(router_ref, \"user\", 100);\n    helper.check_xastro_balance(router_ref, \"user\", 100);\n\n    // Create valid voting escrow lock\n    helper\n        .create_lock(router_ref, \"user\", WEEK * 2, 90f32)\n        .unwrap();\n    // Check that 90 xASTRO were actually debited\n    helper.check_xastro_balance(router_ref, \"user\", 10);\n    helper.check_xastro_balance(router_ref, helper.voting_instance.as_str(), 90);\n\n    // Validate user's lock\n    let cur_period = get_period(router_ref.block_info().time.seconds()).unwrap();\n    let user_lock: LockInfoResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\n            helper.voting_instance.clone(),\n            \u0026QueryMsg::LockInfo {\n                user: \"user\".to_string(),\n            },\n        )\n        .unwrap();\n    assert_eq!(user_lock.amount.u128(), 90_u128 * MULTIPLIER as u128);\n    assert_eq!(user_lock.start, cur_period);\n    assert_eq!(user_lock.end, cur_period + 2);\n    let coeff = user_lock.coefficient.numerator().u128() as f32\n        / user_lock.coefficient.denominator().u128() as f32;\n    if (coeff - 1.02884f32).abs() \u003e 1e-5 {\n        assert_eq!(coeff, 1.02884f32)\n    }\n\n    let total_vp_at_period = helper\n        .query_total_vp_at_period(router_ref, cur_period)\n        .unwrap();\n    let total_vp_at_ts = helper\n        .query_total_vp_at(router_ref, router_ref.block_info().time.seconds())\n        .unwrap();\n    assert_eq!(total_vp_at_period, total_vp_at_ts);\n\n    let user_vp_at_period = helper\n        .query_user_vp_at_period(router_ref, \"user\", cur_period)\n        .unwrap();\n    let user_vp = helper\n        .query_user_vp_at(router_ref, \"user\", router_ref.block_info().time.seconds())\n        .unwrap();\n    assert_eq!(user_vp_at_period, user_vp);\n\n    // Check users' locked xASTRO balance history\n    helper.mint_xastro(router_ref, \"user\", 90);\n    // SnapshotMap checkpoints the data at the next block\n    let start_height = router_ref.block_info().height + 1;\n    let balance = helper\n        .query_locked_balance_at(router_ref, \"user\", start_height)\n        .unwrap();\n    assert_eq!(balance, 90f32);\n    // Make the lockup to live longer\n    helper\n        .extend_lock_time(router_ref, \"user\", WEEK * 100)\n        .unwrap();\n\n    router_ref.update_block(next_block);\n    helper\n        .extend_lock_amount(router_ref, \"user\", 100f32)\n        .unwrap();\n    let balance = helper\n        .query_locked_balance_at(router_ref, \"user\", start_height)\n        .unwrap();\n    assert_eq!(balance, 90f32);\n\n    router_ref.update_block(|bi| bi.height += 100000);\n    let balance = helper\n        .query_locked_balance_at(router_ref, \"user\", start_height)\n        .unwrap();\n    assert_eq!(balance, 90f32);\n    let balance = helper\n        .query_locked_balance_at(router_ref, \"user\", start_height + 2)\n        .unwrap();\n    assert_eq!(balance, 190f32);\n    // The user still has 190 xASTRO locked\n    let balance = helper\n        .query_locked_balance_at(router_ref, \"user\", router_ref.block_info().height)\n        .unwrap();\n    assert_eq!(balance, 190f32);\n\n    router_ref.update_block(|bi| {\n        bi.height += 1;\n        bi.time = bi.time.plus_seconds(WEEK * 102);\n    });\n    helper.withdraw(router_ref, \"user\").unwrap();\n    // Now the users' balance is zero\n    let cur_height = router_ref.block_info().height + 1;\n    let balance = helper\n        .query_locked_balance_at(router_ref, \"user\", cur_height)\n        .unwrap();\n    // But one block before it had 190 xASTRO locked\n    assert_eq!(balance, 0f32);\n    let balance = helper\n        .query_locked_balance_at(router_ref, \"user\", cur_height - 1)\n        .unwrap();\n    assert_eq!(balance, 190f32);\n\n    // add users to the blacklist\n    helper\n        .update_blacklist(\n            router_ref,\n            Some(vec![\n                \"voter1\".to_string(),\n                \"voter2\".to_string(),\n                \"voter3\".to_string(),\n                \"voter4\".to_string(),\n                \"voter5\".to_string(),\n                \"voter6\".to_string(),\n                \"voter7\".to_string(),\n                \"voter8\".to_string(),\n            ]),\n            None,\n        )\n        .unwrap();\n\n    // query all blacklisted voters\n    let blacklisted_voters = helper\n        .query_blacklisted_voters(router_ref, None, None)\n        .unwrap();\n    assert_eq!(\n        blacklisted_voters,\n        vec![\n            Addr::unchecked(\"voter1\"),\n            Addr::unchecked(\"voter2\"),\n            Addr::unchecked(\"voter3\"),\n            Addr::unchecked(\"voter4\"),\n            Addr::unchecked(\"voter5\"),\n            Addr::unchecked(\"voter6\"),\n            Addr::unchecked(\"voter7\"),\n            Addr::unchecked(\"voter8\"),\n        ]\n    );\n\n    // query not blacklisted voter\n    let err = helper\n        .query_blacklisted_voters(router_ref, Some(\"voter9\".to_string()), Some(10u32))\n        .unwrap_err();\n    assert_eq!(\n        StdError::generic_err(\n            \"Querier contract error: Generic error: The voter9 address is not blacklisted\"\n        ),\n        err\n    );\n\n    // query voters by specified parameters\n    let blacklisted_voters = helper\n        .query_blacklisted_voters(router_ref, Some(\"voter2\".to_string()), Some(2u32))\n        .unwrap();\n    assert_eq!(\n        blacklisted_voters,\n        vec![Addr::unchecked(\"voter3\"), Addr::unchecked(\"voter4\")]\n    );\n\n    // add users to the blacklist\n    helper\n        .update_blacklist(\n            router_ref,\n            Some(vec![\"voter0\".to_string(), \"voter33\".to_string()]),\n            None,\n        )\n        .unwrap();\n\n    // query voters by specified parameters\n    let blacklisted_voters = helper\n        .query_blacklisted_voters(router_ref, Some(\"voter2\".to_string()), Some(2u32))\n        .unwrap();\n    assert_eq!(\n        blacklisted_voters,\n        vec![Addr::unchecked(\"voter3\"), Addr::unchecked(\"voter33\")]\n    );\n\n    let blacklisted_voters = helper\n        .query_blacklisted_voters(router_ref, Some(\"voter4\".to_string()), Some(10u32))\n        .unwrap();\n    assert_eq!(\n        blacklisted_voters,\n        vec![\n            Addr::unchecked(\"voter5\"),\n            Addr::unchecked(\"voter6\"),\n            Addr::unchecked(\"voter7\"),\n            Addr::unchecked(\"voter8\"),\n        ]\n    );\n\n    let empty_blacklist: Vec\u003cAddr\u003e = vec![];\n    let blacklisted_voters = helper\n        .query_blacklisted_voters(router_ref, Some(\"voter8\".to_string()), Some(10u32))\n        .unwrap();\n    assert_eq!(blacklisted_voters, empty_blacklist);\n\n    // check if voters are blacklisted\n    let res = helper\n        .check_voters_are_blacklisted(router_ref, vec![\"voter1\".to_string(), \"voter9\".to_string()])\n        .unwrap();\n    assert_eq!(\"Voter is not blacklisted: voter9\", res.to_string());\n\n    let res = helper\n        .check_voters_are_blacklisted(router_ref, vec![\"voter1\".to_string(), \"voter8\".to_string()])\n        .unwrap();\n    assert_eq!(\"Voters are blacklisted!\", res.to_string());\n}\n\n#[test]\nfn check_deposit_for() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    helper.mint_xastro(router_ref, \"owner\", 100);\n\n    // Mint ASTRO, stake it and mint xASTRO\n    helper.mint_xastro(router_ref, \"user1\", 100);\n    helper.check_xastro_balance(router_ref, \"user1\", 100);\n    helper.mint_xastro(router_ref, \"user2\", 100);\n    helper.check_xastro_balance(router_ref, \"user2\", 100);\n\n    // 104 weeks ~ 2 years\n    helper\n        .create_lock(router_ref, \"user1\", 104 * WEEK, 50f32)\n        .unwrap();\n    let vp = helper.query_user_vp(router_ref, \"user1\").unwrap();\n    assert_eq!(124.99999, vp);\n    helper\n        .deposit_for(router_ref, \"user2\", \"user1\", 50f32)\n        .unwrap();\n    let vp = helper.query_user_vp(router_ref, \"user1\").unwrap();\n    assert_eq!(249.99998, vp);\n    helper.check_xastro_balance(router_ref, \"user1\", 50);\n    helper.check_xastro_balance(router_ref, \"user2\", 50);\n}\n\n#[test]\nfn check_update_owner() {\n    let mut app = mock_app();\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(\u0026mut app, owner);\n\n    let new_owner = String::from(\"new_owner\");\n\n    // New owner\n    let msg = ExecuteMsg::ProposeNewOwner {\n        new_owner: new_owner.clone(),\n        expires_in: 100, // seconds\n    };\n\n    // Unauthed check\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"not_owner\"),\n            helper.voting_instance.clone(),\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Generic error: Unauthorized\");\n\n    // Claim before proposal\n    let err = app\n        .execute_contract(\n            Addr::unchecked(new_owner.clone()),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::ClaimOwnership {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Ownership proposal not found\"\n    );\n\n    // Propose new owner\n    app.execute_contract(\n        Addr::unchecked(\"owner\"),\n        helper.voting_instance.clone(),\n        \u0026msg,\n        \u0026[],\n    )\n    .unwrap();\n\n    // Claim from invalid addr\n    let err = app\n        .execute_contract(\n            Addr::unchecked(\"invalid_addr\"),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::ClaimOwnership {},\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Generic error: Unauthorized\");\n\n    // Claim ownership\n    app.execute_contract(\n        Addr::unchecked(new_owner.clone()),\n        helper.voting_instance.clone(),\n        \u0026ExecuteMsg::ClaimOwnership {},\n        \u0026[],\n    )\n    .unwrap();\n\n    // Let's query the contract state\n    let msg = QueryMsg::Config {};\n    let res: ConfigResponse = app\n        .wrap()\n        .query_wasm_smart(\u0026helper.voting_instance, \u0026msg)\n        .unwrap();\n\n    assert_eq!(res.owner, new_owner)\n}\n\n#[test]\nfn check_blacklist() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    // Mint ASTRO, stake it and mint xASTRO\n    helper.mint_xastro(router_ref, \"user1\", 100);\n    helper.mint_xastro(router_ref, \"user2\", 100);\n    helper.mint_xastro(router_ref, \"user3\", 100);\n\n    // Try to execute with empty arrays\n    let err = helper.update_blacklist(router_ref, None, None).unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"Generic error: Append and remove arrays are empty\"\n    );\n\n    // Blacklisting user2\n    let res = helper\n        .update_blacklist(router_ref, Some(vec![\"user2\".to_string()]), None)\n        .unwrap();\n    assert_eq!(\n        res.events[1].attributes[1],\n        attr(\"action\", \"update_blacklist\")\n    );\n    assert_eq!(\n        res.events[1].attributes[2],\n        attr(\"added_addresses\", \"user2\")\n    );\n\n    helper\n        .create_lock(router_ref, \"user1\", WEEK * 10, 50f32)\n        .unwrap();\n    // Try to create lock from a blacklisted address\n    let err = helper\n        .create_lock(router_ref, \"user2\", WEEK * 10, 100f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The user2 address is blacklisted\"\n    );\n    let err = helper\n        .deposit_for(router_ref, \"user2\", \"user3\", 50f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The user2 address is blacklisted\"\n    );\n\n    // Since user2 is blacklisted, their xASTRO balance was left unchanged\n    helper.check_xastro_balance(router_ref, \"user2\", 100);\n    // And they did not create a lock, thus we have no information to query\n    let vp = helper.query_user_vp(router_ref, \"user2\").unwrap();\n    assert_eq!(vp, 0.0);\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(2 * WEEK));\n\n    // user2 is still blacklisted\n    let err = helper\n        .create_lock(router_ref, \"user2\", WEEK * 10, 100f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The user2 address is blacklisted\"\n    );\n\n    // Blacklisting user1 using the guardian\n    let msg = ExecuteMsg::UpdateBlacklist {\n        append_addrs: Some(vec![\"user1\".to_string()]),\n        remove_addrs: None,\n    };\n    let res = router_ref\n        .execute_contract(\n            Addr::unchecked(\"guardian\"),\n            helper.voting_instance.clone(),\n            \u0026msg,\n            \u0026[],\n        )\n        .unwrap();\n    assert_eq!(\n        res.events[1].attributes[1],\n        attr(\"action\", \"update_blacklist\")\n    );\n    assert_eq!(\n        res.events[1].attributes[2],\n        attr(\"added_addresses\", \"user1\")\n    );\n\n    // user1 is now blacklisted\n    let err = helper\n        .extend_lock_time(router_ref, \"user1\", WEEK * 10)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The user1 address is blacklisted\"\n    );\n    let err = helper\n        .extend_lock_amount(router_ref, \"user1\", 10f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The user1 address is blacklisted\"\n    );\n    let err = helper\n        .deposit_for(router_ref, \"user2\", \"user1\", 50f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The user2 address is blacklisted\"\n    );\n    let err = helper\n        .deposit_for(router_ref, \"user3\", \"user1\", 50f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The user1 address is blacklisted\"\n    );\n    // user1 doesn't have voting power now\n    let vp = helper.query_user_vp(router_ref, \"user1\").unwrap();\n    assert_eq!(vp, 0.0);\n    // But they have voting power in the past\n    let vp = helper\n        .query_user_vp_at(\n            router_ref,\n            \"user1\",\n            router_ref.block_info().time.seconds() - WEEK,\n        )\n        .unwrap();\n    assert_eq!(vp, 51.490376);\n    // Total voting power should be zero as well since there was only one vxASTRO position created by user1\n    let vp = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(vp, 0.0);\n\n    // Go to the future\n    router_ref.update_block(next_block);\n    router_ref.update_block(|block| block.time = block.time.plus_seconds(20 * WEEK));\n\n    // The only option available for a blacklisted user is to withdraw their funds if their lock expired\n    helper.withdraw(router_ref, \"user1\").unwrap();\n\n    // Remove user1 from the blacklist\n    let res = helper\n        .update_blacklist(router_ref, None, Some(vec![\"user1\".to_string()]))\n        .unwrap();\n    assert_eq!(\n        res.events[1].attributes[1],\n        attr(\"action\", \"update_blacklist\")\n    );\n    assert_eq!(\n        res.events[1].attributes[2],\n        attr(\"removed_addresses\", \"user1\")\n    );\n\n    // Now user1 can create a new lock\n    helper\n        .create_lock(router_ref, \"user1\", WEEK, 10f32)\n        .unwrap();\n}\n\n#[test]\nfn check_residual() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n    let lock_duration = 104;\n    let users_num = 1000;\n    let lock_amount = 100_000_000;\n\n    helper.mint_xastro(router_ref, \"owner\", 100);\n\n    for i in 1..(users_num / 2) {\n        let user = \u0026format!(\"user{}\", i);\n        helper.mint_xastro(router_ref, user, 100);\n        helper\n            .create_lock_u128(router_ref, user, WEEK * lock_duration, lock_amount)\n            .unwrap();\n    }\n\n    let mut sum = 0;\n    for i in 1..=users_num {\n        let user = \u0026format!(\"user{}\", i);\n        sum += helper.query_exact_user_vp(router_ref, user).unwrap();\n    }\n\n    assert_eq!(sum, helper.query_exact_total_vp(router_ref).unwrap());\n\n    router_ref.update_block(|bi| {\n        bi.height += 1;\n        bi.time = bi.time.plus_seconds(WEEK);\n    });\n\n    for i in (users_num / 2)..users_num {\n        let user = \u0026format!(\"user{}\", i);\n        helper.mint_xastro(router_ref, user, 1000000);\n        helper\n            .create_lock_u128(router_ref, user, WEEK * lock_duration, lock_amount)\n            .unwrap();\n    }\n\n    for _ in 1..104 {\n        sum = 0;\n        for i in 1..=users_num {\n            let user = \u0026format!(\"user{}\", i);\n            sum += helper.query_exact_user_vp(router_ref, user).unwrap();\n        }\n\n        let ve_vp = helper.query_exact_total_vp(router_ref).unwrap();\n        let diff = (sum as f64 - ve_vp as f64).abs();\n        assert_eq!(diff, 0.0, \"diff: {}, sum: {}, ve_vp: {}\", diff, sum, ve_vp);\n\n        router_ref.update_block(|bi| {\n            bi.height += 1;\n            bi.time = bi.time.plus_seconds(WEEK);\n        });\n    }\n}\n\n#[test]\nfn total_vp_multiple_slope_subtraction() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    helper.mint_xastro(router_ref, \"user1\", 1000);\n    helper\n        .create_lock(router_ref, \"user1\", 2 * WEEK, 100f32)\n        .unwrap();\n    let total = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(total, 102.88461);\n\n    router_ref.update_block(|bi| bi.time = bi.time.plus_seconds(2 * WEEK));\n    // Slope changes have been applied\n    let total = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(total, 0.0);\n\n    // Try to manipulate over expired lock 2 weeks later\n    router_ref.update_block(|bi| bi.time = bi.time.plus_seconds(2 * WEEK));\n    let err = helper\n        .extend_lock_amount(router_ref, \"user1\", 100f32)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The lock expired. Withdraw and create new lock\"\n    );\n    let err = helper\n        .create_lock(router_ref, \"user1\", 2 * WEEK, 100f32)\n        .unwrap_err();\n    assert_eq!(err.root_cause().to_string(), \"Lock already exists\");\n    let err = helper\n        .extend_lock_time(router_ref, \"user1\", 2 * WEEK)\n        .unwrap_err();\n    assert_eq!(\n        err.root_cause().to_string(),\n        \"The lock expired. Withdraw and create new lock\"\n    );\n    let total = helper.query_total_vp(router_ref).unwrap();\n    assert_eq!(total, 0f32);\n}\n\n#[test]\nfn marketing_info() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    let err = router_ref\n        .execute_contract(\n            helper.owner.clone(),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::SetLogoUrlsWhitelist {\n                whitelist: vec![\n                    \"@hello-test-url .com/\".to_string(),\n                    \"example.com/\".to_string(),\n                ],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"Generic error: Link contains invalid characters: @hello-test-url .com/\"\n    );\n\n    let err = router_ref\n        .execute_contract(\n            helper.owner.clone(),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::SetLogoUrlsWhitelist {\n                whitelist: vec![\"example.com\".to_string()],\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"Marketing info validation error: Whitelist link should end with '/': example.com\"\n    );\n\n    router_ref\n        .execute_contract(\n            helper.owner.clone(),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::SetLogoUrlsWhitelist {\n                whitelist: vec![\"example.com/\".to_string()],\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    let err = router_ref\n        .execute_contract(\n            helper.owner.clone(),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::UpdateMarketing {\n                project: Some(\"\u003cscript\u003ealert('test')\u003c/script\u003e\".to_string()),\n                description: None,\n                marketing: None,\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"Marketing info validation error: project contains invalid characters: \u003cscript\u003ealert('test')\u003c/script\u003e\"\n    );\n\n    let err = router_ref\n        .execute_contract(\n            helper.owner.clone(),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::UpdateMarketing {\n                project: None,\n                description: Some(\"\u003cscript\u003ealert('test')\u003c/script\u003e\".to_string()),\n                marketing: None,\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"Marketing info validation error: description contains invalid characters: \u003cscript\u003ealert('test')\u003c/script\u003e\"\n    );\n\n    router_ref\n        .execute_contract(\n            helper.owner.clone(),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::UpdateMarketing {\n                project: Some(\"Some project\".to_string()),\n                description: Some(\"Some description\".to_string()),\n                marketing: None,\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    let config: ConfigResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\u0026helper.voting_instance, \u0026QueryMsg::Config {})\n        .unwrap();\n    assert_eq!(config.logo_urls_whitelist, vec![\"example.com/\".to_string()]);\n    let marketing_info: MarketingInfoResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\u0026helper.voting_instance, \u0026QueryMsg::MarketingInfo {})\n        .unwrap();\n    assert_eq!(marketing_info.project, Some(\"Some project\".to_string()));\n    assert_eq!(\n        marketing_info.description,\n        Some(\"Some description\".to_string())\n    );\n\n    let err = router_ref\n        .execute_contract(\n            helper.owner.clone(),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::UploadLogo(Logo::Url(\"https://some-website.com/logo.svg\".to_string())),\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\n        \u0026err.root_cause().to_string(),\n        \"Marketing info validation error: Logo link is not whitelisted: https://some-website.com/logo.svg\",\n    );\n\n    router_ref\n        .execute_contract(\n            helper.owner.clone(),\n            helper.voting_instance.clone(),\n            \u0026ExecuteMsg::UploadLogo(Logo::Url(\"example.com/logo.svg\".to_string())),\n            \u0026[],\n        )\n        .unwrap();\n\n    let marketing_info: MarketingInfoResponse = router_ref\n        .wrap()\n        .query_wasm_smart(\u0026helper.voting_instance, \u0026QueryMsg::MarketingInfo {})\n        .unwrap();\n    assert_eq!(\n        marketing_info.logo.unwrap(),\n        LogoInfo::Url(\"example.com/logo.svg\".to_string())\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","tests","simulation.rs"],"content":"use crate::test_utils::{mock_app, Helper, MULTIPLIER};\nuse anyhow::Result;\nuse astroport_governance::utils::{\n    get_period, get_periods_count, EPOCH_START, MAX_LOCK_TIME, WEEK,\n};\nuse cosmwasm_std::Addr;\nuse cw_multi_test::{next_block, App, AppResponse};\nuse std::collections::hash_map::Entry;\nuse std::collections::HashMap;\n\nmod test_utils;\n\n#[derive(Clone, Default, Debug)]\nstruct Point {\n    amount: f64,\n    end: u64,\n}\n\n#[derive(Clone, Debug)]\nenum Event {\n    CreateLock(f64, u64),\n    IncreaseTime(u64),\n    ExtendLock(f64),\n    Withdraw,\n    Blacklist,\n    Recover,\n}\n\nuse Event::*;\n\nstruct Simulator {\n    // Point history (history[period][user] = point)\n    points: Vec\u003cHashMap\u003cString, Point\u003e\u003e,\n    // Current user's lock (amount, end)\n    locked: HashMap\u003cString, (f64, u64)\u003e,\n    users: Vec\u003cString\u003e,\n    helper: Helper,\n    router: App,\n}\n\nfn apply_coefficient(amount: f64, interval: u64) -\u003e f64 {\n    let coeff = 1f64 + (1.5 * interval as f64) / get_periods_count(MAX_LOCK_TIME) as f64;\n    // Imitate decimal fraction multiplication\n    (amount * coeff * MULTIPLIER as f64).trunc() / MULTIPLIER as f64\n}\n\nimpl Simulator {\n    fn new\u003cT: Clone + Into\u003cString\u003e\u003e(users: \u0026[T]) -\u003e Self {\n        let mut router = mock_app();\n        Self {\n            points: vec![HashMap::new(); 10000],\n            locked: Default::default(),\n            users: users.iter().cloned().map(|user| user.into()).collect(),\n            helper: Helper::init(\u0026mut router, Addr::unchecked(\"owner\")),\n            router,\n        }\n    }\n\n    fn mint(\u0026mut self, user: \u0026str, amount: u128) {\n        self.helper\n            .mint_xastro(\u0026mut self.router, user, amount as u64)\n    }\n\n    fn block_period(\u0026self) -\u003e u64 {\n        get_period(self.router.block_info().time.seconds()).unwrap()\n    }\n\n    fn app_next_period(\u0026mut self) {\n        self.router.update_block(next_block);\n        self.router\n            .update_block(|block| block.time = block.time.plus_seconds(WEEK));\n    }\n\n    fn create_lock(\u0026mut self, user: \u0026str, amount: f64, interval: u64) -\u003e Result\u003cAppResponse\u003e {\n        let block_period = self.block_period();\n        let periods_interval = get_periods_count(interval);\n        self.helper\n            .create_lock(\u0026mut self.router, user, interval, amount as f32)\n            .map(|response| {\n                self.add_point(\n                    block_period as usize,\n                    user,\n                    apply_coefficient(amount, periods_interval),\n                    block_period + periods_interval,\n                );\n                self.locked.extend(vec![(\n                    user.to_string(),\n                    (amount, block_period + periods_interval),\n                )]);\n                response\n            })\n    }\n\n    fn increase_time(\u0026mut self, user: \u0026str, interval: u64) -\u003e Result\u003cAppResponse\u003e {\n        self.helper\n            .extend_lock_time(\u0026mut self.router, user, interval)\n            .map(|response| {\n                let cur_period = self.block_period() as usize;\n                let periods_interval = get_periods_count(interval);\n                let end = if let Some(point) = self.get_user_point_at(cur_period, user) {\n                    point.end\n                } else {\n                    let prev_point = self\n                        .get_prev_point(user)\n                        .expect(\"We always need previous point!\");\n                    prev_point.end\n                };\n                let dt = end + periods_interval - cur_period as u64;\n                let lock = self.locked.get_mut(user).unwrap();\n                lock.1 += periods_interval;\n                let amount = lock.0.to_owned();\n                self.add_point(\n                    cur_period,\n                    user,\n                    apply_coefficient(amount, dt),\n                    end + periods_interval,\n                );\n                response\n            })\n    }\n\n    fn extend_lock(\u0026mut self, user: \u0026str, amount: f64) -\u003e Result\u003cAppResponse\u003e {\n        self.helper\n            .extend_lock_amount(\u0026mut self.router, user, amount as f32)\n            .map(|response| {\n                let cur_period = self.block_period() as usize;\n                let (user_balance, end) =\n                    if let Some(point) = self.get_user_point_at(cur_period, user) {\n                        (point.amount, point.end)\n                    } else {\n                        let prev_point = self\n                            .get_prev_point(user)\n                            .expect(\"We always need previous point!\");\n                        (self.calc_user_balance_at(cur_period, user), prev_point.end)\n                    };\n                let vp = apply_coefficient(amount, end - cur_period as u64);\n                self.add_point(cur_period, user, user_balance + vp, end);\n                let mut lock = self.locked.get_mut(user).unwrap();\n                lock.0 += amount;\n                response\n            })\n    }\n\n    fn withdraw(\u0026mut self, user: \u0026str) -\u003e Result\u003cAppResponse\u003e {\n        self.helper\n            .withdraw(\u0026mut self.router, user)\n            .map(|response| {\n                let cur_period = self.block_period();\n                self.add_point(cur_period as usize, user, 0.0, cur_period);\n                self.locked.remove(user);\n                response\n            })\n    }\n\n    fn append2blacklist(\u0026mut self, user: \u0026str) -\u003e Result\u003cAppResponse\u003e {\n        self.helper\n            .update_blacklist(\u0026mut self.router, Some(vec![user.to_string()]), None)\n            .map(|response| {\n                let cur_period = self.block_period();\n                self.add_point(cur_period as usize, user, 0.0, cur_period);\n                response\n            })\n    }\n\n    fn remove_from_blacklist(\u0026mut self, user: \u0026str) -\u003e Result\u003cAppResponse\u003e {\n        self.helper\n            .update_blacklist(\u0026mut self.router, None, Some(vec![user.to_string()]))\n            .map(|response| {\n                let cur_period = self.block_period() as usize;\n                if let Some((amount, end)) = self.locked.get(user).copied() {\n                    let dt = end.saturating_sub(cur_period as u64);\n                    let new_amount = if dt != 0 {\n                        apply_coefficient(amount, dt)\n                    } else {\n                        0.0\n                    };\n                    self.add_point(cur_period, user, new_amount, end);\n                }\n                response\n            })\n    }\n\n    fn event_router(\u0026mut self, user: \u0026str, event: Event) {\n        println!(\"User {} Event {:?}\", user, event);\n        match event {\n            Event::CreateLock(amount, interval) =\u003e {\n                if let Err(err) = self.create_lock(user, amount, interval) {\n                    dbg!(err);\n                }\n            }\n            Event::IncreaseTime(interval) =\u003e {\n                if let Err(err) = self.increase_time(user, interval) {\n                    dbg!(err);\n                }\n            }\n            Event::ExtendLock(amount) =\u003e {\n                if let Err(err) = self.extend_lock(user, amount) {\n                    dbg!(err);\n                }\n            }\n            Event::Withdraw =\u003e {\n                if let Err(err) = self.withdraw(user) {\n                    dbg!(err);\n                }\n            }\n            Event::Blacklist =\u003e {\n                if let Err(err) = self.append2blacklist(user) {\n                    dbg!(err);\n                }\n            }\n            Event::Recover =\u003e {\n                if let Err(err) = self.remove_from_blacklist(user) {\n                    dbg!(err);\n                }\n            }\n        }\n        let real_balance = self\n            .get_user_point_at(self.block_period() as usize, user)\n            .map(|point| point.amount)\n            .unwrap_or_else(|| self.calc_user_balance_at(self.block_period() as usize, user));\n        let contract_balance = self\n            .helper\n            .query_user_vp(\u0026mut self.router, user)\n            .unwrap_or(0.0) as f64;\n        if (real_balance - contract_balance).abs() \u003e= 10e-3 {\n            assert_eq!(real_balance, contract_balance)\n        };\n    }\n\n    fn checkpoint_all_users(\u0026mut self) {\n        let cur_period = self.block_period() as usize;\n        self.users.clone().iter().for_each(|user| {\n            // we need to calc point only if it was not calculated yet\n            if self.get_user_point_at(cur_period, user).is_none() {\n                self.checkpoint_user(user)\n            }\n        })\n    }\n\n    fn add_point\u003cT: Into\u003cString\u003e\u003e(\u0026mut self, period: usize, user: T, amount: f64, end: u64) {\n        let map = \u0026mut self.points[period];\n        map.extend(vec![(user.into(), Point { amount, end })]);\n    }\n\n    fn get_prev_point(\u0026mut self, user: \u0026str) -\u003e Option\u003cPoint\u003e {\n        let prev_period = (self.block_period() - 1) as usize;\n        self.get_user_point_at(prev_period, user)\n    }\n\n    fn checkpoint_user(\u0026mut self, user: \u0026str) {\n        let cur_period = self.block_period() as usize;\n        let user_balance = self.calc_user_balance_at(cur_period, user);\n        let prev_point = self\n            .get_prev_point(user)\n            .expect(\"We always need previous point!\");\n        self.add_point(cur_period, user, user_balance, prev_point.end);\n    }\n\n    fn get_user_point_at\u003cT: Into\u003cString\u003e\u003e(\u0026mut self, period: usize, user: T) -\u003e Option\u003cPoint\u003e {\n        let points_map = \u0026mut self.points[period];\n        match points_map.entry(user.into()) {\n            Entry::Occupied(value) =\u003e Some(value.get().clone()),\n            Entry::Vacant(_) =\u003e None,\n        }\n    }\n\n    fn calc_user_balance_at(\u0026mut self, period: usize, user: \u0026str) -\u003e f64 {\n        match self.get_user_point_at(period, user) {\n            Some(point) =\u003e point.amount,\n            None =\u003e {\n                let prev_point = self\n                    .get_user_point_at(period - 1, user)\n                    .expect(\"We always need previous point!\");\n                let dt = prev_point.end.saturating_sub(period as u64 - 1);\n                if dt == 0 {\n                    0.0\n                } else {\n                    prev_point.amount - prev_point.amount / dt as f64\n                }\n            }\n        }\n    }\n\n    fn calc_total_balance_at(\u0026mut self, period: usize) -\u003e f64 {\n        self.users.clone().iter().fold(0.0, |acc, user| {\n            acc + self.get_user_point_at(period, user).unwrap().amount\n        })\n    }\n}\n\nuse proptest::prelude::*;\n\nconst MAX_PERIOD: usize = 10;\nconst MAX_USERS: usize = 6;\nconst MAX_EVENTS: usize = 100;\n\nfn amount_strategy() -\u003e impl Strategy\u003cValue = f64\u003e {\n    (1f64..=100f64).prop_map(|val| (val * MULTIPLIER as f64).trunc() / MULTIPLIER as f64)\n}\n\nfn events_strategy() -\u003e impl Strategy\u003cValue = Event\u003e {\n    prop_oneof![\n        Just(Event::Withdraw),\n        Just(Event::Blacklist),\n        Just(Event::Recover),\n        amount_strategy().prop_map(Event::ExtendLock),\n        (0..MAX_LOCK_TIME).prop_map(Event::IncreaseTime),\n        (amount_strategy(), 0..MAX_LOCK_TIME).prop_map(|(a, b)| Event::CreateLock(a, b)),\n    ]\n}\n\nfn generate_cases() -\u003e impl Strategy\u003cValue = (Vec\u003cString\u003e, Vec\u003c(usize, String, Event)\u003e)\u003e {\n    let users_strategy = prop::collection::vec(\"[a-z]{4,32}\", 1..MAX_USERS);\n    users_strategy.prop_flat_map(|users| {\n        (\n            Just(users.clone()),\n            prop::collection::vec(\n                (\n                    1..=MAX_PERIOD,\n                    prop::sample::select(users),\n                    events_strategy(),\n                ),\n                0..MAX_EVENTS,\n            ),\n        )\n    })\n}\n\nproptest! {\n    #[test]\n    fn run_simulations\n    (\n        case in generate_cases()\n    ) {\n        let mut events: Vec\u003cVec\u003c(String, Event)\u003e\u003e = vec![vec![]; MAX_PERIOD + 1];\n        let (users, events_tuples) = case;\n        for (period, user, event) in events_tuples {\n            events[period].push((user, event));\n        };\n\n        let mut simulator = Simulator::new(\u0026users);\n        for user in users {\n            simulator.mint(\u0026user, 10000);\n            simulator.add_point(0, user, 0.0, 104);\n        }\n        simulator.app_next_period();\n\n        for period in 1..=MAX_PERIOD {\n            if let Some(period_events) = events.get(period) {\n                for (user, event) in period_events {\n                    simulator.event_router(user, event.clone())\n                }\n            }\n            simulator.checkpoint_all_users();\n            let real_balance = simulator.calc_total_balance_at(period);\n            let contract_balance = simulator\n                .helper\n                .query_total_vp(\u0026mut simulator.router)\n                .unwrap_or(0.0) as f64;\n            if (real_balance - contract_balance).abs() \u003e= 10e-3 {\n                assert_eq!(real_balance, contract_balance)\n            };\n            // Evaluate historical periods\n            for check_period in 1..period {\n                let real_balance = simulator.calc_total_balance_at(check_period);\n                let contract_balance = simulator\n                    .helper\n                    .query_total_vp_at(\u0026mut simulator.router, EPOCH_START + check_period as u64 * WEEK)\n                    .unwrap_or(0.0) as f64;\n                if (real_balance - contract_balance).abs() \u003e= 10e-3 {\n                    assert_eq!(real_balance, contract_balance)\n                };\n            }\n            simulator.app_next_period()\n        }\n    }\n}\n\n#[test]\nfn exact_simulation() {\n    let case = (\n        [\"bpcy\"],\n        [\n            (1, \"bpcy\", CreateLock(100.0, 3024000)),\n            (2, \"bpcy\", IncreaseTime(3024000)),\n            (3, \"bpcy\", Blacklist),\n            (3, \"bpcy\", Recover),\n        ],\n    );\n\n    let mut events: Vec\u003cVec\u003c(String, Event)\u003e\u003e = vec![vec![]; MAX_PERIOD + 1];\n    let (users, events_tuples) = case;\n    for (period, user, event) in events_tuples {\n        events[period].push((user.to_string(), event));\n    }\n\n    let mut simulator = Simulator::new(\u0026users);\n    for user in users {\n        simulator.mint(user, 10000);\n        simulator.add_point(0, user, 0.0, 104);\n    }\n    simulator.app_next_period();\n\n    for period in 1..=MAX_PERIOD {\n        if let Some(period_events) = events.get(period) {\n            if !period_events.is_empty() {\n                println!(\"Period {}:\", period);\n            }\n            for (user, event) in period_events {\n                simulator.event_router(user, event.clone())\n            }\n        }\n        simulator.checkpoint_all_users();\n        let real_balance = simulator.calc_total_balance_at(period);\n        let contract_balance = simulator\n            .helper\n            .query_total_vp(\u0026mut simulator.router)\n            .unwrap_or(0.0) as f64;\n        if (real_balance - contract_balance).abs() \u003e= 10e-3 {\n            println!(\"Assert failed at period {}\", period);\n            assert_eq!(real_balance, contract_balance)\n        };\n        // Evaluate historical periods\n        for check_period in 1..period {\n            let real_balance = simulator.calc_total_balance_at(check_period);\n            let contract_balance = simulator\n                .helper\n                .query_total_vp_at(\n                    \u0026mut simulator.router,\n                    EPOCH_START + check_period as u64 * WEEK,\n                )\n                .unwrap_or(0.0) as f64;\n            if (real_balance - contract_balance).abs() \u003e= 10e-3 {\n                assert_eq!(real_balance, contract_balance)\n            };\n        }\n        simulator.app_next_period()\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow","tests","test_utils.rs"],"content":"use anyhow::Result;\nuse astroport::{staking as xastro, token as astro};\nuse astroport_governance::escrow_fee_distributor::InstantiateMsg as FeeDistributorInstantiateMsg;\nuse astroport_governance::utils::EPOCH_START;\nuse astroport_governance::voting_escrow::{\n    BlacklistedVotersResponse, Cw20HookMsg, ExecuteMsg, InstantiateMsg, QueryMsg,\n    UpdateMarketingInfo, VotingPowerResponse,\n};\nuse cosmwasm_std::testing::{mock_env, MockApi, MockStorage};\nuse cosmwasm_std::{attr, to_binary, Addr, QueryRequest, StdResult, Timestamp, Uint128, WasmQuery};\nuse cw20::{BalanceResponse, Cw20ExecuteMsg, Cw20QueryMsg, Logo, MinterResponse};\nuse cw_multi_test::{App, AppBuilder, AppResponse, BankKeeper, ContractWrapper, Executor};\nuse voting_escrow::astroport;\n\npub const MULTIPLIER: u64 = 1000000;\n\npub struct Helper {\n    pub owner: Addr,\n    pub astro_token: Addr,\n    pub staking_instance: Addr,\n    pub xastro_token: Addr,\n    pub voting_instance: Addr,\n    pub fee_distributor_instance: Addr,\n}\n\nimpl Helper {\n    pub fn init(router: \u0026mut App, owner: Addr) -\u003e Self {\n        let astro_token_contract = Box::new(ContractWrapper::new_with_empty(\n            astroport_token::contract::execute,\n            astroport_token::contract::instantiate,\n            astroport_token::contract::query,\n        ));\n\n        let astro_token_code_id = router.store_code(astro_token_contract);\n\n        let msg = astro::InstantiateMsg {\n            name: String::from(\"Astro token\"),\n            symbol: String::from(\"ASTRO\"),\n            decimals: 6,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                minter: owner.to_string(),\n                cap: None,\n            }),\n            marketing: None,\n        };\n\n        let astro_token = router\n            .instantiate_contract(\n                astro_token_code_id,\n                owner.clone(),\n                \u0026msg,\n                \u0026[],\n                String::from(\"ASTRO\"),\n                None,\n            )\n            .unwrap();\n\n        let staking_contract = Box::new(\n            ContractWrapper::new_with_empty(\n                astroport_staking::contract::execute,\n                astroport_staking::contract::instantiate,\n                astroport_staking::contract::query,\n            )\n            .with_reply_empty(astroport_staking::contract::reply),\n        );\n\n        let staking_code_id = router.store_code(staking_contract);\n\n        let msg = xastro::InstantiateMsg {\n            owner: owner.to_string(),\n            token_code_id: astro_token_code_id,\n            deposit_token_addr: astro_token.to_string(),\n            marketing: None,\n        };\n        let staking_instance = router\n            .instantiate_contract(\n                staking_code_id,\n                owner.clone(),\n                \u0026msg,\n                \u0026[],\n                String::from(\"xASTRO\"),\n                None,\n            )\n            .unwrap();\n\n        let res = router\n            .wrap()\n            .query::\u003cxastro::ConfigResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                contract_addr: staking_instance.to_string(),\n                msg: to_binary(\u0026xastro::QueryMsg::Config {}).unwrap(),\n            }))\n            .unwrap();\n\n        let voting_contract = Box::new(ContractWrapper::new_with_empty(\n            voting_escrow::contract::execute,\n            voting_escrow::contract::instantiate,\n            voting_escrow::contract::query,\n        ));\n\n        let voting_code_id = router.store_code(voting_contract);\n\n        let marketing_info = UpdateMarketingInfo {\n            project: Some(\"Astroport\".to_string()),\n            description: Some(\"Astroport is a decentralized application for managing the supply of space resources.\".to_string()),\n            marketing: Some(owner.to_string()),\n            logo: Some(Logo::Url(\"https://astroport.com/logo.png\".to_string())),\n        };\n\n        let msg = InstantiateMsg {\n            owner: owner.to_string(),\n            guardian_addr: Some(\"guardian\".to_string()),\n            deposit_token_addr: res.share_token_addr.to_string(),\n            marketing: Some(marketing_info),\n            logo_urls_whitelist: vec![\"https://astroport.com/\".to_string()],\n        };\n        let voting_instance = router\n            .instantiate_contract(\n                voting_code_id,\n                owner.clone(),\n                \u0026msg,\n                \u0026[],\n                String::from(\"vxASTRO\"),\n                None,\n            )\n            .unwrap();\n\n        let fee_distributor_contract = Box::new(ContractWrapper::new_with_empty(\n            astroport_escrow_fee_distributor::contract::execute,\n            astroport_escrow_fee_distributor::contract::instantiate,\n            astroport_escrow_fee_distributor::contract::query,\n        ));\n\n        let fee_distributor_code_id = router.store_code(fee_distributor_contract);\n\n        let msg = FeeDistributorInstantiateMsg {\n            owner: owner.to_string(),\n            astro_token: astro_token.to_string(),\n            voting_escrow_addr: voting_instance.to_string(),\n            claim_many_limit: None,\n            is_claim_disabled: None,\n        };\n\n        let fee_distributor_instance = router\n            .instantiate_contract(\n                fee_distributor_code_id,\n                owner.clone(),\n                \u0026msg,\n                \u0026[],\n                String::from(\"Fee distributor\"),\n                None,\n            )\n            .unwrap();\n\n        Self {\n            owner,\n            xastro_token: res.share_token_addr,\n            astro_token,\n            staking_instance,\n            voting_instance,\n            fee_distributor_instance,\n        }\n    }\n\n    pub fn mint_xastro(\u0026self, router: \u0026mut App, to: \u0026str, amount: u64) {\n        let amount = amount * MULTIPLIER;\n        let msg = cw20::Cw20ExecuteMsg::Mint {\n            recipient: String::from(to),\n            amount: Uint128::from(amount),\n        };\n        let res = router\n            .execute_contract(self.owner.clone(), self.astro_token.clone(), \u0026msg, \u0026[])\n            .unwrap();\n        assert_eq!(res.events[1].attributes[1], attr(\"action\", \"mint\"));\n        assert_eq!(res.events[1].attributes[2], attr(\"to\", String::from(to)));\n        assert_eq!(\n            res.events[1].attributes[3],\n            attr(\"amount\", Uint128::from(amount))\n        );\n\n        let to_addr = Addr::unchecked(to);\n        let msg = Cw20ExecuteMsg::Send {\n            contract: self.staking_instance.to_string(),\n            msg: to_binary(\u0026xastro::Cw20HookMsg::Enter {}).unwrap(),\n            amount: Uint128::from(amount),\n        };\n        router\n            .execute_contract(to_addr, self.astro_token.clone(), \u0026msg, \u0026[])\n            .unwrap();\n    }\n\n    #[allow(dead_code)]\n    pub fn check_xastro_balance(\u0026self, router: \u0026mut App, user: \u0026str, amount: u64) {\n        let amount = amount * MULTIPLIER;\n        let res: BalanceResponse = router\n            .wrap()\n            .query_wasm_smart(\n                self.xastro_token.clone(),\n                \u0026Cw20QueryMsg::Balance {\n                    address: user.to_string(),\n                },\n            )\n            .unwrap();\n        assert_eq!(res.balance.u128(), amount as u128);\n    }\n\n    #[allow(dead_code)]\n    pub fn check_astro_balance(\u0026self, router: \u0026mut App, user: \u0026str, amount: u64) {\n        let amount = amount * MULTIPLIER;\n        let res: BalanceResponse = router\n            .wrap()\n            .query_wasm_smart(\n                self.astro_token.clone(),\n                \u0026Cw20QueryMsg::Balance {\n                    address: user.to_string(),\n                },\n            )\n            .unwrap();\n        assert_eq!(res.balance.u128(), amount as u128);\n    }\n\n    pub fn create_lock(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        time: u64,\n        amount: f32,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let amount = (amount * MULTIPLIER as f32) as u64;\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.voting_instance.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::CreateLock { time }).unwrap(),\n        };\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.xastro_token.clone(),\n            \u0026cw20msg,\n            \u0026[],\n        )\n    }\n\n    #[allow(dead_code)]\n    pub fn create_lock_u128(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        time: u64,\n        amount: u128,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.voting_instance.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::CreateLock { time }).unwrap(),\n        };\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.xastro_token.clone(),\n            \u0026cw20msg,\n            \u0026[],\n        )\n    }\n\n    pub fn extend_lock_amount(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        amount: f32,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let amount = (amount * MULTIPLIER as f32) as u64;\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.voting_instance.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::ExtendLockAmount {}).unwrap(),\n        };\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.xastro_token.clone(),\n            \u0026cw20msg,\n            \u0026[],\n        )\n    }\n\n    #[allow(dead_code)]\n    pub fn deposit_for(\n        \u0026self,\n        router: \u0026mut App,\n        from: \u0026str,\n        to: \u0026str,\n        amount: f32,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let amount = (amount * MULTIPLIER as f32) as u64;\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.voting_instance.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::DepositFor {\n                user: to.to_string(),\n            })\n            .unwrap(),\n        };\n        router.execute_contract(\n            Addr::unchecked(from),\n            self.xastro_token.clone(),\n            \u0026cw20msg,\n            \u0026[],\n        )\n    }\n\n    pub fn extend_lock_time(\u0026self, router: \u0026mut App, user: \u0026str, time: u64) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.voting_instance.clone(),\n            \u0026ExecuteMsg::ExtendLockTime { time },\n            \u0026[],\n        )\n    }\n\n    pub fn withdraw(\u0026self, router: \u0026mut App, user: \u0026str) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.voting_instance.clone(),\n            \u0026ExecuteMsg::Withdraw {},\n            \u0026[],\n        )\n    }\n\n    pub fn update_blacklist(\n        \u0026self,\n        router: \u0026mut App,\n        append_addrs: Option\u003cVec\u003cString\u003e\u003e,\n        remove_addrs: Option\u003cVec\u003cString\u003e\u003e,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(\"owner\"),\n            self.voting_instance.clone(),\n            \u0026ExecuteMsg::UpdateBlacklist {\n                append_addrs,\n                remove_addrs,\n            },\n            \u0026[],\n        )\n    }\n\n    pub fn query_user_vp(\u0026self, router: \u0026mut App, user: \u0026str) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_instance.clone(),\n                \u0026QueryMsg::UserVotingPower {\n                    user: user.to_string(),\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    #[allow(dead_code)]\n    pub fn query_exact_user_vp(\u0026self, router: \u0026mut App, user: \u0026str) -\u003e StdResult\u003cu128\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_instance.clone(),\n                \u0026QueryMsg::UserVotingPower {\n                    user: user.to_string(),\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128())\n    }\n\n    #[allow(dead_code)]\n    pub fn query_user_vp_at(\u0026self, router: \u0026mut App, user: \u0026str, time: u64) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_instance.clone(),\n                \u0026QueryMsg::UserVotingPowerAt {\n                    user: user.to_string(),\n                    time,\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    #[allow(dead_code)]\n    pub fn query_user_vp_at_period(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        period: u64,\n    ) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_instance.clone(),\n                \u0026QueryMsg::UserVotingPowerAtPeriod {\n                    user: user.to_string(),\n                    period,\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_total_vp(\u0026self, router: \u0026mut App) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(self.voting_instance.clone(), \u0026QueryMsg::TotalVotingPower {})\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    #[allow(dead_code)]\n    pub fn query_exact_total_vp(\u0026self, router: \u0026mut App) -\u003e StdResult\u003cu128\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(self.voting_instance.clone(), \u0026QueryMsg::TotalVotingPower {})\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128())\n    }\n\n    pub fn query_total_vp_at(\u0026self, router: \u0026mut App, time: u64) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_instance.clone(),\n                \u0026QueryMsg::TotalVotingPowerAt { time },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    #[allow(dead_code)]\n    pub fn query_total_vp_at_period(\u0026self, router: \u0026mut App, period: u64) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_instance.clone(),\n                \u0026QueryMsg::TotalVotingPowerAtPeriod { period },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    #[allow(dead_code)]\n    pub fn query_locked_balance_at(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        height: u64,\n    ) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_instance.clone(),\n                \u0026QueryMsg::UserDepositAtHeight {\n                    user: user.to_string(),\n                    height,\n                },\n            )\n            .map(|vp: Uint128| vp.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    #[allow(dead_code)]\n    pub fn query_blacklisted_voters(\n        \u0026self,\n        router: \u0026mut App,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cVec\u003cAddr\u003e\u003e {\n        router.wrap().query_wasm_smart(\n            self.voting_instance.clone(),\n            \u0026QueryMsg::BlacklistedVoters { start_after, limit },\n        )\n    }\n\n    #[allow(dead_code)]\n    pub fn check_voters_are_blacklisted(\n        \u0026self,\n        router: \u0026mut App,\n        voters: Vec\u003cString\u003e,\n    ) -\u003e StdResult\u003cBlacklistedVotersResponse\u003e {\n        router.wrap().query_wasm_smart(\n            self.voting_instance.clone(),\n            \u0026QueryMsg::CheckVotersAreBlacklisted { voters },\n        )\n    }\n}\n\npub fn mock_app() -\u003e App {\n    let mut env = mock_env();\n    env.block.time = Timestamp::from_seconds(EPOCH_START);\n    let api = MockApi::default();\n    let bank = BankKeeper::new();\n    let storage = MockStorage::new();\n\n    AppBuilder::new()\n        .with_api(api)\n        .with_block(env.block)\n        .with_bank(bank)\n        .with_storage(storage)\n        .build(|_, _, _| {})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","examples","voting_escrow_delegation_schema.rs"],"content":"use astroport_governance::voting_escrow_delegation::{ExecuteMsg, InstantiateMsg, QueryMsg};\nuse cosmwasm_schema::write_api;\n\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        query: QueryMsg,\n        execute: ExecuteMsg,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","src","contract.rs"],"content":"use astroport_governance::utils::{calc_voting_power, get_period, get_periods_count};\nuse astroport_governance::voting_escrow::{get_voting_power, get_voting_power_at, MAX_LIMIT};\nuse std::marker::PhantomData;\n\nuse crate::error::ContractError;\nuse crate::state::{CONFIG, DELEGATED, OWNERSHIP_PROPOSAL, TOKENS};\nuse astroport_governance::astroport::common::{\n    claim_ownership, drop_ownership_proposal, propose_new_owner,\n};\nuse astroport_governance::voting_escrow_delegation::{\n    Config, ExecuteMsg, InstantiateMsg, QueryMsg,\n};\n\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    attr, to_binary, Addr, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Reply, ReplyOn,\n    Response, StdError, StdResult, SubMsg, Uint128, WasmMsg,\n};\nuse cw2::set_contract_version;\nuse cw721::NftInfoResponse;\nuse cw_utils::parse_reply_instantiate_data;\n\nuse crate::helpers::{\n    calc_delegation, calc_extend_delegation, calc_not_delegated_vp, calc_total_delegated_vp,\n    validate_parameters,\n};\nuse cw721_base::helpers as cw721_helpers;\nuse cw721_base::msg::{ExecuteMsg as ExecuteMsgNFT, InstantiateMsg as InstantiateMsgNFT};\nuse cw721_base::{Extension, MintMsg};\n\n// Version info for contract migration.\nconst CONTRACT_NAME: \u0026str = \"voting-escrow-delegation\";\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Delegated voting power NFT information.\nconst TOKEN_NAME: \u0026str = \"Delegated VP NFT\";\nconst TOKEN_SYMBOL: \u0026str = \"VP-NFT\";\n\n/// Creates a new contract with the specified parameters in the [`InstantiateMsg`].\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    let config = Config {\n        owner: deps.api.addr_validate(\u0026msg.owner)?,\n        nft_addr: Addr::unchecked(\"\"),\n        voting_escrow_addr: deps.api.addr_validate(\u0026msg.voting_escrow_addr)?,\n    };\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    // Create an Astroport NFT\n    let sub_msg = SubMsg {\n        msg: WasmMsg::Instantiate {\n            admin: Some(config.owner.to_string()),\n            code_id: msg.nft_code_id,\n            msg: to_binary(\u0026InstantiateMsgNFT {\n                name: TOKEN_NAME.to_string(),\n                symbol: TOKEN_SYMBOL.to_string(),\n                minter: env.contract.address.to_string(),\n            })?,\n            funds: vec![],\n            label: String::from(\"Delegated VP NFT\"),\n        }\n        .into(),\n        id: 1,\n        gas_limit: None,\n        reply_on: ReplyOn::Success,\n    };\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"instantiate\")\n        .add_attribute(\"owner\", config.owner)\n        .add_submessage(sub_msg))\n}\n\n/// Exposes all the execute functions available in the contract.\n///\n/// ## Execute messages\n/// * **ExecuteMsg::CreateDelegation { percentage, cancel_time, expire_time, token_id, recipient}**\n/// Delegates voting power in percent into other account.\n///\n/// * **ExecuteMsg::ExtendDelegation { percentage, cancel_time, expire_time, token_id, recipient}**\n/// Extends an already created delegation with a new specified parameters\n///\n/// * **ExecuteMsg::ProposeNewOwner { owner, expires_in }** Creates a new request to change\n/// contract ownership.\n///\n/// * **ExecuteMsg::DropOwnershipProposal {}** Removes a request to change contract ownership.\n///\n/// * **ExecuteMsg::ClaimOwnership {}** Claims contract ownership.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::CreateDelegation {\n            bps,\n            expire_time,\n            token_id,\n            recipient,\n        } =\u003e create_delegation(deps, env, info, bps, expire_time, token_id, recipient),\n        ExecuteMsg::ExtendDelegation {\n            bps,\n            expire_time,\n            token_id,\n        } =\u003e extend_delegation(deps, env, info, bps, expire_time, token_id),\n        ExecuteMsg::UpdateConfig { new_voting_escrow } =\u003e {\n            update_config(deps, info, new_voting_escrow)\n        }\n        ExecuteMsg::ProposeNewOwner {\n            new_owner,\n            expires_in,\n        } =\u003e {\n            let config = CONFIG.load(deps.storage)?;\n            propose_new_owner(\n                deps,\n                info,\n                env,\n                new_owner,\n                expires_in,\n                config.owner,\n                OWNERSHIP_PROPOSAL,\n            )\n            .map_err(Into::into)\n        }\n        ExecuteMsg::DropOwnershipProposal {} =\u003e {\n            let config: Config = CONFIG.load(deps.storage)?;\n\n            drop_ownership_proposal(deps, info, config.owner, OWNERSHIP_PROPOSAL)\n                .map_err(Into::into)\n        }\n        ExecuteMsg::ClaimOwnership {} =\u003e {\n            claim_ownership(deps, info, env, OWNERSHIP_PROPOSAL, |deps, new_owner| {\n                CONFIG\n                    .update::\u003c_, StdError\u003e(deps.storage, |mut v| {\n                        v.owner = new_owner;\n                        Ok(v)\n                    })\n                    .map(|_| ())\n            })\n            .map_err(Into::into)\n        }\n    }\n}\n\n/// The entry point to the contract for processing replies from sub-messages. For now it only\n/// sets the NFT contract address.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(deps: DepsMut, _env: Env, msg: Reply) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut config: Config = CONFIG.load(deps.storage)?;\n\n    if config.nft_addr != Addr::unchecked(\"\") {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let res = parse_reply_instantiate_data(msg)?;\n    config.nft_addr = deps.api.addr_validate(res.contract_address.as_str())?;\n\n    CONFIG.save(deps.storage, \u0026config)?;\n    Ok(Response::new())\n}\n\n/// Creates NFT with specified parameters and connect it with delegated voting power\n/// in percent into other account.\n///\n/// * **percentage** is a percentage value to determine the amount of\n/// voting power to delegate\n///\n/// * **expire_time** is a point in time, at least a day in the future, at which the value of the\n/// voting power will reach 0.\n///\n/// * **token_id** is an NFT identifier.\n///\n/// * **recipient** is an account to receive the delegated voting power.\npub fn create_delegation(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    bps: u16,\n    expire_time: u64,\n    token_id: String,\n    recipient: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let recipient_addr = deps.api.addr_validate(recipient.as_str())?;\n    let delegator = info.sender;\n    let cfg = CONFIG.load(deps.storage)?;\n    let block_period = get_period(env.block.time.seconds())?;\n    let exp_period = block_period + get_periods_count(expire_time);\n\n    // We can create only one NFT for a specific token ID\n    let nft_helper = cw721_helpers::Cw721Contract::\u003cEmpty, Empty\u003e(\n        cfg.nft_addr.clone(),\n        PhantomData,\n        PhantomData,\n    );\n\n    let nft_instance: StdResult\u003cNftInfoResponse\u003cExtension\u003e\u003e =\n        nft_helper.nft_info(\u0026deps.querier, \u0026token_id);\n\n    if nft_instance.is_ok() {\n        return Err(ContractError::DelegationTokenAlreadyExists(token_id));\n    }\n\n    let vp = get_voting_power(\u0026deps.querier, \u0026cfg.voting_escrow_addr, \u0026delegator)?;\n    if vp.is_zero() {\n        return Err(ContractError::ZeroVotingPower {});\n    }\n\n    validate_parameters(\n        \u0026deps.querier,\n        \u0026cfg,\n        \u0026delegator,\n        block_period,\n        exp_period,\n        bps,\n        None,\n    )?;\n\n    let not_delegated_vp = calc_not_delegated_vp(deps.as_ref(), \u0026delegator, vp, block_period)?;\n    let delegation = calc_delegation(not_delegated_vp, block_period, exp_period, bps)?;\n\n    DELEGATED.save(deps.storage, (\u0026delegator, token_id.clone()), \u0026delegation)?;\n    TOKENS.save(deps.storage, token_id.clone(), \u0026delegation)?;\n\n    Ok(Response::default()\n        .add_attributes(vec![\n            attr(\"action\", \"create_delegation\"),\n            attr(\"recipient\", recipient),\n            attr(\"token_id\", token_id.clone()),\n            attr(\"expire_time\", expire_time.to_string()),\n            attr(\"bps\", bps.to_string()),\n            attr(\"delegated_voting_power\", delegation.power.to_string()),\n        ])\n        .add_submessage(SubMsg::new(WasmMsg::Execute {\n            contract_addr: cfg.nft_addr.to_string(),\n            msg: to_binary(\u0026ExecuteMsgNFT::\u003cExtension, Empty\u003e::Mint(MintMsg::\u003c\n                Extension,\n            \u003e {\n                token_id,\n                owner: recipient_addr.to_string(),\n                token_uri: None,\n                extension: None,\n            }))?,\n            funds: vec![],\n        })))\n}\n\n/// Extends a previously created delegation by a new specified parameters.\n///\n/// * **percentage** is a percentage value to determine the amount of voting power to delegate.\n///\n/// * **expire_time** is a point in time, at least a day in the future, at which the value of the\n/// voting power will reach 0.\n///\n/// * **token_id** is an NFT identifier.\n///\n/// * **recipient** is an account to receive the delegated voting power.\npub fn extend_delegation(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    bps: u16,\n    expire_time: u64,\n    token_id: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let delegator = info.sender;\n    let cfg = CONFIG.load(deps.storage)?;\n\n    let old_delegation = DELEGATED.load(deps.storage, (\u0026delegator, token_id.clone()))?;\n\n    let vp = get_voting_power(\u0026deps.querier, \u0026cfg.voting_escrow_addr, \u0026delegator)?;\n    if vp.is_zero() {\n        return Err(ContractError::ZeroVotingPower {});\n    }\n\n    let block_period = get_period(env.block.time.seconds())?;\n    let exp_period = block_period + get_periods_count(expire_time);\n\n    validate_parameters(\n        \u0026deps.querier,\n        \u0026cfg,\n        \u0026delegator,\n        block_period,\n        exp_period,\n        bps,\n        Some(\u0026old_delegation),\n    )?;\n\n    let new_delegation = calc_extend_delegation(\n        deps.as_ref(),\n        \u0026delegator,\n        vp,\n        \u0026old_delegation,\n        block_period,\n        exp_period,\n        bps,\n    )?;\n\n    DELEGATED.save(\n        deps.storage,\n        (\u0026delegator, token_id.clone()),\n        \u0026new_delegation,\n    )?;\n    TOKENS.save(deps.storage, token_id.clone(), \u0026new_delegation)?;\n\n    Ok(Response::default().add_attributes(vec![\n        attr(\"action\", \"extend_delegation\"),\n        attr(\"token_id\", token_id),\n        attr(\"expire_time\", expire_time.to_string()),\n        attr(\"bps\", bps.to_string()),\n        attr(\"delegated_voting_power\", new_delegation.power.to_string()),\n    ]))\n}\n\n/// Updates contract parameters.\n///\n/// * **new_voting_escrow** is a new address of Voting Escrow contract.\nfn update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    new_voting_escrow: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut cfg = CONFIG.load(deps.storage)?;\n\n    if info.sender != cfg.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(new_voting_escrow) = new_voting_escrow {\n        cfg.voting_escrow_addr = deps.api.addr_validate(\u0026new_voting_escrow)?;\n    }\n\n    CONFIG.save(deps.storage, \u0026cfg)?;\n\n    Ok(Response::default().add_attribute(\"action\", \"execute_update_config\"))\n}\n\n/// Expose available contract queries.\n///\n/// ## Queries\n/// * **QueryMsg::Config {}** Fetch contract config\n///\n/// * **QueryMsg::AdjustedBalance { account, timestamp }** Adjusted voting power balance after\n/// accounting for delegations.\n///\n/// * **QueryMsg::AlreadyDelegatedVP { account, timestamp }** Returns the amount of delegated\n/// voting power according to the given parameters.\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Config {} =\u003e to_binary(\u0026CONFIG.load(deps.storage)?),\n        QueryMsg::AdjustedBalance { account, timestamp } =\u003e {\n            to_binary(\u0026adjusted_balance(deps, env, account, timestamp)?)\n        }\n        QueryMsg::DelegatedVotingPower { account, timestamp } =\u003e {\n            to_binary(\u0026delegated_vp(deps, env, account, timestamp)?)\n        }\n    }\n}\n\n/// Returns an adjusted voting power balance after accounting for delegations.\n///\n/// * **account** is an address of the account to return adjusted balance.\n///\n/// * **timestamp** is a point in time, at least a day in the future, at which the value of\n/// the voting power will reach 0.\nfn adjusted_balance(\n    deps: Deps,\n    env: Env,\n    account: String,\n    timestamp: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let account = deps.api.addr_validate(account.as_str())?;\n    let config = CONFIG.load(deps.storage)?;\n\n    let mut current_vp = if let Some(timestamp) = timestamp {\n        get_voting_power_at(\n            \u0026deps.querier,\n            \u0026config.voting_escrow_addr,\n            \u0026account,\n            timestamp,\n        )?\n    } else {\n        get_voting_power(\u0026deps.querier, \u0026config.voting_escrow_addr, \u0026account)?\n    };\n\n    let block_period = get_period(timestamp.unwrap_or_else(|| env.block.time.seconds()))?;\n    let total_delegated_vp = calc_total_delegated_vp(deps, \u0026account, block_period)?;\n\n    // we must to subtract the delegated voting power\n    current_vp = current_vp.checked_sub(total_delegated_vp)?;\n\n    let nft_helper =\n        cw721_helpers::Cw721Contract::\u003cEmpty, Empty\u003e(config.nft_addr, PhantomData, PhantomData);\n\n    let mut account_tokens = vec![];\n    let mut start_after = None;\n\n    // we need to take all tokens for specified account\n    loop {\n        let tokens = nft_helper\n            .tokens(\u0026deps.querier, account.clone(), start_after, Some(MAX_LIMIT))?\n            .tokens;\n        if tokens.is_empty() {\n            break;\n        }\n        start_after = tokens.last().cloned();\n        account_tokens.extend(tokens);\n    }\n\n    for token_id in account_tokens {\n        let token = TOKENS.load(deps.storage, token_id)?;\n\n        if token.start \u003c= block_period \u0026\u0026 token.expire_period \u003e block_period {\n            current_vp += calc_voting_power(token.slope, token.power, token.start, block_period);\n        }\n    }\n\n    Ok(current_vp)\n}\n\n/// Returns an amount of delegated voting power.\n///\n/// * **account** is an address of the account to return adjusted balance.\n///\n/// * **timestamp** is an optional field that specifies the period for which the function\n/// returns voting power.\nfn delegated_vp(\n    deps: Deps,\n    env: Env,\n    account: String,\n    timestamp: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let account = deps.api.addr_validate(account.as_str())?;\n    let block_period = get_period(timestamp.unwrap_or_else(|| env.block.time.seconds()))?;\n\n    calc_total_delegated_vp(deps, \u0026account, block_period)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse cw_utils::ParseReplyError;\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"{0}\")]\n    ParseReplyError(#[from] ParseReplyError),\n\n    #[error(\"You can't delegate with zero voting power\")]\n    ZeroVotingPower {},\n\n    #[error(\"You have already delegated all the voting power.\")]\n    AllVotingPowerIsDelegated {},\n\n    #[error(\"The delegation period must be at least a week and not more than a user lock period.\")]\n    DelegationPeriodError {},\n\n    #[error(\"New expiration date must be greater than previously set and less than or equal to user's end of voting power lock.\")]\n    DelegationExtendPeriodError {},\n\n    #[error(\"Not enough voting power to proceed\")]\n    NotEnoughVotingPower {},\n\n    #[error(\"The percentage range must be from 0 to 100.\")]\n    PercentageError {},\n\n    #[error(\"A delegation with a token {0} already exists.\")]\n    DelegationTokenAlreadyExists(String),\n\n    #[error(\"New delegated voting power can not be less than it was previously.\")]\n    DecreasedDelegatedVotingPower {},\n\n    #[error(\"Basic points conversion error. The basic points must be from 1 to 10000: {0}\")]\n    BPSConversionError(u16),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","src","helpers.rs"],"content":"use crate::state::DELEGATED;\nuse crate::ContractError;\nuse astroport_governance::utils::calc_voting_power;\nuse astroport_governance::voting_escrow::get_lock_info;\nuse astroport_governance::voting_escrow_delegation::{Config, Token};\nuse cosmwasm_std::{Addr, Deps, Order, QuerierWrapper, StdError, StdResult, Uint128};\n\nconst MAX_BPS_AMOUNT: u16 = 10000u16;\nconst MIN_BPS_AMOUNT: u16 = 1u16;\n\n/// Adjusting voting power according to the slope by specified percentage.\npub fn calc_delegation(\n    not_delegated_vp: Uint128,\n    block_period: u64,\n    exp_period: u64,\n    bps: u16,\n) -\u003e Result\u003cToken, ContractError\u003e {\n    let vp_to_delegate = not_delegated_vp.multiply_ratio(bps, MAX_BPS_AMOUNT);\n\n    let dt = Uint128::from(exp_period - block_period);\n    let slope = vp_to_delegate\n        .checked_div(dt)\n        .map_err(|e| ContractError::Std(e.into()))?;\n    let power = slope * dt;\n\n    if power.is_zero() {\n        return Err(ContractError::NotEnoughVotingPower {});\n    }\n\n    Ok(Token {\n        power,\n        slope,\n        start: block_period,\n        expire_period: exp_period,\n    })\n}\n\n/// Calculates the total delegated voting power for specified account.\npub(crate) fn calc_total_delegated_vp(\n    deps: Deps,\n    delegator: \u0026Addr,\n    block_period: u64,\n) -\u003e StdResult\u003cUint128\u003e {\n    let delegates = DELEGATED\n        .prefix(delegator)\n        .range(deps.storage, None, None, Order::Ascending)\n        .filter_map(|pair| {\n            let (_, token) = match pair {\n                Ok(v) =\u003e v,\n                Err(e) =\u003e return Some(Err(e)),\n            };\n            if token.start \u003c= block_period \u0026\u0026 token.expire_period \u003e block_period {\n                Some(Ok(token))\n            } else {\n                None\n            }\n        })\n        .collect::\u003cResult\u003cVec\u003cToken\u003e, StdError\u003e\u003e()?;\n\n    let mut total_delegated_vp = Uint128::zero();\n    for delegate in delegates {\n        total_delegated_vp +=\n            calc_voting_power(delegate.slope, delegate.power, delegate.start, block_period);\n    }\n\n    Ok(total_delegated_vp)\n}\n\n/// Validates input parameters to create or extend a delegation.\npub fn validate_parameters(\n    querier: \u0026QuerierWrapper,\n    cfg: \u0026Config,\n    delegator: \u0026Addr,\n    block_period: u64,\n    exp_period: u64,\n    bps: u16,\n    old_delegate: Option\u003c\u0026Token\u003e,\n) -\u003e Result\u003c(), ContractError\u003e {\n    let user_lock = get_lock_info(querier, \u0026cfg.voting_escrow_addr, delegator)?;\n\n    // vxASTRO delegation must be at least WEEK and no more then lock end period\n    if (exp_period \u003c= block_period) || (exp_period \u003e user_lock.end) {\n        return Err(ContractError::DelegationPeriodError {});\n    }\n\n    if !(MIN_BPS_AMOUNT..=MAX_BPS_AMOUNT).contains(\u0026bps) {\n        return Err(ContractError::BPSConversionError(bps));\n    }\n\n    if let Some(old_token) = old_delegate {\n        if exp_period \u003c= old_token.expire_period {\n            return Err(ContractError::DelegationExtendPeriodError {});\n        }\n    }\n\n    Ok(())\n}\n\n/// Calculates available balance for a new delegation.\npub fn calc_not_delegated_vp(\n    deps: Deps,\n    delegator: \u0026Addr,\n    vp: Uint128,\n    block_period: u64,\n) -\u003e Result\u003cUint128, ContractError\u003e {\n    let total_delegated_vp = calc_total_delegated_vp(deps, delegator, block_period)?;\n\n    if vp \u003c= total_delegated_vp {\n        return Err(ContractError::AllVotingPowerIsDelegated {});\n    }\n\n    Ok(vp - total_delegated_vp)\n}\n\n/// Calculates the available balance for the specified delegation.\npub fn calc_extend_delegation(\n    deps: Deps,\n    delegator: \u0026Addr,\n    vp: Uint128,\n    old_delegation: \u0026Token,\n    block_period: u64,\n    exp_period: u64,\n    bps: u16,\n) -\u003e Result\u003cToken, ContractError\u003e {\n    let not_delegated_vp = calc_not_delegated_vp(deps, delegator, vp, block_period)?;\n\n    // we should deduct the previous delegation balance and assign a new delegation data\n    let new_delegation = if old_delegation.expire_period \u003e block_period {\n        let old_delegation_vp = calc_voting_power(\n            old_delegation.slope,\n            old_delegation.power,\n            old_delegation.start,\n            block_period,\n        );\n\n        let new_delegation = calc_delegation(\n            not_delegated_vp + old_delegation_vp,\n            block_period,\n            exp_period,\n            bps,\n        )?;\n\n        let new_delegation_vp = calc_voting_power(\n            new_delegation.slope,\n            new_delegation.power,\n            new_delegation.start,\n            block_period,\n        );\n\n        if old_delegation_vp \u003e new_delegation_vp {\n            return Err(ContractError::DecreasedDelegatedVotingPower {});\n        }\n\n        new_delegation\n    } else {\n        calc_delegation(not_delegated_vp, block_period, exp_period, bps)?\n    };\n\n    Ok(new_delegation)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","src","lib.rs"],"content":"pub mod contract;\nmod error;\nmod helpers;\npub mod state;\npub use crate::error::ContractError;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","src","state.rs"],"content":"use astroport_governance::astroport::common::OwnershipProposal;\nuse astroport_governance::voting_escrow_delegation::{Config, Token};\nuse cosmwasm_std::Addr;\nuse cw_storage_plus::{Item, Map};\n\n/// Contains a proposal to change contract ownership\npub const OWNERSHIP_PROPOSAL: Item\u003cOwnershipProposal\u003e = Item::new(\"ownership_proposal\");\n\n/// Stores the contract config at the given key\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n\n/// Delegated voting power are stored using a (contract_addr =\u003e token_ID) key\npub const DELEGATED: Map\u003c(\u0026Addr, String), Token\u003e = Map::new(\"delegated\");\n\n/// Delegated token history is stored using a token ID key\npub const TOKENS: Map\u003cString, Token\u003e = Map::new(\"tokens\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","tests","integration.rs"],"content":"use astroport_governance::utils::WEEK;\nuse astroport_governance::voting_escrow_delegation::Config;\nuse astroport_governance::voting_escrow_delegation::QueryMsg;\nuse cosmwasm_std::{to_binary, Addr, Empty, QueryRequest, Uint128, WasmQuery};\nuse cw721_base::{ExecuteMsg as ExecuteMsgNFT, Extension, MintMsg, QueryMsg as QueryMsgNFT};\nuse cw_multi_test::Executor;\n\nuse cw721::{ContractInfoResponse, Cw721ExecuteMsg, NumTokensResponse, TokensResponse};\n\nuse crate::test_helper::{mock_app, Helper};\n\nmod test_helper;\n\nconst EMPTY_TOKENS: Vec\u003cString\u003e = vec![];\nconst USER: \u0026str = \"user\";\n\n#[test]\nfn config() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    let res = router\n        .wrap()\n        .query::\u003cConfig\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: helper.delegation_instance.to_string(),\n            msg: to_binary(\u0026QueryMsg::Config {}).unwrap(),\n        }))\n        .unwrap();\n\n    assert_eq!(\"owner\", res.owner.to_string());\n}\n\n#[test]\nfn mint() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let helper = Helper::init(router_ref, owner);\n\n    let resp = router_ref\n        .wrap()\n        .query::\u003cContractInfoResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: helper.nft_instance.to_string(),\n            msg: to_binary(\u0026QueryMsgNFT::\u003cEmpty\u003e::ContractInfo {}).unwrap(),\n        }))\n        .unwrap();\n    assert_eq!(\"Delegated VP NFT\", resp.name);\n    assert_eq!(\"VP-NFT\", resp.symbol);\n\n    // try to mint from random\n    let err = router_ref\n        .execute_contract(\n            Addr::unchecked(\"random\"),\n            helper.nft_instance.clone(),\n            \u0026ExecuteMsgNFT::\u003cExtension, Empty\u003e::Mint(MintMsg::\u003cExtension\u003e {\n                token_id: \"token_1\".to_string(),\n                owner: USER.to_string(),\n                token_uri: None,\n                extension: None,\n            }),\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\"Unauthorized\", err.root_cause().to_string());\n\n    // try to mint from owner\n    router_ref\n        .execute_contract(\n            helper.delegation_instance.clone(),\n            helper.nft_instance.clone(),\n            \u0026ExecuteMsgNFT::\u003cExtension, Empty\u003e::Mint(MintMsg::\u003cExtension\u003e {\n                token_id: \"token_1\".to_string(),\n                owner: USER.to_string(),\n                token_uri: None,\n                extension: None,\n            }),\n            \u0026[],\n        )\n        .unwrap();\n\n    let resp = router_ref\n        .wrap()\n        .query::\u003cNumTokensResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: helper.nft_instance.to_string(),\n            msg: to_binary(\u0026QueryMsgNFT::\u003cEmpty\u003e::NumTokens {}).unwrap(),\n        }))\n        .unwrap();\n    assert_eq!(1, resp.count);\n\n    let resp = router_ref\n        .wrap()\n        .query::\u003cTokensResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: helper.nft_instance.to_string(),\n            msg: to_binary(\u0026QueryMsgNFT::\u003cEmpty\u003e::Tokens {\n                owner: USER.to_string(),\n                start_after: None,\n                limit: None,\n            })\n            .unwrap(),\n        }))\n        .unwrap();\n    assert_eq!(vec![\"token_1\",], resp.tokens);\n\n    // try to mint from owner for the same token ID\n    let err = router_ref\n        .execute_contract(\n            helper.delegation_instance.clone(),\n            helper.nft_instance.clone(),\n            \u0026ExecuteMsgNFT::\u003cExtension, Empty\u003e::Mint(MintMsg::\u003cExtension\u003e {\n                token_id: \"token_1\".to_string(),\n                owner: USER.to_string(),\n                token_uri: None,\n                extension: None,\n            }),\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\"token_id already claimed\", err.root_cause().to_string());\n\n    // try to burn nft by token ID\n    let err = router_ref\n        .execute_contract(\n            helper.delegation_instance.clone(),\n            helper.nft_instance.clone(),\n            \u0026ExecuteMsgNFT::\u003cExtension, Empty\u003e::Burn {\n                token_id: \"token_1\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\"Unauthorized\", err.root_cause().to_string());\n\n    // check if token exists\n    let resp = router_ref\n        .wrap()\n        .query::\u003cTokensResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: helper.nft_instance.to_string(),\n            msg: to_binary(\u0026QueryMsgNFT::\u003cEmpty\u003e::Tokens {\n                owner: USER.to_string(),\n                start_after: None,\n                limit: None,\n            })\n            .unwrap(),\n        }))\n        .unwrap();\n    assert_eq!(vec![\"token_1\",], resp.tokens);\n}\n\n#[test]\nfn create_delegation() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let delegator_helper = Helper::init(router_ref, owner);\n\n    // try to create delegation from user with zero voting power\n    let err = delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            5000,\n            WEEK,\n            \"token_1\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"You can't delegate with zero voting power\",\n        err.root_cause().to_string()\n    );\n\n    // Mint ASTRO, stake it and mint xASTRO\n    delegator_helper\n        .escrow_helper\n        .mint_xastro(router_ref, \"user\", 200);\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user\", 200);\n\n    // Create valid voting escrow lock\n    delegator_helper\n        .escrow_helper\n        .create_lock(router_ref, \"user\", WEEK * 2, 100f32)\n        .unwrap();\n    // Check that 100 xASTRO were actually debited\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user\", 100);\n    delegator_helper.escrow_helper.check_xastro_balance(\n        router_ref,\n        delegator_helper.escrow_helper.escrow_instance.as_str(),\n        100,\n    );\n\n    // Mint ASTRO, stake it and mint xASTRO\n    delegator_helper\n        .escrow_helper\n        .mint_xastro(router_ref, \"user2\", 200);\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user2\", 200);\n\n    // Create valid voting escrow lock\n    delegator_helper\n        .escrow_helper\n        .create_lock(router_ref, \"user2\", WEEK * 2, 100f32)\n        .unwrap();\n    // Check that 100 xASTRO were actually debited\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user2\", 100);\n    delegator_helper.escrow_helper.check_xastro_balance(\n        router_ref,\n        delegator_helper.escrow_helper.escrow_instance.as_str(),\n        200,\n    );\n\n    // check user's adjusted balance before create a delegation\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(102_884_614), resp);\n\n    // check user's nft tokens before create a delegation\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // check user2's adjusted balance before create a delegation\n    let user2_vp_before_delegation = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(102_884_614), user2_vp_before_delegation);\n\n    // check user2's nft tokens before create a delegation\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // try to create delegation with the 10_001 bps\n    let err = delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            10001,\n            WEEK,\n            \"token_1\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"Basic points conversion error. The basic points must be from 1 to 10000: 10001\",\n        err.root_cause().to_string()\n    );\n\n    // try to create delegation with the 10_001 bps\n    let err = delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            0,\n            WEEK,\n            \"token_1\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"Basic points conversion error. The basic points must be from 1 to 10000: 0\",\n        err.root_cause().to_string()\n    );\n\n    // create delegation for one week\n    delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            10000,\n            WEEK,\n            \"token_1\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap();\n\n    // try to create delegation with the same token ID\n    let err = delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            10000,\n            WEEK,\n            \"token_1\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap_err();\n    assert_eq!(\n        \"A delegation with a token token_1 already exists.\",\n        err.root_cause().to_string()\n    );\n\n    // try create delegation without free voting power\n    let err = delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            3000,\n            WEEK,\n            \"token_2\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        \"You have already delegated all the voting power.\",\n        err.root_cause().to_string()\n    );\n\n    // check user's nft tokens\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // check user2's nft tokens\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_1\"], resp.tokens);\n\n    // check user's balance after the delegation\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(0), resp);\n\n    // check user2's balance after the delegation\n    let user2_vp_after_delegation = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(205_769_228), user2_vp_after_delegation);\n\n    let user_delegated_vp = delegator_helper\n        .delegated_balance(router_ref, \"user\", None)\n        .unwrap();\n\n    // check user's user_vp_after_delegation + user_delegated_vp = user_vp_before_delegation\n    assert_eq!(\n        user2_vp_after_delegation,\n        user_delegated_vp + user2_vp_before_delegation\n    );\n\n    router_ref.update_block(|block_info| {\n        block_info.time = block_info.time.plus_seconds(WEEK);\n        block_info.height += 1;\n    });\n\n    // check user's adjusted balance when delegation expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(51_442_307), resp);\n\n    // check user2's adjusted balance when delegation expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(51_442_307), resp);\n\n    // try to transfer NFT to user2\n    let err = router_ref\n        .execute_contract(\n            Addr::unchecked(\"user\"),\n            delegator_helper.nft_instance.clone(),\n            \u0026Cw721ExecuteMsg::TransferNft {\n                recipient: \"user2\".to_string(),\n                token_id: \"token_1\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\"Unauthorized\", err.root_cause().to_string());\n}\n\n#[test]\nfn create_multiple_delegation() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let delegator_helper = Helper::init(router_ref, owner);\n\n    // Mint ASTRO, stake it and mint xASTRO\n    delegator_helper\n        .escrow_helper\n        .mint_xastro(router_ref, \"user\", 200);\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user\", 200);\n\n    // Create valid voting escrow lock\n    delegator_helper\n        .escrow_helper\n        .create_lock(router_ref, \"user\", WEEK * 10, 100f32)\n        .unwrap();\n\n    // Check that 100 xASTRO were actually debited\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user\", 100);\n    delegator_helper.escrow_helper.check_xastro_balance(\n        router_ref,\n        delegator_helper.escrow_helper.escrow_instance.as_str(),\n        100,\n    );\n\n    // Mint ASTRO, stake it and mint xASTRO\n    delegator_helper\n        .escrow_helper\n        .mint_xastro(router_ref, \"user2\", 200);\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user2\", 200);\n\n    // Create valid voting escrow lock\n    delegator_helper\n        .escrow_helper\n        .create_lock(router_ref, \"user2\", WEEK * 5, 100f32)\n        .unwrap();\n    // Check that 100 xASTRO were actually debited\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user2\", 100);\n    delegator_helper.escrow_helper.check_xastro_balance(\n        router_ref,\n        delegator_helper.escrow_helper.escrow_instance.as_str(),\n        200,\n    );\n\n    // Mint ASTRO, stake it and mint xASTRO\n    delegator_helper\n        .escrow_helper\n        .mint_xastro(router_ref, \"user3\", 200);\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user3\", 200);\n\n    // Create valid voting escrow lock\n    delegator_helper\n        .escrow_helper\n        .create_lock(router_ref, \"user3\", WEEK, 100f32)\n        .unwrap();\n\n    // Check that 100 xASTRO were actually debited\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user3\", 100);\n    delegator_helper.escrow_helper.check_xastro_balance(\n        router_ref,\n        delegator_helper.escrow_helper.escrow_instance.as_str(),\n        300,\n    );\n\n    // try to create delegation for 1 week for user2\n    delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            3000,\n            WEEK,\n            \"token_1\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap();\n\n    // try to create delegation for 3 weeks for user3\n    delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            3000,\n            WEEK * 3,\n            \"token_2\".to_string(),\n            \"user3\".to_string(),\n        )\n        .unwrap();\n\n    // try to create delegation for 2 weeks for user1\n    let err = delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user3\",\n            3000,\n            WEEK * 2,\n            \"token_3\".to_string(),\n            \"user\".to_string(),\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        \"The delegation period must be at least a week and not more than a user lock period.\",\n        err.root_cause().to_string()\n    );\n\n    // try to create delegation for 1 week for user1\n    delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user3\",\n            3000,\n            WEEK,\n            \"token_3\".to_string(),\n            \"user\".to_string(),\n        )\n        .unwrap();\n\n    // check the user's NFT.\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_3\"], resp.tokens);\n\n    // check user's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(86_499_999), resp);\n\n    // check the user2's NFT.\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_1\"], resp.tokens);\n\n    // check user2's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(141_538_456), resp);\n\n    // check user3's nft tokens\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user3\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_2\"], resp.tokens);\n\n    // check user3's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user3\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(95_038_457), resp);\n\n    router_ref.update_block(|block_info| {\n        block_info.time = block_info.time.plus_seconds(WEEK);\n        block_info.height += 1;\n    });\n\n    // try to create delegation without free voting power\n    let err = delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user3\",\n            3000,\n            WEEK,\n            \"token_4\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap_err();\n\n    assert_eq!(\n        \"You can't delegate with zero voting power\",\n        err.root_cause().to_string()\n    );\n\n    // check user's adjusted balance when one delegation is expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(86_961_535), resp);\n\n    // check user2's adjusted balance when delegation expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(85_769_228), resp);\n\n    // check user3's adjusted balance when lock is expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user3\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(16_019_228), resp);\n\n    // try to transfer NFT with ID `token_1` from user1 to user3\n    let err = router_ref\n        .execute_contract(\n            Addr::unchecked(\"user1\"),\n            delegator_helper.nft_instance.clone(),\n            \u0026Cw721ExecuteMsg::TransferNft {\n                recipient: \"user3\".to_string(),\n                token_id: \"token_1\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n    assert_eq!(\"Unauthorized\", err.root_cause().to_string());\n\n    // try to transfer NFT with ID `token_1` from user2 to user3\n    router_ref\n        .execute_contract(\n            Addr::unchecked(\"user2\"),\n            delegator_helper.nft_instance.clone(),\n            \u0026Cw721ExecuteMsg::TransferNft {\n                recipient: \"user3\".to_string(),\n                token_id: \"token_1\".to_string(),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // check the user's NFT.\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_3\"], resp.tokens);\n\n    // check the user2's NFT.\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // check the user3's NFT.\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user3\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_1\", \"token_2\"], resp.tokens);\n\n    // check user's adjusted balance after transferred token\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(86_961_535), resp);\n\n    // check user2's adjusted balance when delegation expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(85_769_228), resp);\n\n    // check user3's adjusted balance when lock is expired and token_1 is expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user3\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(16_019_228), resp);\n\n    router_ref.update_block(|block_info| {\n        block_info.time = block_info.time.plus_seconds(WEEK * 8);\n        block_info.height += 1;\n    });\n\n    // check the user's NFT.\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_3\"], resp.tokens);\n\n    // check the user2's NFT.\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // check the user3's NFT.\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user3\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_1\", \"token_2\"], resp.tokens);\n\n    // check user's adjusted balance after transferred token\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(11_442_307), resp);\n\n    // check user2's adjusted balance when user2's lock and tokens are expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(0), resp);\n\n    // check user3's adjusted balance when user3's lock and tokens are expired\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user3\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(0), resp);\n}\n\n#[test]\nfn extend_delegation() {\n    let mut router = mock_app();\n    let router_ref = \u0026mut router;\n    let owner = Addr::unchecked(\"owner\");\n    let delegator_helper = Helper::init(router_ref, owner);\n\n    // Mint ASTRO, stake it and mint xASTRO\n    delegator_helper\n        .escrow_helper\n        .mint_xastro(router_ref, \"user\", 100);\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user\", 100);\n\n    // Create valid voting escrow lock\n    delegator_helper\n        .escrow_helper\n        .create_lock(router_ref, \"user\", WEEK * 5, 100f32)\n        .unwrap();\n\n    // Check that 90 xASTRO were actually debited\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user\", 0);\n    delegator_helper.escrow_helper.check_xastro_balance(\n        router_ref,\n        delegator_helper.escrow_helper.escrow_instance.as_str(),\n        100,\n    );\n\n    // Mint ASTRO, stake it and mint xASTRO\n    delegator_helper\n        .escrow_helper\n        .mint_xastro(router_ref, \"user2\", 100);\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user2\", 100);\n\n    // Create valid voting escrow lock\n    delegator_helper\n        .escrow_helper\n        .create_lock(router_ref, \"user2\", WEEK * 2, 100f32)\n        .unwrap();\n    // Check that 90 xASTRO were actually debited\n    delegator_helper\n        .escrow_helper\n        .check_xastro_balance(router_ref, \"user2\", 0);\n    delegator_helper.escrow_helper.check_xastro_balance(\n        router_ref,\n        delegator_helper.escrow_helper.escrow_instance.as_str(),\n        200,\n    );\n\n    // try to create delegation to user2\n    delegator_helper\n        .create_delegation(\n            router_ref,\n            \"user\",\n            5000,\n            WEEK * 3,\n            \"token_1\".to_string(),\n            \"user2\".to_string(),\n        )\n        .unwrap();\n\n    // check user's nft token\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // check user2's nft token\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_1\"], resp.tokens);\n\n    // check user's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(53_605_768), resp);\n\n    // check user2's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(156_490_381), resp);\n\n    router_ref.update_block(|block_info| {\n        block_info.time = block_info.time.plus_seconds(WEEK);\n        block_info.height += 1;\n    });\n\n    // check user's nft token\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // check user2's nft token\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_1\"], resp.tokens);\n\n    // check user's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(50_032_050), resp);\n\n    // check user2's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(87_179_485), resp);\n\n    // check's that we cannot create a delegation for a smaller amount\n    let err = delegator_helper\n        .extend_delegation(router_ref, \"user\", 4000, WEEK * 3, \"token_1\".to_string())\n        .unwrap_err();\n    assert_eq!(\n        \"New delegated voting power can not be less than it was previously.\",\n        err.root_cause().to_string()\n    );\n\n    // try to extend delegation period\n    delegator_helper\n        .extend_delegation(router_ref, \"user\", 6000, WEEK * 3, \"token_1\".to_string())\n        .unwrap();\n\n    // check user's nft token\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // check user2's nft token\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_1\"], resp.tokens);\n\n    // check user's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(34_307_693), resp);\n\n    // check user2's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(102_903_842), resp);\n\n    router_ref.update_block(|block_info| {\n        block_info.time = block_info.time.plus_seconds(WEEK * 3);\n        block_info.height += 1;\n    });\n\n    // check user's nft token\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user\", None, None)\n        .unwrap();\n    assert_eq!(EMPTY_TOKENS, resp.tokens);\n\n    // check user2's nft token\n    let resp = delegator_helper\n        .nft_helper\n        .tokens(\u0026router_ref.wrap().into(), \"user2\", None, None)\n        .unwrap();\n    assert_eq!(vec![\"token_1\"], resp.tokens);\n\n    // check user's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(21_442_307), resp);\n\n    // check user2's adjusted balance\n    let resp = delegator_helper\n        .adjusted_balance(router_ref, \"user2\", None)\n        .unwrap();\n    assert_eq!(Uint128::new(0), resp);\n\n    // try to extend delegation period\n    let err = delegator_helper\n        .extend_delegation(router_ref, \"user\", 9000, WEEK * 3, \"token_1\".to_string())\n        .unwrap_err();\n    assert_eq!(\n        \"The delegation period must be at least a week and not more than a user lock period.\",\n        err.root_cause().to_string()\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","tests","simulation.rs"],"content":"use anyhow::Result;\nuse astroport_governance::utils::WEEK;\n\nuse crate::test_helper::{mock_app, Helper};\nuse cosmwasm_std::Addr;\nuse cw_multi_test::{next_block, App, AppResponse};\n\nmod test_helper;\n\n#[derive(Clone, Debug)]\nenum Event {\n    CreateDelegation(u16, u64, String, String),\n    ExtendDelegation(u16, u64, String),\n}\n\nuse Event::*;\n\nstruct Simulator {\n    helper: Helper,\n    router: App,\n}\n\nimpl Simulator {\n    fn new() -\u003e Self {\n        let mut router = mock_app();\n        Self {\n            helper: Helper::init(\u0026mut router, Addr::unchecked(\"owner\")),\n            router,\n        }\n    }\n\n    fn mint(\u0026mut self, user: \u0026str, amount: u128) {\n        self.helper\n            .escrow_helper\n            .mint_xastro(\u0026mut self.router, user, amount as u64)\n    }\n\n    fn create_lock(\u0026mut self, user: \u0026str, amount: f64, interval: u64) -\u003e Result\u003cAppResponse\u003e {\n        self.helper\n            .escrow_helper\n            .create_lock(\u0026mut self.router, user, interval, amount as f32)\n    }\n\n    fn app_next_period(\u0026mut self) {\n        self.router.update_block(next_block);\n        self.router\n            .update_block(|block| block.time = block.time.plus_seconds(WEEK));\n    }\n\n    fn create_delegation(\n        \u0026mut self,\n        user: \u0026str,\n        bps: u16,\n        expire_time: u64,\n        token_id: String,\n        recipient: String,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        self.helper.create_delegation(\n            \u0026mut self.router,\n            user,\n            bps,\n            expire_time,\n            token_id,\n            recipient,\n        )\n    }\n\n    fn extend_delegation(\n        \u0026mut self,\n        user: \u0026str,\n        bps: u16,\n        expire_time: u64,\n        token_id: String,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        self.helper\n            .extend_delegation(\u0026mut self.router, user, bps, expire_time, token_id)\n    }\n\n    fn event_router(\u0026mut self, user: \u0026str, event: Event) {\n        println!(\"User {} Event {:?}\", user, event);\n        match event {\n            Event::CreateDelegation(bps, expire_time, token_id, recipient) =\u003e {\n                if let Err(err) =\n                    self.create_delegation(user, bps, expire_time, token_id, recipient)\n                {\n                    dbg!(err);\n                }\n            }\n            Event::ExtendDelegation(percentage, expire_time, token_id) =\u003e {\n                if let Err(err) = self.extend_delegation(user, percentage, expire_time, token_id) {\n                    dbg!(err);\n                }\n            }\n        }\n    }\n}\n\nuse proptest::prelude::*;\n\nconst MAX_PERIOD: usize = 10;\nconst MAX_USERS: usize = 6;\nconst MAX_TOKENS: usize = 10;\nconst MAX_EVENTS: usize = 100;\n\nfn events_strategy() -\u003e impl Strategy\u003cValue = Event\u003e {\n    prop_oneof![\n        (\n            1u16..=100u16,\n            1..MAX_PERIOD,\n            prop::collection::vec(\"[a-z]{4,32}\", 1..MAX_USERS),\n            prop::collection::vec(\"[t-z]{6,32}\", 1..MAX_TOKENS)\n        )\n            .prop_map(|(a, b, c, d)| {\n                Event::CreateDelegation(\n                    a,\n                    WEEK * b as u64,\n                    c.iter().next().unwrap().to_string(),\n                    d.iter().next().unwrap().to_string(),\n                )\n            }),\n        (\n            1u16..=100u16,\n            1..MAX_PERIOD,\n            prop::collection::vec(\"[t-z]{2,32}\", 1..MAX_TOKENS)\n        )\n            .prop_map(|(a, b, c)| {\n                Event::ExtendDelegation(a, WEEK * b as u64, c.iter().next().unwrap().to_string())\n            }),\n    ]\n}\n\nfn generate_cases() -\u003e impl Strategy\u003cValue = (Vec\u003cString\u003e, Vec\u003c(usize, String, String, Event)\u003e)\u003e {\n    let users_strategy = prop::collection::vec(\"[a-z]{4,32}\", 1..MAX_USERS);\n\n    users_strategy.prop_flat_map(|users| {\n        (\n            Just(users.clone()),\n            prop::collection::vec(\n                (\n                    1..=MAX_PERIOD,\n                    prop::sample::select(users.clone()),\n                    prop::sample::select(users.clone()),\n                    events_strategy(),\n                ),\n                0..MAX_EVENTS,\n            ),\n        )\n    })\n}\n\nproptest! {\n    #[test]\n    fn run_simulations\n    (\n        case in generate_cases()\n    ) {\n        let mut events: Vec\u003cVec\u003c(String, String, Event)\u003e\u003e = vec![vec![]; MAX_PERIOD + 1];\n        let (users, events_tuples) = case;\n        for (period, user, recipient, event) in events_tuples {\n            events[period].push((user.to_string(), recipient.to_string(), event));\n        }\n\n        let mut simulator = Simulator::new();\n        for user in users {\n            simulator.mint(user.as_str(), 10000);\n            simulator.create_lock(user.as_str(), 500 as f64, WEEK * 11).unwrap();\n        }\n\n        for period in 1..=MAX_PERIOD {\n            if let Some(period_events) = events.get(period) {\n                if !period_events.is_empty() {\n                    println!(\"Period {}:\", period);\n                }\n                for (user, recipient, event) in period_events {\n                    // check user's balance before the delegation\n                    let user_balance_before = simulator\n                        .helper\n                        .adjusted_balance(\u0026mut simulator.router, user, None)\n                        .unwrap();\n\n                    // check user's delegated balance before the delegation\n                    let user_delegated_balance_before = simulator\n                        .helper\n                        .delegated_balance(\u0026mut simulator.router, user, None)\n                        .unwrap();\n\n                    // check recipient's balance before the delegation\n                    let recipient_balance_before = simulator\n                        .helper\n                        .adjusted_balance(\u0026mut simulator.router, recipient, None)\n                        .unwrap();\n\n                    // check recipient's delegated balance before the delegation\n                    let recipient_delegated_balance_before = simulator\n                        .helper\n                        .delegated_balance(\u0026mut simulator.router, recipient, None)\n                        .unwrap();\n\n                    // try to execute user's event\n                    simulator.event_router(user, event.clone());\n\n                    // check user's balance after the delegation\n                    let user_balance_after = simulator\n                        .helper\n                        .adjusted_balance(\u0026mut simulator.router, user, None)\n                        .unwrap();\n\n                    // check user's delegated balance\n                    let user_delegated_balance_after = simulator\n                        .helper\n                        .delegated_balance(\u0026mut simulator.router, user, None)\n                        .unwrap();\n\n                    // check recipient's balance after the delegation\n                    let recipient_balance_after = simulator\n                        .helper\n                        .adjusted_balance(\u0026mut simulator.router, recipient, None)\n                        .unwrap();\n\n                     // check recipient's delegated balance after the delegation\n                    let recipient_delegated_balance_after = simulator\n                        .helper\n                        .delegated_balance(\u0026mut simulator.router, recipient, None)\n                        .unwrap();\n\n                    // check user's balance\n                    assert_eq!(\n                        user_balance_after,\n                        user_balance_before\n                            - (user_delegated_balance_after - user_delegated_balance_before)\n                    );\n\n                    // check recipient's balance\n                    assert_eq!(\n                        recipient_balance_after,\n                        recipient_balance_before\n                            - (recipient_delegated_balance_after - recipient_delegated_balance_before)\n                    );\n                }\n            }\n\n            simulator.app_next_period()\n        }\n    }\n}\n\n#[test]\nfn exact_simulation() {\n    let case = (\n        [\"user1\", \"user2\"],\n        [\n            (\n                1,\n                \"user1\",\n                \"user2\",\n                CreateDelegation(10000, WEEK * 2, \"token_1\".to_string(), \"user2\".to_string()),\n            ),\n            (\n                1,\n                \"user2\",\n                \"user1\",\n                CreateDelegation(5000, WEEK * 2, \"token_2\".to_string(), \"user1\".to_string()),\n            ),\n            (\n                2,\n                \"user2\",\n                \"user1\",\n                CreateDelegation(3000, WEEK * 2, \"token_3\".to_string(), \"user1\".to_string()),\n            ),\n            (\n                3,\n                \"user2\",\n                \"user1\",\n                ExtendDelegation(7000, WEEK * 5, \"token_2\".to_string()),\n            ),\n            (\n                4,\n                \"user1\",\n                \"user2\",\n                ExtendDelegation(6000, WEEK * 4, \"token_1\".to_string()),\n            ),\n            (\n                5,\n                \"user1\",\n                \"user3\",\n                CreateDelegation(10000, WEEK * 4, \"token_4\".to_string(), \"user3\".to_string()),\n            ),\n            (\n                6,\n                \"user2\",\n                \"user1\",\n                CreateDelegation(10000, WEEK * 4, \"token_5\".to_string(), \"user1\".to_string()),\n            ),\n        ],\n    );\n\n    let mut events: Vec\u003cVec\u003c(String, String, Event)\u003e\u003e = vec![vec![]; MAX_PERIOD + 1];\n    let (users, events_tuples) = case;\n    for (period, user, recipient, event) in events_tuples {\n        events[period].push((user.to_string(), recipient.to_string(), event));\n    }\n\n    let mut simulator = Simulator::new();\n    for user in users {\n        simulator.mint(user, 10000);\n        simulator.create_lock(user, 500 as f64, WEEK * 10).unwrap();\n    }\n\n    for period in 1..=MAX_PERIOD {\n        if let Some(period_events) = events.get(period) {\n            if !period_events.is_empty() {\n                println!(\"Period {}:\", period);\n            }\n            for (user, recipient, event) in period_events {\n                // check user's balance before the delegation\n                let user_balance_before = simulator\n                    .helper\n                    .adjusted_balance(\u0026mut simulator.router, user, None)\n                    .unwrap();\n\n                let user_delegated_balance_before = simulator\n                    .helper\n                    .delegated_balance(\u0026mut simulator.router, user, None)\n                    .unwrap();\n\n                // check recipient's balance before the delegation\n                let recipient_balance_before = simulator\n                    .helper\n                    .adjusted_balance(\u0026mut simulator.router, recipient, None)\n                    .unwrap();\n\n                // try to execute user's event\n                simulator.event_router(user, event.clone());\n\n                // check user's balance after the delegation\n                let user_balance_after = simulator\n                    .helper\n                    .adjusted_balance(\u0026mut simulator.router, user, None)\n                    .unwrap();\n\n                // check user's delegated balance\n                let user_delegated_balance_after = simulator\n                    .helper\n                    .delegated_balance(\u0026mut simulator.router, user, None)\n                    .unwrap();\n\n                // check recipient's balance after the delegation\n                let recipient_balance_after = simulator\n                    .helper\n                    .adjusted_balance(\u0026mut simulator.router, recipient, None)\n                    .unwrap();\n\n                // check user's balance\n                assert_eq!(\n                    user_balance_after,\n                    user_balance_before\n                        - (user_delegated_balance_after - user_delegated_balance_before)\n                );\n\n                // check recipient's balance\n                assert_eq!(\n                    recipient_balance_after,\n                    recipient_balance_before\n                        + (user_delegated_balance_after - user_delegated_balance_before)\n                );\n            }\n        }\n\n        simulator.app_next_period()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","contracts","voting_escrow_delegation","tests","test_helper.rs"],"content":"use anyhow::Result;\nuse astroport_governance::utils::EPOCH_START;\nuse astroport_governance::voting_escrow_delegation::Config;\nuse astroport_governance::voting_escrow_delegation::{InstantiateMsg, QueryMsg};\nuse astroport_tests::escrow_helper::EscrowHelper;\nuse cosmwasm_std::{to_binary, Addr, Empty, QueryRequest, StdResult, Uint128, WasmQuery};\nuse cw_multi_test::{App, AppResponse, Contract, ContractWrapper, Executor};\n\nuse astroport_governance::voting_escrow_delegation::ExecuteMsg;\nuse cw721_base::helpers::Cw721Contract;\n\npub struct Helper {\n    pub escrow_helper: EscrowHelper,\n    pub delegation_instance: Addr,\n    pub nft_instance: Addr,\n    pub nft_helper: Cw721Contract\u003cEmpty, Empty\u003e,\n}\n\nimpl Helper {\n    pub fn contract_escrow_delegation_template() -\u003e Box\u003cdyn Contract\u003cEmpty\u003e\u003e {\n        let contract = ContractWrapper::new_with_empty(\n            voting_escrow_delegation::contract::execute,\n            voting_escrow_delegation::contract::instantiate,\n            voting_escrow_delegation::contract::query,\n        )\n        .with_reply_empty(voting_escrow_delegation::contract::reply);\n        Box::new(contract)\n    }\n\n    pub fn contract_nft_template() -\u003e Box\u003cdyn Contract\u003cEmpty\u003e\u003e {\n        let contract = ContractWrapper::new(\n            astroport_nft::contract::execute,\n            astroport_nft::contract::instantiate,\n            astroport_nft::contract::query,\n        );\n        Box::new(contract)\n    }\n\n    fn instantiate_delegation(\n        router: \u0026mut App,\n        owner: Addr,\n        escrow_addr: Addr,\n        delegation_id: u64,\n        nft_id: u64,\n    ) -\u003e (Addr, Addr) {\n        let delegation_addr = router\n            .instantiate_contract(\n                delegation_id,\n                owner.clone(),\n                \u0026InstantiateMsg {\n                    owner: owner.to_string(),\n                    nft_code_id: nft_id,\n                    voting_escrow_addr: escrow_addr.to_string(),\n                },\n                \u0026[],\n                String::from(\"Astroport Escrow Delegation\"),\n                None,\n            )\n            .unwrap();\n\n        let res = router\n            .wrap()\n            .query::\u003cConfig\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                contract_addr: delegation_addr.to_string(),\n                msg: to_binary(\u0026QueryMsg::Config {}).unwrap(),\n            }))\n            .unwrap();\n\n        (delegation_addr, res.nft_addr)\n    }\n\n    pub fn init(router: \u0026mut App, owner: Addr) -\u003e Self {\n        let escrow_helper = EscrowHelper::init(router, owner.clone());\n\n        let delegation_id = router.store_code(Helper::contract_escrow_delegation_template());\n        let nft_id = router.store_code(Helper::contract_nft_template());\n\n        let (delegation_addr, nft_addr) = Helper::instantiate_delegation(\n            router,\n            owner,\n            escrow_helper.escrow_instance.clone(),\n            delegation_id,\n            nft_id,\n        );\n\n        let nft_helper = cw721_base::helpers::Cw721Contract(\n            nft_addr.clone(),\n            Default::default(),\n            Default::default(),\n        );\n\n        escrow_helper.mint_xastro(router, \"owner\", 1001);\n\n        Helper {\n            escrow_helper,\n            delegation_instance: delegation_addr,\n            nft_instance: nft_addr,\n            nft_helper,\n        }\n    }\n\n    pub fn create_delegation(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        bps: u16,\n        expire_time: u64,\n        token_id: String,\n        recipient: String,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.delegation_instance.clone(),\n            \u0026ExecuteMsg::CreateDelegation {\n                bps,\n                expire_time,\n                token_id,\n                recipient,\n            },\n            \u0026[],\n        )\n    }\n\n    pub fn extend_delegation(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        bps: u16,\n        expire_time: u64,\n        token_id: String,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.delegation_instance.clone(),\n            \u0026ExecuteMsg::ExtendDelegation {\n                bps,\n                expire_time,\n                token_id,\n            },\n            \u0026[],\n        )\n    }\n\n    pub fn adjusted_balance(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        timestamp: Option\u003cu64\u003e,\n    ) -\u003e StdResult\u003cUint128\u003e {\n        router\n            .wrap()\n            .query::\u003cUint128\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                contract_addr: self.delegation_instance.to_string(),\n                msg: to_binary(\u0026QueryMsg::AdjustedBalance {\n                    account: user.to_string(),\n                    timestamp,\n                })\n                .unwrap(),\n            }))\n    }\n\n    pub fn delegated_balance(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        timestamp: Option\u003cu64\u003e,\n    ) -\u003e StdResult\u003cUint128\u003e {\n        router\n            .wrap()\n            .query::\u003cUint128\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                contract_addr: self.delegation_instance.to_string(),\n                msg: to_binary(\u0026QueryMsg::DelegatedVotingPower {\n                    account: user.to_string(),\n                    timestamp,\n                })\n                .unwrap(),\n            }))\n    }\n}\n\npub fn mock_app() -\u003e App {\n    let mut app = App::default();\n\n    app.update_block(|bi| {\n        bi.time = bi.time.plus_seconds(EPOCH_START);\n        bi.height += 1;\n    });\n\n    app\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","assembly.rs"],"content":"// TODO: DO NOT COMMIT\nuse crate::assembly::helpers::is_safe_link;\nuse cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::{Addr, CosmosMsg, Decimal, StdError, StdResult, Uint128, Uint64};\nuse cw20::Cw20ReceiveMsg;\nuse std::fmt::{Display, Formatter, Result};\nuse std::str::FromStr;\n\n#[cfg(not(feature = \"testnet\"))]\nmod proposal_constants {\n    use std::ops::RangeInclusive;\n\n    pub const MINIMUM_PROPOSAL_REQUIRED_THRESHOLD_PERCENTAGE: u64 = 33;\n    pub const MAX_PROPOSAL_REQUIRED_THRESHOLD_PERCENTAGE: u64 = 100;\n    pub const MAX_PROPOSAL_REQUIRED_QUORUM_PERCENTAGE: \u0026str = \"1\";\n    pub const MINIMUM_PROPOSAL_REQUIRED_QUORUM_PERCENTAGE: \u0026str = \"0.01\";\n    pub const VOTING_PERIOD_INTERVAL: RangeInclusive\u003cu64\u003e = 12342..=7 * 12342;\n    // from 0.5 to 1 day in blocks (7 seconds per block)\n    pub const DELAY_INTERVAL: RangeInclusive\u003cu64\u003e = 6171..=14400;\n    pub const EXPIRATION_PERIOD_INTERVAL: RangeInclusive\u003cu64\u003e = 12342..=100_800;\n    // from 10k to 60k $xASTRO\n    pub const DEPOSIT_INTERVAL: RangeInclusive\u003cu128\u003e = 10000000000..=60000000000;\n}\n\n#[cfg(feature = \"testnet\")]\nmod proposal_constants {\n    use std::ops::RangeInclusive;\n\n    pub const MINIMUM_PROPOSAL_REQUIRED_THRESHOLD_PERCENTAGE: u64 = 33;\n    pub const MAX_PROPOSAL_REQUIRED_THRESHOLD_PERCENTAGE: u64 = 100;\n    pub const MAX_PROPOSAL_REQUIRED_QUORUM_PERCENTAGE: \u0026str = \"1\";\n    pub const MINIMUM_PROPOSAL_REQUIRED_QUORUM_PERCENTAGE: \u0026str = \"0.001\";\n    pub const VOTING_PERIOD_INTERVAL: RangeInclusive\u003cu64\u003e = 200..=7 * 12342;\n    // from ~350 sec to 1 day in blocks (7 seconds per block)\n    pub const DELAY_INTERVAL: RangeInclusive\u003cu64\u003e = 50..=14400;\n    pub const EXPIRATION_PERIOD_INTERVAL: RangeInclusive\u003cu64\u003e = 400..=100_800;\n    // from 0.001 to 60k $xASTRO\n    pub const DEPOSIT_INTERVAL: RangeInclusive\u003cu128\u003e = 1000..=60000000000;\n}\n\npub use proposal_constants::*;\n\n/// Proposal validation attributes\nconst MIN_TITLE_LENGTH: usize = 4;\nconst MAX_TITLE_LENGTH: usize = 64;\nconst MIN_DESC_LENGTH: usize = 4;\nconst MAX_DESC_LENGTH: usize = 1024;\nconst MIN_LINK_LENGTH: usize = 12;\nconst MAX_LINK_LENGTH: usize = 128;\n\n/// Special characters that are allowed in proposal text\nconst SAFE_TEXT_CHARS: \u0026str = \"!\u0026?#()*+'-./\\\"\";\n\n/// This structure holds the parameters used for creating an Assembly contract.\n#[cw_serde]\npub struct InstantiateMsg {\n    /// Address of xASTRO token\n    pub xastro_token_addr: String,\n    /// Address of vxASTRO token\n    pub vxastro_token_addr: Option\u003cString\u003e,\n    /// Voting Escrow delegator address\n    pub voting_escrow_delegator_addr: Option\u003cString\u003e,\n    /// Astroport IBC controller contract\n    pub ibc_controller: Option\u003cString\u003e,\n    /// Generator controller contract capable of immediate proposals\n    pub generator_controller_addr: Option\u003cString\u003e,\n    /// Hub contract that handles voting from Outposts\n    pub hub_addr: Option\u003cString\u003e,\n    /// Address of the builder unlock contract\n    pub builder_unlock_addr: String,\n    /// Proposal voting period\n    pub proposal_voting_period: u64,\n    /// Proposal effective delay\n    pub proposal_effective_delay: u64,\n    /// Proposal expiration period\n    pub proposal_expiration_period: u64,\n    /// Proposal required deposit\n    pub proposal_required_deposit: Uint128,\n    /// Proposal required quorum\n    pub proposal_required_quorum: String,\n    /// Proposal required threshold\n    pub proposal_required_threshold: String,\n    /// Whitelisted links\n    pub whitelisted_links: Vec\u003cString\u003e,\n}\n\n/// This enum describes all execute functions available in the contract.\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Receive a message of type [`Cw20ReceiveMsg`]\n    Receive(Cw20ReceiveMsg),\n    /// Cast a vote for an active proposal\n    CastVote {\n        /// Proposal identifier\n        proposal_id: u64,\n        /// Vote option\n        vote: ProposalVoteOption,\n    },\n    /// Cast a vote on an Assembly proposal from an Outpost via the Hub\n    CastOutpostVote {\n        /// Proposal identifier\n        proposal_id: u64,\n        /// The voter from an Outpost\n        voter: Addr,\n        /// The vote option\n        vote: ProposalVoteOption,\n        /// The voting power applied to this vote\n        voting_power: Uint128,\n    },\n    /// Set the status of a proposal that expired\n    EndProposal {\n        /// Proposal identifier\n        proposal_id: u64,\n    },\n    /// Checks that proposal messages are correct.\n    CheckMessages {\n        /// messages\n        messages: Vec\u003cCosmosMsg\u003e,\n    },\n    /// The last endpoint which is executed only if all proposal messages have been passed\n    CheckMessagesPassed {},\n    /// Execute a successful proposal\n    ExecuteProposal {\n        /// Proposal identifier\n        proposal_id: u64,\n    },\n    /// Load and execute a special emissions proposal. This proposal is passed\n    /// immediately and is not subject to voting as it is coming from the\n    /// generator controller based on emission votes.\n    ExecuteEmissionsProposal {\n        title: String,\n        description: String,\n        messages: Vec\u003cCosmosMsg\u003e,\n        /// If proposal should be executed on a remote chain this field should specify governance channel\n        ibc_channel: Option\u003cString\u003e,\n    },\n    /// Remove a proposal that was already executed (or failed/expired)\n    RemoveCompletedProposal {\n        /// Proposal identifier\n        proposal_id: u64,\n    },\n    /// Update parameters in the Assembly contract\n    /// ## Executor\n    /// Only the Assembly contract is allowed to update its own parameters\n    UpdateConfig(Box\u003cUpdateConfig\u003e),\n    /// Update proposal status InProgress -\u003e Executed or Failed.\n    /// ## Executor\n    /// Only the IBC controller contract is allowed to call this method.\n    IBCProposalCompleted {\n        proposal_id: u64,\n        status: ProposalStatus,\n    },\n}\n\n/// Thie enum describes all the queries available in the contract.\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// Return the contract's configuration\n    #[returns(Config)]\n    Config {},\n    /// Return the current list of proposals\n    #[returns(ProposalListResponse)]\n    Proposals {\n        /// Id from which to start querying\n        start: Option\u003cu64\u003e,\n        /// The amount of proposals to return\n        limit: Option\u003cu32\u003e,\n    },\n    /// Return proposal voters of specified proposal\n    #[returns(Vec\u003cAddr\u003e)]\n    ProposalVoters {\n        /// Proposal unique id\n        proposal_id: u64,\n        /// Proposal vote option\n        vote_option: ProposalVoteOption,\n        /// Id from which to start querying\n        start: Option\u003cu64\u003e,\n        /// The amount of proposals to return\n        limit: Option\u003cu32\u003e,\n    },\n    /// Return information about a specific proposal\n    #[returns(Proposal)]\n    Proposal { proposal_id: u64 },\n    /// Return information about the votes cast on a specific proposal\n    #[returns(ProposalVotesResponse)]\n    ProposalVotes { proposal_id: u64 },\n    /// Return user voting power for a specific proposal\n    #[returns(Uint128)]\n    UserVotingPower { user: String, proposal_id: u64 },\n    /// Return total voting power for a specific proposal\n    #[returns(Uint128)]\n    TotalVotingPower { proposal_id: u64 },\n}\n\n/// This structure stores data for a CW20 hook message.\n#[cw_serde]\npub enum Cw20HookMsg {\n    /// Submit a new proposal in the Assembly\n    SubmitProposal {\n        title: String,\n        description: String,\n        link: Option\u003cString\u003e,\n        messages: Option\u003cVec\u003cCosmosMsg\u003e\u003e,\n        /// If proposal should be executed on a remote chain this field should specify governance channel\n        ibc_channel: Option\u003cString\u003e,\n    },\n}\n\n/// This structure stores general parameters for the Assembly contract.\n#[cw_serde]\npub struct Config {\n    /// xASTRO token address\n    pub xastro_token_addr: Addr,\n    /// vxASTRO token address\n    pub vxastro_token_addr: Option\u003cAddr\u003e,\n    /// Voting Escrow delegator address\n    pub voting_escrow_delegator_addr: Option\u003cAddr\u003e,\n    /// Astroport IBC controller contract\n    pub ibc_controller: Option\u003cAddr\u003e,\n    /// Generator controller contract capable of immediate proposals\n    pub generator_controller: Option\u003cAddr\u003e,\n    /// Hub contract that handles voting from Outposts\n    pub hub: Option\u003cAddr\u003e,\n    /// Builder unlock contract address\n    pub builder_unlock_addr: Addr,\n    /// Proposal voting period\n    pub proposal_voting_period: u64,\n    /// Proposal effective delay\n    pub proposal_effective_delay: u64,\n    /// Proposal expiration period\n    pub proposal_expiration_period: u64,\n    /// Proposal required deposit\n    pub proposal_required_deposit: Uint128,\n    /// Proposal required quorum\n    pub proposal_required_quorum: Decimal,\n    /// Proposal required threshold\n    pub proposal_required_threshold: Decimal,\n    /// Whitelisted links\n    pub whitelisted_links: Vec\u003cString\u003e,\n}\n\nimpl Config {\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        if self.proposal_required_threshold\n            \u003e Decimal::percent(MAX_PROPOSAL_REQUIRED_THRESHOLD_PERCENTAGE)\n            || self.proposal_required_threshold\n                \u003c Decimal::percent(MINIMUM_PROPOSAL_REQUIRED_THRESHOLD_PERCENTAGE)\n        {\n            return Err(StdError::generic_err(format!(\n                \"The required threshold for a proposal cannot be lower than {MINIMUM_PROPOSAL_REQUIRED_THRESHOLD_PERCENTAGE}% or higher than {MAX_PROPOSAL_REQUIRED_THRESHOLD_PERCENTAGE}%\"\n            )));\n        }\n\n        let max_quorum = Decimal::from_str(MAX_PROPOSAL_REQUIRED_QUORUM_PERCENTAGE)?;\n        let min_quorum = Decimal::from_str(MINIMUM_PROPOSAL_REQUIRED_QUORUM_PERCENTAGE)?;\n        if self.proposal_required_quorum \u003e max_quorum || self.proposal_required_quorum \u003c min_quorum\n        {\n            return Err(StdError::generic_err(format!(\n                \"The required quorum for a proposal cannot be lower than {}% or higher than {}%\",\n                min_quorum * Decimal::from_ratio(100u8, 1u8),\n                max_quorum * Decimal::from_ratio(100u8, 1u8)\n            )));\n        }\n\n        if !DELAY_INTERVAL.contains(\u0026self.proposal_effective_delay) {\n            return Err(StdError::generic_err(format!(\n                \"The effective delay for a proposal cannot be lower than {} or higher than {}\",\n                DELAY_INTERVAL.start(),\n                DELAY_INTERVAL.end()\n            )));\n        }\n\n        if !EXPIRATION_PERIOD_INTERVAL.contains(\u0026self.proposal_expiration_period) {\n            return Err(StdError::generic_err(format!(\n                \"The expiration period for a proposal cannot be lower than {} or higher than {}\",\n                EXPIRATION_PERIOD_INTERVAL.start(),\n                EXPIRATION_PERIOD_INTERVAL.end()\n            )));\n        }\n\n        if !VOTING_PERIOD_INTERVAL.contains(\u0026self.proposal_voting_period) {\n            return Err(StdError::generic_err(format!(\n                \"The voting period for a proposal should be more than {} or less than {} blocks.\",\n                VOTING_PERIOD_INTERVAL.start(),\n                VOTING_PERIOD_INTERVAL.end()\n            )));\n        }\n\n        if !DEPOSIT_INTERVAL.contains(\u0026self.proposal_required_deposit.u128()) {\n            return Err(StdError::generic_err(format!(\n                \"The required deposit for a proposal cannot be lower than {} or higher than {}\",\n                DEPOSIT_INTERVAL.start(),\n                DEPOSIT_INTERVAL.end()\n            )));\n        }\n\n        if self.voting_escrow_delegator_addr.is_some() \u0026\u0026 self.vxastro_token_addr.is_none() {\n            return Err(StdError::generic_err(\n                \"The Voting Escrow contract should be specified to use the Voting Escrow Delegator contract.\"\n            ));\n        }\n\n        Ok(())\n    }\n}\n\n/// This structure stores the params used when updating the main Assembly contract params.\n#[cw_serde]\npub struct UpdateConfig {\n    /// xASTRO token address\n    pub xastro_token_addr: Option\u003cString\u003e,\n    /// vxASTRO token address\n    pub vxastro_token_addr: Option\u003cString\u003e,\n    /// Voting Escrow delegator address\n    pub voting_escrow_delegator_addr: Option\u003cString\u003e,\n    /// Astroport IBC controller contract\n    pub ibc_controller: Option\u003cString\u003e,\n    /// Generator controller contract capable of immediate proposals\n    pub generator_controller: Option\u003cString\u003e,\n    /// Hub contract that handles voting from Outposts\n    pub hub: Option\u003cString\u003e,\n    /// Builder unlock contract address\n    pub builder_unlock_addr: Option\u003cString\u003e,\n    /// Proposal voting period\n    pub proposal_voting_period: Option\u003cu64\u003e,\n    /// Proposal effective delay\n    pub proposal_effective_delay: Option\u003cu64\u003e,\n    /// Proposal expiration period\n    pub proposal_expiration_period: Option\u003cu64\u003e,\n    /// Proposal required deposit\n    pub proposal_required_deposit: Option\u003cu128\u003e,\n    /// Proposal required quorum\n    pub proposal_required_quorum: Option\u003cString\u003e,\n    /// Proposal required threshold\n    pub proposal_required_threshold: Option\u003cString\u003e,\n    /// Links to remove from whitelist\n    pub whitelist_remove: Option\u003cVec\u003cString\u003e\u003e,\n    /// Links to add to whitelist\n    pub whitelist_add: Option\u003cVec\u003cString\u003e\u003e,\n}\n\n/// This structure stores data for a proposal.\n#[cw_serde]\npub struct Proposal {\n    /// Unique proposal ID\n    pub proposal_id: Uint64,\n    /// The address of the proposal submitter\n    pub submitter: Addr,\n    /// Status of the proposal\n    pub status: ProposalStatus,\n    /// `For` power of proposal\n    pub for_power: Uint128,\n    /// `Against` power of proposal\n    pub against_power: Uint128,\n    /// `For` votes for the proposal\n    pub for_voters: Vec\u003cAddr\u003e,\n    /// `Against` votes for the proposal\n    pub against_voters: Vec\u003cAddr\u003e,\n    /// Start block of proposal\n    pub start_block: u64,\n    /// Start time of proposal\n    pub start_time: u64,\n    /// End block of proposal\n    pub end_block: u64,\n    /// Delayed end block of proposal\n    pub delayed_end_block: u64,\n    /// Expiration block of proposal\n    pub expiration_block: u64,\n    /// Proposal title\n    pub title: String,\n    /// Proposal description\n    pub description: String,\n    /// Proposal link\n    pub link: Option\u003cString\u003e,\n    /// Proposal messages\n    pub messages: Option\u003cVec\u003cCosmosMsg\u003e\u003e,\n    /// Amount of xASTRO deposited in order to post the proposal\n    pub deposit_amount: Uint128,\n    /// IBC channel\n    pub ibc_channel: Option\u003cString\u003e,\n}\n\nimpl Proposal {\n    pub fn validate(\u0026self, whitelisted_links: Vec\u003cString\u003e) -\u003e StdResult\u003c()\u003e {\n        // Title validation\n        if self.title.len() \u003c MIN_TITLE_LENGTH {\n            return Err(StdError::generic_err(\"Title too short!\"));\n        }\n        if self.title.len() \u003e MAX_TITLE_LENGTH {\n            return Err(StdError::generic_err(\"Title too long!\"));\n        }\n        if !self.title.chars().all(|c| {\n            c.is_ascii_alphanumeric() || c.is_ascii_whitespace() || SAFE_TEXT_CHARS.contains(c)\n        }) {\n            return Err(StdError::generic_err(\n                \"Title is not in alphanumeric format!\",\n            ));\n        }\n\n        // Description validation\n        if self.description.len() \u003c MIN_DESC_LENGTH {\n            return Err(StdError::generic_err(\"Description too short!\"));\n        }\n        if self.description.len() \u003e MAX_DESC_LENGTH {\n            return Err(StdError::generic_err(\"Description too long!\"));\n        }\n        if !self.description.chars().all(|c| {\n            c.is_ascii_alphanumeric() || c.is_ascii_whitespace() || SAFE_TEXT_CHARS.contains(c)\n        }) {\n            return Err(StdError::generic_err(\n                \"Description is not in alphanumeric format\",\n            ));\n        }\n\n        // Link validation\n        if let Some(link) = \u0026self.link {\n            if link.len() \u003c MIN_LINK_LENGTH {\n                return Err(StdError::generic_err(\"Link too short!\"));\n            }\n            if link.len() \u003e MAX_LINK_LENGTH {\n                return Err(StdError::generic_err(\"Link too long!\"));\n            }\n            if !whitelisted_links.iter().any(|wl| link.starts_with(wl)) {\n                return Err(StdError::generic_err(\"Link is not whitelisted!\"));\n            }\n            if !is_safe_link(link) {\n                return Err(StdError::generic_err(\n                    \"Link is not properly formatted or contains unsafe characters!\",\n                ));\n            }\n        }\n\n        Ok(())\n    }\n}\n\n/// This enum describes available statuses/states for a Proposal.\n#[cw_serde]\npub enum ProposalStatus {\n    Active,\n    Passed,\n    Rejected,\n    InProgress,\n    Failed,\n    Executed,\n    Expired,\n}\n\nimpl Display for ProposalStatus {\n    fn fmt(\u0026self, fmt: \u0026mut Formatter) -\u003e Result {\n        match self {\n            ProposalStatus::Active {} =\u003e fmt.write_str(\"active\"),\n            ProposalStatus::Passed {} =\u003e fmt.write_str(\"passed\"),\n            ProposalStatus::Rejected {} =\u003e fmt.write_str(\"rejected\"),\n            ProposalStatus::InProgress =\u003e fmt.write_str(\"in_progress\"),\n            ProposalStatus::Failed =\u003e fmt.write_str(\"failed\"),\n            ProposalStatus::Executed {} =\u003e fmt.write_str(\"executed\"),\n            ProposalStatus::Expired {} =\u003e fmt.write_str(\"expired\"),\n        }\n    }\n}\n\n/// This structure describes a proposal vote.\n#[cw_serde]\npub struct ProposalVote {\n    /// Voted option for the proposal\n    pub option: ProposalVoteOption,\n    /// Vote power\n    pub power: Uint128,\n}\n\n/// This enum describes available options for voting on a proposal.\n#[cw_serde]\npub enum ProposalVoteOption {\n    For,\n    Against,\n}\n\nimpl Display for ProposalVoteOption {\n    fn fmt(\u0026self, fmt: \u0026mut Formatter) -\u003e Result {\n        match self {\n            ProposalVoteOption::For {} =\u003e fmt.write_str(\"for\"),\n            ProposalVoteOption::Against {} =\u003e fmt.write_str(\"against\"),\n        }\n    }\n}\n\n/// This structure describes a proposal vote response.\n#[cw_serde]\npub struct ProposalVotesResponse {\n    /// Proposal identifier\n    pub proposal_id: u64,\n    /// Total amount of `for` votes for a proposal\n    pub for_power: Uint128,\n    /// Total amount of `against` votes for a proposal.\n    pub against_power: Uint128,\n}\n\n/// This structure describes a proposal list response.\n#[cw_serde]\npub struct ProposalListResponse {\n    /// The amount of proposals returned\n    pub proposal_count: Uint64,\n    /// The list of proposals that are returned\n    pub proposal_list: Vec\u003cProposal\u003e,\n}\n\npub mod helpers {\n    use cosmwasm_std::{StdError, StdResult};\n\n    const SAFE_LINK_CHARS: \u0026str = \"-_:/?#@!$\u0026()*+,;=.~[]'%\";\n\n    /// Checks if the link is valid. Returns a boolean value.\n    pub fn is_safe_link(link: \u0026str) -\u003e bool {\n        link.chars()\n            .all(|c| c.is_ascii_alphanumeric() || SAFE_LINK_CHARS.contains(c))\n    }\n\n    /// Validating the list of links. Returns an error if a list has an invalid link.\n    pub fn validate_links(links: \u0026[String]) -\u003e StdResult\u003c()\u003e {\n        for link in links {\n            if !(is_safe_link(link) \u0026\u0026 link.contains('.') \u0026\u0026 link.ends_with('/')) {\n                return Err(StdError::generic_err(format!(\n                    \"Link is not properly formatted or contains unsafe characters: {link}.\"\n                )));\n            }\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":244,"address":[6554112],"length":1,"stats":{"Line":0},"fn_name":"validate"},{"line":245,"address":[6554201,6554151,6554291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[6554163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[6554277,6554227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[6554239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[6554402],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[6554806,6554664,6554320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[6554728,6554962,6554874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[6554938,6555030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[6555211,6555311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[6555120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[6555254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[6555085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[6555592,6555637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[6555571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[6555616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[6555536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[6555961,6555916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[6555895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[6555940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[6555860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[6556311,6556266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[6556245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[6556290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[6556184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[6556580,6556625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[6556559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[6556604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[6556536,6556840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[6556906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[6556895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[6556976,6558502],"length":1,"stats":{"Line":0},"fn_name":"validate"},{"line":387,"address":[6557034,6557108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[6557144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[6557122,6557228],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[6557272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[6557242,6557350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[6923405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[6557474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[6557544,6557452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[6557580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[6557650,6557558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[6557693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[6557768,6557666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[6923517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[6557891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[6557852,6557958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[6558016,6557966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[6558039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[6558106,6558027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[6558143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[6558122,6558215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[6558338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[6558410,6558321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[6558440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[6557994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[6558544],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":452,"address":[6558562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[6558597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[6558630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[6558663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[6558693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[6558723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[6558753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[6558783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[6558832],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":482,"address":[6558851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[6558869],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[6558900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[6942256],"length":1,"stats":{"Line":0},"fn_name":"is_safe_link"},{"line":516,"address":[6942270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[7440640,7440653],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":521,"address":[6942320],"length":1,"stats":{"Line":0},"fn_name":"validate_links"},{"line":522,"address":[6942377,6942451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[6942461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[6942589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[6942440],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":77},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","builder_unlock.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, StdError, Uint128};\n\n/// This structure stores general parameters for the builder unlock contract.\n#[cw_serde]\npub struct Config {\n    /// Account that can create new unlock schedules\n    pub owner: Addr,\n    /// Address of ASTRO token\n    pub astro_token: Addr,\n    /// Max ASTRO tokens to allocate\n    pub max_allocations_amount: Uint128,\n}\n\n/// This structure stores the total and the remaining amount of ASTRO to be unlocked by all accounts.\n#[cw_serde]\n#[derive(Default)]\npub struct State {\n    /// Amount of ASTRO tokens deposited into the contract\n    pub total_astro_deposited: Uint128,\n    /// Currently available ASTRO tokens that still need to be unlocked and/or withdrawn\n    pub remaining_astro_tokens: Uint128,\n    /// Amount of ASTRO tokens deposited into the contract but not assigned to an allocation\n    pub unallocated_tokens: Uint128,\n}\n\n/// This structure stores the parameters describing a typical unlock schedule.\n#[cw_serde]\n#[derive(Default)]\npub struct Schedule {\n    /// Timestamp for the start of the unlock schedule (in seconds)\n    pub start_time: u64,\n    /// Cliff period during which no tokens can be withdrawn out of the contract\n    pub cliff: u64,\n    /// Time after the cliff during which the remaining tokens linearly unlock\n    pub duration: u64,\n}\n\n/// This structure stores the parameters used to describe an ASTRO allocation.\n#[cw_serde]\n#[derive(Default)]\npub struct AllocationParams {\n    /// Total amount of ASTRO tokens allocated to a specific account\n    pub amount: Uint128,\n    /// Parameters controlling the unlocking process\n    pub unlock_schedule: Schedule,\n    /// Proposed new receiver who will get the ASTRO allocation\n    pub proposed_receiver: Option\u003cAddr\u003e,\n}\n\nimpl AllocationParams {\n    pub fn validate(\u0026self, account: \u0026str) -\u003e Result\u003c(), StdError\u003e {\n        if self.unlock_schedule.cliff \u003e= self.unlock_schedule.duration {\n            return Err(StdError::generic_err(format!(\n                \"The new cliff value must be less than the duration: {} \u003c {}. Account: {}\",\n                self.unlock_schedule.cliff, self.unlock_schedule.duration, account\n            )));\n        };\n\n        if self.amount.is_zero() {\n            return Err(StdError::generic_err(format!(\n                \"Amount must not be zero. Account: {account}\"\n            )));\n        }\n\n        if self.proposed_receiver.is_some() {\n            return Err(StdError::generic_err(format!(\n                \"Proposed receiver must be unset. Account: {account}\"\n            )));\n        }\n\n        Ok(())\n    }\n\n    pub fn update_schedule(\n        \u0026mut self,\n        new_schedule: Schedule,\n        account: \u0026String,\n    ) -\u003e Result\u003c(), StdError\u003e {\n        if new_schedule.cliff \u003c self.unlock_schedule.cliff {\n            return Err(StdError::generic_err(format!(\n                \"The new cliff value should be greater than or equal to the old one: {} \u003e= {}. Account error: {}\",\n                new_schedule.cliff, self.unlock_schedule.cliff, account\n            )));\n        }\n\n        if new_schedule.start_time \u003c self.unlock_schedule.start_time {\n            return Err(StdError::generic_err(format!(\n                \"The new start time should be later than or equal to the old one: {} \u003e= {}. Account error: {}\",\n                new_schedule.start_time, self.unlock_schedule.start_time, account\n            )));\n        }\n\n        if new_schedule.duration \u003c self.unlock_schedule.duration {\n            return Err(StdError::generic_err(format!(\n                \"The new duration value should be greater than or equal to the old one: {} \u003e= {}. Account error: {}\",\n                new_schedule.duration, self.unlock_schedule.duration, account\n            )));\n        }\n\n        self.unlock_schedule = new_schedule;\n        Ok(())\n    }\n}\n\n/// This structure stores the parameters used to describe the status of an allocation.\n#[cw_serde]\n#[derive(Default)]\npub struct AllocationStatus {\n    /// Amount of ASTRO already withdrawn\n    pub astro_withdrawn: Uint128,\n    /// Already unlocked amount after decreasing\n    pub unlocked_amount_checkpoint: Uint128,\n}\n\nimpl AllocationStatus {\n    pub const fn new() -\u003e Self {\n        Self {\n            astro_withdrawn: Uint128::zero(),\n            unlocked_amount_checkpoint: Uint128::zero(),\n        }\n    }\n}\n\npub mod msg {\n    use crate::builder_unlock::Schedule;\n    use cosmwasm_schema::{cw_serde, QueryResponses};\n    use cosmwasm_std::Uint128;\n    use cw20::Cw20ReceiveMsg;\n\n    use super::{AllocationParams, AllocationStatus, Config};\n\n    /// This structure holds the initial parameters used to instantiate the contract.\n    #[cw_serde]\n    pub struct InstantiateMsg {\n        /// Account that can create new allocations\n        pub owner: String,\n        /// ASTRO token address\n        pub astro_token: String,\n        /// Max ASTRO tokens to allocate\n        pub max_allocations_amount: Uint128,\n    }\n\n    /// This enum describes all the execute functions available in the contract.\n    #[cw_serde]\n    pub enum ExecuteMsg {\n        /// Receive is an implementation for the CW20 receive msg\n        Receive(Cw20ReceiveMsg),\n        /// Withdraw claims withdrawable ASTRO\n        Withdraw {},\n        /// ProposeNewReceiver allows a user to change the receiver address for their ASTRO allocation\n        ProposeNewReceiver { new_receiver: String },\n        /// DropNewReceiver allows a user to remove the previously proposed new receiver for their ASTRO allocation\n        DropNewReceiver {},\n        /// ClaimReceiver allows newly proposed receivers to claim ASTRO allocations ownership\n        ClaimReceiver { prev_receiver: String },\n        /// Increase the ASTRO allocation of a receiver\n        IncreaseAllocation { receiver: String, amount: Uint128 },\n        /// Decrease the ASTRO allocation of a receiver\n        DecreaseAllocation { receiver: String, amount: Uint128 },\n        /// Transfer unallocated tokens (only accessible to the owner)\n        TransferUnallocated {\n            amount: Uint128,\n            recipient: Option\u003cString\u003e,\n        },\n        /// Propose a new owner for the contract\n        ProposeNewOwner { new_owner: String, expires_in: u64 },\n        /// Remove the ownership transfer proposal\n        DropOwnershipProposal {},\n        /// Claim contract ownership\n        ClaimOwnership {},\n        /// Update parameters in the contract configuration\n        UpdateConfig { new_max_allocations_amount: Uint128 },\n        /// Update a schedule of allocation for specified accounts\n        UpdateUnlockSchedules {\n            new_unlock_schedules: Vec\u003c(String, Schedule)\u003e,\n        },\n    }\n\n    /// This enum describes receive msg templates.\n    #[cw_serde]\n    pub enum ReceiveMsg {\n        /// CreateAllocations creates new ASTRO allocations\n        CreateAllocations {\n            allocations: Vec\u003c(String, AllocationParams)\u003e,\n        },\n        /// Increase the ASTRO allocation for a receiver\n        IncreaseAllocation { user: String, amount: Uint128 },\n    }\n\n    /// Thie enum describes all the queries available in the contract.\n    #[cw_serde]\n    #[derive(QueryResponses)]\n    pub enum QueryMsg {\n        /// Config returns the configuration for this contract\n        #[returns(Config)]\n        Config {},\n        /// State returns the state of this contract\n        #[returns(StateResponse)]\n        State {},\n        /// Allocation returns the parameters and current status of an allocation\n        #[returns(AllocationResponse)]\n        Allocation {\n            /// Account whose allocation status we query\n            account: String,\n        },\n        /// Allocations returns a vector that contains builder unlock allocations by specified\n        /// parameters\n        #[returns(Vec\u003c(String, AllocationParams)\u003e)]\n        Allocations {\n            start_after: Option\u003cString\u003e,\n            limit: Option\u003cu32\u003e,\n        },\n        #[returns(Uint128)]\n        /// UnlockedTokens returns the unlocked tokens from an allocation\n        UnlockedTokens {\n            /// Account whose amount of unlocked ASTRO we query for\n            account: String,\n        },\n        /// SimulateWithdraw simulates how many ASTRO will be released if a withdrawal is attempted\n        #[returns(SimulateWithdrawResponse)]\n        SimulateWithdraw {\n            /// Account for which we simulate a withdrawal\n            account: String,\n            /// Timestamp used to simulate how much ASTRO the account can withdraw\n            timestamp: Option\u003cu64\u003e,\n        },\n    }\n\n    pub type ConfigResponse = Config;\n\n    /// This structure stores the parameters used to return the response when querying for an allocation data.\n    #[cw_serde]\n    pub struct AllocationResponse {\n        /// The allocation parameters\n        pub params: AllocationParams,\n        /// The allocation status\n        pub status: AllocationStatus,\n    }\n\n    /// This structure stores the parameters used to return a response when simulating a withdrawal.\n    #[cw_serde]\n    pub struct SimulateWithdrawResponse {\n        /// Amount of ASTRO to receive\n        pub astro_to_withdraw: Uint128,\n    }\n\n    /// This structure stores parameters used to return the response when querying for the contract state.\n    #[cw_serde]\n    pub struct StateResponse {\n        /// ASTRO tokens deposited into the contract and that are meant to unlock\n        pub total_astro_deposited: Uint128,\n        /// Currently available ASTRO tokens that weren't yet withdrawn from the contract\n        pub remaining_astro_tokens: Uint128,\n        /// Currently available ASTRO tokens to withdraw or increase allocations by the owner\n        pub unallocated_astro_tokens: Uint128,\n    }\n}\n","traces":[{"line":52,"address":[6887600],"length":1,"stats":{"Line":0},"fn_name":"validate"},{"line":53,"address":[16533688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[16533727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[16533703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[16534045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[16534022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[6888196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[6888185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[6888384],"length":1,"stats":{"Line":0},"fn_name":"update_schedule"},{"line":80,"address":[6888430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[6888473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[6888450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[6888805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[6888781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[6889138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[6889099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[6889122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[6889440],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":119,"address":[6889457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[6889472],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":20},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","escrow_fee_distributor.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::{Addr, Uint128};\nuse cw20::Cw20ReceiveMsg;\n\n/// This structure describes the basic settings for creating a contract.\n#[cw_serde]\npub struct InstantiateMsg {\n    /// Admin address\n    pub owner: String,\n    /// Fee token address\n    pub astro_token: String,\n    /// Voting escrow contract address\n    pub voting_escrow_addr: String,\n    /// Max limit of addresses to claim rewards for in a single call\n    pub claim_many_limit: Option\u003cu64\u003e,\n    /// Whether reward claiming is disabled\n    pub is_claim_disabled: Option\u003cbool\u003e,\n}\n\n/// This structure describes the execute messages available in the contract.\n#[cw_serde]\npub enum ExecuteMsg {\n    /// ProposeNewOwner creates a request to change contract ownership\n    ProposeNewOwner {\n        /// The newly proposed owner\n        owner: String,\n        /// The validity period of the offer to change the contract owner\n        expires_in: u64,\n    },\n    /// DropOwnershipProposal removes the request to change contract ownership\n    DropOwnershipProposal {},\n    /// ClaimOwnership claims contract ownership\n    ClaimOwnership {},\n    /// Claim claims staking rewards for a single staker and sends them to the specified recipient\n    Claim {\n        recipient: Option\u003cString\u003e,\n        max_periods: Option\u003cu64\u003e,\n    },\n    /// ClaimMany claims staking rewards for multiple addresses in a single call\n    ClaimMany { receivers: Vec\u003cString\u003e },\n    /// UpdateConfig updates the contract configuration\n    UpdateConfig {\n        /// Max limit of addresses to claim rewards for in a single call\n        claim_many_limit: Option\u003cu64\u003e,\n        /// Whether reward claiming is disabled\n        is_claim_disabled: Option\u003cbool\u003e,\n    },\n    /// Receive receives a message of type [`Cw20ReceiveMsg`] and processes it depending on the received template\n    Receive(Cw20ReceiveMsg),\n}\n\n/// This structure describes query messages available in the contract.\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// Config returns control settings using a custom [`ConfigResponse`] structure\n    #[returns(ConfigResponse)]\n    Config {},\n    /// UserReward returns the reward amount that can be claimed by a staker in the form of ASTRO at a specified timestamp\n    #[returns(Uint128)]\n    UserReward { user: String, timestamp: u64 },\n    /// AvailableRewardPerWeek returns a vector that contains the total reward amount per week distributed to vxASTRO stakers\n    #[returns(Vec\u003cUint128\u003e)]\n    AvailableRewardPerWeek {\n        start_after: Option\u003cu64\u003e,\n        limit: Option\u003cu64\u003e,\n    },\n}\n\n/// This structure describes the parameters returned when querying for the contract configuration.\n#[cw_serde]\npub struct ConfigResponse {\n    /// Address that's allowed to change contract parameters\n    pub owner: Addr,\n    /// Fee token address (ASTRO token)\n    pub astro_token: Addr,\n    /// Voting escrow contract address\n    pub voting_escrow_addr: Addr,\n    /// Max limit of addresses to claim rewards for in a single call\n    pub claim_many_limit: u64,\n    /// Wthether reward claiming is disabled\n    pub is_claim_disabled: bool,\n}\n\n/// This structure describes a migration message.\n#[cw_serde]\npub struct MigrateMsg {}\n\n/// This structure describes custom hooks for a CW20.\n#[cw_serde]\npub enum Cw20HookMsg {\n    /// ReceiveTokens receives tokens into the contract and triggers a vxASTRO checkpoint.\n    ReceiveTokens {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","generator_controller.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::{Addr, Decimal, Uint128};\n\n/// The maximum amount of voters that can be kicked at once from\npub const VOTERS_MAX_LIMIT: u32 = 30;\n\n/// This structure describes the basic settings for creating a contract.\n#[cw_serde]\npub struct InstantiateMsg {\n    /// Contract owner\n    pub owner: String,\n    /// The vxASTRO token contract address\n    pub escrow_addr: String,\n    /// Generator contract address\n    pub generator_addr: String,\n    /// Factory contract address\n    pub factory_addr: String,\n    /// Max number of pools that can receive ASTRO emissions at the same time\n    pub pools_limit: u64,\n    /// The list of pools which are eligible to receive votes\n    pub whitelisted_pools: Vec\u003cString\u003e,\n}\n\n/// This structure describes the execute messages available in the contract.\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Removes all votes applied by blacklisted voters\n    KickBlacklistedVoters { blacklisted_voters: Vec\u003cString\u003e },\n    /// Vote allows a vxASTRO holder to cast votes on which generators should get ASTRO emissions in the next epoch\n    Vote { votes: Vec\u003c(String, u16)\u003e },\n    /// TunePools transforms the latest vote distribution into alloc_points which are then applied to ASTRO generators\n    TunePools {},\n    UpdateConfig {\n        /// The number of voters that can be kicked at once from the pool..\n        blacklisted_voters_limit: Option\u003cu32\u003e,\n        /// Main pool that will receive a minimum amount of ASTRO emissions\n        main_pool: Option\u003cString\u003e,\n        /// The minimum percentage of ASTRO emissions that main pool should get every block\n        main_pool_min_alloc: Option\u003cDecimal\u003e,\n        /// Should the main pool be removed or not? If the variable is omitted then the pool will be kept.\n        remove_main_pool: Option\u003cbool\u003e,\n    },\n    /// ChangePoolsLimit changes the max amount of pools that can be voted at once to receive ASTRO emissions\n    ChangePoolsLimit { limit: u64 },\n    /// ProposeNewOwner proposes a new owner for the contract\n    ProposeNewOwner {\n        /// Newly proposed contract owner\n        new_owner: String,\n        /// The timestamp when the contract ownership change expires\n        expires_in: u64,\n    },\n    /// DropOwnershipProposal removes the latest contract ownership transfer proposal\n    DropOwnershipProposal {},\n    /// ClaimOwnership allows the newly proposed owner to claim contract ownership\n    ClaimOwnership {},\n    /// Adds or removes the pools which are eligible to receive votes\n    UpdateWhitelist {\n        add: Option\u003cVec\u003cString\u003e\u003e,\n        remove: Option\u003cVec\u003cString\u003e\u003e,\n    },\n}\n\n/// This structure describes the query messages available in the contract.\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// UserInfo returns information about a voter and the generators they voted for\n    #[returns(UserInfoResponse)]\n    UserInfo { user: String },\n    /// TuneInfo returns information about the latest generators that were voted to receive ASTRO emissions\n    #[returns(GaugeInfoResponse)]\n    TuneInfo {},\n    /// Config returns the contract configuration\n    #[returns(ConfigResponse)]\n    Config {},\n    /// PoolInfo returns the latest voting power allocated to a specific pool (generator)\n    #[returns(VotedPoolInfoResponse)]\n    PoolInfo { pool_addr: String },\n    /// PoolInfo returns the voting power allocated to a specific pool (generator) at a specific period\n    #[returns(VotedPoolInfoResponse)]\n    PoolInfoAtPeriod { pool_addr: String, period: u64 },\n}\n\n/// This structure describes a migration message.\n/// We currently take no arguments for migrations.\n#[cw_serde]\npub struct MigrateMsg {}\n\n/// This structure describes the parameters returned when querying for the contract configuration.\n#[cw_serde]\npub struct ConfigResponse {\n    /// Address that's allowed to change contract parameters\n    pub owner: Addr,\n    /// The vxASTRO token contract address\n    pub escrow_addr: Addr,\n    /// Generator contract address\n    pub generator_addr: Addr,\n    /// Factory contract address\n    pub factory_addr: Addr,\n    /// Max number of pools that can receive ASTRO emissions at the same time\n    pub pools_limit: u64,\n    /// Max number of blacklisted voters which can be removed\n    pub blacklisted_voters_limit: Option\u003cu32\u003e,\n    /// Main pool that will receive a minimum amount of ASTRO emissions\n    pub main_pool: Option\u003cAddr\u003e,\n    /// The minimum percentage of ASTRO emissions that main pool should get every block\n    pub main_pool_min_alloc: Decimal,\n    /// The list of pools which are eligible to receive votes\n    pub whitelisted_pools: Vec\u003cAddr\u003e,\n}\n\n/// This structure describes the response used to return voting information for a specific pool (generator).\n#[cw_serde]\n#[derive(Default)]\npub struct VotedPoolInfoResponse {\n    /// vxASTRO amount that voted for this pool/generator\n    pub vxastro_amount: Uint128,\n    /// The slope at which the amount of vxASTRO that voted for this pool/generator will decay\n    pub slope: Uint128,\n}\n\n/// This structure describes the response used to return tuning parameters for all pools/generators.\n#[cw_serde]\n#[derive(Default)]\npub struct GaugeInfoResponse {\n    /// Last timestamp when a tuning vote happened\n    pub tune_ts: u64,\n    /// Distribution of alloc_points to apply in the Generator contract\n    pub pool_alloc_points: Vec\u003c(String, Uint128)\u003e,\n}\n\n/// The struct describes a response used to return a staker's vxASTRO lock position.\n#[cw_serde]\n#[derive(Default)]\npub struct UserInfoResponse {\n    /// Last timestamp when the user voted\n    pub vote_ts: u64,\n    /// The user's vxASTRO voting power\n    pub voting_power: Uint128,\n    /// The slope at which the user's voting power decays\n    pub slope: Uint128,\n    /// Timestamp when the user's lock expires\n    pub lock_end: u64,\n    /// The vote distribution for all the generators/pools the staker picked\n    pub votes: Vec\u003c(Addr, u16)\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","generator_controller_lite.rs"],"content":"// TODO: DO NOT COMMIT - THIS IS INCLUDED IN ANOTHER PR\nuse cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::{Addr, Decimal, Uint128};\n\n/// The maximum amount of voters that can be kicked at once from\npub const VOTERS_MAX_LIMIT: u32 = 30;\n\n/// This structure describes the basic settings for creating a contract.\n#[cw_serde]\npub struct InstantiateMsg {\n    /// Contract owner\n    pub owner: String,\n    /// The vxASTRO token contract address\n    pub escrow_addr: String,\n    /// Generator contract address\n    pub generator_addr: String,\n    /// Factory contract address\n    pub factory_addr: String,\n    /// Assembly contract address\n    pub assembly_addr: String,\n    /// Hub contract address\n    pub hub_addr: Option\u003cString\u003e,\n    /// Max number of pools that can receive ASTRO emissions at the same time\n    pub pools_limit: u64,\n    /// The list of pools which are eligible to receive votes\n    pub whitelisted_pools: Vec\u003cString\u003e,\n    /// Prefix for addresses on this network\n    pub address_prefix: String,\n}\n\n/// This structure describes the execute messages available in the contract.\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Removes all votes applied by blacklisted voters\n    KickBlacklistedVoters { blacklisted_voters: Vec\u003cString\u003e },\n    /// Removes all votes applied by voters that have unlocked\n    KickUnlockedVoters { unlocked_voters: Vec\u003cString\u003e },\n    /// Removes all votes applied by a voter that have unlocked on an Outpost\n    KickUnlockedOutpostVoter { unlocked_voter: Addr },\n    /// Vote allows a vxASTRO holder to cast votes on which generators should get ASTRO emissions in the next epoch\n    Vote { votes: Vec\u003c(String, u16)\u003e },\n    /// OutpostVote allows a vxASTRO holder on an Outpost to cast votes on which generators should get ASTRO emissions in the next epoch\n    OutpostVote {\n        voter: Addr,\n        voting_power: Uint128,\n        votes: Vec\u003c(String, u16)\u003e,\n    },\n    /// TunePools transforms the latest vote distribution into alloc_points which are then applied to ASTRO generators\n    TunePools {},\n    UpdateConfig {\n        // Assembly contract address\n        assembly_addr: Option\u003cString\u003e,\n        /// The number of voters that can be kicked at once from the pool..\n        kick_voters_limit: Option\u003cu32\u003e,\n        /// Main pool that will receive a minimum amount of ASTRO emissions\n        main_pool: Option\u003cString\u003e,\n        /// The minimum percentage of ASTRO emissions that main pool should get every block\n        main_pool_min_alloc: Option\u003cDecimal\u003e,\n        /// Should the main pool be removed or not? If the variable is omitted then the pool will be kept.\n        remove_main_pool: Option\u003cbool\u003e,\n        // Hub contract address\n        hub_addr: Option\u003cString\u003e,\n    },\n    /// ChangePoolsLimit changes the max amount of pools that can be voted at once to receive ASTRO emissions\n    ChangePoolsLimit { limit: u64 },\n    /// ProposeNewOwner proposes a new owner for the contract\n    ProposeNewOwner {\n        /// Newly proposed contract owner\n        new_owner: String,\n        /// The timestamp when the contract ownership change expires\n        expires_in: u64,\n    },\n    /// DropOwnershipProposal removes the latest contract ownership transfer proposal\n    DropOwnershipProposal {},\n    /// ClaimOwnership allows the newly proposed owner to claim contract ownership\n    ClaimOwnership {},\n    /// Adds or removes the pools which are eligible to receive votes\n    UpdateWhitelist {\n        add: Option\u003cVec\u003cString\u003e\u003e,\n        remove: Option\u003cVec\u003cString\u003e\u003e,\n    },\n    // Update network config for IBC\n    UpdateNetworks {\n        // Adding requires a list of (network, address prefix, IBC governance channel)\n        add: Option\u003cVec\u003cNetworkInfo\u003e\u003e,\n        remove: Option\u003cVec\u003cString\u003e\u003e,\n    },\n}\n\n/// This structure describes the query messages available in the contract.\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// UserInfo returns information about a voter and the generators they voted for\n    #[returns(UserInfoResponse)]\n    UserInfo { user: String },\n    /// TuneInfo returns information about the latest generators that were voted to receive ASTRO emissions\n    #[returns(GaugeInfoResponse)]\n    TuneInfo {},\n    /// Config returns the contract configuration\n    #[returns(ConfigResponse)]\n    Config {},\n    /// PoolInfo returns the latest voting power allocated to a specific pool (generator)\n    #[returns(VotedPoolInfoResponse)]\n    PoolInfo { pool_addr: String },\n    /// PoolInfo returns the voting power allocated to a specific pool (generator) at a specific period\n    #[returns(VotedPoolInfoResponse)]\n    PoolInfoAtPeriod { pool_addr: String, period: u64 },\n}\n\n/// This structure describes a migration message.\n/// We currently take no arguments for migrations.\n#[cw_serde]\npub struct MigrateMsg {}\n\n/// This structure describes the parameters returned when querying for the contract configuration.\n#[cw_serde]\npub struct ConfigResponse {\n    /// Address that's allowed to change contract parameters\n    pub owner: Addr,\n    /// The vxASTRO token contract address\n    pub escrow_addr: Addr,\n    /// Generator contract address\n    pub generator_addr: Addr,\n    /// Factory contract address\n    pub factory_addr: Addr,\n    /// Assembly contract address\n    pub assembly_addr: Addr,\n    /// Hub contract address\n    pub hub_addr: Option\u003cAddr\u003e,\n    /// Max number of pools that can receive ASTRO emissions at the same time\n    pub pools_limit: u64,\n    /// Max number of voters which can be kicked at a time\n    pub kick_voters_limit: Option\u003cu32\u003e,\n    /// Main pool that will receive a minimum amount of ASTRO emissions\n    pub main_pool: Option\u003cAddr\u003e,\n    /// The minimum percentage of ASTRO emissions that main pool should get every block\n    pub main_pool_min_alloc: Decimal,\n    /// The list of pools which are eligible to receive votes\n    pub whitelisted_pools: Vec\u003cAddr\u003e,\n    /// The list of pools which are eligible to receive votes\n    pub whitelisted_networks: Vec\u003cNetworkInfo\u003e,\n}\n\n/// This structure describes the response used to return voting information for a specific pool (generator).\n#[cw_serde]\n#[derive(Default)]\npub struct VotedPoolInfoResponse {\n    /// vxASTRO amount that voted for this pool/generator\n    pub vxastro_amount: Uint128,\n    /// The slope at which the amount of vxASTRO that voted for this pool/generator will decay\n    pub slope: Uint128,\n}\n\n/// This structure describes the response used to return tuning parameters for all pools/generators.\n#[cw_serde]\n#[derive(Default)]\npub struct GaugeInfoResponse {\n    /// Last period when a tuning was applied\n    pub tune_period: u64,\n    /// Distribution of alloc_points to apply in the Generator contract\n    pub pool_alloc_points: Vec\u003c(String, Uint128)\u003e,\n}\n\n/// The struct describes a response used to return a staker's vxASTRO lock position.\n#[cw_serde]\n#[derive(Default)]\npub struct UserInfoResponse {\n    /// The period when the user voted last time, None if they've never voted\n    pub vote_period: Option\u003cu64\u003e,\n    /// The user's vxASTRO voting power\n    pub voting_power: Uint128,\n    /// The vote distribution for all the generators/pools the staker picked\n    pub votes: Vec\u003c(Addr, u16)\u003e,\n}\n\n#[cw_serde]\n#[derive(Eq, Hash)]\npub struct NetworkInfo {\n    /// The address prefix for the network, e.g. \"terra\"\n    pub address_prefix: String,\n    /// The address of the generator contract on the Outpost\n    pub generator_address: Addr,\n    /// The IBC channel used for governance\n    pub ibc_channel: Option\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","hub.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::Addr;\nuse cw20::Cw20ReceiveMsg;\n\n/// Holds the parameters used for creating a Hub contract\n#[cw_serde]\npub struct InstantiateMsg {\n    /// The contract owner\n    pub owner: String,\n    /// The address of the Assembly contract on the Hub\n    pub assembly_addr: String,\n    /// The address of the CW20-ICS20 contract on the Hub that supports\n    /// memo handling\n    pub cw20_ics20_addr: String,\n    /// The address of the xASTRO staking contract on the Hub\n    pub staking_addr: String,\n    /// The address of the generator controller contract on the Hub\n    pub generator_controller_addr: String,\n    /// The timeout in seconds for IBC packets\n    pub ibc_timeout_seconds: u64,\n}\n\n/// The contract migration message\n/// We currently take no arguments for migrations\n#[cw_serde]\npub struct MigrateMsg {}\n\n/// Describes the execute messages available in the contract\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Receive a message of type [`Cw20ReceiveMsg`]\n    Receive(Cw20ReceiveMsg),\n    /// Update parameters in the Hub contract. Only the owner is allowed to\n    /// update the config\n    UpdateConfig {\n        /// The new address of the Assembly on the Hub, ignored if None\n        assembly_addr: Option\u003cString\u003e,\n        /// The new address of the CW20-ICS20 contract on the Hub that\n        /// supports memo handling, ignored if None\n        cw20_ics20_addr: Option\u003cString\u003e,\n    },\n    /// Add a new Outpost to the Hub. Only allowed Outposts can send IBC messages\n    AddOutpost {\n        /// The remote contract address of the Outpost to add\n        outpost_addr: String,\n        /// The channel to use for CW20-ICS20 IBC transfers\n        cw20_ics20_channel: String,\n    },\n    /// Remove an Outpost from the Hub\n    RemoveOutpost {\n        /// The remote contract address of the Outpost to remove\n        outpost_addr: String,\n    },\n    /// Propose a new owner for the contract\n    ProposeNewOwner { new_owner: String, expires_in: u64 },\n    /// Remove the ownership transfer proposal\n    DropOwnershipProposal {},\n    /// Claim contract ownership\n    ClaimOwnership {},\n}\n\n/// Messages handled via CW20 transfers\n#[cw_serde]\npub enum Cw20HookMsg {\n    /// Handles instructions received via an IBC transfer memo in the\n    /// CW20-ICS20 contract\n    OutpostMemo {\n        /// The channel the memo was received on\n        channel: String,\n        /// The original sender of the packet on the outpost\n        sender: String,\n        /// The original intended receiver of the packet on the Hub\n        receiver: String,\n        /// The memo containing the JSON to handle\n        memo: String,\n    },\n    /// Handle failed CW20 IBC transfers\n    TransferFailure {\n        // The original sender where the funds should be returned to\n        receiver: String,\n    },\n}\n\n/// Describes the query messages available in the contract\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// Returns the config of the Hub\n    #[returns(Config)]\n    Config {},\n    /// Returns the list of the current Outposts on the Hub\n    #[returns(Vec\u003cOutpostConfig\u003e)]\n    Outposts {},\n}\n\n/// The config of the Hub\n#[cw_serde]\npub struct Config {\n    /// The owner of the contract\n    pub owner: Addr,\n    /// The address of the Assembly contract on the Hub\n    pub assembly_addr: Addr,\n    /// The address of the CW20-ICS20 contract on the Hub that supports memo\n    /// handling\n    pub cw20_ics20_addr: Addr,\n    /// The address of the ASTRO token contract on the Hub\n    pub token_addr: Addr,\n    /// The address of the xASTRO token contract on the Hub\n    pub xtoken_addr: Addr,\n    /// The address of the staking contract on the Hub\n    pub staking_addr: Addr,\n    /// The address of the generator controller contract on the Hub\n    pub generator_controller_addr: Addr,\n    /// The timeout in seconds for IBC packets\n    pub ibc_timeout_seconds: u64,\n}\n\n/// A response containing the Outpost address and channels\n#[cw_serde]\npub struct OutpostConfig {\n    /// The address of the Outpost contract on another chain\n    pub address: String,\n    /// The channel connecting the Hub contract with that Outpost contract\n    pub channel: String,\n    /// The CS20-ICS20 channel ASTRO is transferred through\n    pub cw20_ics20_channel: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","interchain.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Uint128};\nuse std::fmt::{Display, Formatter, Result};\n\nuse crate::assembly::{Proposal, ProposalVoteOption};\n\n// TODO: This will come from the new CW20-ICS20 contract once it is merged\n// IGNORE\n#[cw_serde]\npub struct TransferMsg {\n    /// The local channel to send the packets on\n    pub channel: String,\n    /// The remote address to send to.\n    /// Don't use HumanAddress as this will likely have a different Bech32 prefix than we use\n    /// and cannot be validated locally\n    pub remote_address: String,\n    /// How long the packet lives in seconds. If not specified, use default_timeout\n    pub timeout: Option\u003cu64\u003e,\n    /// An optional memo to add to the IBC transfer\n    pub memo: Option\u003cString\u003e,\n}\n// END IGNORE\n\n/// Hub defines the messages that can be sent from an Outpost to the Hub\n#[cw_serde]\npub enum Hub {\n    /// Queries the Assembly for a proposal by ID via the Hub\n    QueryProposal {\n        /// The ID of the proposal to query\n        id: u64,\n    },\n    /// Cast a vote on an Assembly proposal\n    CastAssemblyVote {\n        /// The ID of the proposal to vote on\n        proposal_id: u64,\n        /// The address of the voter\n        voter: Addr,\n        /// The vote choice\n        vote_option: ProposalVoteOption,\n        /// The voting power held by the voter, in this case xASTRO holdings\n        voting_power: Uint128,\n    },\n    /// Cast a vote during an emissions voting period\n    CastEmissionsVote {\n        /// The address of the voter\n        voter: Addr,\n        /// The voting power held by the voter, in this case vxASTRO  lite holdings\n        voting_power: Uint128,\n        /// The votes in the format (pool address, percent of voting power)\n        votes: Vec\u003c(String, u16)\u003e,\n    },\n    /// Stake ASTRO tokens for xASTRO\n    Stake {},\n    /// Unstake xASTRO tokens for ASTRO\n    Unstake {\n        // The user requesting the unstake and that should receive it\n        receiver: String,\n        /// The amount of xASTRO to unstake\n        amount: Uint128,\n    },\n    /// Kick an unlocked voter's voting power from the Generator Controller lite\n    KickUnlockedVoter {\n        /// The address of the voter to kick\n        voter: Addr,\n    },\n    /// Withdraw stuck funds from the Hub in case of specific IBC failures\n    WithdrawFunds {\n        /// The address of the user to withdraw funds for\n        user: Addr,\n    },\n}\n\n/// Defines the messages that can be sent from the Hub to an Outpost\n#[cw_serde]\npub enum Outpost {\n    /// Mint xASTRO tokens for the user\n    MintXAstro { receiver: String, amount: Uint128 },\n}\n\n/// Defines the messages that can be returned in response to an IBC Hub or\n/// Outpost message\n#[cw_serde]\npub enum Response {\n    /// The response to a QueryProposal message that includes a minimal Proposal\n    QueryProposal(Box\u003cProposal\u003e),\n    /// A generic response to a Hub/Outpost message, mostly used for indicating success\n    /// or error handling\n    Result {\n        /// The action that was performed, None if no specific action was taken\n        action: Option\u003cString\u003e,\n        /// The address of the user that took the action, None if the result\n        /// isn't specific to an address\n        address: Option\u003cString\u003e,\n        /// The error message, if None, the action was successful\n        error: Option\u003cString\u003e,\n    },\n}\n\n/// Utility functions for InterchainResponse to ease creation of responses\nimpl Response {\n    /// Create a new success response that sets address and action but leaves\n    /// error as None\n    pub fn new_success(action: String, address: String) -\u003e Self {\n        Response::Result {\n            action: Some(action),\n            address: Some(address),\n            error: None,\n        }\n    }\n    /// Create a new error response that sets address and action to None\n    /// while adding the error message\n    pub fn new_error(error: String) -\u003e Self {\n        Response::Result {\n            action: None,\n            address: None,\n            error: Some(error),\n        }\n    }\n}\n\n// TODO: Is this needed? Can we use #[derive(Debug)] instead\n/// Implements Display for Hub\nimpl Display for Hub {\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e Result {\n        write!(\n            f,\n            \"{}\",\n            match self {\n                Hub::Stake { .. } =\u003e \"stake\",\n                Hub::CastAssemblyVote { .. } =\u003e \"cast_assembly_vote\",\n                Hub::CastEmissionsVote { .. } =\u003e \"cast_emissions_vote\",\n                Hub::QueryProposal { .. } =\u003e \"query_proposal\",\n                Hub::Unstake { .. } =\u003e \"unstake\",\n                Hub::KickUnlockedVoter { .. } =\u003e \"kick_unlocked_voter\",\n                Hub::WithdrawFunds { .. } =\u003e \"withdraw_funds\",\n            }\n        )\n    }\n}\n\n// TODO: Is this needed? Can we use #[derive(Debug)] instead\n/// Implements Display for Outpost\nimpl Display for Outpost {\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e Result {\n        write!(\n            f,\n            \"{}\",\n            match self {\n                Outpost::MintXAstro { .. } =\u003e \"MintXAstro\",\n            }\n        )\n    }\n}\n\n/// Get the address from an IBC port. If the port is prefixed with `wasm.`,\n/// strip it out, if not, return the port as is.\npub fn get_contract_from_ibc_port(ibc_port: \u0026str) -\u003e \u0026str {\n    match ibc_port.strip_prefix(\"wasm.\") {\n        Some(suffix) =\u003e suffix, // prints: inj1234\n        None =\u003e ibc_port,\n    }\n}\n","traces":[{"line":103,"address":[15880704],"length":1,"stats":{"Line":3},"fn_name":"new_success"},{"line":105,"address":[15880711],"length":1,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[15880736],"length":1,"stats":{"Line":3},"fn_name":null},{"line":112,"address":[15880864],"length":1,"stats":{"Line":2},"fn_name":"new_error"},{"line":116,"address":[15880889],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[15881008],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":125,"address":[15881220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[6234979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[6235082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[6235036],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[6235059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[6235010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[6235105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[6235128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[6235151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[6235264],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":145,"address":[6235282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[6235376],"length":1,"stats":{"Line":6},"fn_name":"get_contract_from_ibc_port"},{"line":158,"address":[6235400],"length":1,"stats":{"Line":6},"fn_name":null},{"line":159,"address":[6235479],"length":1,"stats":{"Line":6},"fn_name":null},{"line":160,"address":[6235467],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":8,"coverable":21},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","lib.rs"],"content":"pub mod assembly;\npub mod builder_unlock;\npub mod escrow_fee_distributor;\npub mod generator_controller;\npub mod generator_controller_lite;\npub mod hub;\npub mod interchain;\npub mod nft;\npub mod outpost;\npub mod utils;\npub mod voting_escrow;\npub mod voting_escrow_delegation;\npub mod voting_escrow_lite;\n\npub use astroport;\n\n// Default pagination constants\npub const DEFAULT_LIMIT: u32 = 10;\npub const MAX_LIMIT: u32 = 30;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","nft.rs"],"content":"use cosmwasm_schema::cw_serde;\n\n/// This structure describes a migration message.\n#[cw_serde]\npub struct MigrateMsg {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","outpost.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::Addr;\nuse cw20::Cw20ReceiveMsg;\n\nuse crate::assembly::ProposalVoteOption;\n\n/// Holds the parameters used for creating an Outpost contract\n#[cw_serde]\npub struct InstantiateMsg {\n    /// The contract owner\n    pub owner: String,\n    /// The address of the xASTRO token contract on the Outpost\n    pub xastro_token_addr: String,\n    /// The address of the vxASTRO lite contract on the Outpost\n    pub vxastro_token_addr: String,\n    /// The address of the Hub contract on the Hub chain\n    pub hub_addr: String,\n    /// The timeout in seconds for IBC packets\n    pub ibc_timeout_seconds: u64,\n}\n\n/// The contract migration message\n/// We currently take no arguments for migrations\n#[cw_serde]\npub struct MigrateMsg {}\n\n/// Describes the execute messages available in the contract\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Receive a message of type [`Cw20ReceiveMsg`]\n    Receive(Cw20ReceiveMsg),\n    /// Update parameters in the Outpost contract. Only the owner is allowed to\n    /// update the config\n    UpdateConfig {\n        /// The new Hub address\n        hub_addr: Option\u003cString\u003e,\n    },\n    /// Cast a vote on an Assembly proposal from an Outpost\n    CastAssemblyVote {\n        /// The ID of the proposal to vote on\n        proposal_id: u64,\n        /// The vote choice\n        vote: ProposalVoteOption,\n    },\n    /// Cast a vote during an emissions voting period\n    CastEmissionsVote {\n        /// The votes in the format (pool address, percent of voting power)\n        votes: Vec\u003c(String, u16)\u003e,\n    },\n    /// Kick an unlocked voter's voting power from the Generator Controller lite\n    KickUnlocked {\n        /// The address of the user to kick\n        user: Addr,\n    },\n    /// Withdraw stuck funds from the Hub in case of specific IBC failures\n    WithdrawHubFunds {},\n    /// Propose a new owner for the contract\n    ProposeNewOwner { new_owner: String, expires_in: u64 },\n    /// Remove the ownership transfer proposal\n    DropOwnershipProposal {},\n    /// Claim contract ownership\n    ClaimOwnership {},\n}\n\n/// Messages handled via CW20 transfers\n#[cw_serde]\npub enum Cw20HookMsg {\n    /// Unstake xASTRO from the Hub and return the ASTRO to the sender\n    Unstake {},\n}\n\n/// Describes the query messages available in the contract\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// Returns the config of the Outpost\n    #[returns(Config)]\n    Config {},\n}\n\n/// The config of the Outpost\n#[cw_serde]\npub struct Config {\n    /// The owner of the contract\n    pub owner: Addr,\n    /// The address of the Hub contract on the Hub chain    \n    pub hub_addr: Addr,\n    /// The channel used to communicate with the Hub\n    pub hub_channel: Option\u003cString\u003e,\n    /// The address of the xASTRO token contract on the Outpost\n    pub xastro_token_addr: Addr,\n    /// The address of the vxASTRO lite contract on the Outpost\n    pub vxastro_token_addr: Addr,\n    /// The timeout in seconds for IBC packets\n    pub ibc_timeout_seconds: u64,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","utils.rs"],"content":"use std::convert::TryInto;\n\nuse cosmwasm_std::{Decimal, Fraction, OverflowError, StdError, StdResult, Uint128, Uint256};\n\n/// Seconds in one week. It is intended for period number calculation.\npub const WEEK: u64 = 7 * 86400; // lock period is rounded down by week\n\n/// Seconds in 2 years which is the maximum lock period.\npub const MAX_LOCK_TIME: u64 = 2 * 365 * 86400; // 2 years (104 weeks)\n\n/// The constant describes the maximum number of accounts for which to claim accrued staking rewards in a single transaction.\npub const CLAIM_LIMIT: u64 = 10;\n\n/// The constant describes the minimum number of accounts for claim.\npub const MIN_CLAIM_LIMIT: u64 = 2;\n\n/// Feb 28 2022 00:00 UTC, Monday\npub const EPOCH_START: u64 = 1646006400;\n\n/// Calculates the period number. Time should be formatted as a timestamp.\npub fn get_period(time: u64) -\u003e StdResult\u003cu64\u003e {\n    if time \u003c EPOCH_START {\n        Err(StdError::generic_err(\"Invalid time\"))\n    } else {\n        Ok((time - EPOCH_START) / WEEK)\n    }\n}\n\n/// Calculates how many periods are in the specified time interval. The time should be in seconds.\npub fn get_periods_count(interval: u64) -\u003e u64 {\n    interval / WEEK\n}\n\n/// This trait was implemented to eliminate Decimal rounding problems.\ntrait DecimalRoundedCheckedMul {\n    fn checked_mul(self, other: Uint128) -\u003e Result\u003cUint128, OverflowError\u003e;\n}\n\npub trait DecimalCheckedOps {\n    fn checked_add(self, other: Decimal) -\u003e Result\u003cDecimal, OverflowError\u003e;\n    fn checked_mul_uint128(self, other: Uint128) -\u003e Result\u003cUint128, OverflowError\u003e;\n}\n\nimpl DecimalRoundedCheckedMul for Decimal {\n    fn checked_mul(self, other: Uint128) -\u003e Result\u003cUint128, OverflowError\u003e {\n        if self.is_zero() || other.is_zero() {\n            return Ok(Uint128::zero());\n        }\n        let numerator = other.full_mul(self.numerator());\n        let multiply_ratio = numerator / Uint256::from(self.denominator());\n        if multiply_ratio \u003e Uint256::from(Uint128::MAX) {\n            Err(OverflowError::new(\n                cosmwasm_std::OverflowOperation::Mul,\n                self,\n                other,\n            ))\n        } else {\n            let mut result: Uint128 = multiply_ratio.try_into().unwrap();\n            let rem: Uint128 = numerator\n                .checked_rem(Uint256::from(self.denominator()))\n                .unwrap()\n                .try_into()\n                .unwrap();\n            // 0.5 in Decimal\n            if rem.u128() \u003e= 500000000000000000_u128 {\n                result += Uint128::from(1_u128);\n            }\n            Ok(result)\n        }\n    }\n}\n\nimpl DecimalCheckedOps for Decimal {\n    fn checked_add(self, other: Decimal) -\u003e Result\u003cDecimal, OverflowError\u003e {\n        self.numerator()\n            .checked_add(other.numerator())\n            .map(|_| self + other)\n    }\n    fn checked_mul_uint128(self, other: Uint128) -\u003e Result\u003cUint128, OverflowError\u003e {\n        if self.is_zero() || other.is_zero() {\n            return Ok(Uint128::zero());\n        }\n        let multiply_ratio = other.full_mul(self.numerator()) / Uint256::from(self.denominator());\n        if multiply_ratio \u003e Uint256::from(Uint128::MAX) {\n            Err(OverflowError::new(\n                cosmwasm_std::OverflowOperation::Mul,\n                self,\n                other,\n            ))\n        } else {\n            Ok(multiply_ratio.try_into().unwrap())\n        }\n    }\n}\n\n/// Main function used to calculate a user's voting power at a specific period as: previous_power - slope*(x - previous_x).\npub fn calc_voting_power(\n    slope: Uint128,\n    old_vp: Uint128,\n    start_period: u64,\n    end_period: u64,\n) -\u003e Uint128 {\n    let shift = slope\n        .checked_mul(Uint128::from(end_period - start_period))\n        .unwrap_or_else(|_| Uint128::zero());\n    old_vp.saturating_sub(shift)\n}\n","traces":[{"line":45,"address":[6465472],"length":1,"stats":{"Line":0},"fn_name":"checked_mul"},{"line":46,"address":[16111557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[16111824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[16111612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[16111647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[16112268,16112305,16111765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[16112203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[16111861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[6465920,6465989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[6465954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[6466113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[6466262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[6466230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[6466304],"length":1,"stats":{"Line":0},"fn_name":"checked_add"},{"line":75,"address":[6466427,6466385,6466341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[6466360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[7330144,7330168],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":79,"address":[16112512],"length":1,"stats":{"Line":0},"fn_name":"checked_mul_uint128"},{"line":80,"address":[6466501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[6466701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[6466556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[6466899,6466832,6466645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[6466834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[6466738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[7330208,7330217],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"}],"covered":0,"coverable":25},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","voting_escrow.rs"],"content":"use crate::voting_escrow::QueryMsg::{\n    LockInfo, TotalVotingPower, TotalVotingPowerAt, UserVotingPower, UserVotingPowerAt,\n};\nuse cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::{Addr, Binary, Decimal, QuerierWrapper, StdResult, Uint128};\nuse cw20::{\n    BalanceResponse, Cw20ReceiveMsg, DownloadLogoResponse, Logo, MarketingInfoResponse,\n    TokenInfoResponse,\n};\nuse std::fmt;\n\n/// ## Pagination settings\n/// The maximum amount of items that can be read at once from\npub const MAX_LIMIT: u32 = 30;\n\n/// The default amount of items to read from\npub const DEFAULT_LIMIT: u32 = 10;\n\npub const DEFAULT_PERIODS_LIMIT: u64 = 20;\n\n/// This structure stores marketing information for vxASTRO.\n#[cw_serde]\npub struct UpdateMarketingInfo {\n    /// Project URL\n    pub project: Option\u003cString\u003e,\n    /// Token description\n    pub description: Option\u003cString\u003e,\n    /// Token marketing information\n    pub marketing: Option\u003cString\u003e,\n    /// Token logo\n    pub logo: Option\u003cLogo\u003e,\n}\n\n/// This structure stores general parameters for the vxASTRO contract.\n#[cw_serde]\npub struct InstantiateMsg {\n    /// The vxASTRO contract owner\n    pub owner: String,\n    /// Address that's allowed to black or whitelist contracts\n    pub guardian_addr: Option\u003cString\u003e,\n    /// xASTRO token address\n    pub deposit_token_addr: String,\n    /// Marketing info for vxASTRO\n    pub marketing: Option\u003cUpdateMarketingInfo\u003e,\n    /// The list of whitelisted logo urls prefixes\n    pub logo_urls_whitelist: Vec\u003cString\u003e,\n}\n\n/// This structure describes the execute functions in the contract.\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Extend the lockup time for your staked xASTRO\n    ExtendLockTime { time: u64 },\n    /// Receives a message of type [`Cw20ReceiveMsg`] and processes it depending on the received\n    /// template.\n    Receive(Cw20ReceiveMsg),\n    /// Withdraw xASTRO from the vxASTRO contract\n    Withdraw {},\n    /// Propose a new owner for the contract\n    ProposeNewOwner { new_owner: String, expires_in: u64 },\n    /// Remove the ownership transfer proposal\n    DropOwnershipProposal {},\n    /// Claim contract ownership\n    ClaimOwnership {},\n    /// Add or remove accounts from the blacklist\n    UpdateBlacklist {\n        append_addrs: Option\u003cVec\u003cString\u003e\u003e,\n        remove_addrs: Option\u003cVec\u003cString\u003e\u003e,\n    },\n    /// Update the marketing info for the vxASTRO contract\n    UpdateMarketing {\n        /// A URL pointing to the project behind this token\n        project: Option\u003cString\u003e,\n        /// A longer description of the token and its utility. Designed for tooltips or such\n        description: Option\u003cString\u003e,\n        /// The address (if any) that can update this data structure\n        marketing: Option\u003cString\u003e,\n    },\n    /// Upload a logo for vxASTRO\n    UploadLogo(Logo),\n    /// Update config\n    UpdateConfig { new_guardian: Option\u003cString\u003e },\n    /// Set whitelisted logo urls\n    SetLogoUrlsWhitelist { whitelist: Vec\u003cString\u003e },\n}\n\n/// This structure describes a CW20 hook message.\n#[cw_serde]\npub enum Cw20HookMsg {\n    /// Create a vxASTRO position and lock xASTRO for `time` amount of time\n    CreateLock { time: u64 },\n    /// Deposit xASTRO in another user's vxASTRO position\n    DepositFor { user: String },\n    /// Add more xASTRO to your vxASTRO position\n    ExtendLockAmount {},\n}\n\n/// This enum describes voters status.\n#[cw_serde]\npub enum BlacklistedVotersResponse {\n    /// Voters are blacklisted\n    VotersBlacklisted {},\n    /// Returns a voter that is not blacklisted.\n    VotersNotBlacklisted { voter: String },\n}\n\nimpl fmt::Display for BlacklistedVotersResponse {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            BlacklistedVotersResponse::VotersBlacklisted {} =\u003e write!(f, \"Voters are blacklisted!\"),\n            BlacklistedVotersResponse::VotersNotBlacklisted { voter } =\u003e {\n                write!(f, \"Voter is not blacklisted: {voter}\")\n            }\n        }\n    }\n}\n\n/// This structure describes the query messages available in the contract.\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// Checks if specified addresses are blacklisted\n    #[returns(BlacklistedVotersResponse)]\n    CheckVotersAreBlacklisted { voters: Vec\u003cString\u003e },\n    /// Return the blacklisted voters\n    #[returns(Vec\u003cAddr\u003e)]\n    BlacklistedVoters {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    /// Return the user's vxASTRO balance\n    #[returns(BalanceResponse)]\n    Balance { address: String },\n    /// Fetch the vxASTRO token information\n    #[returns(TokenInfoResponse)]\n    TokenInfo {},\n    /// Fetch vxASTRO's marketing information\n    #[returns(MarketingInfoResponse)]\n    MarketingInfo {},\n    /// Download the vxASTRO logo\n    #[returns(DownloadLogoResponse)]\n    DownloadLogo {},\n    /// Return the current total amount of vxASTRO\n    #[returns(VotingPowerResponse)]\n    TotalVotingPower {},\n    /// Return the total amount of vxASTRO at some point in the past\n    #[returns(VotingPowerResponse)]\n    TotalVotingPowerAt { time: u64 },\n    /// Return the total voting power at a specific period\n    #[returns(VotingPowerResponse)]\n    TotalVotingPowerAtPeriod { period: u64 },\n    /// Return the user's current voting power (vxASTRO balance)\n    #[returns(VotingPowerResponse)]\n    UserVotingPower { user: String },\n    /// Return the user's vxASTRO balance at some point in the past\n    #[returns(VotingPowerResponse)]\n    UserVotingPowerAt { user: String, time: u64 },\n    /// Return the user's voting power at a specific period\n    #[returns(VotingPowerResponse)]\n    UserVotingPowerAtPeriod { user: String, period: u64 },\n    /// Return information about a user's lock position\n    #[returns(LockInfoResponse)]\n    LockInfo { user: String },\n    /// Return user's locked xASTRO balance at the given block height\n    #[returns(Uint128)]\n    UserDepositAtHeight { user: String, height: u64 },\n    /// Return the  vxASTRO contract configuration\n    #[returns(ConfigResponse)]\n    Config {},\n}\n\n/// This structure is used to return a user's amount of vxASTRO.\n#[cw_serde]\npub struct VotingPowerResponse {\n    /// The vxASTRO balance\n    pub voting_power: Uint128,\n}\n\n/// This structure is used to return the lock information for a vxASTRO position.\n#[cw_serde]\npub struct LockInfoResponse {\n    /// The amount of xASTRO locked in the position\n    pub amount: Uint128,\n    /// This is the initial boost for the lock position\n    pub coefficient: Decimal,\n    /// Start time for the vxASTRO position decay\n    pub start: u64,\n    /// End time for the vxASTRO position decay\n    pub end: u64,\n    /// Slope at which a staker's vxASTRO balance decreases over time\n    pub slope: Uint128,\n}\n\n/// This structure stores the parameters returned when querying for a contract's configuration.\n#[cw_serde]\npub struct ConfigResponse {\n    /// Address that's allowed to change contract parameters\n    pub owner: String,\n    /// Address that can only blacklist vxASTRO stakers and remove their governance power\n    pub guardian_addr: Option\u003cAddr\u003e,\n    /// The xASTRO token contract address\n    pub deposit_token_addr: String,\n    /// The address of $ASTRO\n    pub astro_addr: String,\n    /// The address of $xASTRO staking contract\n    pub xastro_staking_addr: String,\n    /// The list of whitelisted logo urls prefixes\n    pub logo_urls_whitelist: Vec\u003cString\u003e,\n}\n\n/// This structure describes a Migration message.\n#[cw_serde]\npub struct MigrateMsg {\n    pub params: Binary,\n}\n\n/// Queries current user's voting power from the voting escrow contract.\n///\n/// * **user** staker for which we calculate the latest vxASTRO voting power.\npub fn get_voting_power(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    user: impl Into\u003cString\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse =\n        querier.query_wasm_smart(escrow_addr, \u0026UserVotingPower { user: user.into() })?;\n    Ok(vp.voting_power)\n}\n\n/// Queries current user's voting power from the voting escrow contract by timestamp.\n///\n/// * **user** staker for which we calculate the voting power at a specific time.\n///\n/// * **timestamp** timestamp at which we calculate the staker's voting power.\npub fn get_voting_power_at(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    user: impl Into\u003cString\u003e,\n    timestamp: u64,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse = querier.query_wasm_smart(\n        escrow_addr,\n        \u0026UserVotingPowerAt {\n            user: user.into(),\n            time: timestamp,\n        },\n    )?;\n\n    Ok(vp.voting_power)\n}\n\n/// Queries current total voting power from the voting escrow contract.\npub fn get_total_voting_power(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse = querier.query_wasm_smart(escrow_addr, \u0026TotalVotingPower {})?;\n\n    Ok(vp.voting_power)\n}\n\n/// Queries total voting power from the voting escrow contract by timestamp.\n///\n/// * **timestamp** time at which we fetch the total voting power.\npub fn get_total_voting_power_at(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    timestamp: u64,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse =\n        querier.query_wasm_smart(escrow_addr, \u0026TotalVotingPowerAt { time: timestamp })?;\n\n    Ok(vp.voting_power)\n}\n\n/// Queries user's lockup information from the voting escrow contract.\n///\n/// * **user** staker for which we return lock position information.\npub fn get_lock_info(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    user: impl Into\u003cString\u003e,\n) -\u003e StdResult\u003cLockInfoResponse\u003e {\n    let lock_info: LockInfoResponse =\n        querier.query_wasm_smart(escrow_addr, \u0026LockInfo { user: user.into() })?;\n    Ok(lock_info)\n}\n","traces":[{"line":108,"address":[7149312],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":109,"address":[7149345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[7149370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[7149433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[7149438],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","voting_escrow_delegation.rs"],"content":"use crate::voting_escrow_delegation::QueryMsg::AdjustedBalance;\nuse cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::{Addr, QuerierWrapper, StdResult, Uint128};\n\n/// This structure stores the main parameters for the voting escrow delegation contract.\n#[cw_serde]\npub struct Config {\n    /// Address that's allowed to change contract parameters\n    pub owner: Addr,\n    /// Astroport NFT contract address\n    pub nft_addr: Addr,\n    /// vxASTRO contract address\n    pub voting_escrow_addr: Addr,\n}\n\n#[cw_serde]\npub struct Token {\n    /// The amount of voting power to be delegated\n    pub power: Uint128,\n    /// Weekly voting power decay\n    pub slope: Uint128,\n    /// The start period when the delegated voting power start to decrease\n    pub start: u64,\n    /// The period when the delegated voting power should expire\n    pub expire_period: u64,\n}\n\n#[cw_serde]\npub struct InstantiateMsg {\n    /// The contract owner address\n    pub owner: String,\n    /// Astroport NFT code identifier\n    pub nft_code_id: u64,\n    /// vxASTRO contract address\n    pub voting_escrow_addr: String,\n}\n\n#[cw_serde]\npub enum ExecuteMsg {\n    CreateDelegation {\n        /// The share of voting power (in bps) that will be delegated to the recipient\n        bps: u16,\n        expire_time: u64,\n        token_id: String,\n        recipient: String,\n    },\n    ExtendDelegation {\n        /// The share of voting power (in bps) that will be delegated to the recipient\n        bps: u16,\n        expire_time: u64,\n        token_id: String,\n    },\n    UpdateConfig {\n        /// vxASTRO contract address\n        new_voting_escrow: Option\u003cString\u003e,\n    },\n    /// Propose a new owner for the contract\n    ProposeNewOwner { new_owner: String, expires_in: u64 },\n    /// Remove the ownership transfer proposal\n    DropOwnershipProposal {},\n    /// Claim contract ownership\n    ClaimOwnership {},\n}\n\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    #[returns(Config)]\n    Config {},\n    #[returns(Uint128)]\n    AdjustedBalance {\n        account: String,\n        timestamp: Option\u003cu64\u003e,\n    },\n    #[returns(Uint128)]\n    DelegatedVotingPower {\n        account: String,\n        timestamp: Option\u003cu64\u003e,\n    },\n}\n\n/// Queries current user's adjusted voting power from the voting escrow delegation contract.\npub fn get_adjusted_balance(\n    querier: \u0026QuerierWrapper,\n    escrow_delegation_addr: String,\n    account: String,\n    timestamp: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    querier.query_wasm_smart(\n        escrow_delegation_addr,\n        \u0026AdjustedBalance { account, timestamp },\n    )\n}\n","traces":[{"line":83,"address":[6750996,6750864],"length":1,"stats":{"Line":0},"fn_name":"get_adjusted_balance"},{"line":89,"address":[6750927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[6750891],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-governance","src","voting_escrow_lite.rs"],"content":"use crate::voting_escrow_lite::QueryMsg::{\n    LockInfo, TotalVotingPower, TotalVotingPowerAt, UserDepositAtTime, UserEmissionsVotingPower,\n    UserVotingPower, UserVotingPowerAt,\n};\nuse cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::{Addr, Binary, QuerierWrapper, StdResult, Uint128, Uint64};\nuse cw20::{\n    BalanceResponse, Cw20ReceiveMsg, DownloadLogoResponse, Logo, MarketingInfoResponse,\n    TokenInfoResponse,\n};\nuse std::fmt;\n\n/// ## Pagination settings\n/// The maximum amount of items that can be read at once from\npub const MAX_LIMIT: u32 = 30;\n\n/// The default amount of items to read from\npub const DEFAULT_LIMIT: u32 = 10;\n\npub const DEFAULT_PERIODS_LIMIT: u64 = 20;\n\n/// This structure stores marketing information for vxASTRO.\n#[cw_serde]\npub struct UpdateMarketingInfo {\n    /// Project URL\n    pub project: Option\u003cString\u003e,\n    /// Token description\n    pub description: Option\u003cString\u003e,\n    /// Token marketing information\n    pub marketing: Option\u003cString\u003e,\n    /// Token logo\n    pub logo: Option\u003cLogo\u003e,\n}\n\n/// This structure stores general parameters for the vxASTRO contract.\n#[cw_serde]\npub struct InstantiateMsg {\n    /// The vxASTRO contract owner\n    pub owner: String,\n    /// Address that's allowed to black or whitelist contracts\n    pub guardian_addr: Option\u003cString\u003e,\n    /// xASTRO token address\n    pub deposit_token_addr: String,\n    /// Marketing info for vxASTRO\n    pub marketing: Option\u003cUpdateMarketingInfo\u003e,\n    /// The list of whitelisted logo urls prefixes\n    pub logo_urls_whitelist: Vec\u003cString\u003e,\n    /// Minimum unlock wait time in seconds,\n    /// if not provided, defaults to 2 weeks\n    pub unlock_period: Option\u003cu64\u003e,\n    /// Address of the Generator controller to kick unlocked users\n    pub generator_controller_addr: Option\u003cString\u003e,\n}\n\n/// This structure describes the execute functions in the contract.\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Receives a message of type [`Cw20ReceiveMsg`] and processes it depending on the received\n    /// template.\n    Receive(Cw20ReceiveMsg),\n    /// Unlock xASTRO from the vxASTRO contract\n    Unlock {},\n    /// Withdraw xASTRO from the vxASTRO contract\n    Withdraw {},\n    /// Propose a new owner for the contract\n    ProposeNewOwner { new_owner: String, expires_in: u64 },\n    /// Remove the ownership transfer proposal\n    DropOwnershipProposal {},\n    /// Claim contract ownership\n    ClaimOwnership {},\n    /// Add or remove accounts from the blacklist\n    UpdateBlacklist {\n        append_addrs: Option\u003cVec\u003cString\u003e\u003e,\n        remove_addrs: Option\u003cVec\u003cString\u003e\u003e,\n    },\n    /// Update the marketing info for the vxASTRO contract\n    UpdateMarketing {\n        /// A URL pointing to the project behind this token\n        project: Option\u003cString\u003e,\n        /// A longer description of the token and its utility. Designed for tooltips or such\n        description: Option\u003cString\u003e,\n        /// The address (if any) that can update this data structure\n        marketing: Option\u003cString\u003e,\n    },\n    /// Upload a logo for vxASTRO\n    UploadLogo(Logo),\n    /// Update config\n    UpdateConfig {\n        new_guardian: Option\u003cString\u003e,\n        generator_controller: Option\u003cString\u003e,\n    },\n    /// Set whitelisted logo urls\n    SetLogoUrlsWhitelist { whitelist: Vec\u003cString\u003e },\n}\n\n/// This structure describes a CW20 hook message.\n#[cw_serde]\npub enum Cw20HookMsg {\n    /// Create a vxASTRO position and lock xASTRO for `time` amount of time\n    CreateLock { time: u64 },\n    /// Deposit xASTRO in another user's vxASTRO position\n    DepositFor { user: String },\n    /// Add more xASTRO to your vxASTRO position\n    ExtendLockAmount {},\n}\n\n/// This enum describes voters status.\n#[cw_serde]\npub enum BlacklistedVotersResponse {\n    /// Voters are blacklisted\n    VotersBlacklisted {},\n    /// Returns a voter that is not blacklisted.\n    VotersNotBlacklisted { voter: String },\n}\n\nimpl fmt::Display for BlacklistedVotersResponse {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            BlacklistedVotersResponse::VotersBlacklisted {} =\u003e write!(f, \"Voters are blacklisted!\"),\n            BlacklistedVotersResponse::VotersNotBlacklisted { voter } =\u003e {\n                write!(f, \"Voter is not blacklisted: {voter}\")\n            }\n        }\n    }\n}\n\n/// This structure describes the query messages available in the contract.\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    /// Checks if specified addresses are blacklisted\n    #[returns(BlacklistedVotersResponse)]\n    CheckVotersAreBlacklisted { voters: Vec\u003cString\u003e },\n    /// Return the blacklisted voters\n    #[returns(Vec\u003cAddr\u003e)]\n    BlacklistedVoters {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    /// Return the user's vxASTRO balance\n    #[returns(BalanceResponse)]\n    Balance { address: String },\n    /// Fetch the vxASTRO token information\n    #[returns(TokenInfoResponse)]\n    TokenInfo {},\n    /// Fetch vxASTRO's marketing information\n    #[returns(MarketingInfoResponse)]\n    MarketingInfo {},\n    /// Download the vxASTRO logo\n    #[returns(DownloadLogoResponse)]\n    DownloadLogo {},\n    /// Return the current total amount of vxASTRO\n    #[returns(VotingPowerResponse)]\n    TotalVotingPower {},\n    /// Return the total amount of vxASTRO at some point in the past\n    #[returns(VotingPowerResponse)]\n    TotalVotingPowerAt { time: u64 },\n    /// Return the total voting power at a specific period\n    #[returns(VotingPowerResponse)]\n    TotalVotingPowerAtPeriod { period: u64 },\n    /// Return the user's current voting power (vxASTRO balance)\n    #[returns(VotingPowerResponse)]\n    UserVotingPower { user: String },\n    /// Return the user's vxASTRO balance at some point in the past\n    #[returns(VotingPowerResponse)]\n    UserVotingPowerAt { user: String, time: u64 },\n    /// Return the user's voting power at a specific period\n    #[returns(VotingPowerResponse)]\n    UserVotingPowerAtPeriod { user: String, period: u64 },\n\n    #[returns(VotingPowerResponse)]\n    TotalEmissionsVotingPower {},\n    /// Return the total amount of vxASTRO at some point in the past\n    #[returns(VotingPowerResponse)]\n    TotalEmissionsVotingPowerAt { time: u64 },\n    /// Return the total voting power at a specific period\n    #[returns(VotingPowerResponse)]\n    TotalEmissionsVotingPowerAtPeriod { period: u64 },\n    /// Return the user's current emission voting power\n    #[returns(VotingPowerResponse)]\n    UserEmissionsVotingPower { user: String },\n    /// Return the user's emission voting power  at some point in the past\n    #[returns(VotingPowerResponse)]\n    UserEmissionsVotingPowerAt { user: String, time: u64 },\n    /// Return the user's emission voting power at a specific period\n    #[returns(VotingPowerResponse)]\n    UserEmissionsVotingPowerAtPeriod { user: String, period: u64 },\n\n    #[returns(LockInfoResponse)]\n    LockInfo { user: String },\n    /// Return user's locked xASTRO balance at the given block height\n    #[returns(Uint128)]\n    UserDepositAtHeight { user: String, height: u64 },\n    /// Return user's locked xASTRO balance at the given timestamp\n    #[returns(Uint128)]\n    UserDepositAtTime { user: String, timestamp: Uint64 },\n    /// Return the  vxASTRO contract configuration\n    #[returns(ConfigResponse)]\n    Config {},\n}\n\n/// This structure is used to return a user's amount of vxASTRO.\n#[cw_serde]\npub struct VotingPowerResponse {\n    /// The vxASTRO balance\n    pub voting_power: Uint128,\n}\n\n/// This structure is used to return the lock information for a vxASTRO position.\n#[cw_serde]\npub struct LockInfoResponse {\n    /// The amount of xASTRO locked in the position\n    pub amount: Uint128,\n    /// Indicates the end of a lock period, if None the position is locked\n    pub end: Option\u003cu64\u003e,\n}\n\n/// This structure stores the parameters returned when querying for a contract's configuration.\n#[cw_serde]\npub struct ConfigResponse {\n    /// Address that's allowed to change contract parameters\n    pub owner: String,\n    /// Address that can only blacklist vxASTRO stakers and remove their governance power\n    pub guardian_addr: Option\u003cAddr\u003e,\n    /// The xASTRO token contract address\n    pub deposit_token_addr: String,\n    /// The address of $ASTRO\n    pub astro_addr: String,\n    /// The address of $xASTRO staking contract\n    pub xastro_staking_addr: String,\n    /// The list of whitelisted logo urls prefixes\n    pub logo_urls_whitelist: Vec\u003cString\u003e,\n}\n\n/// This structure describes a Migration message.\n#[cw_serde]\npub struct MigrateMsg {\n    pub params: Binary,\n}\n\n/// Queries current user's deposit from the voting escrow contract.\n///\n/// * **user** staker for which we fetch the latest xASTRO deposits.\n///\n/// * **timestamp** timestamp to fetch deposits at.\npub fn get_user_deposit_at_time(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    user: impl Into\u003cString\u003e,\n    timestamp: u64,\n) -\u003e StdResult\u003cUint128\u003e {\n    let balance = querier.query_wasm_smart(\n        escrow_addr,\n        \u0026UserDepositAtTime {\n            user: user.into(),\n            timestamp: Uint64::from(timestamp),\n        },\n    )?;\n    Ok(balance)\n}\n\n/// Queries current user's voting power from the voting escrow contract.\n///\n/// * **user** staker for which we calculate the latest vxASTRO voting power.\npub fn get_voting_power(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    user: impl Into\u003cString\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse =\n        querier.query_wasm_smart(escrow_addr, \u0026UserVotingPower { user: user.into() })?;\n    Ok(vp.voting_power)\n}\n\n/// Queries current user's emissions voting power from the voting escrow contract.\n///\n/// * **user** staker for which we calculate the latest vxASTRO voting power.\npub fn get_emissions_voting_power(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    user: impl Into\u003cString\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse =\n        querier.query_wasm_smart(escrow_addr, \u0026UserEmissionsVotingPower { user: user.into() })?;\n    Ok(vp.voting_power)\n}\n\n/// Queries current user's voting power from the voting escrow contract by timestamp.\n///\n/// * **user** staker for which we calculate the voting power at a specific time.\n///\n/// * **timestamp** timestamp at which we calculate the staker's voting power.\npub fn get_voting_power_at(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    user: impl Into\u003cString\u003e,\n    timestamp: u64,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse = querier.query_wasm_smart(\n        escrow_addr,\n        \u0026UserVotingPowerAt {\n            user: user.into(),\n            time: timestamp,\n        },\n    )?;\n\n    Ok(vp.voting_power)\n}\n\n/// Queries current total voting power from the voting escrow contract.\npub fn get_total_voting_power(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse = querier.query_wasm_smart(escrow_addr, \u0026TotalVotingPower {})?;\n\n    Ok(vp.voting_power)\n}\n\n/// Queries total voting power from the voting escrow contract by timestamp.\n///\n/// * **timestamp** time at which we fetch the total voting power.\npub fn get_total_voting_power_at(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    timestamp: u64,\n) -\u003e StdResult\u003cUint128\u003e {\n    let vp: VotingPowerResponse =\n        querier.query_wasm_smart(escrow_addr, \u0026TotalVotingPowerAt { time: timestamp })?;\n\n    Ok(vp.voting_power)\n}\n\n/// Queries user's lockup information from the voting escrow contract.\n///\n/// * **user** staker for which we return lock position information.\npub fn get_lock_info(\n    querier: \u0026QuerierWrapper,\n    escrow_addr: impl Into\u003cString\u003e,\n    user: impl Into\u003cString\u003e,\n) -\u003e StdResult\u003cLockInfoResponse\u003e {\n    let lock_info: LockInfoResponse =\n        querier.query_wasm_smart(escrow_addr, \u0026LockInfo { user: user.into() })?;\n    Ok(lock_info)\n}\n","traces":[{"line":117,"address":[7565040],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":118,"address":[7565073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[7565098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[7565161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[7565166],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-tests","src","base.rs"],"content":"use cosmwasm_schema::cw_serde;\n\nuse astroport::staking;\nuse astroport::token::InstantiateMsg as AstroTokenInstantiateMsg;\nuse astroport_governance::escrow_fee_distributor::InstantiateMsg as EscrowFeeDistributorInstantiateMsg;\nuse astroport_governance::voting_escrow::{\n    Cw20HookMsg, ExecuteMsg, InstantiateMsg as AstroVotingEscrowInstantiateMsg, QueryMsg,\n    VotingPowerResponse,\n};\nuse cosmwasm_std::{attr, to_binary, Addr, QueryRequest, StdResult, Uint128, WasmQuery};\nuse cw20::{BalanceResponse, Cw20ExecuteMsg, Cw20QueryMsg, MinterResponse};\n\nuse anyhow::Result;\nuse cw_multi_test::{App, AppResponse, ContractWrapper, Executor};\n\npub const MULTIPLIER: u64 = 1_000_000;\n\n#[cw_serde]\npub struct ContractInfo {\n    pub address: Addr,\n    pub code_id: u64,\n}\n\n#[cw_serde]\npub struct BaseAstroportTestPackage {\n    pub owner: Addr,\n    pub astro_token: Option\u003cContractInfo\u003e,\n    pub escrow_fee_distributor: Option\u003cContractInfo\u003e,\n    pub staking: Option\u003cContractInfo\u003e,\n    pub voting_escrow: Option\u003cContractInfo\u003e,\n}\n\n#[cw_serde]\npub struct BaseAstroportTestInitMessage {\n    pub owner: Addr,\n}\n\nimpl BaseAstroportTestPackage {\n    pub fn init_all(router: \u0026mut App, msg: BaseAstroportTestInitMessage) -\u003e Self {\n        let mut base_pack = BaseAstroportTestPackage {\n            owner: msg.owner.clone(),\n            astro_token: None,\n            escrow_fee_distributor: None,\n            staking: None,\n            voting_escrow: None,\n        };\n\n        base_pack.init_astro_token(router, msg.owner.clone());\n        base_pack.init_staking(router, msg.owner.clone());\n        base_pack.init_voting_escrow(router, msg.owner.clone());\n        base_pack.init_escrow_fee_distributor(router, msg.owner);\n        base_pack\n    }\n\n    fn init_astro_token(\u0026mut self, router: \u0026mut App, owner: Addr) {\n        let astro_token_contract = Box::new(ContractWrapper::new_with_empty(\n            astroport_token::contract::execute,\n            astroport_token::contract::instantiate,\n            astroport_token::contract::query,\n        ));\n\n        let astro_token_code_id = router.store_code(astro_token_contract);\n\n        let init_msg = AstroTokenInstantiateMsg {\n            name: String::from(\"Astro token\"),\n            symbol: String::from(\"ASTRO\"),\n            decimals: 6,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                minter: owner.to_string(),\n                cap: None,\n            }),\n            marketing: None,\n        };\n\n        let astro_token_instance = router\n            .instantiate_contract(\n                astro_token_code_id,\n                owner,\n                \u0026init_msg,\n                \u0026[],\n                \"Astro token\",\n                None,\n            )\n            .unwrap();\n\n        self.astro_token = Some(ContractInfo {\n            address: astro_token_instance,\n            code_id: astro_token_code_id,\n        })\n    }\n\n    fn init_staking(\u0026mut self, router: \u0026mut App, owner: Addr) {\n        let staking_contract = Box::new(\n            ContractWrapper::new_with_empty(\n                astroport_staking::contract::execute,\n                astroport_staking::contract::instantiate,\n                astroport_staking::contract::query,\n            )\n            .with_reply_empty(astroport_staking::contract::reply),\n        );\n\n        let staking_code_id = router.store_code(staking_contract);\n\n        let msg = staking::InstantiateMsg {\n            owner: owner.to_string(),\n            token_code_id: self.astro_token.clone().unwrap().code_id,\n            deposit_token_addr: self.astro_token.clone().unwrap().address.to_string(),\n            marketing: None,\n        };\n\n        let staking_instance = router\n            .instantiate_contract(\n                staking_code_id,\n                owner,\n                \u0026msg,\n                \u0026[],\n                String::from(\"xASTRO\"),\n                None,\n            )\n            .unwrap();\n\n        self.staking = Some(ContractInfo {\n            address: staking_instance,\n            code_id: staking_code_id,\n        })\n    }\n\n    pub fn get_staking_xastro(\u0026self, router: \u0026App) -\u003e Addr {\n        let res = router\n            .wrap()\n            .query::\u003cstaking::ConfigResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                contract_addr: self.staking.clone().unwrap().address.to_string(),\n                msg: to_binary(\u0026staking::QueryMsg::Config {}).unwrap(),\n            }))\n            .unwrap();\n\n        res.share_token_addr\n    }\n\n    fn init_voting_escrow(\u0026mut self, router: \u0026mut App, owner: Addr) {\n        let voting_contract = Box::new(ContractWrapper::new_with_empty(\n            voting_escrow::contract::execute,\n            voting_escrow::contract::instantiate,\n            voting_escrow::contract::query,\n        ));\n\n        let voting_code_id = router.store_code(voting_contract);\n\n        let msg = AstroVotingEscrowInstantiateMsg {\n            guardian_addr: Some(\"guardian\".to_string()),\n            marketing: None,\n            owner: owner.to_string(),\n            deposit_token_addr: self.get_staking_xastro(router).to_string(),\n            logo_urls_whitelist: vec![],\n        };\n\n        let voting_instance = router\n            .instantiate_contract(\n                voting_code_id,\n                owner,\n                \u0026msg,\n                \u0026[],\n                String::from(\"vxASTRO\"),\n                None,\n            )\n            .unwrap();\n\n        self.voting_escrow = Some(ContractInfo {\n            address: voting_instance,\n            code_id: voting_code_id,\n        })\n    }\n\n    pub fn init_escrow_fee_distributor(\u0026mut self, router: \u0026mut App, owner: Addr) {\n        let escrow_fee_distributor_contract = Box::new(ContractWrapper::new_with_empty(\n            astroport_escrow_fee_distributor::contract::execute,\n            astroport_escrow_fee_distributor::contract::instantiate,\n            astroport_escrow_fee_distributor::contract::query,\n        ));\n\n        let escrow_fee_distributor_code_id = router.store_code(escrow_fee_distributor_contract);\n\n        let init_msg = EscrowFeeDistributorInstantiateMsg {\n            owner: owner.to_string(),\n            astro_token: self.astro_token.clone().unwrap().address.to_string(),\n            voting_escrow_addr: self.voting_escrow.clone().unwrap().address.to_string(),\n            claim_many_limit: None,\n            is_claim_disabled: None,\n        };\n\n        let escrow_fee_distributor_instance = router\n            .instantiate_contract(\n                escrow_fee_distributor_code_id,\n                owner,\n                \u0026init_msg,\n                \u0026[],\n                \"Astroport escrow fee distributor\",\n                None,\n            )\n            .unwrap();\n\n        self.escrow_fee_distributor = Some(ContractInfo {\n            address: escrow_fee_distributor_instance,\n            code_id: escrow_fee_distributor_code_id,\n        })\n    }\n\n    pub fn create_lock(\n        \u0026self,\n        router: \u0026mut App,\n        user: Addr,\n        time: u64,\n        amount: u64,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let amount = amount * MULTIPLIER;\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.voting_escrow.clone().unwrap().address.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::CreateLock { time }).unwrap(),\n        };\n\n        router.execute_contract(user, self.get_staking_xastro(router), \u0026cw20msg, \u0026[])\n    }\n\n    pub fn extend_lock_amount(\n        \u0026mut self,\n        router: \u0026mut App,\n        user: \u0026str,\n        amount: u64,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let amount = amount * MULTIPLIER;\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.voting_escrow.clone().unwrap().address.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::ExtendLockAmount {}).unwrap(),\n        };\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.get_staking_xastro(router),\n            \u0026cw20msg,\n            \u0026[],\n        )\n    }\n\n    pub fn extend_lock_time(\n        \u0026mut self,\n        router: \u0026mut App,\n        user: \u0026str,\n        time: u64,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.voting_escrow.clone().unwrap().address,\n            \u0026ExecuteMsg::ExtendLockTime { time },\n            \u0026[],\n        )\n    }\n\n    pub fn withdraw(\u0026self, router: \u0026mut App, user: \u0026str) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.voting_escrow.clone().unwrap().address,\n            \u0026ExecuteMsg::Withdraw {},\n            \u0026[],\n        )\n    }\n\n    pub fn query_user_vp(\u0026self, router: \u0026mut App, user: Addr) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_escrow.clone().unwrap().address,\n                \u0026QueryMsg::UserVotingPower {\n                    user: user.to_string(),\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_user_vp_at(\u0026self, router: \u0026mut App, user: Addr, time: u64) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_escrow.clone().unwrap().address,\n                \u0026QueryMsg::UserVotingPowerAt {\n                    user: user.to_string(),\n                    time,\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_total_vp(\u0026self, router: \u0026mut App) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_escrow.clone().unwrap().address,\n                \u0026QueryMsg::TotalVotingPower {},\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_total_vp_at(\u0026self, router: \u0026mut App, time: u64) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.voting_escrow.clone().unwrap().address,\n                \u0026QueryMsg::TotalVotingPowerAt { time },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n}\n\npub fn mint(router: \u0026mut App, owner: Addr, token_instance: Addr, to: \u0026Addr, amount: u128) {\n    let amount = amount * MULTIPLIER as u128;\n    let msg = cw20::Cw20ExecuteMsg::Mint {\n        recipient: to.to_string(),\n        amount: Uint128::from(amount),\n    };\n\n    let res = router\n        .execute_contract(owner, token_instance, \u0026msg, \u0026[])\n        .unwrap();\n    assert_eq!(res.events[1].attributes[1], attr(\"action\", \"mint\"));\n    assert_eq!(res.events[1].attributes[2], attr(\"to\", String::from(to)));\n    assert_eq!(\n        res.events[1].attributes[3],\n        attr(\"amount\", Uint128::from(amount))\n    );\n}\n\npub fn check_balance(app: \u0026mut App, token_addr: \u0026Addr, contract_addr: \u0026Addr, expected: u128) {\n    let msg = Cw20QueryMsg::Balance {\n        address: contract_addr.to_string(),\n    };\n    let res: StdResult\u003cBalanceResponse\u003e = app.wrap().query_wasm_smart(token_addr, \u0026msg);\n    assert_eq!(res.unwrap().balance, Uint128::from(expected));\n}\n\npub fn increase_allowance(\n    router: \u0026mut App,\n    owner: Addr,\n    spender: Addr,\n    token: Addr,\n    amount: Uint128,\n) {\n    let msg = cw20::Cw20ExecuteMsg::IncreaseAllowance {\n        spender: spender.to_string(),\n        amount,\n        expires: None,\n    };\n\n    let res = router\n        .execute_contract(owner.clone(), token, \u0026msg, \u0026[])\n        .unwrap();\n\n    assert_eq!(\n        res.events[1].attributes[1],\n        attr(\"action\", \"increase_allowance\")\n    );\n    assert_eq!(\n        res.events[1].attributes[2],\n        attr(\"owner\", owner.to_string())\n    );\n    assert_eq!(\n        res.events[1].attributes[3],\n        attr(\"spender\", spender.to_string())\n    );\n    assert_eq!(res.events[1].attributes[4], attr(\"amount\", amount));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-tests","src","controller_helper.rs"],"content":"use crate::escrow_helper::EscrowHelper;\nuse anyhow::Result as AnyResult;\nuse astroport::asset::{AssetInfo, PairInfo};\nuse astroport::factory::{PairConfig, PairType};\n\nuse astroport_governance::generator_controller::{ConfigResponse, ExecuteMsg, QueryMsg};\nuse cosmwasm_std::{Addr, Decimal, StdResult};\nuse cw_multi_test::{App, AppResponse, ContractWrapper, Executor};\nuse generator_controller::state::{UserInfo, VotedPoolInfo};\n\npub struct ControllerHelper {\n    pub owner: String,\n    pub generator: Addr,\n    pub controller: Addr,\n    pub factory: Addr,\n    pub escrow_helper: EscrowHelper,\n}\n\nimpl ControllerHelper {\n    pub fn init(router: \u0026mut App, owner: \u0026Addr) -\u003e Self {\n        let escrow_helper = EscrowHelper::init(router, owner.clone());\n\n        let pair_contract = Box::new(\n            ContractWrapper::new_with_empty(\n                astroport_pair::contract::execute,\n                astroport_pair::contract::instantiate,\n                astroport_pair::contract::query,\n            )\n            .with_reply_empty(astroport_pair::contract::reply),\n        );\n\n        let pair_code_id = router.store_code(pair_contract);\n\n        let factory_contract = Box::new(\n            ContractWrapper::new_with_empty(\n                astroport_factory::contract::execute,\n                astroport_factory::contract::instantiate,\n                astroport_factory::contract::query,\n            )\n            .with_reply_empty(astroport_factory::contract::reply),\n        );\n\n        let factory_code_id = router.store_code(factory_contract);\n\n        let whitelist_code_id = store_whitelist_code(router);\n\n        let msg = astroport::factory::InstantiateMsg {\n            pair_configs: vec![PairConfig {\n                code_id: pair_code_id,\n                pair_type: PairType::Xyk {},\n                total_fee_bps: 100,\n                maker_fee_bps: 10,\n                is_disabled: false,\n                is_generator_disabled: false,\n            }],\n            token_code_id: escrow_helper.astro_token_code_id,\n            fee_address: None,\n            generator_address: None,\n            owner: owner.to_string(),\n            whitelist_code_id,\n            coin_registry_address: Addr::unchecked(\"coin_registry\").to_string(),\n        };\n\n        let factory = router\n            .instantiate_contract(factory_code_id, owner.clone(), \u0026msg, \u0026[], \"Factory\", None)\n            .unwrap();\n\n        let generator_contract = Box::new(\n            ContractWrapper::new_with_empty(\n                astroport_generator::contract::execute,\n                astroport_generator::contract::instantiate,\n                astroport_generator::contract::query,\n            )\n            .with_reply_empty(astroport_generator::contract::reply),\n        );\n\n        let generator_code_id = router.store_code(generator_contract);\n        let init_msg = astroport::generator::InstantiateMsg {\n            owner: owner.to_string(),\n            factory: factory.to_string(),\n            generator_controller: None,\n            guardian: None,\n            astro_token: AssetInfo::NativeToken {\n                denom: escrow_helper.astro_token.to_string(),\n            },\n            tokens_per_block: Default::default(),\n            start_block: Default::default(),\n            vesting_contract: \"vesting_placeholder\".to_string(),\n            whitelist_code_id,\n            voting_escrow: None,\n            voting_escrow_delegation: None,\n        };\n\n        let generator = router\n            .instantiate_contract(\n                generator_code_id,\n                owner.clone(),\n                \u0026init_msg,\n                \u0026[],\n                String::from(\"Generator\"),\n                None,\n            )\n            .unwrap();\n\n        let controller_contract = Box::new(ContractWrapper::new_with_empty(\n            generator_controller::contract::execute,\n            generator_controller::contract::instantiate,\n            generator_controller::contract::query,\n        ));\n\n        let controller_code_id = router.store_code(controller_contract);\n        let init_msg = astroport_governance::generator_controller::InstantiateMsg {\n            owner: owner.to_string(),\n            escrow_addr: escrow_helper.escrow_instance.to_string(),\n            generator_addr: generator.to_string(),\n            factory_addr: factory.to_string(),\n            pools_limit: 5,\n            whitelisted_pools: vec![],\n        };\n\n        let controller = router\n            .instantiate_contract(\n                controller_code_id,\n                owner.clone(),\n                \u0026init_msg,\n                \u0026[],\n                String::from(\"Controller\"),\n                None,\n            )\n            .unwrap();\n\n        // Setup controller in generator contract\n        router\n            .execute_contract(\n                owner.clone(),\n                generator.clone(),\n                \u0026astroport::generator::ExecuteMsg::UpdateConfig {\n                    vesting_contract: None,\n                    generator_controller: Some(controller.to_string()),\n                    guardian: None,\n                    checkpoint_generator_limit: None,\n                    voting_escrow: None,\n                    voting_escrow_delegation: None,\n                },\n                \u0026[],\n            )\n            .unwrap();\n\n        Self {\n            owner: owner.to_string(),\n            generator,\n            controller,\n            factory,\n            escrow_helper,\n        }\n    }\n\n    pub fn init_cw20_token(\u0026self, router: \u0026mut App, name: \u0026str) -\u003e AnyResult\u003cAddr\u003e {\n        let msg = astroport::token::InstantiateMsg {\n            name: name.to_string(),\n            symbol: name.to_string(),\n            decimals: 6,\n            initial_balances: vec![],\n            mint: None,\n            marketing: None,\n        };\n\n        router.instantiate_contract(\n            self.escrow_helper.astro_token_code_id,\n            Addr::unchecked(self.owner.clone()),\n            \u0026msg,\n            \u0026[],\n            name.to_string(),\n            None,\n        )\n    }\n\n    pub fn create_pool(\u0026self, router: \u0026mut App, token1: \u0026Addr, token2: \u0026Addr) -\u003e AnyResult\u003cAddr\u003e {\n        let asset_infos = vec![\n            AssetInfo::Token {\n                contract_addr: token1.clone(),\n            },\n            AssetInfo::Token {\n                contract_addr: token2.clone(),\n            },\n        ];\n\n        router.execute_contract(\n            Addr::unchecked(self.owner.clone()),\n            self.factory.clone(),\n            \u0026astroport::factory::ExecuteMsg::CreatePair {\n                pair_type: PairType::Xyk {},\n                asset_infos: asset_infos.to_vec(),\n                init_params: None,\n            },\n            \u0026[],\n        )?;\n\n        let res: PairInfo = router.wrap().query_wasm_smart(\n            self.factory.clone(),\n            \u0026astroport::factory::QueryMsg::Pair {\n                asset_infos: asset_infos.to_vec(),\n            },\n        )?;\n\n        Ok(res.liquidity_token)\n    }\n\n    pub fn create_pool_with_tokens(\n        \u0026self,\n        router: \u0026mut App,\n        name1: \u0026str,\n        name2: \u0026str,\n    ) -\u003e AnyResult\u003cAddr\u003e {\n        let token1 = self.init_cw20_token(router, name1).unwrap();\n        let token2 = self.init_cw20_token(router, name2).unwrap();\n\n        self.create_pool(router, \u0026token1, \u0026token2)\n    }\n\n    pub fn vote(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        votes: Vec\u003c(impl Into\u003cString\u003e, u16)\u003e,\n    ) -\u003e AnyResult\u003cAppResponse\u003e {\n        let msg = ExecuteMsg::Vote {\n            votes: votes\n                .into_iter()\n                .map(|(pool, apoints)| (pool.into(), apoints))\n                .collect(),\n        };\n\n        router.execute_contract(Addr::unchecked(user), self.controller.clone(), \u0026msg, \u0026[])\n    }\n\n    pub fn tune(\u0026self, router: \u0026mut App) -\u003e AnyResult\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(\"anyone\"),\n            self.controller.clone(),\n            \u0026ExecuteMsg::TunePools {},\n            \u0026[],\n        )\n    }\n\n    pub fn kick_holders(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        blacklisted_voters: Vec\u003cString\u003e,\n    ) -\u003e AnyResult\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.controller.clone(),\n            \u0026ExecuteMsg::KickBlacklistedVoters { blacklisted_voters },\n            \u0026[],\n        )\n    }\n\n    pub fn update_blacklisted_limit(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        blacklisted_voters_limit: Option\u003cu32\u003e,\n    ) -\u003e AnyResult\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.controller.clone(),\n            \u0026ExecuteMsg::UpdateConfig {\n                blacklisted_voters_limit,\n                main_pool: None,\n                main_pool_min_alloc: None,\n                remove_main_pool: None,\n            },\n            \u0026[],\n        )\n    }\n\n    pub fn update_main_pool(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        main_pool: Option\u003c\u0026Addr\u003e,\n        main_pool_min_alloc: Option\u003cDecimal\u003e,\n        remove_main_pool: bool,\n    ) -\u003e AnyResult\u003cAppResponse\u003e {\n        let remove_main_pool = if remove_main_pool { Some(true) } else { None };\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.controller.clone(),\n            \u0026ExecuteMsg::UpdateConfig {\n                blacklisted_voters_limit: None,\n                main_pool: main_pool.map(|p| p.to_string()),\n                main_pool_min_alloc,\n                remove_main_pool,\n            },\n            \u0026[],\n        )\n    }\n\n    pub fn update_whitelist(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        add_pools: Option\u003cVec\u003cString\u003e\u003e,\n        remove_pools: Option\u003cVec\u003cString\u003e\u003e,\n    ) -\u003e AnyResult\u003cAppResponse\u003e {\n        let msg = ExecuteMsg::UpdateWhitelist {\n            add: add_pools,\n            remove: remove_pools,\n        };\n\n        router.execute_contract(Addr::unchecked(user), self.controller.clone(), \u0026msg, \u0026[])\n    }\n\n    pub fn query_user_info(\u0026self, router: \u0026mut App, user: \u0026str) -\u003e StdResult\u003cUserInfo\u003e {\n        router.wrap().query_wasm_smart(\n            self.controller.clone(),\n            \u0026QueryMsg::UserInfo {\n                user: user.to_string(),\n            },\n        )\n    }\n\n    pub fn query_voted_pool_info(\u0026self, router: \u0026mut App, pool: \u0026str) -\u003e StdResult\u003cVotedPoolInfo\u003e {\n        router.wrap().query_wasm_smart(\n            self.controller.clone(),\n            \u0026QueryMsg::PoolInfo {\n                pool_addr: pool.to_string(),\n            },\n        )\n    }\n\n    pub fn query_voted_pool_info_at_period(\n        \u0026self,\n        router: \u0026mut App,\n        pool: \u0026str,\n        period: u64,\n    ) -\u003e StdResult\u003cVotedPoolInfo\u003e {\n        router.wrap().query_wasm_smart(\n            self.controller.clone(),\n            \u0026QueryMsg::PoolInfoAtPeriod {\n                pool_addr: pool.to_string(),\n                period,\n            },\n        )\n    }\n\n    pub fn query_config(\u0026self, router: \u0026mut App) -\u003e StdResult\u003cConfigResponse\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(self.controller.clone(), \u0026QueryMsg::Config {})\n    }\n}\n\nfn store_whitelist_code(app: \u0026mut App) -\u003e u64 {\n    let whitelist_contract = Box::new(ContractWrapper::new_with_empty(\n        astroport_whitelist::contract::execute,\n        astroport_whitelist::contract::instantiate,\n        astroport_whitelist::contract::query,\n    ));\n\n    app.store_code(whitelist_contract)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-tests","src","escrow_helper.rs"],"content":"use anyhow::Result;\nuse astroport::{staking as xastro, token as astro};\nuse astroport_governance::voting_escrow::{\n    Cw20HookMsg, ExecuteMsg, InstantiateMsg, LockInfoResponse, QueryMsg, VotingPowerResponse,\n};\nuse cosmwasm_std::{attr, to_binary, Addr, QueryRequest, StdResult, Uint128, WasmQuery};\nuse cw20::{BalanceResponse, Cw20ExecuteMsg, Cw20QueryMsg, MinterResponse};\nuse cw_multi_test::{App, AppResponse, ContractWrapper, Executor};\n\npub const MULTIPLIER: u64 = 1000000;\n\npub struct EscrowHelper {\n    pub owner: Addr,\n    pub astro_token: Addr,\n    pub staking_instance: Addr,\n    pub xastro_token: Addr,\n    pub escrow_instance: Addr,\n    pub astro_token_code_id: u64,\n}\n\nimpl EscrowHelper {\n    pub fn init(router: \u0026mut App, owner: Addr) -\u003e Self {\n        let astro_token_contract = Box::new(ContractWrapper::new_with_empty(\n            astroport_token::contract::execute,\n            astroport_token::contract::instantiate,\n            astroport_token::contract::query,\n        ));\n\n        let astro_token_code_id = router.store_code(astro_token_contract);\n\n        let msg = astro::InstantiateMsg {\n            name: String::from(\"Astro token\"),\n            symbol: String::from(\"ASTRO\"),\n            decimals: 6,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                minter: owner.to_string(),\n                cap: None,\n            }),\n            marketing: None,\n        };\n\n        let astro_token = router\n            .instantiate_contract(\n                astro_token_code_id,\n                owner.clone(),\n                \u0026msg,\n                \u0026[],\n                String::from(\"ASTRO\"),\n                None,\n            )\n            .unwrap();\n\n        let staking_contract = Box::new(\n            ContractWrapper::new_with_empty(\n                astroport_staking::contract::execute,\n                astroport_staking::contract::instantiate,\n                astroport_staking::contract::query,\n            )\n            .with_reply_empty(astroport_staking::contract::reply),\n        );\n\n        let staking_code_id = router.store_code(staking_contract);\n\n        let msg = xastro::InstantiateMsg {\n            owner: owner.to_string(),\n            token_code_id: astro_token_code_id,\n            deposit_token_addr: astro_token.to_string(),\n            marketing: None,\n        };\n        let staking_instance = router\n            .instantiate_contract(\n                staking_code_id,\n                owner.clone(),\n                \u0026msg,\n                \u0026[],\n                String::from(\"xASTRO\"),\n                None,\n            )\n            .unwrap();\n\n        let res = router\n            .wrap()\n            .query::\u003cxastro::ConfigResponse\u003e(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                contract_addr: staking_instance.to_string(),\n                msg: to_binary(\u0026xastro::QueryMsg::Config {}).unwrap(),\n            }))\n            .unwrap();\n\n        let voting_contract = Box::new(ContractWrapper::new_with_empty(\n            voting_escrow::contract::execute,\n            voting_escrow::contract::instantiate,\n            voting_escrow::contract::query,\n        ));\n\n        let voting_code_id = router.store_code(voting_contract);\n\n        let msg = InstantiateMsg {\n            owner: owner.to_string(),\n            guardian_addr: Some(\"guardian\".to_string()),\n            deposit_token_addr: res.share_token_addr.to_string(),\n            marketing: None,\n            logo_urls_whitelist: vec![],\n        };\n        let voting_instance = router\n            .instantiate_contract(\n                voting_code_id,\n                owner.clone(),\n                \u0026msg,\n                \u0026[],\n                String::from(\"vxASTRO\"),\n                None,\n            )\n            .unwrap();\n\n        Self {\n            owner,\n            xastro_token: res.share_token_addr,\n            astro_token,\n            staking_instance,\n            escrow_instance: voting_instance,\n            astro_token_code_id,\n        }\n    }\n\n    pub fn mint_xastro(\u0026self, router: \u0026mut App, to: \u0026str, amount: u64) {\n        let amount = amount * MULTIPLIER;\n        let msg = Cw20ExecuteMsg::Mint {\n            recipient: String::from(to),\n            amount: Uint128::from(amount),\n        };\n        let res = router\n            .execute_contract(self.owner.clone(), self.astro_token.clone(), \u0026msg, \u0026[])\n            .unwrap();\n        assert_eq!(res.events[1].attributes[1], attr(\"action\", \"mint\"));\n        assert_eq!(res.events[1].attributes[2], attr(\"to\", String::from(to)));\n        assert_eq!(\n            res.events[1].attributes[3],\n            attr(\"amount\", Uint128::from(amount))\n        );\n\n        let to_addr = Addr::unchecked(to);\n        let msg = Cw20ExecuteMsg::Send {\n            contract: self.staking_instance.to_string(),\n            msg: to_binary(\u0026xastro::Cw20HookMsg::Enter {}).unwrap(),\n            amount: Uint128::from(amount),\n        };\n        router\n            .execute_contract(to_addr, self.astro_token.clone(), \u0026msg, \u0026[])\n            .unwrap();\n    }\n\n    pub fn check_xastro_balance(\u0026self, router: \u0026mut App, user: \u0026str, amount: u64) {\n        let amount = amount * MULTIPLIER;\n        let res: BalanceResponse = router\n            .wrap()\n            .query_wasm_smart(\n                self.xastro_token.clone(),\n                \u0026Cw20QueryMsg::Balance {\n                    address: user.to_string(),\n                },\n            )\n            .unwrap();\n        assert_eq!(res.balance.u128(), amount as u128);\n    }\n\n    pub fn create_lock(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        time: u64,\n        amount: f32,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let amount = (amount * MULTIPLIER as f32) as u64;\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.escrow_instance.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::CreateLock { time }).unwrap(),\n        };\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.xastro_token.clone(),\n            \u0026cw20msg,\n            \u0026[],\n        )\n    }\n\n    pub fn extend_lock_amount(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        amount: f32,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let amount = (amount * MULTIPLIER as f32) as u64;\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.escrow_instance.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::ExtendLockAmount {}).unwrap(),\n        };\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.xastro_token.clone(),\n            \u0026cw20msg,\n            \u0026[],\n        )\n    }\n\n    pub fn deposit_for(\n        \u0026self,\n        router: \u0026mut App,\n        from: \u0026str,\n        to: \u0026str,\n        amount: f32,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        let amount = (amount * MULTIPLIER as f32) as u64;\n        let cw20msg = Cw20ExecuteMsg::Send {\n            contract: self.escrow_instance.to_string(),\n            amount: Uint128::from(amount),\n            msg: to_binary(\u0026Cw20HookMsg::DepositFor {\n                user: to.to_string(),\n            })\n            .unwrap(),\n        };\n        router.execute_contract(\n            Addr::unchecked(from),\n            self.xastro_token.clone(),\n            \u0026cw20msg,\n            \u0026[],\n        )\n    }\n\n    pub fn extend_lock_time(\u0026self, router: \u0026mut App, user: \u0026str, time: u64) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.escrow_instance.clone(),\n            \u0026ExecuteMsg::ExtendLockTime { time },\n            \u0026[],\n        )\n    }\n\n    pub fn withdraw(\u0026self, router: \u0026mut App, user: \u0026str) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(user),\n            self.escrow_instance.clone(),\n            \u0026ExecuteMsg::Withdraw {},\n            \u0026[],\n        )\n    }\n\n    pub fn update_blacklist(\n        \u0026self,\n        router: \u0026mut App,\n        append_addrs: Option\u003cVec\u003cString\u003e\u003e,\n        remove_addrs: Option\u003cVec\u003cString\u003e\u003e,\n    ) -\u003e Result\u003cAppResponse\u003e {\n        router.execute_contract(\n            Addr::unchecked(\"owner\"),\n            self.escrow_instance.clone(),\n            \u0026ExecuteMsg::UpdateBlacklist {\n                append_addrs,\n                remove_addrs,\n            },\n            \u0026[],\n        )\n    }\n\n    pub fn query_user_vp(\u0026self, router: \u0026mut App, user: \u0026str) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.escrow_instance.clone(),\n                \u0026QueryMsg::UserVotingPower {\n                    user: user.to_string(),\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_user_vp_at(\u0026self, router: \u0026mut App, user: \u0026str, time: u64) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.escrow_instance.clone(),\n                \u0026QueryMsg::UserVotingPowerAt {\n                    user: user.to_string(),\n                    time,\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_user_vp_at_period(\n        \u0026self,\n        router: \u0026mut App,\n        user: \u0026str,\n        period: u64,\n    ) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.escrow_instance.clone(),\n                \u0026QueryMsg::UserVotingPowerAtPeriod {\n                    user: user.to_string(),\n                    period,\n                },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_total_vp(\u0026self, router: \u0026mut App) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(self.escrow_instance.clone(), \u0026QueryMsg::TotalVotingPower {})\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_total_vp_at(\u0026self, router: \u0026mut App, time: u64) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.escrow_instance.clone(),\n                \u0026QueryMsg::TotalVotingPowerAt { time },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_total_vp_at_period(\u0026self, router: \u0026mut App, period: u64) -\u003e StdResult\u003cf32\u003e {\n        router\n            .wrap()\n            .query_wasm_smart(\n                self.escrow_instance.clone(),\n                \u0026QueryMsg::TotalVotingPowerAtPeriod { period },\n            )\n            .map(|vp: VotingPowerResponse| vp.voting_power.u128() as f32 / MULTIPLIER as f32)\n    }\n\n    pub fn query_lock_info(\u0026self, router: \u0026mut App, user: \u0026str) -\u003e StdResult\u003cLockInfoResponse\u003e {\n        router.wrap().query_wasm_smart(\n            self.escrow_instance.clone(),\n            \u0026QueryMsg::LockInfo {\n                user: user.to_string(),\n            },\n        )\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","donovan","Development","astroport-fi","hidden_astroport_governance_hub_outpost","packages","astroport-tests","src","lib.rs"],"content":"pub mod base;\nuse astroport_governance::utils::{get_period, EPOCH_START};\nuse cosmwasm_std::testing::{mock_env, MockApi, MockStorage};\nuse cosmwasm_std::Timestamp;\nuse cw_multi_test::{App, BankKeeper, BasicAppBuilder};\n\n#[allow(clippy::all)]\n#[allow(dead_code)]\npub mod controller_helper;\n\n#[allow(clippy::all)]\n#[allow(dead_code)]\npub mod escrow_helper;\n\npub fn mock_app() -\u003e App {\n    let mut env = mock_env();\n    env.block.time = Timestamp::from_seconds(EPOCH_START);\n    let api = MockApi::default();\n    let bank = BankKeeper::new();\n    let storage = MockStorage::new();\n\n    BasicAppBuilder::new()\n        .with_api(api)\n        .with_block(env.block)\n        .with_bank(bank)\n        .with_storage(storage)\n        .build(|_, _, _| {})\n}\n\npub trait TerraAppExtension {\n    fn next_block(\u0026mut self, time: u64);\n    fn block_period(\u0026self) -\u003e u64;\n}\n\nimpl TerraAppExtension for App {\n    fn next_block(\u0026mut self, time: u64) {\n        self.update_block(|block| {\n            block.time = block.time.plus_seconds(time);\n            block.height += 1\n        });\n    }\n\n    fn block_period(\u0026self) -\u003e u64 {\n        get_period(self.block_info().time.seconds()).unwrap()\n    }\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>